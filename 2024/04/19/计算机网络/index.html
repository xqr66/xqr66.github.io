<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="记录我的学习点滴" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>计算机网络 |  rxq的博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="rxq的博客" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-计算机网络"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  计算机网络
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="article-date">
  <time datetime="2024-04-19T15:01:45.000Z" itemprop="datePublished">2024-04-19</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">13.2k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">46 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="计算机网络："><a href="#计算机网络：" class="headerlink" title="计算机网络："></a>计算机网络：</h2><h4 id="网络的构成"><a href="#网络的构成" class="headerlink" title="网络的构成"></a>网络的构成</h4><p><strong>节点</strong></p>
<ul>
<li><p>主机及其上运行的应用程序</p>
</li>
<li><p>路由器、交换机等网络交换设备</p>
</li>
</ul>
<p><strong>边：通信链路</strong></p>
<ul>
<li><p>接入网链路：主机连接到互联网的链路</p>
</li>
<li><p>主干链路：路由器间的链路</p>
</li>
</ul>
<p><strong>协议</strong></p>
<ul>
<li>传输层TCP、UDP协议</li>
<li>网络层IP协议</li>
<li>应用层FTP、SMTP、HTTP、DNS协议等</li>
</ul>
<p><strong>协议的定义</strong>：对等层实体，在通信过程中，需要遵守的规则的集合、包括语法、语义、报文格式以及次序。</p>
<h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20231003112121217.png" alt="image-20231003112121217"></p>
<p>1、物理层：发送时将数据bit流转化为物理信号（电磁波，光波），接收时将物理信号转换为bit流数据。实现计算机节点之间比特流的传输，规定传输媒体接口的标准，屏蔽掉具体传输介质和物理设备的差异，使数据链路层不必关心网络的具体传输介质，按照物理层规定的标准传输数据就行</p>
<p>2、数据链路层：向上:将物理层的一个个bit，组合转换为帧包括帧头和帧尾，向下:把网络层数据报加头和尾，封装成帧，帧头中包括源MAC地址和目的MAC地址。 提供相邻两个节点之间的数据传输</p>
<p>通过差错控制、流量控制等方法，使有差错的物理线路变为无差错的数据链路。</p>
<p>数据链路层的几个基本方法：数据封装成桢、透明传输、差错控制、流量控制。</p>
<p>封装成桢：把网络层数据报加头和尾，封装成帧，帧头中包括源MAC地址和目的MAC地址。<br>透明传输：零比特填充、转义字符。<br>差错控制：接收者检测错误,如果发现差错，丢弃该帧，差错控制方法有 CRC 循环冗余码<br>流量控制：控制发送的传输速度，使得接收方来得及接收。传输层TCP也有流量控制功能，但TCP是端到端的流量控制，链路层是点到点（比如一个路由器到下一个路由器）<br>3、网络层：<strong>实现网络地址与物理地址的转换</strong>，并通过<strong>路由选择算法为分组通过通信子网选择最适当的路径</strong></p>
<p>网络层最重要的一个功能就是：路由选择。路由一般包括路由表和路由算法两个方面。每个路由器都必须建立和维护自身的路由表，一种是静态维护，也就是人工设置，适用于小型网络；另一种就是动态维护，是在运行过程中根据网络情况自动地动态维护路由表。</p>
<p>4、传输层：提供源端与目的端之间提供可靠的透明数据传输，传输层协议为不同主机上运行的进程提供逻辑通信。</p>
<p>网络层协议负责的是提供主机间的逻辑通信，而传输层协议负责的是提供进程间的逻辑通信。</p>
<p>5、会话层：管理（建立、维护、重连）应用之间的会话，是用户<strong>应用程序和网络之间的接口</strong>，负责在网络中的<strong>两节点之间建立、维持、终止通信</strong>。</p>
<p>6、表示层：<strong>处理用户数据的表示问题</strong>，如数据的编码、<strong>格式转换、加密和解密、压缩和解压缩</strong>。</p>
<p>7、应用层(FTP、SMTP、HTTP、DNS)：传输层基础上实现网络应用，为<strong>用户的应用进程提供网络通信服务</strong>，完成和实现用户请求的各种服务。</p>
<h4 id="各个设备工作在哪一层"><a href="#各个设备工作在哪一层" class="headerlink" title="各个设备工作在哪一层"></a>各个设备工作在哪一层</h4><ul>
<li><p>网桥：工作在<strong>数据链路层</strong>，在不同或相同类型的LAN之间存储并转发数据帧，必要时进行链路层上的协议转换。可连接两个或多个网络，在其中传送信息包。</p>
</li>
<li><p>交换机：工作在<strong>数据链路层</strong>，原理等同于多端口网桥。作用是连接数个相同网段的不同主机，减少网内冲突，隔离冲突域。利用存储转发和过滤技术来从物理上分割网段。</p>
</li>
<li><p>路由器：工作在<strong>网络层</strong>，在不同的网络间存储并转发分组。可在异种网络之间（即不同类型的局域网互连，局域网与广域网，广域网与广域网）传输数据并进行路径选择，使用专门的软件协议从逻辑上对整个网络进行划分。</p>
</li>
<li><p>网关：对高层协议（包括传输层及更高层次）进行转换的网间连接器。允许使用不兼容的协议，比如SPX&#x2F;IPX和TCP&#x2F;IP的系统和网络互连。因为协议转换是网关最重要的功能，所以答案是工作<strong>在传输层及以上层次</strong>。</p>
</li>
<li><p>网卡：在物理层上网卡主要是完成物理接口的连接,电信号的传送以及将数据分解为适当大小的数据包之后向网络上发送的功能. 数据链路层功能包括链路建立和拆除，帧定界同步顺序差错控制这些。大多认为主要工作在物理层。通常包含<strong>物理层以及链路层</strong></p>
</li>
</ul>
<h4 id="TCP粘包拆包问题"><a href="#TCP粘包拆包问题" class="headerlink" title="TCP粘包拆包问题"></a>TCP粘包拆包问题</h4><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><p>TCP在接受数据的时候，有一个滑动窗口来控制接受数据的大小，这个滑动窗口你就可以理解为一个缓冲区的大小。缓冲区满了就会把数据发送。数据包的大小是不固定的，有时候比缓冲区大有时候小。</p>
<ul>
<li>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题；</li>
<li>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包</li>
</ul>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/864571e427ea43eeb8db63e4bcd53455.png" alt="img"></p>
<h5 id="为什么会发生"><a href="#为什么会发生" class="headerlink" title="为什么会发生"></a>为什么会发生</h5><p>1.TCP会发生粘包问题：TCP 是面向连接的传输协议,TCP 传输的数据是以流的形式,而流数据是没有明确的开始结尾边界,所以 TCP 也没办法判断哪一段流属于一个消息;内容与内容之间没有明确的分界标志,需要认为手动地去给这些协议划分边界。<br>粘包时：发送方每次写入数据 &lt; 接收方套接字(Socket)缓冲区大小。<br>拆包时：发送方每次写入数据 &gt; 接收方套接字(Socket)缓冲区大小。</p>
<p>2.UDP不会发生粘包问题：UDP具有保护消息边界,在每个UDP包中就有了消息头(UDP长度、源端口、目的端口、校验和)。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>1、客户端在发送数据包的时候，每个包都固定长度，比如1024个字节大小，如果客户端发送的数据长度不足1024个字节，则通过补充空格的方式补全到指定长度；</p>
<p>2、客户端在每个包的末尾使用固定的分隔符，例如\r\n，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的\r\n，然后对其拆分后的头部部分与前一个包的剩余部分进行合并，这样就得到了一个完整的包；</p>
<p>3、将消息分为头部和消息体，在头部中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；</p>
<h4 id="HTTP如何解决粘包问题的？"><a href="#HTTP如何解决粘包问题的？" class="headerlink" title="HTTP如何解决粘包问题的？"></a>HTTP如何解决粘包问题的？</h4><p>http请求报文格式<br>1）请求行：以\r\n结束；<br>2）请求头：以\r\n结束；<br>3）\r\n；<br>3）数据；</p>
<p>http响应报文格式<br>1）响应行：以\r\n结束；<br>2）响应头：以\r\n结束；<br>3）\r\n；<br>4）数据；</p>
<p>4.1、读取请求行&#x2F;请求头、响应行&#x2F;响应头<br>1、遇到第一个\r\n表示读取请求行或响应行结束；<br>2、遇到\r\n\r\n表示读取请求头或响应头结束；</p>
<p>4.2、 怎么读取body数据呢？<br>HTTP协议通常使用Content-Length来标识body的长度。在服务器端，需要先申请对应长度的buffer，然后再赋值。</p>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1279a01571164f2ba3c2a8141a0e996a.png" alt="img"></p>
<p>如果需要一边生产数据一边发送数据，就需要使用”Transfer-Encoding: chunked” 来代替Content-Length，也就是对数据进行分块传输。</p>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/de563592ba4c4d42b9d1acfbda2af5f5.png" alt="img"></p>
<p>4.2.1、 Content-Length 描述<br>http server接收数据时，发现header中有Content-Length属性，则读取Content-Length的值，确定需要读取body的长度。<br>http server发送数据时，根据需要发送byte的长度，在header中增加Content-Length项，其中value为byte的长度，然后将byte数据当做body发送到客户端。<br>4.2.2、 chunked描述<br>http server接收数据时，发现header中有Transfer-Encoding: chunked，则会按照chunked协议分批读取数据。<br>http server发送数据时，如果需要分批发送到客户端，则需要在header中加上Transfer-Encoding:chunked，然后按照chunked协议分批发送数据。<br>chunked协议具体如下图：</p>
<p> <img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/8ba16c3c85684457a1bfa01ce4014491.png" alt="img"></p>
<p>1、主要包含三部分: chunk，last-chunk和trailer。如果分多次发送，则chunk有多份。</p>
<p>2、 chunk主要包含大小和数据，大小表示这个这个chunk包的大小，使用16进制标示。其中chunk之间的分隔符为CRLF。</p>
<p>3、通过last-chunk来标识chunk发送完成。一般读取到last-chunk(内容为0)的时候，代表chunk发送完成。</p>
<p>4、trailer表示增加header等额外信息，一般情况下header是空。通过CRLF来标识整个chunked数据发送完成。</p>
<p>4.2.3 优&#x2F;缺点<br>优点</p>
<p>1、假如body的长度是10K，对于Content-Length则需要申请10K连续的buffer，而对于Transfer-Encoding:chunked可以申请1k的空间，然后循环使用10次。节省了内存空间的开销。</p>
<p>2、如果内容的长度不可知，则可使用chunked方式能有效的解决Content-Length的问题</p>
<p>3、http服务器压缩可以采用分块压缩，而不是整个块压缩。分块压缩可以一边进行压缩，一般发送数据，来加快数据的传输时间。</p>
<p>缺点</p>
<p>1、chunked协议解析比较复杂。</p>
<p>2、在http转发的场景下(比如nginx)难以处理，比如如何对分块数据进行转发。</p>
<h4 id="TCP队头阻塞问题"><a href="#TCP队头阻塞问题" class="headerlink" title="TCP队头阻塞问题"></a>TCP队头阻塞问题</h4><p>客户端接收端可能会先收到窗口末端的数据，这个时候 TCP 是不会向上层应用交付数据的，它得等到前面的数据都接收到了才向上交付，所以这就出现了队头阻塞，即队头的包如果发生延迟或者丢失，队尾必须等待发送端重新发送并接收到数据后才会一起向上交付。</p>
<h4 id="TCP和UDP的区别和应用场景"><a href="#TCP和UDP的区别和应用场景" class="headerlink" title="TCP和UDP的区别和应用场景"></a>TCP和UDP的区别和应用场景</h4><ul>
<li><p><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</p>
</li>
<li><p><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，确保通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p>
</li>
<li><p><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了</p>
</li>
<li><p><strong>传输效率</strong>：由于使用 TCP 建立连接有握手的机制，进行传输的时候多了连接、确认、重传等机制，TCP 的使用效率会比 UDP 要低</p>
</li>
<li><p><strong>传输形式</strong>：TCP 是面向字节流（把应用程序交下来的数据看成无结构的字节流）的，UDP 是面向报文（对应用层的报文既不合并也不拆分，对长度大小都不做任何改变）的。</p>
</li>
<li><p><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</p>
</li>
<li><p><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</p>
</li>
</ul>
<h5 id="TCP使用场景"><a href="#TCP使用场景" class="headerlink" title="TCP使用场景"></a>TCP使用场景</h5><p>效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</p>
<h5 id="UDP使用场景"><a href="#UDP使用场景" class="headerlink" title="UDP使用场景"></a>UDP使用场景</h5><p>效率要求相对高，对准确性要求相对低的场景。举几个例子：游戏、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播），即使出现传输错误也可以容忍。</p>
<h4 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h4><p>QUIC 全称：Quick UDP Internet Connections，是一种基于 UDP 的传输层协议。</p>
<p><strong>可靠传输</strong></p>
<p>QUIC 是基于 UDP 协议的，而 UDP 是不可靠传输协议，那 QUIC 是如何实现可靠传输的呢？</p>
<p>可靠传输有 2 个重要特点：</p>
<p>（1）完整性：发送端发出的数据包，接收端都能收到</p>
<p>（2）有序性：接收端能按序组装数据包，解码得到有效的数据</p>
<p>问题 1：发送端怎么知道发出的包是否被接收端收到了？</p>
<p>解决方案：通过包号（PKN）和确认应答（SACK）</p>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-aace93419dd55c73ab4b5fd2976e1375_1440w.webp" alt="img"></p>
<p>（1）客户端：发送 3 个数据包给服务器（PKN &#x3D; 1，2，3）</p>
<p>（2）服务器：通过 SACK 告知客户端已经收到了 1 和 3，没有收到 2</p>
<p>（3）客户端：重传第 2 个数据包（PKN&#x3D;4）</p>
<p>由此可以看出，QUIC 的数据包号是单调递增的。也就是说，之前发送的数据包（PKN&#x3D;2）和重传的数据包（PKN&#x3D;4），虽然数据一样，但包号不同。</p>
<p>问题 2：既然包号是单调递增的，那接收端怎么保证数据的有序性呢？</p>
<p>解决方案：通过数据偏移量 offset</p>
<p>每个数据包都有一个 offset 字段，表示在整个数据中的偏移量。</p>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-e6abef5bc9316fd87905a5e97b547050_1440w.webp" alt="img"></p>
<p>接收端根据 offset 字段就可以对异步到达的数据包进行排序了。为什么 QUIC 要将 PKN 设计为单调递增？解决 TCP 的重传歧义问题：</p>
<p>由于原始包和重传包的序列号是一样的，客户端不知道服务器返回的 ACK 包到底是原始包的，还是重传包的。但 QUIC 的原始包和重传包的序列号是不同的，也就可以判断 ACK 包的归属。</p>
<h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><strong>流量控制</strong></h5><p>和 TCP 一样，QUIC 也是利用滑动窗口机制实现流量控制：</p>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-2b659a36da1993c1a65bed4830606997_1440w.webp" alt="img"></p>
<p>发送端的窗口大小由接收端告知，包括发送窗口和可用窗口，如果发送端收到了接收端的 ACK 确认应答（比如 ACK 36），那整个窗口就会向右滑动，发送新的数据包。</p>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-62c627de56caf4617f97628215c4fa03_1440w.webp" alt="img"></p>
<p>和 TCP 不同的是，QUIC 的滑动窗口分为 Connection 和 Stream 两种级别。Connection 流量控制：规定了所有数据流的总窗口大小；Stream 流量控制：规定了每个流的窗口大小。</p>
<p>假设现在有 3 个 Stream，滑动窗口分别如下：</p>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-a5f95afac0935ae11f4672d3fdf9bf3e_1440w.webp" alt="img"></p>
<p>则整个 Connection 的可用窗口大小为：20+30+10 &#x3D; 60</p>
<h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><strong>拥塞控制</strong></h5><p>拥塞控制是通过拥塞窗口限制发送方的数据量，避免整个网络发生拥塞。那拥塞窗口（cwnd）和滑动窗口（发送窗口：swnd，接收窗口：rwnd）有什么关系呢？</p>
<p>swnd &#x3D; min（cwnd，rwnd）</p>
<p>也就是说，发送窗口的大小是由接收窗口和拥塞窗口共同决定的。那拥塞窗口的大小是如何计算的？通过 4 个拥塞控制算法：慢启动、拥塞避免、拥塞发生、快速恢复</p>
<h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a><strong>慢启动</strong></h5><p>初始拥塞窗口大小 cwnd&#x3D;1，也就是可以传输 1 个 MDS（Max Datagram Size）大小的数据包，一般网卡允许传输的最大数据单元 MTU 的大小是 1500 字节。对于 UDP 数据报而言：MDS &#x3D; 1500（MTU）- 20（IP 首部）- 8（UDP 首部） &#x3D; 1472 字节</p>
<p><strong>慢启动算法</strong>： 当发送方每收到一个 ACK，拥塞窗口就加 1（cwnd++）</p>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-54d7f3cc6ec67a9ae47fa5dfa3fccfc0_1440w.webp" alt="img"></p>
<p>由此可以看出，慢启动阶段，拥塞窗口呈指数增长，那增长到多少是个头？</p>
<p>有一个上限值：ssthresh（slow start threshold），从源码看，这个值是 2000 * MDS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const QuicPacketCount kDefaultMaxCongestionWindowPackets = 2000;</span><br></pre></td></tr></table></figure>

<ul>
<li>当 <strong>cwnd &lt; ssthresh</strong> 时，使用慢启动算法</li>
<li>当 <strong>cwnd &gt;&#x3D; ssthresh</strong> 时，使用拥塞避免算法</li>
</ul>
<h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a><strong>拥塞避免</strong></h5><p>当拥塞窗口大小超过慢启动上限后，就会进入拥塞避免阶段。</p>
<p><strong>拥塞避免算法：</strong> 当发送方每收到一个 ACK，拥塞窗口就加 1&#x2F;cwnd</p>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-1072c63fd6e97e671affe2d9346c3836_1440w.webp" alt="img"></p>
<p>假设现在的 cwnd&#x3D;8，可以发送 8 个数据包，当收到这 8 个包的 ACK 时，拥塞窗口才会加 1，由此可知，在拥塞避免阶段，拥塞窗口是线性增长的。</p>
<p>那啥时候是个头呢？不管，让它继续增长，直到网络发生拥塞，出现丢包，这时就会触发重传机制，进入拥塞发生阶段</p>
<h5 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a><strong>拥塞发生</strong></h5><p>重传有 2 种：超时重传和快速重传</p>
<p>如果发生超时重传，使用的拥塞发生算法为：</p>
<ul>
<li>ssthresh &#x3D; cwnd &#x2F; 2</li>
<li>cwnd &#x3D; 1</li>
</ul>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-dcefc32fcbaca9acf5a347580b56ff3c_1440w.webp" alt="img"></p>
<p>重新使用慢启动和拥塞避免算法增加拥塞窗口的大小。</p>
<p>如果发生快速重传（发送方收到 3 个相同的 ACK），使用的拥塞发生算法为：</p>
<ul>
<li>cwnd &#x3D; cwnd &#x2F; 2</li>
<li>ssthresh &#x3D; cwnd</li>
</ul>
<p>接下来就会进入快速恢复阶段。</p>
<h5 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a><strong>快速恢复</strong></h5><p>快速恢复算法：cwnd &#x3D; ssthresh + 3（因为收到 3 个 ACK），然后进入拥塞避免阶段。</p>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-9158217fe2e02f6b17a29aadf649cdd2_1440w.webp" alt="img"></p>
<h4 id="QUIC相比于TCP的优势"><a href="#QUIC相比于TCP的优势" class="headerlink" title="QUIC相比于TCP的优势"></a>QUIC相比于TCP的优势</h4><p>安全性:QUIC它完全以加密形式通信，未加密的通信是完全被禁止的</p>
<p><strong>0-RTT 握手</strong>:其实原理很简单：客户端缓存了 ServerConfig（B&#x3D;b*G%P），下次建连直接使用缓存数据计算通信密钥。</p>
<p>多路复用方面，QUIC可以复用多个stream，同时其中一个stream的丢包并不会影响其他stream，这也说明了在QUIC中，每个stream是相对独立的,解决了TCP协议中队头阻塞问题。</p>
<h4 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h4><p>建立一个 TCP 连接需要“三次握手”，缺一不可：</p>
<ul>
<li><strong>一次握手</strong>:客户端发送带有 SYN（SEQ&#x3D;x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</li>
<li><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态</li>
<li><strong>三次握手</strong>:客户端发送带有 ACK(ACK&#x3D;y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成 TCP 三次握手。</li>
</ul>
<p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<ol>
<li><strong>第一次握手</strong>：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li><strong>第二次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li><strong>第三次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
<li>防止失效的请求报文又请求建立连接，浪费服务器资源</li>
</ol>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20240104135112905.png" alt="image-20240104135112905"></p>
<p>三次握手就能确认双方收发功能都正常，缺一不可。</p>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20231003112124898.png" alt="image-20231003112124898"></p>
<h5 id="第-2-次握手传回了-ACK，为什么还要传回-SYN？"><a href="#第-2-次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="第 2 次握手传回了 ACK，为什么还要传回 SYN？"></a>第 2 次握手传回了 ACK，为什么还要传回 SYN？</h5><p>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信也是正常的。</p>
<blockquote>
<p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP&#x2F;IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20231003112128868.png" alt="image-20231003112128868"></p>
<p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p>
<ol>
<li><strong>第一次挥手</strong>：客户端发送一个 FIN（SEQ&#x3D;x） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li>
<li><strong>第二次挥手</strong>：服务器收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （ACK&#x3D;x+1）标志的数据包-&gt;客户端 。然后服务端进入 <strong>CLOSE-WAIT</strong> 状态，客户端进入 <strong>FIN-WAIT-2</strong> 状态。</li>
<li><strong>第三次挥手</strong>：服务端发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 <strong>LAST-ACK</strong> 状态。</li>
<li><strong>第四次挥手</strong>：客户端发送 ACK (ACK&#x3D;y+1)标志的数据包-&gt;服务端，然后客户端进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (ACK&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li>
</ol>
<p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p>
<h5 id="为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？"><a href="#为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？" class="headerlink" title="为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？"></a>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</h5><p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p>
<h5 id="如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？"><a href="#如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？" class="headerlink" title="# 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？"></a><a href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84-ack-%E6%B2%A1%E6%9C%89%E9%80%81%E8%BE%BE%E5%AE%A2%E6%88%B7%E7%AB%AF-%E4%BC%9A%E6%80%8E%E6%A0%B7">#</a> 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h5><p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p>
<h5 id="为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？"><a href="#为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？" class="headerlink" title="# 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85-2-msl-%E6%8A%A5%E6%96%87%E6%AE%B5%E6%9C%80%E9%95%BF%E5%AF%BF%E5%91%BD-%E6%97%B6%E9%97%B4%E5%90%8E%E6%89%8D%E8%BF%9B%E5%85%A5-closed-%E7%8A%B6%E6%80%81">#</a> 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h5><p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p>
<blockquote>
<p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接，可根据具体实现动态调整MSL。</p>
</blockquote>
<h4 id="讲一讲SYN洪泛攻击，以及解决策略"><a href="#讲一讲SYN洪泛攻击，以及解决策略" class="headerlink" title="讲一讲SYN洪泛攻击，以及解决策略"></a>讲一讲SYN洪泛攻击，以及解决策略</h4><p>洪泛攻击： 在 TCP 的三次握手机制的第一步中，客户端会向服务器发送 SYN 报文段。服务器接收到 SYN 报文段后会为该 TCP分 配缓存和变量，如果攻击分子大量地往服务器发送 SYN 报文段，服务器的连接资源终将被耗尽，导致内存溢出无法继续服务。</p>
<p>解决策略：当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源 IP，目的 IP，端口号以及只有服务器自己知道的一个秘密函数生成一个 cookie，并把 cookie 作为序列号响应给客户端。</p>
<p>如果客户端是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段。接下来服务器会根据确认报文的源 Id，目的 Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1 等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源。</p>
<p>这样一来就不会为恶意攻击的 SYN 报文段分配资源空间，避免了攻击。</p>
<h4 id="详细介绍一下-TCP-的四次挥手机制，为什么要有-TIME-WAIT-状态，为什么需要四次握手？服务器出现了大量-CLOSE-WAIT-状态如何解决"><a href="#详细介绍一下-TCP-的四次挥手机制，为什么要有-TIME-WAIT-状态，为什么需要四次握手？服务器出现了大量-CLOSE-WAIT-状态如何解决" class="headerlink" title="详细介绍一下 TCP 的四次挥手机制，为什么要有 TIME_WAIT 状态，为什么需要四次握手？服务器出现了大量 CLOSE_WAIT 状态如何解决"></a>详细介绍一下 TCP 的四次挥手机制，为什么要有 TIME_WAIT 状态，为什么需要四次握手？服务器出现了大量 CLOSE_WAIT 状态如何解决</h4><p>当客户端要服务器断开连接时，客户端 TCP 会向服务器发送一个特殊的报文段，该报文段的 FIN 标志位会被置 1，接着服务器会向客户端发送一个确认报文段。然后服务器也会客户端发送一个 FIN 标志位为 1 的终止报文段，随后客户端回送一个确认报文段，服务器立即断开连接。客户端等待一段时间后也断开连接。</p>
<p>为什么要有 TIME_WAIT 状态？因为客户端最后向服务器发送的确认 ACK 是有可能丢失的，当出现超时，服务端会再次发送 FIN 报文段，如果客户端已经关闭了就收不到了。</p>
<p>大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。</p>
<p>详情可参考以下博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sunxucool/p/3449068.html">https://www.cnblogs.com/sunxucool/p/3449068.html</a></p>
<h4 id="TCP的可靠传输是如何保障的"><a href="#TCP的可靠传输是如何保障的" class="headerlink" title="TCP的可靠传输是如何保障的"></a>TCP的可靠传输是如何保障的</h4><ul>
<li><strong>基于数据块传输</strong>：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li>
<li><strong>连接稳定可靠</strong>：通过三次握手四次挥手，保证了连接的可靠性，数据传输的完整性。</li>
<li><strong>序号机制，对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号（序列号是数据第一个字节的序号），有了序列号能够将接收到的数据<strong>根据序列号排序</strong>，并且<strong>去掉重复序列号的数据</strong>就可以实现数据包去重。</li>
<li><strong>校验和</strong> : TCP添加伪首部，TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个<strong>相应的确认信息</strong>（ACK）。<strong>超过该定时器时间依旧未收到对方确认，那么对应的数据包就被假设为已丢失并进行重传，便会重新发送该数据</strong></li>
<li><strong>流量控制</strong> : <strong>接收方根据自己接收缓冲的大小，可在设置确认报文字段的窗口字段，动态调整发送方发送窗口大小。</strong>TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制，窗口大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值）。</li>
<li><strong>拥塞控制</strong> : 通过慢启动，当网络拥塞时（发送方的数据迟迟无法到达接收方），发送方估算网络拥堵程度减少数据的发送。</li>
</ul>
<p>总结：TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制</p>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20231003112139329.png" alt="image-20231003112139329"></p>
<p>udp第四个字段为17</p>
<h4 id="详细讲一下TCP的滑动窗口"><a href="#详细讲一下TCP的滑动窗口" class="headerlink" title="详细讲一下TCP的滑动窗口"></a>详细讲一下TCP的滑动窗口<img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp-send-window.png" alt="TCP发送窗口结构"></h4><p>从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。</p>
<h5 id="先讲流量控制："><a href="#先讲流量控制：" class="headerlink" title="先讲流量控制："></a>先讲流量控制：</h5><p><strong>接收方根据自己接收缓冲的大小，可在设置确认报文字段的窗口字段，动态调整发送方发送窗口大小。</strong>TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失</p>
<h5 id="接着讲解拥塞控制："><a href="#接着讲解拥塞控制：" class="headerlink" title="接着讲解拥塞控制："></a>接着讲解拥塞控制：</h5><p>拥塞控制是指发送方先设置一个小的窗口值作为发送速率，当成功发包并接收到 ACK 时，便以<strong>指数速率增大发送窗口的大小</strong>，直到遇到丢包（超时&#x2F;三个冗余 ACK ），才停止并调整窗口的大小。这么做能最大限度地利用带宽，又不至于让网络环境变得太过拥挤。</p>
<p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41431406/article/details/97926927">TCP的拥塞控制（详解）-CSDN博客</a></p>
<p><strong>UDP接收缓冲区</strong></p>
<p>每个UDP socket都有一个接收缓冲区，没有发送缓冲区，从概念上来说就是只要有数据就发，不管对方是否可以正确接收，所以不缓冲，不需要发送缓冲区。</p>
<p>UDP：当套接口接收缓冲区满时，新来的数据报无法进入接收缓冲区，此数据报就被丢弃。UDP是没有流量控制的；快的发送者可以很容易地就淹没慢的接收者，导致接收方的UDP丢弃数据报。</p>
<h4 id="讲述浏览器中输入一个网址之后背后的过程："><a href="#讲述浏览器中输入一个网址之后背后的过程：" class="headerlink" title="讲述浏览器中输入一个网址之后背后的过程："></a><strong>讲述浏览器中输入一个网址之后背后的过程：</strong></h4><ol>
<li><p>URL 解析：</p>
<p><strong>地址解析</strong>：首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，（如果是关键词就直接按照关键词搜索）并且根据你输入的内容进行自动完成、字符编码等操作。浏览器还会进行一些额外的操作，比如安全检查、访问限制</p>
</li>
<li><p>DNS 查询</p>
<p><strong>1</strong>.<strong>浏览器缓存</strong>：浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p>
<p><strong>2. 操作系统缓存</strong>：操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p>
<p><strong>3. 路由器缓存</strong>：路由器也有自己的缓存。</p>
<p><strong>4. 本地 DNS 缓存</strong>：ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，也就是本地DNS服务器，它们在大多数情况下都会有缓存。</p>
<p><strong>5.根域名服务器查询</strong>：本地 DNS 服务器会将请求转发到互联网上的根域,再查询顶级域名服务器，权威域名服务器，找到对应服务器的ip地址</p>
</li>
<li><p>通过ip地址找到服务器，并与服务器建立TCP 连接</p>
</li>
<li><p>浏览器向web服务器发送一个HTTP请求</p>
</li>
<li><p>服务器对发送的请求进行处理，并发回一个HTML响应</p>
</li>
<li><p>浏览器接收到来自服务器的响应资源后，会对资源进行分析接受响应，浏览器渲染页面，得到我们看到的网页</p>
</li>
</ol>
<h4 id="一个请求达到后端整个过程"><a href="#一个请求达到后端整个过程" class="headerlink" title="一个请求达到后端整个过程"></a>一个请求达到后端整个过程</h4><ol>
<li><strong>建立连接</strong>：客户端通过TCP&#x2F;IP协议与服务器建立连接，这是HTTP的基础。</li>
<li><strong>发送请求</strong>：客户端向服务器发送一个HTTP请求，其中包含请求方法（例如GET或POST）和要访问的资源的URL。</li>
<li><strong>处理请求</strong>：服务器接收到请求后，会解析请求，查找所请求的资源，并准备好将其发送回客户端的响应。</li>
<li><strong>发送响应</strong>：服务器将响应发送回客户端，响应通常包括状态码、响应头和响应体。</li>
<li><strong>关闭连接</strong>：连接在请求和响应之后通常会被关闭，但HTTP&#x2F;1.1引入了持久连接以改善性能。</li>
</ol>
<h4 id="讲讲TCP的表头有哪些字段，这些字段你是背的还是了解过有什么作用，有过对每个字段的功能的测试吗"><a href="#讲讲TCP的表头有哪些字段，这些字段你是背的还是了解过有什么作用，有过对每个字段的功能的测试吗" class="headerlink" title="讲讲TCP的表头有哪些字段，这些字段你是背的还是了解过有什么作用，有过对每个字段的功能的测试吗"></a>讲讲TCP的表头有哪些字段，这些字段你是背的还是了解过有什么作用，有过对每个字段的功能的测试吗</h4><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20231003112148772.png" alt="image-20231003112148772"></p>
<ol>
<li><p>源端口和目的端口       各占2个字节，分别写入源端口和目的端口。</p>
</li>
<li><p>序号 在一个TCP连接中传送的字节流中的每一个字节都按照顺序编号，本字段表示本报文段所发送数据的第一个字节的序号。</p>
</li>
<li><p>确认号 起到收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则证明到序号N-1为止的所有数据都已正确收到。</p>
</li>
<li><p>数据偏移（TCP首部长度） TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B为单位，即一个数值是4B</p>
</li>
<li><p>保留          占6位，保留为今后使用，但目前应置为0 。</p>
</li>
<li><p>当URG置为1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。</p>
</li>
<li><p>确认ACK（ACKnowledgment）      仅当ACK &#x3D; 1时确认号字段才有效，当ACK &#x3D; 0时确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。</p>
</li>
<li><p>推送 PSH（PuSH）    当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。接收方TCP收到PSH&#x3D;1的报文段，就尽快地（即“推送”向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付。</p>
</li>
<li><p>复位RST（ReSeT）       当RST&#x3D;1时，表明 TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。</p>
</li>
<li><p>同步SYN（SYNchronization）       在连接建立时用来同步序号。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN&#x3D;1和ACK&#x3D;1，因此SYN置为1就表示这是一个连接请求或连接接受报文。</p>
</li>
<li><p>终止FIN（FINis，意思是“完”“终”）          用来释放一个连接。当FIN&#x3D;1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p>
</li>
<li><p>窗口             占2字节。窗口值是【0，2^16-1】之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。</p>
</li>
<li><p>检验和       占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式和UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）；把第5字段中的UDP中的长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用IPv6,则相应的伪首部也要改变。</p>
</li>
<li><p>紧急指针            占2字节。紧急指针仅在URG&#x3D;1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0时也可以发送紧急数据。</p>
</li>
<li><p>选项       长度可变，最长可达4字节。当没有使用“选项”时，TCP的首部长度是20字节。</p>
</li>
</ol>
<h4 id="IP头部"><a href="#IP头部" class="headerlink" title="IP头部"></a>IP头部</h4><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzM5NDMw,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>一行32bit</p>
<p>版本号（4bit）：告知IP地址是ipv4地址还是ipv6地址</p>
<p>首部长度（4bit）：告知这个数据包头的长度，由此推断出有无可选项</p>
<p>服务类型（8bit）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">按位被定义为 PPP DTRM0</span><br><span class="line">PPP：定义包的优先级，取值越大数据越重要</span><br><span class="line">	 000 普通 (Routine)</span><br><span class="line">  	 001 优先的 (Priority)</span><br><span class="line">	 010 立即的发送 (Immediate)</span><br><span class="line">	 011 闪电式的 (Flash)</span><br><span class="line"> 	 100 比闪电还闪电式的 (Flash Override)</span><br><span class="line">	 101 CRI/TIC/ECP(找不到这个词的翻译)</span><br><span class="line">	 110 网间控制 (Internetwork Control)</span><br><span class="line">	 111 网络控制 (Network Control)</span><br><span class="line">D 时延: 0:普通 1:延迟尽量小</span><br><span class="line">T 吞吐量: 0:普通 1:流量尽量大</span><br><span class="line">R 可靠性: 0:普通 1:可靠性尽量大</span><br><span class="line">M 传输成本: 0:普通 1:成本尽量小</span><br><span class="line">0 最后一位被保留，恒定为0</span><br></pre></td></tr></table></figure>

<p>总长度（16bit）：告知IP数据报文的总长度（包括被分片数据在内），最大承载量为1500字节，超过将进行数据分片</p>
<p>片偏移量（13bit）：决定IP分片数据的先后顺序，只能是0或1480的倍数，第一个分片数据发送时偏移量为0，第二个为1480，第三个为2960，以此类推。目的端重组数据包时靠偏移量来按顺序组合分片数据</p>
<p>标志位（3bit）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一位bit未启用为0               </span><br><span class="line">第二位bit如果需要分片第二位为0，不需要分片第二位为1               </span><br><span class="line">第三位比特为1代表还有后续分片，为0代表为最后一个分片 </span><br><span class="line">共有三种情况：</span><br><span class="line">	001（需要分片且还有后续分片）</span><br><span class="line">	000（需要分片且当前为最后一个分片）</span><br><span class="line">	010（不需要分片）</span><br></pre></td></tr></table></figure>

<p>标识符（16bit）：区分不同的IP数据包的分片数据，在目的端重组分片数据时能快速找到同一数据包的分片数据</p>
<p>生存时间TTL（8bit）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">范围为1-255；</span><br><span class="line">单位为跳数，数据包每经过一台路由器即为一跳，TTL值减一；当TTL为0时，丢弃数据包。</span><br><span class="line">作用是防止数据包在网络中永久的循环</span><br><span class="line">Windows系统TTL一般为128，Linux系统TTL为1-128之间，通常为56,64。</span><br><span class="line">注：跳点跟踪命令：tracert IP地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>协议（8bit）：区分上层协议；6代表TCP协议，17代表UDP协议</p>
<p>首部校验和（16bit）：校验三层IP包头是否有误</p>
<p>源IP地址（32bit）：指发送数据包的主机地址</p>
<p>目标IP地址（32bit）：指接收数据包的目标主机地址</p>
<p>选项字段（长度可变，0-40Byte）：通常不会使用到，因为IP包头部分的长度单位为32bit，因此可选项字段的长度必须为32bit的整数倍，当使用时且剩余部分不足32bit会自动填充无用数据来补足32bit。</p>
<h4 id="http和tcp的区别，分别在哪一层"><a href="#http和tcp的区别，分别在哪一层" class="headerlink" title="http和tcp的区别，分别在哪一层"></a>http和tcp的区别，分别在哪一层</h4><p><strong>TCP协议是传输层协议</strong>，主要解决数据如何在网络中传输，<em><strong>而HTTP是应用层协议</strong></em>**，主要解决如何包装数据，两者本质上没有可比性。</p>
<p>我们在传输数据时，可以只使用（传输层）TCP&#x2F;IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET 等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP&#x2F;IP做传输层协议将它发到网络上。</p>
<p><strong>Http协议是建立在TCP协议基础之上的</strong>，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的，所以Http连接是一种短连接，是一种无状态的连接。</p>
<p>说明：从HTTP&#x2F;1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p>
<p><strong>Http是无状态的短连接</strong>，直观地说，就是每个请求都是独立的，与前面的请求和后面的请求都是没有直接联系的，因此加入了cookie、session等机制实现有状态的的web。<strong>而TCP是有状态的长连接</strong></p>
<h4 id="tcp慢启动是怎么实现的"><a href="#tcp慢启动是怎么实现的" class="headerlink" title="tcp慢启动是怎么实现的"></a>tcp慢启动是怎么实现的</h4><p>最初的TCP的实现方式是，在连接建立成功后便会向网络中发送大尺寸的数据包，假如网络出现问题，很多这样的大包会积攒在路由器上，很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此现在的TCP协议规定了，新建立的连接不能够一开始就发送大尺寸的数据包，而只能从一个小尺寸的包开始发送，在发送和数据被对方确认的过程中去计算对方的接收速度，来逐步增加每次发送的数据量（最后到达一个稳定的值，进入高速传输阶段。相应的，慢启动过程中，TCP通道处在低速传输阶段），以避免上述现象的发生。这个策略就是慢启动。</p>
<p>TCP刚刚开始传输数据时，会<strong>从一个较小的cwnd &#x3D; 1开始，然后按照2的幂逐步增长到sshthresh的过程称为慢启动</strong>，直到<strong>cwnd（拥塞窗口）&gt;（慢启动门限）ssthresh</strong>，则<strong>结束慢启动过程</strong>，<strong>进入到拥塞避免阶段</strong></p>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1036177bbd5c4ad6bdbe70a70bde14c4.png" alt="img"></p>
<h4 id="拥塞避免-1"><a href="#拥塞避免-1" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>当TCP经过慢启动阶段，wnd&gt;ssthresh时，就开始使用拥塞避免算法来进行拥塞控制，这个阶段cwnd是以线性方式增长的，每次收到前面发出去的所有包时，cwnd &#x3D; cwnd + 1（实际是每收到一个ACK, cwnd &#x3D; cwnd + 1&#x2F;cwnd），cwnd线性增长直到检测到拥塞发生。</p>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7a2514f97e0648cf8e44c127a298ca71.png" alt="img"></p>
<h4 id="快速重传与超时重传算法"><a href="#快速重传与超时重传算法" class="headerlink" title="快速重传与超时重传算法"></a>快速重传与超时重传算法</h4><p>首先， 我们要区别快速重传与超时重传。</p>
<p>当接收方发现重复的收到三次或者更多个前一个包的 ACK时，就说明中间丢了一个报文，这时候，发送端就不必等待超时再重传，而是可以直接快速地启动重传———这就是快速重传。</p>
<p>当接收方直到超时，也没有收到ACK和重复时，发送方TCP发送定时器超时后，也会主动发起重传————这就是超时重传。</p>
<p>发生超时重传和发生快速重传时，拥塞控制的算法是不一样的，当发生快速重传时，就引入了快速重传的算法。</p>
<h4 id="http和https有什么区别？"><a href="#http和https有什么区别？" class="headerlink" title="http和https有什么区别？"></a>http和https有什么区别？</h4><p>http与https都是常用的网络通信协议</p>
<p><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</p>
<p><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</p>
<p><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p>
<p><strong>SEO（搜索引擎优化）</strong>：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。</p>
<h4 id="说一说https实现加密通信的实现原理？CA证书是怎么获得的？一定安全吗？能有中间人吗？"><a href="#说一说https实现加密通信的实现原理？CA证书是怎么获得的？一定安全吗？能有中间人吗？" class="headerlink" title="说一说https实现加密通信的实现原理？CA证书是怎么获得的？一定安全吗？能有中间人吗？"></a>说一说https实现加密通信的实现原理？CA证书是怎么获得的？一定安全吗？能有中间人吗？</h4><ul>
<li>https是基于tcp协议的，首先客户端会和服务端发起链接建立</li>
<li>服务端返回它的证书给客户端，证书中包含了服务端公钥S.pub、颁发机构和有效期等信息，证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</li>
<li>客户端通过操作系统、浏览器内置的根证书（内部包含CA机构的公钥C.pub）验证证书的合法性</li>
<li>客户端生成随机的对称加密密钥Z，然后通过服务端的公钥S.pub加密发送给服务端</li>
<li>服务器通过私钥进行解密，获得客户端浏览器的对称加密密钥</li>
<li>客户端和服务端之后就通过对称加密密钥Z加密数据来进行http通信</li>
</ul>
<p>CA证书由网站向CA机构申请，由CA机构颁发，其中包含证书持有者的公钥、域名。同时通过数字签名来做到防止证书被篡改。</p>
<p>网站在使用HTTPS前，需要向<strong>CA机构</strong>申领一份<strong>数字证书</strong>，数字证书里含有证书持有者信息、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明“该公钥对应该网站”。而这里又有一个显而易见的问题，“<strong>证书本身的传输过程中，如何防止被篡改”</strong>？即如何证明证书本身的真实性？身份证运用了一些防伪技术，而数字证书怎么防伪呢？解决这个问题我们就接近胜利了！</p>
<h5 id="如何放防止数字证书被篡改？"><a href="#如何放防止数字证书被篡改？" class="headerlink" title="如何放防止数字证书被篡改？"></a><strong>如何放防止数字证书被篡改？</strong></h5><p>我们把证书原本的内容生成一份“签名”，比对证书内容和签名是否一致就能判别是否被篡改。这就是数字证书的“防伪技术”，这里的“签名”就叫<code>数字签名</code>：</p>
<h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a><strong>数字签名</strong></h5><p>这部分内容建议看下图并结合后面的文字理解，图中左侧是数字签名的制作过程，右侧是验证过程：</p>
<p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-7c78935389af46e197e96d9cd91c06dd_1440w-1696303314365-11.webp" alt="img"></p>
<p>数字签名的生成与验证（<a target="_blank" rel="noopener" href="https://cheapsslsecurity.com/blog/digital-signature-vs-digital-certificate-the-difference-explained/%EF%BC%89">https://cheapsslsecurity.com/blog/digital-signature-vs-digital-certificate-the-difference-explained/）</a></p>
<p>数字签名的制作过程：</p>
<ol>
<li>CA机构拥有非对称加密的私钥和公钥。</li>
<li>CA机构对证书明文数据T进行hash。</li>
<li>对hash后的值用私钥加密，得到数字签名S。</li>
</ol>
<p>明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。<br>那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）</p>
<p>浏览器验证过程：</p>
<ol>
<li>拿到证书，得到明文T，签名S。</li>
<li>用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。</li>
<li>用证书里指明的hash算法对明文T进行hash得到T’。</li>
<li>显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。</li>
</ol>
<p>为何么这样可以保证证书可信呢？我们来仔细想一下。</p>
<h5 id="中间人有可能篡改该证书吗？"><a href="#中间人有可能篡改该证书吗？" class="headerlink" title="中间人有可能篡改该证书吗？"></a><strong>中间人有可能篡改该证书吗？</strong></h5><p>假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。</p>
<p>既然不可能篡改，那整个证书被掉包呢？</p>
<h5 id="中间人有可能把证书掉包吗？"><a href="#中间人有可能把证书掉包吗？" class="headerlink" title="中间人有可能把证书掉包吗？"></a><strong>中间人有可能把证书掉包吗？</strong></h5><p>假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，这确实会导致上文“中间人攻击”那里提到的漏洞？</p>
<p>其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</p>
<h5 id="为什么制作数字签名时需要hash一次？。"><a href="#为什么制作数字签名时需要hash一次？。" class="headerlink" title="为什么制作数字签名时需要hash一次？。"></a><strong>为什么制作数字签名时需要hash一次？</strong>。</h5><p>最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加解密就快很多。</p>
<h4 id="HTTP是基于TCP还是UDP？"><a href="#HTTP是基于TCP还是UDP？" class="headerlink" title="HTTP是基于TCP还是UDP？"></a>HTTP是基于TCP还是UDP？</h4><p>HTTP&#x2F;3.0 之前是基于 TCP 协议的，由于TCP的队头阻塞问题， HTTP&#x2F;3.0 将弃用 TCP，改用 <strong>基于 UDP 的 QUIC 协议</strong> 。</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2024/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/04/19/%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            算法记录
          
        </div>
      </a>
    
    
      <a href="/2023/10/03/hello-world/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Hello World</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2016-2024
        <i class="ri-heart-fill heart_icon"></i> RXQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="rxq的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://juejin.cn/user/3468338628928339">我的掘金</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>