<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="一个大三学生的简单个人博客" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>JUC |  xqr的博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="xqr的博客" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-JUC"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  JUC
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/04/19/JUC/" class="article-date">
  <time datetime="2024-04-19T15:01:45.000Z" itemprop="datePublished">2024-04-19</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">22.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">83 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>进程作为资源分配的基本单位,线程作为调度的基本单位。</p>
<ul>
<li>进程可看做是正在执行的程序,每个进程都有独立的代码和数据空间，所以进程间的切换会有较大的开销。一个进程在其执行的过程中可以产生多个线程。</li>
<li>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器（</strong>线程切换后能恢复到正确的执行位置<strong>）</strong>、<strong>虚拟机栈（</strong>保证线程中的局部变量不被别的线程访问到<strong>）</strong>和<strong>本地方法栈</strong>（包含局部变量，本地方法），所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li>
</ul>
<p>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响,因为它们共享了堆和方法区资源。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231016143302701.png" alt="image-20231016143302701"></p>
<ul>
<li>堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存）</li>
<li>方法区保存在着被加载过的每一个类的信息，包括类的方法、构造器，成员方法，属性等，这些信息由<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">类加载</a>器在加载类时，从类的源文件中抽取出来；<strong>运行时常量池</strong>：当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址转换为真实地址。</li>
</ul>
<h4 id="线程创建方法"><a href="#线程创建方法" class="headerlink" title="线程创建方法"></a>线程创建方法</h4><ol>
<li>继承Thread类并重写run方法</li>
</ol>
<ul>
<li><p>d定义Thread类的子类，并重写该类的run()方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。</p>
</li>
<li><p>创建Thread子类的实例，也就是创建了线程对象</p>
</li>
<li><p>启动线程，即调用线程的start()方法，本质上调用的是runable接口中的run方法</p>
</li>
</ul>
<p>代码实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;<span class="comment">//继承Thread类</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">new</span> <span class="title class_">MyThread</span>().start();<span class="comment">//创建并启动线程</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过实现Runnable接口并重写run方法</li>
</ol>
<ul>
<li><p>定义Runnable接口的实现类，一样要重写run()方法，这个run（）方法和Thread中的run()方法一样是线程的执行体</p>
</li>
<li><p>创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象</p>
</li>
<li><p>第三部依然是通过调用线程对象的start()方法来启动线程</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;<span class="comment">//实现Runnable接口</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　　<span class="comment">//创建并启动线程</span></span><br><span class="line">　　　　MyThread2 myThread=<span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">　　　　Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">　　　　thread().start();</span><br><span class="line">　　　　<span class="comment">//或者    new Thread(new MyThread2()).start();</span></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>实现Callable接口并实现call()方法</li>
</ol>
<ul>
<li><p>创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。</p>
</li>
<li><p>使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值</p>
</li>
<li><p>使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）</p>
</li>
<li><p>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread3</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　MyThread3 th=<span class="keyword">new</span> <span class="title class_">MyThread3</span>();</span><br><span class="line">      th.start();</span><br><span class="line">　　　<span class="comment">//也可以直接使用Lambda表达式创建Callable对象</span></span><br><span class="line">　　   <span class="comment">//使用FutureTask类来包装Callable对象</span></span><br><span class="line">　　　FutureTask&lt;Integer&gt; future=<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(</span><br><span class="line">　　　　(Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　  );</span><br><span class="line"></span><br><span class="line">　　　<span class="keyword">new</span> <span class="title class_">Thread</span>(future,<span class="string">&quot;有返回值的线程&quot;</span>).start();<span class="comment">//实质上还是以Callable对象来创建并启动线程</span></span><br><span class="line">　　  <span class="keyword">try</span> &#123;</span><br><span class="line">　　　　System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span>+future.get());<span class="comment">//get()方法会阻塞，直到子线程执行结束才返回</span></span><br><span class="line"> 　　 &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">　　　　ex.printStackTrace();</span><br><span class="line">　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用线程池来创建线程</li>
</ol>
<h4 id="Future-类有什么用？"><a href="#Future-类有什么用？" class="headerlink" title="Future 类有什么用？"></a>Future 类有什么用？</h4><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p>
<p>这其实就是多线程中经典的 <strong>Future 模式</strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p>
<p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p>
<ul>
<li>取消任务；</li>
<li>判断任务是否被取消;</li>
<li>判断任务是否已经执行完成;</li>
<li>获取任务执行结果。</li>
</ul>
<h4 id="Java内存区域，内存模型？"><a href="#Java内存区域，内存模型？" class="headerlink" title="Java内存区域，内存模型？"></a>Java内存区域，内存模型？</h4><p><strong>Java内存模型（JMM）</strong></p>
<p>可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112214089.png" alt="image-20231003112214089"></p>
<p>在当前的 Java 内存模型下，线程可以把变量保存 <strong>本地内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p>
<p><strong>Java内存区域</strong></p>
<p>Java的内存区域和内存模型是不一样的东西，内存区域是指 JVM 运行时将数据分区域存储，强调对内存空间的划分。</p>
<p>Java内存区域主要由栈、堆、方法区组成</p>
<p><strong>栈</strong>：每个线程有自己独立、不共享的虚拟机栈，由多个栈帧（每个方法运行时需要的内存）组成，其中存放参数、局部变量，返回地址等，每个线程只能有一个活动栈帧，对应当前正在执行的那个方法。</p>
<p><strong>堆</strong>：多个线程共享同一个堆，通过new关键字构建的对象都需要使用堆内存，里面存放了实例对象、字符串常量池，静态变量等。</p>
<p><strong>方法区</strong>：保存在着被加载过的每一个类的信息，包括类的方法、构造器，成员方法，属性等，这些信息由<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">类加载</a>器在加载类时，从类的源文件中抽取出来；<strong>运行时常量池</strong>：当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址转换为真实地址。</p>
<p><strong>程序计数器：</strong>每个线程都有一个独立的程序计数器，记录下一条JVM指令的执行地址</p>
<p><strong>本地方法栈：</strong>调用本地方法（由C或者C++编写的底层的方法，与操作系统的底层API打交道）时给本地方法提供的内存空间</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112225692.png" alt="image-20231003112225692"></p>
<h4 id="线程的上下文切换是什么"><a href="#线程的上下文切换是什么" class="headerlink" title="线程的上下文切换是什么"></a>线程的上下文切换是什么</h4><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p>
<ul>
<li>线程的 CPU 时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行，CPU被抢占</li>
<li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li>
<li>主动让出CPU调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
</ul>
<p>线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p>
<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念<br>就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p>
<p>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等<br>Context Switch 频繁发生会影响性能</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112229884.png" alt="image-20231003112229884"></p>
<h4 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h4><p>多个线程同时被阻塞，处于相互等待的状态，如果没有外界干预，线程会被无限期地阻塞，因此程序不可能正常终止</p>
<h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><p>互斥条件：该资源任意一个时刻只由一个线程占用。</p>
<p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p>
<p>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系</p>
<h5 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h5><p><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</p>
<p><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p>
<p><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>
<ul>
<li><h4 id="同步、异步、阻塞、非阻塞的理解"><a href="#同步、异步、阻塞、非阻塞的理解" class="headerlink" title="同步、异步、阻塞、非阻塞的理解"></a>同步、异步、阻塞、非阻塞的理解</h4><p>同步与异步关注的是<strong>消息通信机制</strong>（synchronous communication&#x2F; asynchronous communication）关注的<strong>是在发出调用后需不需要等待调用结果再返回调用</strong>。</p>
<p>阻塞和非阻塞关注的是<strong>程序在等待调用结果</strong>（消息，返回值）时的状态，关注的<strong>是等待调用结果时线程能否处理其他事情</strong>。</p>
<p><strong>阻塞</strong>调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<strong>非阻塞</strong>调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<p><strong>(1)阻塞(blocking)、非阻塞（non-blocking）：</strong>可以简单理解为需要做一件事能不能立即得到返回应答，如果不能立即获得返回，需要等待，那就阻塞了(进程或线程就阻塞在那了，不能做其它事情)，否则就可以理解为非阻塞(在等待的过程中可以做其它事情)。</p>
<p><strong>(2)同步(synchronous)、异步(asynchronous)：</strong> 总是做完一件再去做另一件，不管是否需要时间等待，这就是同步(在发出一个功能调用时，在没有得到结果之前，该调用就不返回,即此时不能做下一件事情)；异步则反之，可以同时做几件事，并非一定需要一件事做完再做另一件事(当一个异步过程调用发出后，调用者不能立刻得到结果,此时可以接着做其它事情)。</p>
<p>同步简单理解成一问一答同步进行，异步可以简单理解为不必等一个问题有了答案再去问另一个问题，尽管问，有答了再通知你。</p>
</li>
</ul>
<h4 id="start和-run方法的区别"><a href="#start和-run方法的区别" class="headerlink" title="start和 run方法的区别"></a>start和 run方法的区别</h4><ul>
<li><p>直接调用 run 是在主线程中执行了 run，没有启动新的线程</p>
</li>
<li><p>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</p>
</li>
</ul>
<p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<h4 id="java里面线程有几种状态？"><a href="#java里面线程有几种状态？" class="headerlink" title="java里面线程有几种状态？"></a>java里面线程有几种状态？</h4><h5 id="操作系统-层面来描述"><a href="#操作系统-层面来描述" class="headerlink" title="操作系统 层面来描述"></a>操作系统 层面来描述</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112235300.png" alt="image-20231003112235300"></p>
<ul>
<li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</li>
<li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li>
<li>【运行状态】指获取了 CPU 时间片运行中的状态 ：当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li>
<li>【阻塞状态】：如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】：等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】，阻塞状态与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li>
<li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li>
</ul>
<h5 id="Java-API-层面来描述"><a href="#Java-API-层面来描述" class="headerlink" title="Java API 层面来描述"></a>Java API 层面来描述</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112238774.png" alt="image-20231003112238774"></p>
<ul>
<li><p>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code>。</p>
<p>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</p>
<p>BLOCKED：阻塞状态，需要等待锁释放。</p>
<p>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</p>
<p>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</p>
<p>TERMINATED：终止状态，表示该线程已经运行完毕.</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112242092.png" alt="image-20231003112242092"></p>
</li>
</ul>
<h4 id="阻塞和等待有什么区别？"><a href="#阻塞和等待有什么区别？" class="headerlink" title="阻塞和等待有什么区别？"></a>阻塞和等待有什么区别？</h4><p>造成原因不同：线程因为对共享资源竞争失败进入阻塞，而等待是因为api调用而进入等待</p>
<p>我们说一个操作是”阻塞”的，我们的意思是这个操作会<strong>停止线程的执行</strong>，直到某个条件得到满足。例如，在传统的同步I&#x2F;O中，一个读操作会阻塞线程，直到数据可用为止。<strong>在阻塞期间，线程不能做任何其他的事情，它只是停在那里，等待读操作完成。</strong></p>
<p>当我们说一个操作是”等待”的，我们的意思是这个操作会<strong>让出线程的控制权</strong>，直到某个条件得到满足。例如，在异步I&#x2F;O中，一个读操作（如ReadAsync）会立即返回一个任务，代表这个操作的完成情况。<strong>在等待这个任务时，线程可以去做其他的事情。这就是所谓的”非阻塞”行为。</strong></p>
<h4 id="什么情况下会让线程进入-block-状态"><a href="#什么情况下会让线程进入-block-状态" class="headerlink" title="什么情况下会让线程进入 block 状态"></a>什么情况下会让线程进入 block 状态</h4><ul>
<li>t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED</li>
<li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED</li>
</ul>
<h4 id="线程调用sleep方法，sleep-10s-，结束后，调用sleep的线程处于什么状态？"><a href="#线程调用sleep方法，sleep-10s-，结束后，调用sleep的线程处于什么状态？" class="headerlink" title="线程调用sleep方法，sleep(10s)，结束后，调用sleep的线程处于什么状态？"></a>线程调用sleep方法，sleep(10s)，结束后，调用sleep的线程处于什么状态？</h4><p><strong>Runable状态</strong></p>
<p>在sleep的时间内，线程不会释放临界资源，在sleep结束之后，线程正常运行，sleep一般是模拟一些业务，之后unlock就释放了临界资源，比如锁</p>
<h4 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h4><p><strong>使用位置不同</strong>：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用</p>
<p><strong>释放资源不同</strong>：调用wait方法时，该线程必须持有锁资源，<strong>wait 方法会主动的释放锁，而 sleep 方法则不会</strong></p>
<p><strong>源头不同</strong>：wait 方法属于 Object 类的方法，而 sleep 属于 Thread 类的方法</p>
<p>sleep 方法必须要传递一个超时时间的参数，且过了超时时间之后，线程会自动唤醒。而 wait 方法可以不传递任何参数，不传递任何参数时表示永久休眠，直到另一个线程调用了 notify 或 notifyAll 之后，休眠的线程才能被唤醒。也就是说 <strong>sleep 方法具有主动唤醒功能，而不传递任何参数的 wait 方法只能被动的被唤醒</strong>。<strong>调用 sleep 方法线程会进入 TIMED_WAITING 有时限等待状态，而调用无参数的 wait 方法，线程会进入 WAITING 无时限等待状态</strong></p>
<h4 id="为什么wait和notify方法要写在synchronized同步代码块中？"><a href="#为什么wait和notify方法要写在synchronized同步代码块中？" class="headerlink" title="为什么wait和notify方法要写在synchronized同步代码块中？"></a>为什么wait和notify方法要写在synchronized同步代码块中？</h4><p>这是Java设计者为了避免使用者出现lost wake up(可能导致线程陷入永久等待)问题而搞出来的。</p>
<p>列举下面永久等待的场景：</p>
<p>所以需要synchronized这样的同步机制来避免多线程并发修改这个共享变量，造成永久等待的问题</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112303623.png" alt="image-20231003112303623"></p>
<p>问题的根源在于，消费者在检查count到调用wait()之间，count就可能被改掉了。</p>
<p>常见的解决方式是加锁</p>
<p> wait 和 notify 用来实现多线程之间的协调，wait 表示让线程进入到阻塞状态，notify 表示让阻塞的线程唤醒。</p>
<p>wait 和 notify 必然是成对出现的，如果一个线程被 wait()方法阻塞，那么必然需要另外一个线程通过 notify()方法来唤醒这个被阻塞的线程，从而实现多线程之间的通信。</p>
<p>在多线程里面，要实现多个线程之间的通信，除了管道流以外，只能通过共享变量的方法来实现，也就是线程 t1 修改共享变量 s，线程 t2 获取修改后的共享变量 s，从而完成数据通信。</p>
<p>但是多线程本身具有并行执行的特性，也就是在同一时刻，多个线程可以同时执行。在这种情况下，线程 t2 在访问共享变量 s 之前，必须要知道线程 t1 已经修改过了共享变量 s，否则就需要等待。<br>同时，线程 t1 修改过了共享变量 S 之后，还需要通知在等待中的线程 t2。所以要在这种特性下要去实现线程之间的通信，就必须要有一个竞争条件控制线程在什么条件下等待，什么条件下唤醒。</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231015195346379.png" alt="image-20231015195346379"></p>
<p>而 Synchronized 同步关键字就可以实现这样一个互斥条件，也就是在通过共享变量来实现多个线程通信的场景里面，参与通信的线程必须要竞争到这个共享变量的锁资源，才有资格对共享变量做修改，修改完成后就释放锁，那么其他的线程就可以再次来竞争同一个共享变量的锁来获取修改后的数据，从而完成线程之前的通信。</p>
<p>所以这也是为什么 wait&#x2F;notify 需要放在 Synchronized 同步代码块中的原因，有了 Synchronized 同步锁，就可以实现对多个通信线程之间的互斥，实现条件等待和条件唤醒。</p>
<h3 id="关键字与锁"><a href="#关键字与锁" class="headerlink" title="关键字与锁"></a>关键字与锁</h3><h4 id="类锁与对象锁的区别："><a href="#类锁与对象锁的区别：" class="headerlink" title="类锁与对象锁的区别："></a>类锁与对象锁的区别：</h4><h5 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a><strong>类锁</strong></h5><p>用synchronized修饰静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> method（）</span><br></pre></td></tr></table></figure>

<p>作用在代码块上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> method（）&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(object.class)&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类锁是加载类上的，而类信息是存在 JVM 方法区的，并且整个 JVM 只有一份，方法区又是所有线程共享的，所以类锁是所有线程共享的，所以同一时刻，只能有一个线程使用加了类锁的方法或方法体，不管是不是同一个实例。</p>
<h5 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h5><p>作用在实例方法上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> method（）&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>作用在代码块上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> method（）&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">   <span class="comment">//这里是需要同步的部分</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用对象锁的情况，只有使用同一实例的线程才会受对象锁的影响，多个实例调用同一方法也不会受影响。</p>
<p><strong>类锁和对象锁不存在冲突</strong>，<strong>对象锁和类锁互不影响</strong>，可同时申请一个类的类锁、和该类某实例的对象锁</p>
<h4 id="说一下synchronized关键字底层原理"><a href="#说一下synchronized关键字底层原理" class="headerlink" title="说一下synchronized关键字底层原理"></a>说一下synchronized关键字底层原理</h4><p>synchronized的底层是通过monitor对象来实现的。</p>
<p>Java对象在内存中的布局大致可以分为三部分：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>填充对齐</strong>。因为<code>synchronized</code>用的锁是存在对象头里的，这里我们需要重点了解对象头。如果对象头是数组类型，则对象头由<strong>Mark Word</strong>、<strong>Class MetadataAddress</strong>和<strong>Array length</strong>组成，如果对象头非数组类型，对象头则由<strong>Mark Word</strong>和<strong>Class MetadataAddress</strong>组成。</p>
<p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112246654.png" alt="image-20231003112246654"></p>
<p>monitor对象中有owner用来指示拥有锁的线程，entrylist来存放阻塞的线程（竞争失败的线程），waitSet来存放wating的线程（wait()方法），初始时，Monitor中的Owner为null，当第一个竞争锁的线程获得锁，其他的竞争这个锁的线程就会被放入EntryList等待，当获得锁的线程执行完同步代码块中的内容，就会唤醒EntryList中等待的线程，发生非公平竞争这个锁。<br>注意：<br>synchronized 必须是进入同一个对象的 monitor 才有上述的效果</p>
<p><strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p>
<p>上面的字节码中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。</p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 **对象监视器 <code>monitor</code>**（每个Java对象都可以关联一个monitor对象） 的持有权。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由[ObjectMonitoropen in new window](https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp)实现的。每个对象中都内置了一个 `ObjectMonitor`对象。</span><br><span class="line"></span><br><span class="line">另外，`wait/notify`等方法也依赖于`monitor`对象，这就是为什么只有在同步的块或者方法中才能调用`wait/notify`等方法，否则会抛出`java.lang.IllegalMonitorStateException`的异常的原因。</span><br></pre></td></tr></table></figure>

<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112249933.png" alt="image-20231003112249933"></p>
<p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112256314.png" alt="image-20231003112256314"></p>
<p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h5 id="synchronized-修饰方法的的情况"><a href="#synchronized-修饰方法的的情况" class="headerlink" title="synchronized 修饰方法的的情况"></a>synchronized 修饰方法的的情况</h5><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
<p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p>
<h4 id="讲一讲AQS"><a href="#讲一讲AQS" class="headerlink" title="讲一讲AQS"></a>讲一讲AQS</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p><code>AbstractQueuedSynchronizer(AQS)</code>提供了一套可用于实现锁同步机制和其他同步组件的框架。<code>AQS通过一个</code>FIFO<code>队列维护线程同步状态，实现类只需要继承该类，并重写指定方法即可实现一套线程同步机制</code>。在JUC<code>中，诸如</code>ReentrantLock<code>、</code>CountDownLatch<code>等都基于</code>AQS&#96;实现。</p>
<p><code>AQS</code>根据资源互斥级别提供了<strong>独占和共享</strong>两种资源访问模式；同时其定义<code>Condition</code>结构提供了<code>wait/signal</code>等待唤醒机制。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><code>AQS</code>维护了一个<code>volatile int state</code>变量（state &#x3D; 0 表示锁可用， state &#x3D;&gt; 1 表示锁已被占用）用来记录锁竞争的状态。</p>
<ul>
<li>一个线程来获得锁资源的时候首先会判断state是否等于0，如果是就把state更新为1，表示获得这个锁，为了防止多个线程同时更新state，AQS使用CAS保障state互斥变量更新的原子性。</li>
<li>未获得到锁的线程会阻塞，并按照先进先出的原则加入到双向链表中。</li>
</ul>
<p>当获得锁资源的线程释放锁后会从双向链表唤醒阻塞的线程。 </p>
<ul>
<li>AQS获取锁有公平竞争和非公平竞争，公平竞争就是在获取锁的时候，需要判断双向链表是否有阻塞的线程，如果有就需要去排队等待。 </li>
<li>非公平锁不管双向链表是否存在阻塞的线程，都会直接尝试更改state去获取锁。对于双向队列中阻塞的线程是不公平的</li>
</ul>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112335241.png" alt="image-20231003112335241"></p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/e22dfb7003ee44afb6f80ddfbce68a93tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-1696303417939-13.webp" alt="img"></p>
<p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p>
<ul>
<li>tryAcquire</li>
<li>tryRelease</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
<li>isHeldExclusively</li>
</ul>
<p><strong><code>Node</code>主要包含5个核心字段：</strong></p>
<ul>
<li><p>waitStatus</p>
<p>：当前节点状态，该字段共有5种取值：</p>
<ul>
<li><code>CANCELLED = 1</code>。节点引用线程由于等待超时或被打断时的状态。</li>
<li><code>SIGNAL = -1</code>。后继节点线程需要被唤醒时的当前节点状态。当队列中加入后继节点被挂起<code>(block)</code>时，其前驱节点会被设置为<code>SIGNAL</code>状态，表示该节点需要被唤醒。</li>
<li><code>CONDITION = -2</code>。当节点线程进入<code>condition</code>队列时的状态。(见<code>ConditionObject</code>)</li>
<li><code>PROPAGATE = -3</code>。仅在释放共享锁<code>releaseShared</code>时对头节点使用。(见共享锁分析)</li>
<li><code>0</code>。节点初始化时的状态。</li>
</ul>
</li>
<li><p><code>prev</code>：前驱节点。</p>
</li>
<li><p><code>next</code>：后继节点。</p>
</li>
<li><p><code>thread</code>：引用线程，头节点不包含线程。</p>
</li>
<li><p><code>nextWaiter</code>：<code>condition</code>条件队列。(见<code>ConditionObject</code>)</p>
</li>
</ul>
<h4 id="jdk1-7对synchorinzed的优化？"><a href="#jdk1-7对synchorinzed的优化？" class="headerlink" title="jdk1.7对synchorinzed的优化？"></a>jdk1.7对synchorinzed的优化？</h4><p>JDK1.6为了减少获得锁和释放锁所带来的性能消耗，引入了<strong>“偏向锁”</strong>和<strong>“轻量级锁”</strong>，所以在JDK1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。<strong>锁可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>
<td>适用于只有一个线程访问同步块场景。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>
<td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td>
<td>追求响应时间。同步块执行速度非常快。</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU。</td>
<td>线程阻塞，响应时间缓慢。</td>
<td>追求吞吐量。同步块执行速度较长。</td>
</tr>
</tbody></table>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁，顾名思义，它会偏向于第一个访问锁的线程</p>
<p>如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。线程第二次到达同步代码块时，会判断此时持有锁的线程是否就是自己，如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。<br>如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。<br>级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致<code>STW(stop the word)</code>操作</p>
<ul>
<li><h6 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h6><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象<br>的 Thread ID<br>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程</p>
</li>
<li><h6 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h6><p>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p>
</li>
</ul>
<h5 id="轻量级锁（还未关联monitor对象）"><a href="#轻量级锁（还未关联monitor对象）" class="headerlink" title="轻量级锁（还未关联monitor对象）"></a>轻量级锁（还未关联monitor对象）</h5><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以<br>使用轻量级锁来优化。当存在竞争时，锁膨胀升级为重量级锁来互斥访问。</p>
<p>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164622798.png" alt="image-20240322164622798"></p>
<p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164644569.png" alt="image-20240322164644569"></p>
<p>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164712066.png" alt="image-20240322164712066"></p>
<p>如果 cas 失败，有两种情况</p>
<ol>
<li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li>
<li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li>
</ol>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164748554.png" alt="image-20240322164748554"></p>
<p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164814658.png" alt="image-20240322164814658"></p>
<p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</p>
<ul>
<li>成功，则解锁成功</li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
<p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164905678.png" alt="image-20240322164905678"></p>
<p>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<strong>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</strong><br>然后自己进入 Monitor 的 EntryList BLOCKED</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164942030.png" alt="image-20240322164942030"></p>
<p>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁<br>流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</p>
<h5 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h5><p>重量级锁竞争的时候，如果竞争锁失败，该线程不会马上阻塞，使用自旋重试来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p>
<h4 id="Reentrantlock-与-synchronized-的区别"><a href="#Reentrantlock-与-synchronized-的区别" class="headerlink" title="Reentrantlock 与 synchronized 的区别"></a>Reentrantlock 与 synchronized 的区别</h4><p>Synchronized 可以通过两种方式来控制锁的粒度</p>
<ul>
<li>一种是把 synchronized 关键字修饰在方法层面，</li>
<li>另一种是修饰在代码块上，并且我们可以通过 Synchronized 加锁对象的声明周期来控制锁的作用范围，比如锁对象是静态对象或者类对象，那么这个锁就是全局锁。如果锁对象是普通实例对象，那这个锁的范围取决于这个实例的声明周期。</li>
</ul>
<p>Lock 锁的粒度是通过它里面提供的 lock()和 unlock()方法决定的（贴图），包裹在这两个方法之间的代码能够保证线程安全性。而锁的作用域取决于 Lock 实例的生命周期</p>
<p>相对于 synchronized 它具备如下特点</p>
<ul>
<li><strong>可以设置超时时间</strong>， Lock 还提供了非阻塞的竞争锁方法 tryLock(int time)方法，在规定时间获取不到锁会返回false</li>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li>
<li><strong>可实现选择性通知（支持多个条件变量）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
</ul>
<p>与 synchronized 一样，都支持可重入</p>
<h4 id="公平锁与非公平锁？底层实现是什么"><a href="#公平锁与非公平锁？底层实现是什么" class="headerlink" title="公平锁与非公平锁？底层实现是什么"></a>公平锁与非公平锁？底层实现是什么</h4><p>底层都是AQS，默认一般使用<strong>非公平锁</strong>，它的效率和吞吐量都比公平锁高的多。由于公平锁需要关心队列的情况，得按照队列里的先后顺序来获取锁(会造成大量的线程上下文切换)，而非公平锁则没有这个限制。所以也就能解释非公平锁的效率会被公平锁更高。</p>
<p><strong>公平锁</strong>：</p>
<p>线程在tryAcquire（arg）尝试获得锁之前会利用 hasQueuedPredecessors() 方法来判断 AQS 的队列中中是否有其他线程，如果有则不会尝试获取锁(<strong>这是公平锁特有的情况</strong>)。</p>
<p>如果队列中没有线程就利用 CAS 来将 AQS 中的 state 修改为1，也就是获取锁，获取成功则将当前线程置为获得锁的独占线程(setExclusiveOwnerThread(current))。</p>
<p>如果 state 大于 0 时，说明锁已经被获取了，则需要判断获取锁的线程是否为当前线程(ReentrantLock 支持重入)，是则需要将 state + 1，并将值更新。</p>
<p>如果tryAcquire(arg) 获取锁失败，则需要用 addWaiter(Node.EXCLUSIVE) 将当前线程写入队列中。</p>
<p>写入之前需要将当前线程包装为一个 Node 对象(addWaiter(Node.EXCLUSIVE))，通过自旋加上 CAS 保证一定能写入队列。</p>
<p><strong>非公平锁</strong>：尝试获取锁时tryAcquire(arg)，非公平锁是不需要判断队列中是否还有其他线程，也是直接尝试获取锁：</p>
<h4 id="可中断锁和不可中断锁有什么区别？"><a href="#可中断锁和不可中断锁有什么区别？" class="headerlink" title="可中断锁和不可中断锁有什么区别？"></a>可中断锁和不可中断锁有什么区别？</h4><ul>
<li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li>
<li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁</li>
</ul>
<h4 id="volatile关键字的原理？怎么用？是否保证原子性？"><a href="#volatile关键字的原理？怎么用？是否保证原子性？" class="headerlink" title="volatile关键字的原理？怎么用？是否保证原子性？"></a>volatile关键字的原理？怎么用？是否保证原子性？</h4><p>由于JVM缓存优化，线程读变量值时，可能会到自己的工作缓存去读而不是到内存，所以当一个线程对变量执行写操作到内存，可能其他线程无法读到最新的变量值。</p>
<p>用法：在多线程读，一线程写的情况下，用来修饰成员变量和静态成员变量，这就指示 JVM，这个变量是共享且不稳定的，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。</p>
<h5 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112310433.png" alt="image-20231003112310433"></p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112313979.png" alt="image-20231003112313979"></p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112317775.png" alt="image-20231003112317775"></p>
<p>Volatile关键字底层实现主要是<strong>通过汇编lock指令</strong>，当某个CPU修改了缓存里面的数据，该数据会马上通过总线同步回主存，（lock指令开启其他CPU的总线嗅探机制）其他CPU通过一个<strong>总线嗅探机制</strong>来感知数据的变化从而将自己缓存里面的数据失效，需要使用这个数据，必须重新去内存中获取最新的数据，来保证数据的可见性。</p>
<h5 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h5><p>当对volatile修饰变量赋值，会加上写屏障，写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当对volatile修饰变量取值，会加上读屏障，读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="不能解决指令交错（无法保证原子性）："><a href="#不能解决指令交错（无法保证原子性）：" class="headerlink" title="不能解决指令交错（无法保证原子性）："></a>不能解决指令交错（无法保证原子性）：</h5><p>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去<br>而有序性的保证也只是保证了本线程内相关代码不被重排序</p>
<h4 id="synchronized关键字保证可见性和有序性"><a href="#synchronized关键字保证可见性和有序性" class="headerlink" title="synchronized关键字保证可见性和有序性"></a>synchronized关键字保证可见性和有序性</h4><p>我们都知道sychronized底层是通过monitorenter的指令来进行加锁的、通过monitorexit指令来释放锁的。</p>
<p>但是很多人都不知道的一点是，monitorenter指令其实还具有Load屏障的作用。</p>
<p>也就是通过monitorenter指令之后，synchronized内部的共享变量，每次读取数据的时候被强制从主内存读取最新的数据。</p>
<p>同样的道理monitorexit指令也具有Store屏障的作用，也就是让synchronized代码块内的共享变量，如果数据有变更的，强制刷新回主内存。</p>
<p>这样通过这种方式，数据修改之后立即刷新回主内存，其他线程进入synchronized代码块后，使用共享变量的时候强制读取主内存的数据，上一个线程对共享变量的变更操作，它就能立即看到了。</p>
<p>同时synchronized加的内存屏障也能保证内部代码的有序性</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112322766.png" alt="image-20231003112322766"></p>
<h4 id="为什么单线程不需要这个volatile关键字多线程需要"><a href="#为什么单线程不需要这个volatile关键字多线程需要" class="headerlink" title="为什么单线程不需要这个volatile关键字多线程需要"></a>为什么单线程不需要这个volatile关键字多线程需要</h4><p>因为在单线程的环境下，只有一个线程会使用修改的变量，变量不存在可见性问题。同时，单线程下，JVM的指令重排序也不会改变执行结果。</p>
<h4 id="为什么会出现指令重排序："><a href="#为什么会出现指令重排序：" class="headerlink" title="为什么会出现指令重排序："></a>为什么会出现指令重排序：</h4><p>指令还可以再划分成一个个更小的阶段，在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行，从而提高CPU的吞吐率。</p>
<h4 id="讲一下CAS"><a href="#讲一下CAS" class="headerlink" title="讲一下CAS"></a>讲一下CAS</h4><p>CAS（Compare And Swap）是一种无锁同步机制，基于乐观锁的思想，但是它底层还是有用到锁的，使用总线锁锁住总线，确保在比较替换的过程中没有其他线程对该值进行修改，保障比较并替换的原子性。</p>
<p><strong>CAS 必须借助 volatile</strong> 才能读取到共享变量的最新值来实现【比较并交换】的效果</p>
<p>CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。</p>
<p>CAS指令执行时，通过发送一个lock指令锁住总线，确保整个比较并替换的操作是一个原子操作。<strong>当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则放弃对数据的操作。</strong></p>
<p>cas可以不用自旋重试机制，失败也可以直接返回false。只是一般应用场景下，cas都会带有重试机制（while和for实现空转，不断尝试）</p>
<h5 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h5><ul>
<li>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、竞争较少，多核 CPU 的场景下。</li>
<li>CAS 是基于乐观锁的思想：最乐观的估计，预计很少出现并发问题，当出现后，再重试。</li>
<li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，当一个线程上了锁，其他线程只能阻塞等待解锁。使得线程只能串行访问同步代码块，效率较低。</li>
<li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思</li>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈，可以想到CAS自旋重试必然频繁发生，反而效率会受影响</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p><strong>CAS长时间自旋开销很大：</strong>我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</p>
<p><strong>只能保证一个共享变量的原子操作：</strong>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p>
<p><strong>ABA*问题</strong>：<strong>通过版本号法解决。</strong>Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h5 id="用处："><a href="#用处：" class="headerlink" title="用处："></a>用处：</h5><p>Automic原子类，多线程的互斥同步等</p>
<h4 id="乐观锁和悲观锁的区别？"><a href="#乐观锁和悲观锁的区别？" class="headerlink" title="乐观锁和悲观锁的区别？"></a>乐观锁和悲观锁的区别？</h4><h5 id="什么悲观锁？"><a href="#什么悲观锁？" class="headerlink" title="什么悲观锁？"></a><strong>什么悲观锁？</strong></h5><p>悲观锁是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;</p>
<p>特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;		高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p>
<h5 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a><strong>什么是乐观锁？</strong></h5><p>乐观锁是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);</p>
<p>特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。</p>
<h5 id="理论上来说："><a href="#理论上来说：" class="headerlink" title="理论上来说："></a>理论上来说：</h5><ul>
<li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li>
<li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li>
</ul>
<h4 id="ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？"><a href="#ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？" class="headerlink" title="ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？"></a>ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112342131.png" alt="image-20231003112342131"></p>
<p>threadLocal 是一个用来解决线程安全性问题的工具。它相当于让每个线程都开辟一块内存空间，用来存储共享变量的副本。<br>然后每个线程只需要访问和操作自己的共享变量副本即可，从而避免多线程竞争同一个共享资源。<br>它的工作原理很简单（如图）</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112345346.png" alt="image-20231003112345346"></p>
<p>每个线程里面有一个成员变量 ThreadLocalMap,<br>当线程访问用 ThreadLocal 修饰的共享数据的时候<br>这个线程就会在自己成员变量 ThreadLocalMap 里面保存一份数据副本。<br>key 指向 ThreadLocal 这个引用，并且是弱引用关系，而 value 保存的是共享数据的副本。<br>因为每个线程都持有一个副本，所以就解决了线程安全性问题。</p>
<p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用<strong>弱引用</strong>的ThreadLocal实例，value为线程变量的副本。这些对象之间的引用关系如下,</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112348542.png" alt="image-20231003112348542"></p>
<blockquote>
<p>实心箭头表示强引用，空心箭头表示弱引用</p>
</blockquote>
<h5 id="ThreadLocal-内存泄漏的原因"><a href="#ThreadLocal-内存泄漏的原因" class="headerlink" title="ThreadLocal 内存泄漏的原因"></a>ThreadLocal 内存泄漏的原因</h5><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>
<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>由于Thread中包含变量ThreadLocalMap，因此ThreadLocalMap与Thread的生命周期是一样长，如果都没有手动删除对应key，都会导致内存泄漏。</p>
<p>但是使用<strong>弱引用</strong>可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set(),get(),remove()的时候会被清除。</p>
<p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p>
<h5 id="ThreadLocal正确的使用方法"><a href="#ThreadLocal正确的使用方法" class="headerlink" title="ThreadLocal正确的使用方法"></a>ThreadLocal正确的使用方法</h5><ul>
<li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li>
<li>(将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 )</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="单核-CPU-上运行多个线程效率一定会高吗？"><a href="#单核-CPU-上运行多个线程效率一定会高吗？" class="headerlink" title="单核 CPU 上运行多个线程效率一定会高吗？"></a>单核 CPU 上运行多个线程效率一定会高吗？</h4><p>单核CPU同时运行多个线程的效率是否会高，取决于线程的类型和任务的性质。两种类型的线程：CPU密集型和IO密集型。</p>
<ul>
<li>CPU密集型的线程主要进行计算和逻辑处理，需要占用大量的CPU资源。</li>
<li>IO密集型的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待IO设备的响应，而不占用太多的CPU资源。</li>
</ul>
<p>在单核CPU上，同一时刻只能有一个线程在运行，其他线程需要等待CPU的时间片分配。如果线程是CPU密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。</p>
<p>如果线程是IO密集型的，那么多个线程同时运行可以利用CPU在等待IO时的空闲时间，提高了效率。</p>
<p>因此，对于单核CPU来说，如果任务是CPU密集型的，那么开很多线程会影响效率；如果任务是IO密集型的，那么开很多线程会提高效率。当然，这里的“很多”也要适度，不能超过系统能够承受的上限。</p>
<h4 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h4 id="线程池的缺点"><a href="#线程池的缺点" class="headerlink" title="线程池的缺点"></a>线程池的缺点</h4><ul>
<li>可能引发死锁：在使用线程池时，如果任务之间存在依赖关系，或者线程因为资源的竞争，可能会引发死锁问题，需要额外的注意和处理。</li>
<li>不能对于线程池中任务设置优先级，只能按照先来先服务的策略</li>
<li><strong>难以调试</strong>: 线程池中的线程是由线程池管理的，因此在出现问题时，很难追踪和调试特定的线程。这可能会增加故障排除的难度。</li>
</ul>
<h4 id="线程池的拒绝策略有哪些？"><a href="#线程池的拒绝策略有哪些？" class="headerlink" title="线程池的拒绝策略有哪些？"></a>线程池的拒绝策略有哪些？</h4><p>若线程池中的核心线程数被用完且阻塞队列已排满，则此时线程池的资源已耗尽，线程池将没有足够的线程资源执行新的任务。为了保证操作系统的安全，线程池将通过拒绝策略处理新添加的线程任务。</p>
<h5 id="1-AbortPolicy（默认策略）"><a href="#1-AbortPolicy（默认策略）" class="headerlink" title="1. AbortPolicy（默认策略）"></a><strong>1. AbortPolicy</strong>（默认策略）</h5><p>第一种拒绝策略是 <code>AbortPolicy</code>，这种拒绝策略在拒绝任务时，会直接抛出一个类型为 RejectedExecutionException的RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。</p>
<h5 id="2-DiscardPolicy"><a href="#2-DiscardPolicy" class="headerlink" title="2.DiscardPolicy"></a><strong>2.DiscardPolicy</strong></h5><p>第2种拒绝策略是 <code>DiscardPolicy</code>，这种拒绝策略正如它的名字所描述的一样，当新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失。</p>
<h5 id="3-DiscardOldestPolicy"><a href="#3-DiscardOldestPolicy" class="headerlink" title="3.DiscardOldestPolicy"></a><strong>3.DiscardOldestPolicy</strong></h5><p>第3种拒绝策略是 <code>DiscardOldestPolicy</code>，如果线程池没被关闭且没有能力执行，则会丢弃任务队列中的头结点，通常是存活时间最长的任务，这种策略与第二种不同之处在于它丢弃的不是最新提交的，而是队列中存活时间最长的，这样就可以腾出空间给新提交的任务，但同理它也存在一定的数据丢失风险。</p>
<h5 id="4-CallerRunsPolicy"><a href="#4-CallerRunsPolicy" class="headerlink" title="4.CallerRunsPolicy"></a><strong>4.CallerRunsPolicy</strong></h5><p>第4种拒绝策略是 CallerRunsPolicy，相对而言它就比较完善了，当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。这样做主要有两点好处。</p>
<ol>
<li>第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。</li>
<li>第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。</li>
</ol>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>本文中我们学习线程池中的4 种默认的拒绝策略。线程池会在以下两种情况下会拒绝新提交的任务。</p>
<ul>
<li>第一种情况是当我们调用 shutdown 等方法关闭线程池后，即便此时可能线程池内部依然有没执行完的任务正在执行，但是由于线程池已经关闭，此时如果再向线程池内提交任务，就会遭到拒绝。</li>
<li>第二种情况是线程池没有能力继续处理新提交的任务，也就是工作已经非常饱和的时候。</li>
</ul>
<p>线程池状态</p>
<p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112330381.png" alt="image-20231003112330381"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c 为旧值， ctlOf 返回结果为新值</span></span><br><span class="line">ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));</span><br><span class="line"><span class="comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Excetors工具类提供了哪些线程池？有什么问题吗？"><a href="#Excetors工具类提供了哪些线程池？有什么问题吗？" class="headerlink" title="Excetors工具类提供了哪些线程池？有什么问题吗？"></a>Excetors工具类提供了哪些线程池？有什么问题吗？</h4><p>四种阻塞队列</p>
<p>*<strong>基于数组的先进先出队列，有界</strong></p>
<ul>
<li>new ArrayBlockingQueue&lt;&gt;(10)</li>
</ul>
<p>生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行</p>
<p><strong>由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列</strong></p>
<ul>
<li>new LinkedBlockingQueue&lt;&gt;()</li>
</ul>
<p>生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p>
<p><strong>无缓冲的等待队列，无界</strong></p>
<ul>
<li>new SynchronousQueue&lt;&gt;()</li>
</ul>
<p>不存储元素的阻塞队列，也即单个元素的队列。</p>
<p><strong>使用优先级队列实现的延迟无界阻塞队列。</strong></p>
<p>new DelayQueue&lt;&gt;()<br>DelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p>
<p>Executors中创建线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Executors</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建固定数量线程的线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这是最后一个参数--阻塞队列调用的方法，长度是Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     * public LinkedBlockingQueue() &#123;</span></span><br><span class="line"><span class="comment">     *    this(Integer.MAX_VALUE);</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建只有一个线程的线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这是最后一个参数--阻塞队列调用的方法，长度也是Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     * public LinkedBlockingQueue() &#123;</span></span><br><span class="line"><span class="comment">     *    this(Integer.MAX_VALUE);</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created single-threaded Executor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *创建一个缓冲线程池 </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这是最后一个参数--阻塞队列调用的方法</span></span><br><span class="line"><span class="comment">     * public SynchronousQueue() &#123;</span></span><br><span class="line"><span class="comment">     *    this(false);</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 它的第二个参数，maximumPoolSize 为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a thread pool that can schedule commands to run after a</span></span><br><span class="line"><span class="comment">     * given delay, or to execute periodically.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 创建一个可以在给定延迟后再执行或定期执行命令的线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ScheduledThreadPoolExecutor 是 ThreadPoolExecutor 的子类，代码如下：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor</span></span><br><span class="line"><span class="comment">        implements ScheduledExecutorService &#123;</span></span><br><span class="line"><span class="comment">            //这是下面调用的构造方法，其实是调用了父类的构造方法,这些参数都是下面分析的参数</span></span><br><span class="line"><span class="comment">            public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span></span><br><span class="line"><span class="comment">               super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span></span><br><span class="line"><span class="comment">               new DelayedWorkQueue());</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FixedThreadPool 和 SingleThreadExecutor 传入的最后一个参数阻塞队列 ”workQueue“，默认的长度是INTEGER.MAX_VALUE，而它们允许的最大线程数量又是有限的，所以当请求线程的任务过多线程不够用时，它们会在队列中等待，又因为队列的长度特别长，所以可能会堆积大量的请求，导致OOM。</p>
<p>CachedThreadPool 和 ScheduledThreadPool 它们的阻塞队列长度有限，但是传入的第二个参数maximumPoolSize 为Integer.MAX_VALUE，这就意味着当请求线程的任务过多线程不够而且队列也满了的时候，线程池就会创建新的线程，因为它允许的最大线程数量是相当大的，所以可能会创建大量线程，导致OOM。</p>
<p>Executors类中封装好的创建线程池的方法使用方便，但是也有其局限性和风险性，所以我们可以使用 ThreadPoolExecutor 类中的构造方法手动创建线程池的实例， 从而可以根据我们的使用情况来指定参数，满足使用的同时又能规避风险。<br>所以，说白了，使用Executors类创建线程池与使用ThreadPoolExecutor类的区别就是使用ThreadPoolExecutor类可以自定义传入我们设置的线程池的参数，更加灵活。</p>
<h4 id="线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列"><a href="#线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列" class="headerlink" title="线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列"></a>线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列</h4><ul>
<li><h5 id="corePoolSize-核心线程数目-正常情况下最多保留的线程数"><a href="#corePoolSize-核心线程数目-正常情况下最多保留的线程数" class="headerlink" title="corePoolSize 核心线程数目 (正常情况下最多保留的线程数)"></a>corePoolSize 核心线程数目 (正常情况下最多保留的线程数)</h5></li>
</ul>
<p>线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。任务提交到线程池后，首先会检查当前线程数是否达到了corePoolSize，如果没有达到的话，则会创建一个新线程来处理这个任务。</p>
<ul>
<li><h5 id="maximumPoolSize-最大线程数目"><a href="#maximumPoolSize-最大线程数目" class="headerlink" title="maximumPoolSize 最大线程数目"></a>maximumPoolSize 最大线程数目</h5></li>
</ul>
<p>当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务缓存到工作队列（后面会介绍）中。如果队列也已满，则会去创建一个新线程来出来这个处理。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即maximunPoolSize指定</p>
<ul>
<li><h5 id="keepAliveTime-生存时间-针对救急线程，当没有任务一段时间会被销毁"><a href="#keepAliveTime-生存时间-针对救急线程，当没有任务一段时间会被销毁" class="headerlink" title="keepAliveTime 生存时间 - 针对救急线程，当没有任务一段时间会被销毁"></a>keepAliveTime 生存时间 - 针对救急线程，当没有任务一段时间会被销毁</h5></li>
</ul>
<p>线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 <code>corePoolSize</code> ，回收过程才会停止。</p>
<ul>
<li><h5 id="unit-时间单位-针对多余空闲线程，-救急线程存活时间单位"><a href="#unit-时间单位-针对多余空闲线程，-救急线程存活时间单位" class="headerlink" title="unit 时间单位 - 针对多余空闲线程， 救急线程存活时间单位"></a>unit 时间单位 - 针对多余空闲线程， 救急线程存活时间单位</h5></li>
<li><h5 id="workQueue-阻塞队列"><a href="#workQueue-阻塞队列" class="headerlink" title="workQueue 阻塞队列"></a>workQueue 阻塞队列</h5></li>
</ul>
<p>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程</p>
<ul>
<li><h5 id="threadFactory-线程工厂-可以为线程创建时起个好名字"><a href="#threadFactory-线程工厂-可以为线程创建时起个好名字" class="headerlink" title="threadFactory 线程工厂 - 可以为线程创建时起个好名字"></a>threadFactory 线程工厂 - 可以为线程创建时起个好名字</h5></li>
</ul>
<p>创建一个新线程时使用的工厂，可以用来<strong>设定线程名、是否为daemon（守护线程）线程</strong>等等</p>
<ul>
<li><h5 id="handler-拒绝策略"><a href="#handler-拒绝策略" class="headerlink" title="handler 拒绝策略"></a>handler 拒绝策略</h5></li>
</ul>
<p>当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，就会采用拒绝策略</p>
<h4 id="为什么线程池创建新线程需要获取全局锁？"><a href="#为什么线程池创建新线程需要获取全局锁？" class="headerlink" title="为什么线程池创建新线程需要获取全局锁？"></a>为什么线程池创建新线程需要获取全局锁？</h4><ol>
<li><strong>线程池的状态管理</strong>：线程池需要跟踪已创建的线程数、空闲线程数、正在运行的任务等状态信息。这些状态信息需要在多线程环境下进行更新和访问，因此需要使用全局锁来确保状态的一致性，防止多个线程同时修改状态信息导致的竞态条件。</li>
<li><strong>线程资源管理</strong>：线程池通常会限制创建的线程数量，以避免因为创建过多线程导致系统资源耗尽或者性能下降。因此，在创建新线程之前需要检查当前已创建的线程数量，这涉及到对线程池状态的读取和更新，需要使用全局锁来确保一致性。</li>
</ol>
<h4 id="execute源码步骤"><a href="#execute源码步骤" class="headerlink" title="execute源码步骤"></a>execute源码步骤</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-c2f64c062ff28d9ca7b37a2624367fb3_1440w.webp" alt="img"></p>
<p>从上图可以把execute方法主要分三个步骤：</p>
<ul>
<li>首先如果当前工作线程数小于核心线程，则调用addWorker(command, true)方法创建核心线程执行任务。</li>
<li>其次如果当前线程大于核心线程数则判断等待队列是否已满，如果没有满则添加任务到等待队列中去，如果工作线程数量为0则调用addWorker(null, false)方法创建非核心线程，并从等待队列中拉取任务执行。</li>
<li>最后如果队列已满则会调用addWorker(command, false)方法创建一个非核心线程执行任务。如果创建失败则会拒绝任务。</li>
</ul>
<p><strong>简单来说就是优先核心线程，其次等待队列，最后非核心线程。</strong></p>
<h5 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h5><p><strong>可以看到execute中最关键的就是addWorker方法</strong>，它接受两个参数：</p>
<ul>
<li>第一个参数是要执行的任务，如果为null那么会从等待队列中拉取任务；</li>
<li>第二个参数是表示是否核心线程，用来控制addWorker方法流程的；</li>
</ul>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-757aff298fc6e148b609037749de418c_1440w.webp" alt="img"></p>
<p>流程中去除一些异常情况，只留了主要流程，流程中有一步验证线程数大于核心线程或者最大线程数</p>
<ul>
<li>如果传递的参数core等于true那么运行线程数量不能大于核心线程数量，</li>
<li>如果为false则当前线程数量不能大于最大线程数。</li>
</ul>
<p><strong>addWorker只有两个作用：增加工作线程数量、创建一个Worker并加到工作线程集合中。</strong></p>
<h5 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h5><p>Worker类就是线程池中执行任务的类，主要源码和解释如下图：</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-19a9c0570d56fb82d57680103305496d_1440w.webp" alt="img"></p>
<p>所以Worker本身就是一个Runnable，它有两个属性thead、firstTask；那我们就可以来梳理一下整体的运行流程了：</p>
<p><strong>线程池调用execute</strong>—&gt;<strong>创建Worker（设置属性thead、firstTask）</strong>—&gt;**worker.thread.start()**—&gt;**实际上调用的是worker.run()**—&gt;**线程池的runWorker(worker)**—&gt;<strong>worker.firstTask.run()</strong>(如果firstTask为null就从等待队列中拉取一个)。</p>
<p>转了一大圈最终调用最开始传进来的任务的run方法，不过通过等待队列可以重复利用worker与worker中的线程，变化的只是firstTask；</p>
<h4 id="submit和execute的区别"><a href="#submit和execute的区别" class="headerlink" title="submit和execute的区别:"></a>submit和execute的区别:</h4><p><font color = gold>execute和submit最大的区别就是execute没有返回值，submit有返回值。submit返回的是一个future ，可以通过这个future取到线程执行的结果或者异常信息。</font></p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/637fd0fa146c4bb4be2e6cbaefb9bc6ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="图片"></p>
<p>submit不打印异常信息，而execute则会打印异常信息！，submit的方式不打印异常信息，显然在生产中，是不可行的，因为我们无法保证线程中的任务永不异常，而如果使用submit的方式出现了异常，直接如上写法，我们将无法获取到异常信息，做出对应的判断和处理，所以下一步需要知道如何获取线程池抛出的异常！</p>
<p><code>submit()</code>想要获取异常信息就必须使用<code>get()</code>方法！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当线程池抛出异常后 submit无提示，其他线程继续执行</span></span><br><span class="line">Future&lt;?&gt; submit = executorService.submit(<span class="keyword">new</span> <span class="title class_">task</span>());</span><br><span class="line">submit.get();</span><br></pre></td></tr></table></figure>

<p>submit打印异常信息如下：</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/4cdc421e484c4468ab052ff82c500a39tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="图片"></p>
<p>submit源码在底层还是调用的execute方法，只不过多一层Future封装，并返回了这个Future，这也解释了为什么submit会有返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//submit()方法</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//execute内部执行这个对象内部的逻辑，然后将结果或者异常 set到这个ftask里面</span></span><br><span class="line">     RunnableFuture&lt;T&gt; ftask = newTaskFor(task); </span><br><span class="line">     <span class="comment">// 执行execute方法</span></span><br><span class="line">     execute(ftask); </span><br><span class="line">     <span class="comment">//返回这个ftask</span></span><br><span class="line">     <span class="keyword">return</span> ftask;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果用execute提交的任务，会被封装成了一个runable任务，然后进去 再被封装成一个worker,最后在worker的run方法里面调用runWoker方法， <code>runWoker</code>方法里面执行任务任务，如果任务出现异常，用<code>try-catch</code>捕获异常往外面抛，我们在最外层使用<code>try-catch</code>捕获到了 <code>runWoker</code>方法中抛出的异常。因此我们在execute中看到了我们的任务的异常信息。</li>
<li><font color = gold>submit是将任务封装成了一个<code>futureTask</code></font> ，然后这个<code>futureTask</code>被封装成worker，在woker的run方法里面，最终调用的是<code>futureTask</code>的run方法， 里面是直接吞掉了异常，并没有抛出异常，因此在worker的<code>runWorker</code>方法里面无法捕获到异常。</li>
</ul>
<p>下面来看一下<code>futureTask</code>的run方法，在try-catch中吞掉了异常，将异常放到了 <code>setException(ex);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">         !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                      <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Callable&lt;V&gt; c = callable;</span><br><span class="line">         <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">             V result;</span><br><span class="line">             <span class="type">boolean</span> ran;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 result = c.call();</span><br><span class="line">                 ran = <span class="literal">true</span>;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                 result = <span class="literal">null</span>;</span><br><span class="line">                 ran = <span class="literal">false</span>;</span><br><span class="line">                 <span class="comment">//在此方法中设置了异常信息</span></span><br><span class="line">                 setException(ex);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (ran)</span><br><span class="line">                 set(result);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//省略下文</span></span><br><span class="line">         。。。。。</span><br><span class="line">        <span class="comment">//setException(ex)`方法如下：将异常对象赋予`outcome</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setException</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">//将异常对象赋予outcome，记住这个outcome，</span></span><br><span class="line">           outcome = t;</span><br><span class="line">           UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">           finishCompletion();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>将异常对象赋予<code>outcome</code>有什么用呢？这个<code>outcome</code>是什么呢？当我们使用submit返回Future对象，并使用<code>Future.get()</code>时， 会调用内部的report方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="comment">//注意这个方法</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reoport里面实际上返回的是outcome ,刚好之前的异常就set到了这个outcome里面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException &#123;</span><br><span class="line"> <span class="comment">//设置`outcome`</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">     <span class="comment">//返回`outcome`</span></span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color = gold>因此，在用submit提交的时候，runable对象被封装成了future ，future 里面的 run方法在处理异常时， <code>try-catch</code>了所有的异常，通过<code>setException(ex);</code>方法设置到了变量outcome里面， 可以通过<code>future.get</code>获取到outcome。</font></p>
<p><strong>在submit提交的时候，里面发生了异常， 是不会有任何抛出信息的。而通过<code>future.get（）</code>可以获取到submit抛出的异常！</strong>在submit里面，除了从返回结果里面取到异常之外, 没有其他方法。因此，在不需要返回结果的情况下，<strong>最好用execute ，这样就算没有写<code>try-catch</code>，疏漏了异常捕捉，也不至于丢掉异常信息</strong>。</p>
<h5 id="解决异常："><a href="#解决异常：" class="headerlink" title="解决异常："></a>解决异常：</h5><p><strong>方案一：在run()方法中使用 try -catch</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">ThreadPoolException</span> &#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个线程池</span></span><br><span class="line">        <span class="title class_">ExecutorService</span> executorService = <span class="title class_">Executors</span>.<span class="title function_">newFixedThreadPool</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当线程池抛出异常后 submit无提示，其他线程继续执行</span></span><br><span class="line">        executorService.<span class="title function_">submit</span>(<span class="keyword">new</span> <span class="title function_">task</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当线程池抛出异常后 execute抛出异常，其他线程继续执行新任务</span></span><br><span class="line">        executorService.<span class="title function_">execute</span>(<span class="keyword">new</span> <span class="title function_">task</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">task</span> implements <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;进入了task方法！！！&quot;</span>);</span><br><span class="line">            int i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) &#123;</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;使用了try -catch 捕获异常&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/52929d67d8707f0909d7b9c3125cf590.png" alt="img"></p>
<p>可以看到 submit 和 execute都清晰易懂的捕获到了异常，可以知道我们的任务出现了问题，而不是消失的无影无踪。</p>
<p><strong>实现 ThreadFactory，自定义线程工厂类（推荐）</strong></p>
<p>第一种方法需要我们在每个任务中手动添加 try-catch 代码块，这样做非常繁琐且不可靠。为了避免重复工作，我们可以通过自定义线程工厂类来实现。线程池创建工作线程时会使用 ThreadFactory 的实现类来创建线程，因此我们只需要实现 ThreadFactory 接口，自定义线程工厂类，并将其传递给创建线程池的构造方法中。</p>
<p>自定义线程工厂方法，为每一个 run 方法添加 try-catch 代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">poolNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    CustomThreadFactory() &#123;</span><br><span class="line">        namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                poolNumber.getAndIncrement() +</span><br><span class="line">                <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, namePrefix + threadNumber.getAndIncrement()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">super</span>.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;异常信息：&quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color = gold>当使用 submit 方法提交的任务出现异常时，仍然无法进行处理,因为在run()方法中出现异常被内部捕获了，但至少解决了在 execute 方法中任务出现异常的情况。对于 FutureTask 的异常，调用方需要自行处理，因为 FutureTask 设计的本意就是将结果交给调用方处理，这个结果也包含异常。</font></p>
<h4 id="为什么核心线程池满了后-不直接创建新的线程去执行新任务？而是先交给任务队列呢？"><a href="#为什么核心线程池满了后-不直接创建新的线程去执行新任务？而是先交给任务队列呢？" class="headerlink" title="为什么核心线程池满了后 不直接创建新的线程去执行新任务？而是先交给任务队列呢？"></a>为什么核心线程池满了后 不直接创建新的线程去执行新任务？而是先交给任务队列呢？</h4><p><strong>因为如果核心线程满了就创建新的线程去执行，达到最大线程数之后再放入队列，那么新创建线程就需要获取全局锁，对性能有很大的损耗。</strong>而且如果正在被核心线程执行的任务很快的执行完，就可以直接从任务队列中取出新的任务执行。</p>
<p>ThreadPoolExecutor 采取上述步 骤 的 总 体 设计 思路，是 为 了在 执 行 execute() 方法时，尽可能地避免获取全局锁 （创建新的线程需要先获取全局锁、销毁线程也需要获取全局锁mainLock）。而从阻塞队列中取任务来执行不需要获取全局锁</p>
<p> <img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/8477e7c513404fcfa6aa2c57dc335019.png" alt="img"></p>
<h4 id="阻塞队列的作用是什么"><a href="#阻塞队列的作用是什么" class="headerlink" title="阻塞队列的作用是什么"></a>阻塞队列的作用是什么</h4><ul>
<li>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使线程进入wait状态，释放CPU资源</li>
<li>阻塞队列自带阻塞和唤醒的功能，不需要额外处理，无任务执行时，线程池利用阻塞队列的take方法挂起，从而维持核心线程的存活，不至于一直占的CPU资源</li>
</ul>
<h4 id="使用阻塞队列需要注意什么"><a href="#使用阻塞队列需要注意什么" class="headerlink" title="使用阻塞队列需要注意什么"></a>使用阻塞队列需要注意什么</h4><ol>
<li><strong>异常处理</strong>：在使用阻塞队列时，需要注意异常处理机制。例如，在使用有界阻塞队列时，如果队列已满而无法接受新任务，可能会触发拒绝策略，需要合理处理拒绝策略以防止任务丢失。</li>
<li><strong>选择合适的阻塞队列类型</strong>：Java 提供了多种阻塞队列实现，如 <code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>PriorityBlockingQueue</code> 等。选择合适的队列类型需要考虑线程池的特性、任务处理情况以及性能需求。</li>
<li><strong>队列容量设置</strong>：阻塞队列的容量设置需要根据系统负载和任务处理速度进行合理的调整。如果任务处理速度远快于任务提交速度，可能会导致队列溢出，从而触发拒绝策略。因此，需要根据具体情况设置合适的队列容量。</li>
</ol>
<h4 id="创建多少核心线程数合适（线程池的参数怎么设计）"><a href="#创建多少核心线程数合适（线程池的参数怎么设计）" class="headerlink" title="创建多少核心线程数合适（线程池的参数怎么设计）"></a>创建多少核心线程数合适（线程池的参数怎么设计）</h4><ul>
<li>过小会导致程序不能充分地利用系统资源、容易导致饥饿</li>
<li>过大会导致更多的线程上下文切换，占用更多内存</li>
</ul>
<h5 id="CPU-密集型运算"><a href="#CPU-密集型运算" class="headerlink" title="CPU 密集型运算"></a>CPU 密集型运算</h5><p>通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p>
<h5 id="I-O-密集型运算"><a href="#I-O-密集型运算" class="headerlink" title="I&#x2F;O 密集型运算"></a>I&#x2F;O 密集型运算</h5><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。<br>经验公式如下</p>
<p>线程数 &#x3D; 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) &#x2F; CPU 计算时间</p>
<p>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式</p>
<p>4 * 100% * 100% &#x2F; 50% &#x3D; 8</p>
<p>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式</p>
<p>4 * 100% * 100% &#x2F; 10% &#x3D; 40</p>
<p><strong>公示也只是参考，具体还是要根据项目实际线上运行情况来动态调整</strong>，包括核心线程数、最大线程数、自定义任务队列等等</p>
<h4 id="假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？"><a href="#假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？" class="headerlink" title="假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？"></a>假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？</h4><ul>
<li>高并发低延迟业务，低延迟说明大概率是CPU密集型，高并发的情况下为了防止大量的上下文切换，核心线程数不宜设置太高，应该设置大概CPU核数 + 1个线程，</li>
<li>低并发高延迟业务，高延迟说明所需数据或外部资源需要较长时间等待，大概率是IO密集型，核心线程数应该设置为    CPU 核数 * 总时间(CPU计算时间+等待时间) &#x2F; CPU 计算时间</li>
</ul>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><h4 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h4><h5 id="LongAdder的成员变量"><a href="#LongAdder的成员变量" class="headerlink" title="LongAdder的成员变量"></a><strong>LongAdder的成员变量</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPU的数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">// Cell对象的数组，长度一般是2的指数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="comment">// 基础value值，当并发较低时，只累加该值</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"><span class="comment">// 创建或者扩容Cells数组时使用的自旋锁变量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br></pre></td></tr></table></figure>

<p>当并发量较少时，cell数组尚未初始化，所以只调用<code>casBase</code>函数，对base变量进行CAS累加。</p>
<p>并发量大时，放弃使用base变量，而是从cells数组中随机选择一个cell，CAS累加，这样就可以减少并发冲突，获取值就用base加上cells中所有元素累加获得值，遍历数组不是个原子操作，所以LongAdder取到的值不是最新值，再获取精确计数的场景，可能不适合。</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240329130947920.png" alt="image-20240329130947920"></p>
<h4 id="CountdownLatch和CyclicBarrier的区别使用场景与具体实现"><a href="#CountdownLatch和CyclicBarrier的区别使用场景与具体实现" class="headerlink" title="CountdownLatch和CyclicBarrier的区别使用场景与具体实现"></a>CountdownLatch和CyclicBarrier的区别使用场景与具体实现</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/139020914">CountdownLatch和CyclicBarrier的区别使用场景与具体实现 - 知乎 (zhihu.com)</a></p>
<p><strong>CountdownLatch 使用场景</strong></p>
<p>顾名思义CountdownLatch可以当做一个计数器来使用,比如主线程需要等待其他几个线程都执行过某个时间节点后才能继续执行 我们来模拟一个场景,某公司一共有十个人,门卫要等十个人都来上班以后,才可以休息,代码实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//lambda中只能只用final的变量</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在赶路&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> * times);</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;到公司了&quot;</span>);</span><br><span class="line">                    <span class="comment">//调用latch的countDown方法使计数器-1</span></span><br><span class="line">                    latch.countDown();</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始工作&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;门卫等待员工上班中...&quot;</span>);</span><br><span class="line">            <span class="comment">//主线程阻塞等待计数器归零</span></span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;员工都来了,门卫去休息了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行后结果如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">子线程Thread-<span class="number">0</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">2</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">0</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">0</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">1</span>正在赶路</span><br><span class="line">门卫等待员工上班中...</span><br><span class="line">子线程Thread-<span class="number">4</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">9</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">5</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">6</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">7</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">8</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">3</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">1</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">1</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">2</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">2</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">3</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">3</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">4</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">4</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">5</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">5</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">6</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">6</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">7</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">7</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">8</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">8</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">9</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">9</span>开始工作</span><br><span class="line">员工都来了,门卫去休息了</span><br></pre></td></tr></table></figure>

<h5 id="CyclicBarrier-使用场景"><a href="#CyclicBarrier-使用场景" class="headerlink" title="CyclicBarrier 使用场景"></a>CyclicBarrier 使用场景</h5><p>我们重新模拟一个新的场景,就用已经被说烂的跑步场景吧,十名运动员各自准备比赛,需要等待所有运动员都准备好以后,裁判才能说开始然后所有运动员一起跑,代码实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">10</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有人都准备好了裁判开始了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//lambda中只能只用final的变量</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在准备&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> * times);</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备好了&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始跑了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">子线程Thread-<span class="number">0</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">2</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">1</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">3</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">4</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">0</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">5</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">6</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">7</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">8</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">9</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">1</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">2</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">3</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">4</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">5</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">6</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">7</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">8</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">9</span>准备好了</span><br><span class="line">所有人都准备好了裁判开始了</span><br><span class="line">子线程Thread-<span class="number">9</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">0</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">2</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">1</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">7</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">6</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">5</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">4</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">3</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">8</span>开始跑了</span><br></pre></td></tr></table></figure>

<h5 id="CountdownLatch-底层实现"><a href="#CountdownLatch-底层实现" class="headerlink" title="CountdownLatch 底层实现"></a>CountdownLatch 底层实现</h5><p>我们先来看看CountdownLatch的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先保证了count一定要大于零,然后初始化了一个Sync对象,在看看这个Sync对象是个什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">        Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Sync是CountdownLatch的静态内部类,继承了AbstractQueuedSynchronizer(即AQS,提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的工具,回头单讲)抽象类, 在Sync的构造方法中,调用了setState方法,可以视作初始化了一个标记来记录当前计数器的数量</p>
<p>我们来看CountdownLatch的两个核心方法,await和countdown,先来看await</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//可以视作将线程阻塞</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>await调用的是AQS的方法,可以视作阻塞线程,具体实现在分析AQS的章节中展开 再来看看countdown方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调用了sync的一个方法,再来看看这个方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再来看这个tryReleaseShared方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取标记位</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//用cas的方式更新标记位</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在调用tryReleaseShared实际上是将标记位-1并且返回标记位是否为0,如果标记位为0 那么调用的doReleaseShared可以视作将阻塞的线程放行,这样整个的流程就通了</p>
<h5 id="CyclicBarrier-底层实现"><a href="#CyclicBarrier-底层实现" class="headerlink" title="CyclicBarrier 底层实现"></a>CyclicBarrier 底层实现</h5><p>老规矩先看构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="built_in">this</span>.parties = parties;</span><br><span class="line">        <span class="built_in">this</span>.count = parties;</span><br><span class="line">        <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这边传入了两个对象简单的记录了一下存值,我们直接查看一下关键的await方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再来看dowait的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">trip</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">/** 省略部分代码 **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">               TimeoutException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line">            <span class="comment">//判断是否被打断</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将计数器-1 即在构造方法中赋值的count</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="comment">//如果所有的线程都执行完毕即count=0时</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行传入的方法</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    ranAction = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//唤醒所有线程</span></span><br><span class="line">                    nextGeneration();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果count没有到0那么阻塞当前线程</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        trip.await();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                        <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到,CyclicBarrier是利用Lock的condition方法来进行线程的阻塞和唤醒,类似Object.wait()和notifyAll()在count不为0时阻塞,在count&#x3D;0时唤醒所有线程</p>
<p><strong>总结</strong></p>
<p>1,CountdownLatch适用于所有线程通过某一点后通知方法,而CyclicBarrier则适合让所有线程在同一点同时执行</p>
<p> 2,CountdownLatch利用继承AQS的共享锁来进行线程的通知,利用CAS来进行–state，当state变成0之后才放行这个调用latch.await()的线程,而CyclicBarrier则利用ReentrantLock的Condition来阻塞和通知线程，count不为0时阻塞,在count&#x3D;0时唤醒所有被阻塞线程</p>
<h3 id="手撕线程题"><a href="#手撕线程题" class="headerlink" title="手撕线程题"></a>手撕线程题</h3><h4 id="实现’A’、’B’、’C’循环打印ABCABC，每个线程打印时其他线程不能打印"><a href="#实现’A’、’B’、’C’循环打印ABCABC，每个线程打印时其他线程不能打印" class="headerlink" title="实现’A’、’B’、’C’循环打印ABCABC，每个线程打印时其他线程不能打印"></a>实现’A’、’B’、’C’循环打印ABCABC，每个线程打印时其他线程不能打印</h4><h5 id="使用lock"><a href="#使用lock" class="headerlink" title="使用lock"></a>使用lock</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCUsingLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times; <span class="comment">// 控制打印次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;   <span class="comment">// 当前状态值：保证三个线程之间交替打印</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintABCUsingLock</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.times = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String name, <span class="type">int</span> targetNum)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (state % <span class="number">3</span> == targetNum) &#123;</span><br><span class="line">                state++;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.print(name);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintABCUsingLock</span> <span class="variable">loopThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintABCUsingLock</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            loopThread.printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            loopThread.printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            loopThread.printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用wait-notify"><a href="#使用wait-notify" class="headerlink" title="使用wait&#x2F;notify"></a><strong>使用wait&#x2F;notify</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCUsingWaitNotify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintABCUsingWaitNotify</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.times = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintABCUsingWaitNotify</span> <span class="variable">printABC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintABCUsingWaitNotify</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printABC.printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printABC.printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printABC.printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String name, <span class="type">int</span> targetState)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">while</span> (state % <span class="number">3</span> != targetState) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                state++;</span><br><span class="line">                System.out.print(name);</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="两个线程交替打印奇数和偶数"><a href="#两个线程交替打印奇数和偶数" class="headerlink" title="两个线程交替打印奇数和偶数"></a>两个线程交替打印奇数和偶数</h4><p>使用对象监视器实现，两个线程 A、B 竞争同一把锁，只要其中一个线程获取锁成功，就打印 ++i，并通知另一线程从等待集合中释放，然后自身线程加入等待集合并释放锁即可。</p>
<p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-9731382f3dfea5a4be6a5b4ef8ccdc87_1440w.webp" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OddEvenPrinter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    OddEvenPrinter(<span class="type">int</span> initCount, <span class="type">int</span> times) &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = initCount;</span><br><span class="line">        <span class="built_in">this</span>.limit = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">OddEvenPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OddEvenPrinter</span>(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::print, <span class="string">&quot;odd&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::print, <span class="string">&quot;even&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; limit) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;线程[%s]打印数字:%d&quot;</span>, Thread.currentThread().getName(), ++count));</span><br><span class="line">                    monitor.notifyAll();</span><br><span class="line">                    monitor.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//防止有子线程被阻塞未被唤醒，导致主线程不退出</span></span><br><span class="line">            monitor.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的思路，来解决下第 5 题：用两个线程，一个输出字母，一个输出数字，交替输出 1A2B3C4D…26Z</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumAndLetterPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printer(), <span class="string">&quot;numThread&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printer(), <span class="string">&quot;letterThread&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().getName() == <span class="string">&quot;numThread&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">//打印数字1-26</span></span><br><span class="line">                    System.out.print((i + <span class="number">1</span>));</span><br><span class="line">                    <span class="comment">// 唤醒其他在等待的线程</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 让当前线程释放锁资源，进入wait状态</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Thread.currentThread().getName() == <span class="string">&quot;letterThread&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 打印字母A-Z</span></span><br><span class="line">                    System.out.print((<span class="type">char</span>) (<span class="string">&#x27;A&#x27;</span> + i));</span><br><span class="line">                    <span class="comment">// 唤醒其他在等待的线程</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 让当前线程释放锁资源，进入wait状态</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-Lock-Condition"><a href="#使用-Lock-Condition" class="headerlink" title="使用 Lock&#x2F;Condition"></a>使用 Lock&#x2F;Condition</h5><p>还是以第一题为例，使用 Condition 来实现，其实和 wait&#x2F;notify 的思路一样。</p>
<blockquote>
<p>Condition 中的 <code>await()</code> 方法相当于 Object 的 <code>wait()</code> 方法，Condition 中的 <code>signal()</code> 方法相当于Object 的 <code>notify()</code> 方法，Condition 中的 <code>signalAll()</code> 相当于 Object 的 <code>notifyAll()</code> 方法。<br>不同的是，Object 中的 <code>wait(),notify(),notifyAll()</code>方法是和<code>&quot;同步锁&quot;</code>(synchronized关键字)捆绑使用的；而 Condition 是需要与<code>&quot;互斥锁&quot;/&quot;共享锁&quot;</code>捆绑使用的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCUsingLockCondition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintABCUsingLockCondition</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.times = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintABCUsingLockCondition</span> <span class="variable">print</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintABCUsingLockCondition</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>, c1, c2);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>, c2, c3);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>, c3, c1);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String name, <span class="type">int</span> targetState, Condition current, Condition next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (state % <span class="number">3</span> != targetState) &#123;</span><br><span class="line">                    current.await();</span><br><span class="line">                &#125;</span><br><span class="line">                state++;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.print(name);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Lock 锁的多个 Condition 可以实现精准唤醒，所以碰到那种多个线程交替打印不同次数的题就比较容易想到，比如解决第四题：多线程按顺序调用，A-&gt;B-&gt;C，AA 打印 5 次，BB 打印10 次，CC 打印 15 次，重复 10 次</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2024/04/19/JUC/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/04/19/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Java知识点总结
          
        </div>
      </a>
    
    
      <a href="/2024/04/19/Java%E5%9F%BA%E7%A1%80/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Java基础</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2016-2024
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="xqr的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://juejin.cn/user/3468338628928339">我的掘金</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>