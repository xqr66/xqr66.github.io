<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/10/07/JVM/"/>
      <url>/2023/10/07/JVM/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h4 id="jvm堆的分区"><a href="#jvm堆的分区" class="headerlink" title="jvm堆的分区"></a>jvm堆的分区</h4><p>堆中有字符串常量池</p><p>Java堆从GC的角度可以细分为新生代YoungGeneration（Eden区、From Survivor、To Survivor，空间比例8:1:1）和老年代OldGeneration（空间比例1:2）。</p><p><img src="/imgs/JVM/v2-108fca6ca82b85d2d6f559d0d469c770_1440w-1696644123324-1.webp" alt="img"></p><h4 id="jvm各种区域介绍"><a href="#jvm各种区域介绍" class="headerlink" title="jvm各种区域介绍"></a>jvm各种区域介绍</h4><p><strong>Java内存区域</strong></p><p>Java的内存区域和内存模型是不一样的东西，内存区域是指 JVM 运行时将数据分区域存储，强调对内存空间的划分。</p><p>Java内存区域主要由栈、堆、方法区组成</p><p><strong>栈</strong>：每个线程有自己独立、不共享的虚拟机栈，由多个栈帧（每个方法运行时需要的内存）组成，其中存放参数、局部变量，返回地址等，每个线程只能有一个活动栈帧，对应当前正在执行的那个方法。</p><p><strong>堆</strong>：多个线程共享同一个堆，通过new关键字构建的对象都需要使用堆内存，里面存放了实例对象、字符串常量池，类对象、静态变量（存放在_java_mirror后面）等。</p><p><strong>方法区</strong>：保存在着被加载过的每一个类的信息，包括类的方法、构造器，成员方法，属性等，这些信息由<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">类加载</a>器在加载类时，从类的源文件中抽取出来；<strong>运行时常量池</strong>：当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址转换为真实地址。</p><p><strong>程序计数器：</strong>每个线程都有一个独立的程序计数器，记录下一条JVM指令的执行地址</p><p><strong>本地方法栈：</strong>调用本地方法（由C或者C++编写的底层的方法，与操作系统的底层API打交道）时给本地方法提供的内存空间</p><p><img src="/imgs/JVM/image-20231007100258355.png" alt="image-20231007100258355"></p><p><strong>直接内存：</strong>操作系统的内存，分配回收成本较高，读写性能高，不受JVM内存回收管理</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>JVM中的垃圾回收器通过可达性分析来探索所有存活的对象<br>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果找不到，则表示可以回收</p><h5 id="可以作为GC-Root的对象"><a href="#可以作为GC-Root的对象" class="headerlink" title="可以作为GC Root的对象"></a>可以作为GC Root的对象</h5><ul><li>系统类System Class（Object、String等）</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li><li>所有被同步锁（synchronized关键字）持有的对象。</li><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li></ul><h4 id="强引用、弱引用、软引用、虚引用的区别"><a href="#强引用、弱引用、软引用、虚引用的区别" class="headerlink" title="强引用、弱引用、软引用、虚引用的区别"></a>强引用、弱引用、软引用、虚引用的区别</h4><p>在Java中提供了四个级别的引用：<strong>强引用</strong>，<strong>软引用</strong>，<strong>弱引用</strong>和<strong>虚引用</strong>。在这四个引用类型中，只有强引用FinalReference类是包内可见，其他三种引用类型均为public，可以在应用程序中直接使用。引用类型的类结构如图所示。</p><p><img src="/imgs/JVM/image-20231007100307554.png" alt="image-20231007100307554"></p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a><strong>强引用</strong></h5><p>Java中默认声明的就是强引用，例如以下代码，如果M对象被回收了，会打印 finalize() 方法中的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">M</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">M</span>();  <span class="comment">//只要m还指向M对象，M对象就不会被回收</span></span><br><span class="line">        <span class="comment">// m = null;   //手动置null</span></span><br><span class="line">        System.gc();  <span class="comment">// 进行垃圾回收</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象被回收了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/imgs/JVM/v2-e5f1836efa6748c371bcd126823414f7_1440w-1696303052906-5-1696644194745-3.webp" alt="img"></p><p>只要强引用存在，垃圾收集器将永远不会回收被引用的对象，哪怕<strong>内存不足</strong>时，JVM也会直接抛出OutOfMemoryError，<strong>不会去回收</strong>。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了。例如上面的代码，将 m &#x3D; null; 注释放开时，运行结果如下：</p><p><img src="/imgs/JVM/image-20231007100321611.png" alt="image-20231007100321611"></p><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a><strong>软引用</strong></h5><p>软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在垃圾回收后，<strong>内存仍然不足</strong>时，系统则<strong>会回收</strong>软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出OutOfMemoryError。这种特性常常被用来实现<strong>缓存技术</strong>，比如网页缓存，图片缓存等。</p><p>在 JDK1.2 之后，用 SoftReference 类来表示软引用。下面以一个例子来进一步说明强引用和软引用的区别。</p><p>在运行下面的Java代码之前，需要先配置参数 -Xms2M -Xmx2M，将 JVM 的初始内存设为2M，最大可用内存为 2M。</p><p>首先先来测试一下强引用，在限制了 JVM 内存的前提下，下面的代码运行正常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 当 new byte为 1M 时，程序运行正常</span></span><br><span class="line">        <span class="type">byte</span>[] buff1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// byte[] buff2 = new byte[1024 * 1024 * 1];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果我们再创建一个1M大小的 byte数组时，则内存不够使用，程序直接报错。因为强引用不会被回收。</p><p><img src="/imgs/JVM/image-20231007100331571.png" alt="image-20231007100331571"></p><p>接着来看一下软引用会有什么不一样，在下面的示例中先创建一个大小为 1M 的软引用对象，打印m的地址，然后进行垃圾回收，休眠500ms后打印m的地址。最后又创建了一个1M的字节数组，打印m的地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SoftReference&lt;<span class="type">byte</span>[]&gt; m = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line"> </span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        <span class="comment">// 再分配一个数组，heap将装不下，</span></span><br><span class="line">        <span class="comment">// 这时系统会进行垃圾回收，如果内存不够，会把软引用干掉</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1</span>];</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/imgs/JVM/v2-210fffb5827e8aea4115430e5b373238_1440w-1696303070608-7-1696644264300-7.webp" alt="img"></p><p>根据运行结果，我们可以看到，在内存不足的情况下，软引用才会被回收。</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a><strong>弱引用</strong></h5><p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够</strong>，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象<strong>都会被回收</strong>。在 JDK1.2 之后，用 WeakReference 来表示弱引用。</p><p>我们以与软引用同样的方式来测试一下弱引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        WeakReference&lt;<span class="type">byte</span>[]&gt; m = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line"> </span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/imgs/JVM/image-20231007100408990.png" alt="image-20231007100408990"></p><p>根据运行结果，可以发现垃圾回收后被弱引用关联的对象被回收了。</p><p>在 Java 集合中有一种特殊的 Map 类型：<strong>WeakHashMap</strong>， 在这种 Map 中存放了键对象的弱引用，当一个键对象被垃圾回收，那么相应的值对象的引用会从 Map 中删除。WeakHashMap 能够节约存储空间，可用来缓存那些非必须存在的数据。</p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象。</p><p>虚引用必须要和 ReferenceQueue 引用队列一起使用，主要配合ByteBuffer使用，在引用对象被回收时，会将虚引用入队，Reference Handler线程调用虚引用相关方法释放直接内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PhantomReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Object&gt; LIST = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReferenceQueue</span> <span class="variable">QUEUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        PhantomReference&lt;M&gt; m = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">M</span>(), QUEUE);<span class="comment">//关联软引用对象和引用队列</span></span><br><span class="line"> <span class="comment">//当软引用所关联的byte数组被回收时，软引用会自己加入到queue中</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                LIST.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>]);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(m.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Reference</span> <span class="variable">poll</span> <span class="operator">=</span> QUEUE.poll();</span><br><span class="line">                <span class="keyword">if</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//获取queue中的无用的软引用对象，并移除</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;虚引用对象：&quot;</span> + poll + <span class="string">&quot; 被jvm回收了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象被回收了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/imgs/JVM/v2-db69836fc83d1e8d39f5088bc1a4b8a9_1440w-1696303085353-9-1696644279259-9.webp" alt="img"></p><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><p><strong>1.标记-清除算法</strong>：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</p><ul><li>该算法分为两个阶段，<strong>标记和清除</strong>。标记阶段标记所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。该算法最大的问题就是内存碎片严重化，后续可能发生对象不能找到利用空间的问题。</li></ul><p><img src="/imgs/JVM/v2-7389d400dc04abb145a67fa86a662e33_1440w-1696644286321-11.webp" alt="img"></p><p><strong>2.复制算法</strong>：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</p><ul><li>按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。</li></ul><p><img src="/imgs/JVM/v2-20adb8ac4c5deb44fc27e30c8381281d_1440w-1696644293178-13.webp" alt="img"></p><p><strong>3.标记-整理算法</strong>：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</p><ul><li>标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。</li></ul><p><img src="/imgs/JVM/v2-cc722c4e5b289434d2181451f4fd154c_1440w-1696644300930-15.webp" alt="img"></p><p><strong>4.分代算法</strong>：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</p><ul><li>当前商业虚拟机都采用分代收集的垃圾收集算法。分代收集算法，顾名思义是根据对象的存活周期将内存划分为几块。一般包括年轻代、老年代 和 永久代。</li></ul><p><img src="/imgs/JVM/v2-40cbacd540b1555badbbf89132aace5f_1440w-1696644309230-17.webp" alt="img"></p><p><img src="/imgs/JVM/image-20231007100514803.png" alt="image-20231007100514803"></p><h4 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h4><p><a href="https://juejin.cn/post/6974281849031884830">JVM调优——GC 调优 - 掘金 (juejin.cn)</a></p><h4 id="垃圾收集器cms和g1比较"><a href="#垃圾收集器cms和g1比较" class="headerlink" title="垃圾收集器cms和g1比较"></a>垃圾收集器cms和g1比较</h4><h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><ul><li>默认无参构造</li><li>自动拆装箱</li><li>for-each</li><li>泛型擦除（比如在list集合中put和get都把泛型当作Object）</li><li>可变参数</li><li>枚举类</li><li>重写桥接（子类重写父类方法的返回值可以是父类方法返回值的子类， 通过一个桥接方法来调用子类的重写方法）</li></ul><h4 id="静态变量的加载过程"><a href="#静态变量的加载过程" class="headerlink" title="静态变量的加载过程"></a>静态变量的加载过程</h4><p><img src="/imgs/JVM/image-20231007100523336.png" alt="image-20231007100523336"></p><h4 id="Java运行一个程序的过程？"><a href="#Java运行一个程序的过程？" class="headerlink" title="Java运行一个程序的过程？"></a>Java运行一个程序的过程？</h4><ol><li><strong>编译阶段</strong></li></ol><p>Java 代码首先需要被编译器编译，Java 编译器首先检查语法和语义的错误，然后将源码转换成字节码。编译生成的字节码被存储在一个或多个 .class 文件中，这些文件可以直接在 JVM 上运行或在网络上传输。</p><ol start="2"><li><strong>运行阶段</strong></li></ol><p><strong>Java 代码的运行分为三个阶段：装载、链接和初始化。</strong></p><p>- 装载：Java 虚拟机装载字节码，通常从 ClassPath 路径中获取，并检查字节码的正确性和合法性。</p><p>- 链接：在链接阶段，Java 虚拟机将其装载的类型与所依赖的类型链接起来，生成实际的可执行代码，主要包括验证、准备、解析三个阶段：</p><ul><li>验证：Java 虚拟机对字节码进行验证，以确保其符合规范和安全标准。验证阶段检查字节码中包含的元数据和字节码是否符合规范和安全标准。</li><li>准备：Java 虚拟机为类变量分配存储空间，并将其初始化为标准初始值。</li><li>解析：Java 虚拟机在准备阶段对常量池进行了解析，以确定每个符号对应的目标，这个过程称为解析。</li></ul><p>- 初始化：在初始化阶段，Java 虚拟机按照程序设定的顺序执行类构造器，以完成类的初始化。类构造器是由编译器自动生成的，它们负责将静态变量初始化并执行静态语句块中的代码。</p><p>在初始化阶段完成后，Java 虚拟机就开始执行字节码指令了，在这个阶段，Java 虚拟机通过解释器将字节码转换为机器码，并开始执行代码逻辑，完成 Java 代码的运行和执行。</p><p>总的来说，Java 代码的执行流程包括 编译、装载、链接、初始化和运行五个阶段。在这些阶段中，Java 虚拟机执行一系列严格的规则和步骤，以保证代码安全性和正确性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/10/07/MySQL/"/>
      <url>/2023/10/07/MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL："><a href="#MySQL：" class="headerlink" title="MySQL："></a>MySQL：</h2><h4 id="SQL语句执行顺序"><a href="#SQL语句执行顺序" class="headerlink" title="SQL语句执行顺序"></a>SQL语句执行顺序</h4><ol><li><p>from 子句组装来自不同数据源的数据；</p></li><li><p>where 子句基于指定的条件对记录行进行筛选；  </p></li><li><p>group by 子句将数据划分为多个分组；  </p></li><li><p>使用聚集函数进行计算； </p></li><li><p>使用 having 子句筛选分组；</p></li><li><p>计算所有的表达式后，select；  </p></li><li><p>使用 order by 对结果集进行排序。</p></li><li><p>limit限制查询数量、查询偏移量</p><p><img src="/imgs/MySQL/image-20231007095614868.png" alt="image-20231007095614868"></p></li></ol><h4 id="事务的四大特性（ACID）："><a href="#事务的四大特性（ACID）：" class="headerlink" title="事务的四大特性（ACID）："></a>事务的四大特性（ACID）：</h4><ul><li>原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性：事务完成时，必须使得所有的数据保持一致状态</li><li>隔离性：数据库系统提供的隔离机制，保证事务不受外部并发操作的影响，在独立的环境下运行。</li><li>持久性：事务一单提交或回滚，会对数据库产生永久的改变</li></ul><p>而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，</p><p>一份是redo log日志，一份是undo log日志。 而持久性是通过数据库的锁，加上MVCC来保证的。</p><h4 id="并发事务问题："><a href="#并发事务问题：" class="headerlink" title="并发事务问题："></a>并发事务问题：</h4><ol><li><p>脏读：一个事务读到了另一个事务还没有提交的数据。<img src="/imgs/MySQL/image-20231007095624542.png" alt="image-20231007095624542"></p></li><li><p>不可重复读：一个事务先后读取同一条记录，但是两次读取的数据不同</p></li></ol><p><img src="/imgs/MySQL/image-20231007095635241.png" alt="image-20231007095635241"></p><ol start="3"><li>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了”幻影“;<img src="/imgs/MySQL/image-20231007095644077.png" alt="image-20231007095644077"></li></ol><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p><img src="/imgs/MySQL/image-20231007095652192.png" alt="image-20231007095652192"></p><h4 id="mysql执行流程"><a href="#mysql执行流程" class="headerlink" title="mysql执行流程"></a>mysql执行流程</h4><h4 id="B-Tree-与-B-Tree相比"><a href="#B-Tree-与-B-Tree相比" class="headerlink" title="B+Tree 与 B-Tree相比"></a>B+Tree 与 B-Tree相比</h4><ul><li>所有的数据都会出现在叶子节点。</li><li>叶子节点形成一个双向循环链表。</li><li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。<img src="/imgs/MySQL/image-20231007095709426.png" alt="image-20231007095709426"></li></ul><h4 id="为什么InnoDB存储引擎选择使用B-tree索引结构"><a href="#为什么InnoDB存储引擎选择使用B-tree索引结构" class="headerlink" title="为什么InnoDB存储引擎选择使用B+tree索引结构?"></a>为什么InnoDB存储引擎选择使用B+tree索引结构?</h4><ol><li>相对于二叉树，层级更少，搜索效率高；</li><li>对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</li><li>相对Hash索引，B+tree支持范围匹配及排序操作；</li><li>数据都在叶子节点，搜索效率稳定，且叶子节点形成双向循环链表，便于范围查找和排序</li></ol><h4 id="聚集索引-二级索引"><a href="#聚集索引-二级索引" class="headerlink" title="聚集索引&amp;二级索引"></a>聚集索引&amp;二级索引</h4><p><img src="/imgs/MySQL/image-20231007095717439.png" alt="image-20231007095717439"></p><p>聚集索引选取规则:</p><ul><li><p>​如果存在主键，主键索引就是聚集索引。</p></li><li><p>​如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p></li><li><p>​如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p><p><img src="/imgs/MySQL/image-20231007095727258.png" alt="image-20231007095727258"></p></li><li><p>聚集索引的叶子节点下挂的是这一行的数据 。</p></li><li><p>二级索引的叶子节点下挂的是该字段值对应的主键值。</p></li></ul><h4 id="联合索引在b-树中怎么存储"><a href="#联合索引在b-树中怎么存储" class="headerlink" title="联合索引在b+树中怎么存储"></a>联合索引在b+树中怎么存储</h4><p>联合索引和其他索引的区别就是在非叶子节点存储的是联合索引上全部字段，按照最左前缀法则排序，叶子节点会存储联合索引全部字段和主键id</p><p><img src="/imgs/MySQL/image-20231007095734260.png" alt="image-20231007095734260"></p><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><ol><li>在索引列上进行运算操作， 索引将失效  <code>explain select * from tb_user where substring(phone,10,2) = &#39;15&#39;;</code> </li><li>字符串不加引号  <code>explain select * from tb_user where profession = 软件工程 and age = 31 and status = 0;</code></li><li>模糊查询（尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效） <code>explain select * from tb_user where profession like &#39;软件%&#39;;</code></li><li>or连接条件 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</li><li>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</li><li>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效。当范围查询使用&gt;&#x3D; 或 &lt;&#x3D; 时，走联合索引，不会使右侧的列索引失效</li><li>MySQL评估不走索引比走索引还快，索引也失效。</li></ol><h4 id="如何去合理地创建表的索引"><a href="#如何去合理地创建表的索引" class="headerlink" title="如何去合理地创建表的索引"></a>如何去合理地创建表的索引</h4><ul><li><p>针对于数据量较大，且查询比较频繁的表建立索引。</p></li><li><p>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p></li><li><p>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p></li><li><p>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p></li><li><p>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p></li><li><p>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率</p></li></ul><h4 id="通过索引查询数据，会经历几次磁盘IO"><a href="#通过索引查询数据，会经历几次磁盘IO" class="headerlink" title="通过索引查询数据，会经历几次磁盘IO"></a>通过索引查询数据，会经历几次磁盘IO</h4><p>这个要根据B+树的高度和查询的条件来判断</p><p>如果查询建立了聚集索引，或者能够使用覆盖索引，就不需要回表，也就是需要B+树的层高次，</p><p>否则要查两次索引，也就是两倍层高次</p><h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><h5 id="插入数据优化"><a href="#插入数据优化" class="headerlink" title="插入数据优化"></a>插入数据优化</h5><ol><li><p>批量插入数据 <code>Insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;); </code></p></li><li><p>手动控制事务 ，避免频繁开启、提交事务</p><p><code>start transaction; insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;); insert into tb_test values(4,&#39;Tom&#39;),(5,&#39;Cat&#39;),(6,&#39;Jerry&#39;); insert into tb_test values(7,&#39;Tom&#39;),(8,&#39;Cat&#39;),(9,&#39;Jerry&#39;); commit;</code></p></li><li><p>主键顺序插入，性能要高于乱序插入，乱序插入会出现页分裂会降低效率。</p></li><li><p>一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，可以使用MySQL数据库提供的load指令进行插入</p><p><code>-- 客户端连接服务端时，加上参数 -–local-infile</code><br><code>mysql –-local-infile -u root -p</code><br><code>-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</code><br><code>set global local_infile = 1;</code><br><code>-- 执行load指令将准备好的数据，加载到表结构中</code><br><code>load data local infile &#39;/root/sql1.log&#39; into table tb_user fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39; ;</code></p></li></ol><h5 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h5><ul><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改</li></ul><h5 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h5><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li><li>尽量使用覆盖索引。</li><li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）。</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。</li></ul><h5 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h5><ul><li>在分组操作时，可以通过索引来提高效率。</li><li>分组操作时，索引的使用也是满足最左前缀法则的。</li></ul><h5 id="表连接优化"><a href="#表连接优化" class="headerlink" title="表连接优化"></a>表连接优化</h5><p>left join的情况下，对右表加索引，左表是驱动表，左连接就是左边都要查出来，所以左边还是all，但是右边是ref了。</p><p>左连接的时候索引应该加在右表，右连接应该加在左表。</p><h5 id="子查询怎么优化"><a href="#子查询怎么优化" class="headerlink" title="子查询怎么优化"></a>子查询怎么优化</h5><p>把子查询转化为表连接，建立索引实现优化</p><h5 id="limit优化-深度分页怎么优化？"><a href="#limit优化-深度分页怎么优化？" class="headerlink" title="(limit优化)深度分页怎么优化？"></a>(limit优化)深度分页怎么优化？</h5><p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><p>先通过聚集索引查询主键，再利用覆盖索引来获取。</p><p><code>select * from tb_sku limit 2000000, 10;</code> </p><p>可以转换为：<code>explain select * from tb_sku t , (select id from tb_sku order by id limit 2000000,10) a where t.id = a.id;</code></p><p>如果id或者其他有索引的字段是自增的，可以先通过索引找到偏移位置，再分页：</p><p>select * from test_big_data where name like ‘itlgitlg%’ and id &gt; 800000 order by id asc limit 0,10</p><h5 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h5><p>count(数字)：InoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。</p><p>count(*)： InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</p><p>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(<em>)，所以尽量使用 count(</em>)。</p><h5 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h5><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。</p><h4 id="慢sql怎么看-怎么解决"><a href="#慢sql怎么看-怎么解决" class="headerlink" title="慢sql怎么看 怎么解决"></a>慢sql怎么看 怎么解决</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。如果要开启慢查询日志，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 开启MySQL慢日志查询开关`</span><br><span class="line">`slow_query_log=1`</span><br><span class="line"></span><br><span class="line">`#设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志`</span><br><span class="line">`long_query_time=2`</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#重启mysql服务</span><br><span class="line">`systemctl restart mysqld` </span><br></pre></td></tr></table></figure><p>检查慢查询日志 ：在慢查询日志中，只会记录执行时间超多我们预设时间（2s）的SQL，执行较快的SQL是不会记录的。</p><p>那这样，通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化</p><p><strong>用explain分析sql</strong></p><h5 id="explain中的字段："><a href="#explain中的字段：" class="headerlink" title="explain中的字段："></a>explain中的字段：</h5><p>[explain有哪些字段，分别有什么含义_explain字段含义-CSDN博客](<a href="https://blog.csdn.net/weixin_50998273/article/details/111938295#:~:text=explain%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89">https://blog.csdn.net/weixin_50998273/article/details/111938295#:~:text=explain有哪些字段，分别有什么含义</a> 1 1. id SQL查询中的序列号。 id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行。 2 2.,查询真正使用到的索引。 … 8 8. key_len 查询用到的索引长度（字节数）。 … 更多项目)</p><p>解决：</p><ol><li>SQL语句优化，尽量精简，去除非必要语句</li><li>索引优化，让所有SQL都能够走索引</li><li>如果是表的瓶颈问题，则分表，单表数据量维持在2000W（理论上）以内</li><li>如果是单库瓶颈问题，则分库，读写分离</li><li>如果是物理机器性能问题，则分多个数据库节点</li></ol><h4 id="怎么保证redis和DB的数据一致性"><a href="#怎么保证redis和DB的数据一致性" class="headerlink" title="怎么保证redis和DB的数据一致性"></a>怎么保证redis和DB的数据一致性</h4><h5 id="采用延时双删"><a href="#采用延时双删" class="headerlink" title="采用延时双删"></a>采用延时双删</h5><p>先删除缓存，再更新数据库，当更新数据后休眠一段时间通过定时任务（可通过整合定时任务框架、创建线程池，从中拿出一个线程休眠一段时间再启动）再删除一次缓存。</p><h5 id="异步更新缓存-基于订阅binlog的同步机制"><a href="#异步更新缓存-基于订阅binlog的同步机制" class="headerlink" title="异步更新缓存(基于订阅binlog的同步机制)"></a>异步更新缓存(基于订阅binlog的同步机制)</h5><p>采用缓存淘汰策略，先更新数据库，再删除对应redis缓存后更新缓存。</p><p><img src="/imgs/MySQL/image-20231007095757867.png" alt="image-20231007095757867"></p><p>通过 Canal（消息推送工具也可以用kafka、rabbitMQ等来实现可靠性消息通信更新Redis。） 组件，（伪装成从节点）监控 Mysql 中 binlog（记录MySQL中新的写入、更新、删除等操作） 的日志，把更新后的数据同步到 Redis 里面，canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。。</p><p><img src="/imgs/MySQL/image-20231007095806660.png" alt="image-20231007095806660"></p><p>因为这里是基于最终一致性来实现的，如果业务场景不能接受数据的短期不一致性，那就不能使用这个方案来做。</p><h4 id="union和union-all的区别"><a href="#union和union-all的区别" class="headerlink" title="union和union all的区别"></a>union和union all的区别</h4><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。<br>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。<br>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。</p><h4 id="使用自增id还是UUID来当主键"><a href="#使用自增id还是UUID来当主键" class="headerlink" title="使用自增id还是UUID来当主键"></a>使用自增id还是UUID来当主键</h4><p>UUID。B+树使用双向链表来保存数据，所以使用自增id能够直接加到尾部，不需要页分裂，效率很高，且占用的空间小。但是如果一些敏感信息设置成自增就很容易被推理，暴露机密。</p><p>同时当单表的数据量上来之后我们就需要进行水平分表操作（将一张数据表的数据分成多张表），如果这时我们还是按照之前的自增形式来做主键 id，就有可能会出现 id 重复的问题。</p><p>如果使用UUID，生成的ID不仅是表独立的，而且是库独立的。对以后的数据操作很有好处，可以说一劳永逸。我们可以使用 UUID 来作为不重复的主键 id，但是 UUID 是无序的字符串，所以主键索引就会失效，而且占用空间大。</p><ul><li>全局唯一性：不能出现重复的 id</li><li>递增性：MySQL 的 InnoDB 使用的是聚簇索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，因此在主键的选择上我们还是应该尽可能地使用有序的主键来保证写入性能，我们保证下一个 id 一定大于上一个 id，以此来满足事务版本号、IM 增量消息或者排序的特殊需求</li><li>安全性：如果 id 是连续的，那么我们在知道一些基本规则的情况下就能很轻松地推测出下一份数据，这在一些机密性较高的业务场景是很危险的。所以我们有时会希望 id 是无规则的，最好还能包含有时间戳，这样就能够在开发中快速了解这个分布式 id 的生成时间</li><li>高性能高可用性：确保在任何时候都能正确地生成 id，并且在高并发的环境下也能表现良好</li></ul><p>UUID：我们可以使用 UUID 来作为不重复的主键 id，但是 UUID 是无序的字符串，所以主键索引就会失效</p><p>优点：简单、方便、性能好、出现数据拆分、合并存储的时候，能达到全局的唯一性<br>缺点：占用空间大，无序性、存储的是字符串、查询效率低、传输数据量大</p><p>雪花算法：雪花算法是 Twitter 推出的针对分布式环境下的 id 生成算法，其结果是一个 Long 型的 64bit id。具体实现上使用 41bit 作为毫秒数，10bit 作为机器的 id（5bit 是数据中心，5bit 是机器 id），12bit 作为毫秒内的流水号（这意味着每个节点在每毫秒内可以产生 4096 个 id），最后还有一个符号位永远是 0</p><p>优点：不依赖数据库、完全在内存中生成 id、高性能高可用、容量大、每秒可生成数百万个 id、id 递增、后续插入数据库的索引时性能较高<br>缺点：严重依赖系统时钟，如果某台机器的系统时钟发生回拨，就有可能会造成 id 冲突甚至 id 乱序</p><h4 id="讲一讲mysql主从部署"><a href="#讲一讲mysql主从部署" class="headerlink" title="讲一讲mysql主从部署"></a>讲一讲mysql主从部署</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p><p>MySQL 复制的优点主要包含以下三个方面：<br>主库出现问题，可以快速切换到从库提供服务。<br>实现读写分离，降低主库的访问压力。<br>可以在从库中执行备份，以避免备份期间影响主库服务。</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>MySQL主从复制的核心就是 二进制日志，具体的过程如下：</p><p><img src="/imgs/MySQL/image-20231007095821147.png" alt="image-20231007095821147"></p><p>从上图来看，复制分成三步：</p><ol><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li><li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ol><h5 id="搭建主从环境："><a href="#搭建主从环境：" class="headerlink" title="搭建主从环境："></a>搭建主从环境：</h5><p>配置主库，修改配置文件 &#x2F;etc&#x2F;my.cnf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 232-1，默认为1</span><br><span class="line">server-id=1</span><br><span class="line">#是否只读,1 代表只读, 0 代表读写</span><br><span class="line">read-only=0</span><br></pre></td></tr></table></figure><p>重启MySQL服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld </span><br></pre></td></tr></table></figure><p>登录mysql，创建远程连接的账号，并授予主从复制权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#创建itcast用户，并设置密码，该用户可在任意主机连接该MySQL服务</span><br><span class="line">CREATE USER &#x27;itcast&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;Root@123456&#x27;</span><br><span class="line">;</span><br><span class="line">#为 &#x27;itcast&#x27;@&#x27;%&#x27; 用户分配主从复制权限</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;itcast&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>通过指令，查看二进制日志坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status ;</span><br></pre></td></tr></table></figure><p><img src="/imgs/MySQL/image-20231007095831175.png" alt="image-20231007095831175"></p><p>字段含义说明：<br>file : 从哪个日志文件开始推送日志文件<br>position ： 从哪个位置开始推送日志<br>binlog_ignore_db : 指定不需要同步的数据库</p><h5 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h5><p>修改配置文件 &#x2F;etc&#x2F;my.cnf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，和主库不一样即可</span><br><span class="line">server-id=2</span><br><span class="line">#是否只读,1 代表只读, 0 代表读写</span><br><span class="line">read-only=1</span><br></pre></td></tr></table></figure><p>重新启动MySQL服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>登录mysql，设置主库配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CHANGE REPLICATION SOURCE TO SOURCE_HOST=&#x27;192.168.200.200&#x27;, SOURCE_USER=&#x27;itcast&#x27;,</span><br><span class="line">SOURCE_PASSWORD=&#x27;Root@123456&#x27;, SOURCE_LOG_FILE=&#x27;binlog.000004&#x27;,</span><br><span class="line">SOURCE_LOG_POS=663;</span><br><span class="line">或者</span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.200.200&#x27;, MASTER_USER=&#x27;itcast&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;Root@123456&#x27;, MASTER_LOG_FILE=&#x27;binlog.000004&#x27;,</span><br><span class="line">MASTER_LOG_POS=663;</span><br></pre></td></tr></table></figure><p>开启同步操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start replica ; #8.0.22之后</span><br><span class="line">start slave ; #8.0.22之前</span><br></pre></td></tr></table></figure><p>查看主从同步状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show replica status ; #8.0.22之后</span><br><span class="line">show slave status ; #8.0.22之前</span><br></pre></td></tr></table></figure><p><img src="/imgs/MySQL/image-20231007095843632.png" alt="image-20231007095843632"></p><h4 id="mysql：死锁是什么？-实习中你有遇到死锁的情况吗"><a href="#mysql：死锁是什么？-实习中你有遇到死锁的情况吗" class="headerlink" title="mysql：死锁是什么？ 实习中你有遇到死锁的情况吗"></a>mysql：死锁是什么？ 实习中你有遇到死锁的情况吗</h4><p>简单来说就是两个或者两个以上的线程在执行的过程中，争夺同一个共享资源造成的相互等待的现象。如果没有外部干预，线程会一直阻塞无法往下执行，这些一直处于相互等待资源的线程就称为死锁线程。</p><p>解决方法：尽量使用相同的顺序来访问索引记录和表，可以实现对数据排序，保证每个线程按照固定的顺序来处理。</p><h4 id="MySQL三大范式"><a href="#MySQL三大范式" class="headerlink" title="MySQL三大范式"></a>MySQL三大范式</h4><ul><li><h5 id="第一范式（1-NF）：字段不可再拆分。"><a href="#第一范式（1-NF）：字段不可再拆分。" class="headerlink" title="第一范式（1 NF）：字段不可再拆分。"></a>第一范式（1 NF）：字段不可再拆分。</h5><p><img src="/imgs/MySQL/image-20231007095856953.png" alt="image-20231007095856953"></p></li><li><h5 id="第二范式（2-NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。"><a href="#第二范式（2-NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。" class="headerlink" title="第二范式（2 NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。"></a>第二范式（2 NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。</h5><ol><li>造成整表的数据冗余。</li></ol><p>如，学生表，可能我就只有2个学生，每个学生都有许多的信息，比如，年龄、性别、身高、住址……如果与课程信息放到同一张表中，可能每个学生有3门课程，那数据总条数就会变成6条了。但是通过拆分，学生表我们只需要存储 2 条学生信息，课程表只需要存储 3 条课程信息，成绩表就只需保留学号、课程名称和成绩字段。</p><ol start="2"><li>更新数据不方便。</li></ol><p>假设，课程的学分发生了变更，那我们就需要把整表关于该课程的学分都要更新一次，但如果我们拆分出课程表，那我们就只需要把课程表中的课程信息更新就行。</p><ol start="3"><li>插入数据不方便或产生异常。</li></ol><p>① 假设主键是学号或课程名称，我们新增了某个课程，需要把数据插入到表中，这时，可能只有部分人有选修这门课程，那我们插入数据的时候还要规定给哪些人插入对应的课程信息，同时可能由于成绩还没有，我们需要对成绩置空，后续有成绩后还得重新更新一遍。</p><p>② 假设主键是学号和课程名称的联合主键。同样也是新增了某课程，但是暂时没有人选修这门课，缺少了学号主键字段数据，会导致课程信息无法插入。</p></li><li><h5 id="第三范式（3-NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段-A-可以获取-某非主键字段-B。"><a href="#第三范式（3-NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段-A-可以获取-某非主键字段-B。" class="headerlink" title="第三范式（3 NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。"></a>第三范式（3 NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。</h5></li></ul><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><ul><li>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和MVCC(多版本并发控制) 。</li><li>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undolog中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</li><li>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</li></ul><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo logfile）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p><img src="/imgs/MySQL/image-20231007095915993.png" alt="image-20231007095915993"></p><p>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redolog buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。</p><h4 id="MySQL如何解决幻读"><a href="#MySQL如何解决幻读" class="headerlink" title="MySQL如何解决幻读"></a>MySQL如何解决幻读</h4><p><strong>快照读</strong></p><p>快照读，读取的是<strong>快照数据</strong>，不加锁的普通 SELECT 都属于快照读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span></span><br><span class="line">复制代码<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure><p>通过mvcc机制来解决幻读</p><p><strong>当前读</strong></p><p>当前读就是读的是<strong>最新数据</strong>，而不是历史的数据，加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>复制代码<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> <span class="keyword">values</span> ...</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ...</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> ...</span><br></pre></td></tr></table></figure><p>在当前读的条件下，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li><li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li></ul><p><em>间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会</em><br><em>阻止另一个事务在同一间隙上采用间隙锁。</em></p><p><a href="https://juejin.cn/post/7056583607929798692">MySQL 如何解决幻读（MVCC 原理分析） - 掘金 (juejin.cn)</a></p><h4 id="MVCC机制"><a href="#MVCC机制" class="headerlink" title="MVCC机制"></a>MVCC机制</h4><p>详见<a href="https://juejin.cn/post/7016165148020703246#heading-24">看一遍就理解：MVCC原理详解 - 掘金 (juejin.cn)</a></p><p>InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是</p><p><img src="/imgs/MySQL/image-20231007095927862.png" alt="image-20231007095927862"></p><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><p>当某个事务执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，<br>并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/imgs/MySQL/image-20231007095937632.png" alt="image-20231007095937632"></p><p>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条<br>记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><p>ReadView（读视图）是快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p><p><strong>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</strong></p><p><strong>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView</strong></p><p>ReadView中包含了四个核心字段：</p><p><img src="/imgs/MySQL/image-20231007095944831.png" alt="image-20231007095944831"></p><p>而在readview中就规定了版本链数据的访问规则：<br>trx_id 代表当前undolog版本链对应事务ID。</p><p><img src="/imgs/MySQL/image-20231007095952369.png" alt="image-20231007095952369"></p><h4 id="MySQL-事务的可重复读和读已提交，Read-View-时机"><a href="#MySQL-事务的可重复读和读已提交，Read-View-时机" class="headerlink" title="MySQL 事务的可重复读和读已提交，Read View 时机"></a>MySQL 事务的可重复读和读已提交，Read View 时机</h4><ul><li>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li><li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li></ul><h4 id="乐观锁与悲观锁，在MySQL中怎么实现"><a href="#乐观锁与悲观锁，在MySQL中怎么实现" class="headerlink" title="乐观锁与悲观锁，在MySQL中怎么实现"></a>乐观锁与悲观锁，在MySQL中怎么实现</h4><p>悲观锁，比较消极的一种锁处理方式。直接在操作数据时，抢占锁。其他的事务在进行时就会等待，直到占有锁的事务释放锁为止。</p><p>​    这种处理方式能保证数据的最大一致性，但是容易导致锁超时、并发程度低等问题。 首先我们开启事务一，并且对id&#x3D;1的数据进行update操作，此时我们不提交事务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql root@127.0.0.1:demo&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.002s</span><br><span class="line">mysql root@127.0.0.1:demo&gt; update `user` set name = &#x27;张三111111&#x27;where id = 1;</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line">Time: 0.004s</span><br></pre></td></tr></table></figure><p>​    接着我们开启事务二，对id&#x3D;1的数据进行update操作，查看此时会发生什么情况？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql root@127.0.0.1:demo&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.002s</span><br><span class="line">mysql root@127.0.0.1:demo&gt; update `user` set sex = 1 where id = 1;</span><br></pre></td></tr></table></figure><p>​    我们执行完update语句之后，就处于等待状态，SQL语句也不会马上被执行，这是因为事务一没有commit，也就没有释放id&#x3D;1的数据对应的写锁。</p><p>乐观锁认为数据一般情况下不会造成冲突，只有当数据去执行修改情况时，才会针对数据冲突做处理。这里是如何发现冲突了呢？常规的方式，都是在数据行上加一个版本号或者时间戳等字段。(本文使用version作为版本号方式，使用时间戳方式同理)</p><p>​    <strong>乐观锁的实现原理：</strong></p><ul><li>一个事务在读取数据时，将对应的版本号字段读取出来，假设此时的版本号是1。    </li><li>另外一个事务也是执行同样的读取操作。当事务一提交时，对版本号执行+1，此时该数据行的版本号就是2。    </li><li>第二个事务执行修改操作时，针对业务数据做条件，并默认增加一个版本号作为where条件。此时修改语句中的版本号字段是不满足where条件，该事务执行失败。通过这种方式来达到锁的功能。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/2023/10/06/JUC/"/>
      <url>/2023/10/06/JUC/</url>
      
        <content type="html"><![CDATA[<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。</p><p>线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器（</strong>线程切换后能恢复到正确的执行位置<strong>）</strong>、<strong>虚拟机栈（</strong>保证线程中的局部变量不被别的线程访问到<strong>，虚拟机栈和本地方法栈是线程私有的）</strong>和<strong>本地方法栈</strong>（包含局部变量，本地方法），所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器<strong>。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p><p><img src="/imgs/JUC/image-20231007093748705.png" alt="image-20231007093748705"></p><ul><li>堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存</li><li>方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li></ul><h4 id="单核-CPU-上运行多个线程效率一定会高吗？"><a href="#单核-CPU-上运行多个线程效率一定会高吗？" class="headerlink" title="单核 CPU 上运行多个线程效率一定会高吗？"></a>单核 CPU 上运行多个线程效率一定会高吗？</h4><p>单核CPU同时运行多个线程的效率是否会高，取决于线程的类型和任务的性质。两种类型的线程：CPU密集型和IO密集型。</p><ul><li>CPU密集型的线程主要进行计算和逻辑处理，需要占用大量的CPU资源。</li><li>IO密集型的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待IO设备的响应，而不占用太多的CPU资源。</li></ul><p>在单核CPU上，同一时刻只能有一个线程在运行，其他线程需要等待CPU的时间片分配。如果线程是CPU密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。</p><p>如果线程是IO密集型的，那么多个线程同时运行可以利用CPU在等待IO时的空闲时间，提高了效率。</p><p>因此，对于单核CPU来说，如果任务是CPU密集型的，那么开很多线程会影响效率；如果任务是IO密集型的，那么开很多线程会提高效率。当然，这里的“很多”也要适度，不能超过系统能够承受的上限。</p><h4 id="线程创建方法"><a href="#线程创建方法" class="headerlink" title="线程创建方法"></a>线程创建方法</h4><p>方法一，直接使用 Thread</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ 创建线程对象</span><br><span class="line">Thread t = new Thread() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">// 要执行的任务</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 启动线程</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>方法二，使用 Runnable 配合 Thread<br>Runnable 可运行的任务（线程要执行的代码）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable = new Runnable() &#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">// 要执行的任务</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 创建线程对象</span><br><span class="line">Thread t = new Thread( runnable );</span><br><span class="line">// 启动线程</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>方法三，FutureTask 配合 Thread</p><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建任务对象</span><br><span class="line">FutureTask&lt;Integer&gt; task3 = new FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">log.debug(&quot;hello&quot;);</span><br><span class="line">return 100;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/ 参数1 是任务对象; 参数2 是线程名字，推荐</span><br><span class="line">new Thread(task3, &quot;t3&quot;).start();</span><br><span class="line">// 主线程阻塞，同步等待 task 执行完毕的结果</span><br><span class="line">Integer result = task3.get();</span><br><span class="line">log.debug(&quot;结果是:&#123;&#125;&quot;, result);</span><br></pre></td></tr></table></figure><h4 id="Java内存区域，内存模型？"><a href="#Java内存区域，内存模型？" class="headerlink" title="Java内存区域，内存模型？"></a>Java内存区域，内存模型？</h4><p><strong>Java内存模型（JMM）</strong></p><p>可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</p><p><img src="/imgs/JUC/image-20231007093815280.png" alt="image-20231007093815280"></p><p>在当前的 Java 内存模型下，线程可以把变量保存 <strong>本地内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p><p><strong>Java内存区域</strong></p><p>Java的内存区域和内存模型是不一样的东西，内存区域是指 JVM 运行时将数据分区域存储，强调对内存空间的划分。</p><p>Java内存区域主要由栈、堆、方法区组成</p><p><strong>栈</strong>：每个线程有自己独立、不共享的虚拟机栈，由多个栈帧（每个方法运行时需要的内存）组成，其中存放参数、局部变量，返回地址等，每个线程只能有一个活动栈帧，对应当前正在执行的那个方法。</p><p><strong>堆</strong>：多个线程共享同一个堆，通过new关键字构建的对象都需要使用堆内存，里面存放了实例对象、字符串常量池，静态变量等。</p><p><strong>方法区</strong>：保存在着被加载过的每一个类的信息，包括类的方法、构造器，成员方法，属性等，这些信息由<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">类加载</a>器在加载类时，从类的源文件中抽取出来；<strong>运行时常量池</strong>：当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址转换为真实地址。</p><p><strong>程序计数器：</strong>每个线程都有一个独立的程序计数器，记录下一条JVM指令的执行地址</p><p><strong>本地方法栈：</strong>调用本地方法（由C或者C++编写的底层的方法，与操作系统的底层API打交道）时给本地方法提供的内存空间</p><p><img src="/imgs/JUC/image-20231007093939407.png" alt="image-20231007093939407"></p><h4 id="线程的上下文切换是什么"><a href="#线程的上下文切换是什么" class="headerlink" title="线程的上下文切换是什么"></a>线程的上下文切换是什么</h4><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 CPU 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行，CPU被抢占</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li><li>主动让出CPU调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li></ul><p>线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念<br>就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><p>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等<br>Context Switch 频繁发生会影响性能</p><p><img src="/imgs/JUC/image-20231007093956598.png" alt="image-20231007093956598"></p><h4 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h4><p>多个线程同时被阻塞，处于相互等待的状态，如果没有外界干预，线程会被无限期地阻塞，因此程序不可能正常终止</p><h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><p>互斥条件：该资源任意一个时刻只由一个线程占用。</p><p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p><p>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系</p><h5 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h5><p><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</p><p><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><h4 id="解释多线程的同步"><a href="#解释多线程的同步" class="headerlink" title="解释多线程的同步"></a>解释多线程的同步</h4><p>处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。 这时候，我们就需要用到“线程同步”。 <strong>线程同步其实就是一种等待机制</strong>，<strong>多个需要同时访问此对象的线程进入这个对象的</strong>等待池,形成队列，等待前面的线程使用完毕后，下一个线程再使用。</p><ul><li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用直接返回。</li></ul><h4 id="start和-run方法的区别"><a href="#start和-run方法的区别" class="headerlink" title="start和 run方法的区别"></a>start和 run方法的区别</h4><ul><li><p>直接调用 run 是在主线程中执行了 run，没有启动新的线程</p></li><li><p>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</p></li></ul><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p><h4 id="java里面线程有几种状态？"><a href="#java里面线程有几种状态？" class="headerlink" title="java里面线程有几种状态？"></a>java里面线程有几种状态？</h4><h5 id="操作系统-层面来描述"><a href="#操作系统-层面来描述" class="headerlink" title="操作系统 层面来描述"></a>操作系统 层面来描述</h5><p><img src="/imgs/JUC/image-20231007094010824.png" alt="image-20231007094010824"></p><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li><li>【运行状态】指获取了 CPU 时间片运行中的状态 ：当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li><li>【阻塞状态】：如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入</li><li>【阻塞状态】：等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h5 id="Java-API-层面来描述"><a href="#Java-API-层面来描述" class="headerlink" title="Java API 层面来描述"></a>Java API 层面来描述</h5><p><img src="/imgs/JUC/image-20231007094036799.png" alt="image-20231007094036799"></p><ul><li><p>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</p><p>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</p><p>BLOCKED：阻塞状态，需要等待锁释放。</p><p>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</p><p>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</p><p>TERMINATED：终止状态，表示该线程已经运行完毕.</p><p><img src="/imgs/JUC/image-20231007094049347.png" alt="image-20231007094049347"></p></li></ul><h4 id="阻塞和等待有什么区别？"><a href="#阻塞和等待有什么区别？" class="headerlink" title="阻塞和等待有什么区别？"></a>阻塞和等待有什么区别？</h4><p>阻塞会持有临界资源并等待，等待会释放临界资源，不过概念还是比较模糊</p><h4 id="什么情况下会让线程进入-block-状态"><a href="#什么情况下会让线程进入-block-状态" class="headerlink" title="什么情况下会让线程进入 block 状态"></a>什么情况下会让线程进入 block 状态</h4><ul><li>t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED</li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED</li></ul><h4 id="线程调用sleep方法，sleep-10s-，结束后，调用sleep的线程处于什么状态？"><a href="#线程调用sleep方法，sleep-10s-，结束后，调用sleep的线程处于什么状态？" class="headerlink" title="线程调用sleep方法，sleep(10s)，结束后，调用sleep的线程处于什么状态？"></a>线程调用sleep方法，sleep(10s)，结束后，调用sleep的线程处于什么状态？</h4><p>在sleep的时间内，线程不会释放临界资源，在sleep结束之后，线程正常运行，sleep一般是模拟一些业务，之后unlock就释放了临界资源，比如锁</p><h4 id="有哪些线程安全的容器？"><a href="#有哪些线程安全的容器？" class="headerlink" title="有哪些线程安全的容器？"></a>有哪些线程安全的容器？</h4><h5 id="不可变类："><a href="#不可变类：" class="headerlink" title="不可变类："></a>不可变类：</h5><ul><li>String：String的各个substring、replace、reverse 等方法都是重新new一个String对象，不会改变源对象，而且用final修饰，不会有子类覆盖String的方法，不会出现线程安全问题</li><li>Integer 类似String</li><li>Random 类似String</li></ul><h5 id="遗留的线程安全集合"><a href="#遗留的线程安全集合" class="headerlink" title="遗留的线程安全集合"></a>遗留的线程安全集合</h5><ul><li>StringBuﬀer 对方法加上了synchronized锁，保证线程安全，但是效率比StringBuilder低一些</li><li>Vector 每个方法都加上了synchronized 关键字，串行化执行，效率低下。而且多线程下组合调用这些方法还是会出现线程不安全。</li><li>Hashtable： 每个方法都加上了synchronized 关键字，串行化执行，效率低下。而且多线程下组合调用这些方法还是会出现线程不安全。</li></ul><h5 id="经过修饰的线程安全的集合"><a href="#经过修饰的线程安全的集合" class="headerlink" title="经过修饰的线程安全的集合"></a>经过修饰的线程安全的集合</h5><ul><li>synchronizedList 、synchronizedMap 、 synchronizedSet等等， 把不安全的list、map、set等作为构造的参数， 其方法使用synchronized(mutex) {map.get();} 使用的还是原本集合中的方法，但是通过synchronized和信号量来实现同步</li></ul><h5 id="java-util-concurrent-包下的类"><a href="#java-util-concurrent-包下的类" class="headerlink" title="java.util.concurrent 包下的类"></a>java.util.concurrent 包下的类</h5><p>concurrentHashMap。</p><p>copyOnWriteArrayList: <code>CopyOnWriteArrayList</code> 中的读取操作是完全无需加锁的。更加厉害的是，写入操作也不会阻塞读取操作，只有写写才会互斥。这样一来，读操作的性能就可以大幅度提升。</p><p><code>CopyOnWriteArrayList</code> 线程安全的核心在于其采用了 <strong>写时复制（Copy-On-Write）</strong> 的策略，从 <code>CopyOnWriteArrayList</code> 的名字就能看出了。</p><p>当需要修改（ <code>add</code>，<code>set</code>、<code>remove</code> 等操作） <code>CopyOnWriteArrayList</code> 的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去，这样就可以保证写操作不会影响读操作了。</p><p>BlockingQueue的实现类:阻塞队列（<code>BlockingQueue</code>）被广泛使用在“生产者-消费者”问题中，其原因是 <code>BlockingQueue</code> 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p><p>线程安全的类不一定能保证线程安全，只能保证单个方法执行是线程安全的，但是多个方法的组合还是会出现不安全</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = new concurrentHashMap&lt;&gt;();</span><br><span class="line">int count = map.get(str);</span><br><span class="line">//在此处时间片结束，线程不安全</span><br><span class="line">map.put(str,count == 0 : 1 ? count + 1);;</span><br></pre></td></tr></table></figure><h4 id="类锁与对象锁的区别："><a href="#类锁与对象锁的区别：" class="headerlink" title="类锁与对象锁的区别："></a>类锁与对象锁的区别：</h4><h5 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a><strong>类锁</strong></h5><p>类锁是加载类上的，而类信息是存在 JVM 方法区的，并且整个 JVM 只有一份，方法区又是所有线程共享的，所以类锁是所有线程共享的，所以同一时刻，只能有一个线程使用加了锁的方法或方法体，不管是不是同一个实例。</p><h5 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h5><p>使用对象锁的情况，只有使用同一实例的线程才会受锁的影响，多个实例调用同一方法也不会受影响。</p><h4 id="说一下synchronized关键字底层原理"><a href="#说一下synchronized关键字底层原理" class="headerlink" title="说一下synchronized关键字底层原理"></a>说一下synchronized关键字底层原理</h4><p>synchronized的底层是通过monitor对象来实现的。</p><p>Java对象在内存中的布局大致可以分为三部分：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>填充对齐</strong>。因为<code>synchronized</code>用的锁是存在对象头里的，这里我们需要重点了解对象头。如果对象头是数组类型，则对象头由<strong>Mark Word</strong>、<strong>Class MetadataAddress</strong>和<strong>Array length</strong>组成，如果对象头非数组类型，对象头则由<strong>Mark Word</strong>和<strong>Class MetadataAddress</strong>组成。</p><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p><p><img src="/imgs/JUC/image-20231007094112330.png" alt="image-20231007094112330"></p><p>monitor对象中有owner用来指示拥有锁的线程，entrylist来存放阻塞的线程（竞争失败的线程），waitSet来存放wating的线程（wait()方法），初始时，Monitor中的Owner为null，当第一个竞争锁的线程获得锁，其他的竞争这个锁的线程就会被放入EntryList等待，当获得锁的线程执行完同步代码块中的内容，就会唤醒EntryList中等待的线程，发生非公平竞争这个锁。<br>注意：<br>synchronized 必须是进入同一个对象的 monitor 才有上述的效果</p><p><strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p><p>上面的字节码中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 **对象监视器 <code>monitor</code>**（每个Java对象都可以关联一个monitor对象） 的持有权。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由[ObjectMonitoropen in new window](https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp)实现的。每个对象中都内置了一个 `ObjectMonitor`对象。</span><br><span class="line"></span><br><span class="line">另外，`wait/notify`等方法也依赖于`monitor`对象，这就是为什么只有在同步的块或者方法中才能调用`wait/notify`等方法，否则会抛出`java.lang.IllegalMonitorStateException`的异常的原因。</span><br></pre></td></tr></table></figure><p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><p><img src="/imgs/JUC/image-20231007094153386.png" alt="image-20231007094153386"></p><p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p><p><img src="/imgs/JUC/image-20231007094203335.png" alt="image-20231007094203335"></p><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><h5 id="synchronized-修饰方法的的情况"><a href="#synchronized-修饰方法的的情况" class="headerlink" title="synchronized 修饰方法的的情况"></a>synchronized 修饰方法的的情况</h5><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p><p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p><h4 id="为什么wait和notify方法要写在synchronized同步代码块中？"><a href="#为什么wait和notify方法要写在synchronized同步代码块中？" class="headerlink" title="为什么wait和notify方法要写在synchronized同步代码块中？"></a>为什么wait和notify方法要写在synchronized同步代码块中？</h4><p>这是Java设计者为了避免使用者出现lost wake up(可能导致线程陷入永久等待)问题而搞出来的</p><p><img src="/imgs/JUC/image-20231007094226372.png" alt="image-20231007094226372"></p><p>问题的根源在于，消费者在检查count到调用wait()之间，count就可能被改掉了。</p><p>常见的解决方式是加锁</p><h4 id="jdk1-7对synchorinzed的优化？"><a href="#jdk1-7对synchorinzed的优化？" class="headerlink" title="jdk1.7对synchorinzed的优化？"></a>jdk1.7对synchorinzed的优化？</h4><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以<br>使用轻量级锁来优化。当存在竞争时，锁膨胀升级为重量级锁来互斥访问。</p><h5 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h5><p>重量级锁竞争的时候，如果竞争锁失败，该线程不会马上阻塞，使用自旋重试来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作（cas 交换 Object 的 Mark Word 和 锁记录地址）。<br>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现<br>这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p><ul><li><h6 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h6><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象<br>的 Thread ID<br>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程</p></li><li><h6 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h6><p>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p></li></ul><h4 id="Reentrantlock-与-synchronized-的区别"><a href="#Reentrantlock-与-synchronized-的区别" class="headerlink" title="Reentrantlock 与 synchronized 的区别"></a>Reentrantlock 与 synchronized 的区别</h4><p>Synchronized 可以通过两种方式来控制锁的粒度</p><ul><li>一种是把 synchronized 关键字修饰在方法层面，</li><li>另一种是修饰在代码块上，并且我们可以通过 Synchronized 加锁对象的声明周期来控制锁的作用范围，比如锁对象是静态对象或者类对象，那么这个锁就是全局锁。如果锁对象是普通实例对象，那这个锁的范围取决于这个实例的声明周期。</li></ul><p>Lock 锁的粒度是通过它里面提供的 lock()和 unlock()方法决定的（贴图），包裹在这两个方法之间的代码能够保证线程安全性。而锁的作用域取决于 Lock 实例的生命周期</p><p>相对于 synchronized 它具备如下特点</p><ul><li>可以设置超时时间， Lock 还提供了非阻塞的竞争锁方法 tryLock(int time)方法，在规定时间获取不到锁会返回false</li><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li><li><strong>可实现选择性通知（支持多个条件变量）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul><p>与 synchronized 一样，都支持可重入</p><h4 id="可中断锁和不可中断锁有什么区别？"><a href="#可中断锁和不可中断锁有什么区别？" class="headerlink" title="可中断锁和不可中断锁有什么区别？"></a>可中断锁和不可中断锁有什么区别？</h4><ul><li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li><li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁</li></ul><h4 id="volatile关键字的原理？怎么用？是否保证原子性？"><a href="#volatile关键字的原理？怎么用？是否保证原子性？" class="headerlink" title="volatile关键字的原理？怎么用？是否保证原子性？"></a>volatile关键字的原理？怎么用？是否保证原子性？</h4><p>由于JVM缓存优化，线程读变量值时，可能会到自己的工作缓存去读而不是到内存，所以当一个线程对变量执行写操作到内存，可能其他线程无法读到最新的变量值。</p><p>用法：在多线程读，一线程写的情况下，用来修饰成员变量和静态成员变量，这就指示 JVM，这个变量是共享且不稳定的，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。</p><h5 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h5><p><img src="/imgs/JUC/image-20231007094336194.png" alt="image-20231007094336194"></p><p><img src="/imgs/JUC/image-20231007094412404.png" alt="image-20231007094412404"></p><p><img src="/imgs/JUC/image-20231007094356401.png" alt="image-20231007094356401"></p><p>Volatile关键字底层实现主要是通过汇编lock指令，当某个CPU修改了缓存里面的数据，该数据会马上通过总线同步回主存，（lock指令开启其他CPU的总线嗅探机制）其他CPU通过一个<strong>总线嗅探机制</strong>来感知数据的变化从而将自己缓存里面的数据失效，需要使用这个数据，必须重新去内存中获取最新的数据，来保证数据的可见性。</p><ul><li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void actor2(I_Result r) &#123;</span><br><span class="line">num = 2;</span><br><span class="line">ready = true; // ready 是 volatile 赋值带写屏障</span><br><span class="line">// 写屏障</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void actor1(I_Result r) &#123;</span><br><span class="line">// 读屏障</span><br><span class="line">// ready 是 volatile 读取值带读屏障</span><br><span class="line">if(ready) &#123;</span><br><span class="line">r.r1 = num + num;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">r.r1 = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h5><p>当对volatile修饰变量赋值，会加上写屏障，写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void actor2(I_Result r) &#123;</span><br><span class="line">num = 2;</span><br><span class="line">ready = true; // ready 是 volatile 赋值带写屏障</span><br><span class="line">// 写屏障</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当对volatile修饰变量取值，会加上读屏障，读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void actor1(I_Result r) &#123;</span><br><span class="line">// 读屏障</span><br><span class="line">// ready 是 volatile 读取值带读屏障</span><br><span class="line">if(ready) &#123;</span><br><span class="line">r.r1 = num + num;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">r.r1 = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不能解决指令交错（无法保证原子性）："><a href="#不能解决指令交错（无法保证原子性）：" class="headerlink" title="不能解决指令交错（无法保证原子性）："></a>不能解决指令交错（无法保证原子性）：</h5><p>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去<br>而有序性的保证也只是保证了本线程内相关代码不被重排序</p><h4 id="synchronized关键字保证可见性和有序性"><a href="#synchronized关键字保证可见性和有序性" class="headerlink" title="synchronized关键字保证可见性和有序性"></a>synchronized关键字保证可见性和有序性</h4><p>我们都知道sychronized底层是通过monitorenter的指令来进行加锁的、通过monitorexit指令来释放锁的。</p><p>但是很多人都不知道的一点是，monitorenter指令其实还具有Load屏障的作用。</p><p>也就是通过monitorenter指令之后，synchronized内部的共享变量，每次读取数据的时候被强制从主内存读取最新的数据。</p><p>同样的道理monitorexit指令也具有Store屏障的作用，也就是让synchronized代码块内的共享变量，如果数据有变更的，强制刷新回主内存。</p><p>这样通过这种方式，数据修改之后立即刷新回主内存，其他线程进入synchronized代码块后，使用共享变量的时候强制读取主内存的数据，上一个线程对共享变量的变更操作，它就能立即看到了。</p><p>同时synchronized加的内存屏障也能保证内部代码的有序性</p><p><img src="/imgs/JUC/image-20231007094424592.png" alt="image-20231007094424592"></p><h4 id="为什么单线程不需要这个volatile关键字多线程需要"><a href="#为什么单线程不需要这个volatile关键字多线程需要" class="headerlink" title="为什么单线程不需要这个volatile关键字多线程需要"></a>为什么单线程不需要这个volatile关键字多线程需要</h4><p>因为在单线程的环境下，只有一个线程会使用修改的变量，变量不存在可见性问题。同时，单线程下，JVM的指令重排序也不会改变执行结果。</p><h4 id="为什么会出现指令重排序："><a href="#为什么会出现指令重排序：" class="headerlink" title="为什么会出现指令重排序："></a>为什么会出现指令重排序：</h4><p>指令还可以再划分成一个个更小的阶段，在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行，从而提高CPU的吞吐率。</p><h4 id="多线程通信方式"><a href="#多线程通信方式" class="headerlink" title="多线程通信方式"></a>多线程通信方式</h4><p>在Java中，多线程通信是通过一些机制和方法来实现的，以确保不同线程之间能够协同工作。以下是一些常见的多线程通信方式：</p><ol><li><strong>共享变量：</strong> 多个线程可以共享一个变量，通过读写该变量来进行通信。为了确保线程安全，通常需要使用<code>volatile</code>关键字或者<code>synchronized</code>关键字来控制访问。例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeclass SharedResource &#123;</span><br><span class="line">    private volatile int sharedValue;</span><br><span class="line"></span><br><span class="line">    public void setValue(int value) &#123;</span><br><span class="line">        sharedValue = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getValue() &#123;</span><br><span class="line">        return sharedValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>wait()和notify()：</strong> 这是基于对象监视器（Object Monitor）的机制，用于线程之间的等待和通知。<code>wait()</code>方法让一个线程等待，而<code>notify()</code>方法通知等待的线程继续执行。通常与<code>synchronized</code>关键字一起使用。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeclass SharedResource &#123;</span><br><span class="line">    private int sharedValue;</span><br><span class="line"></span><br><span class="line">    public synchronized void setValue(int value) &#123;</span><br><span class="line">        sharedValue = value;</span><br><span class="line">        notify(); // 通知等待的线程</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized int getValue() throws InterruptedException &#123;</span><br><span class="line">        if (sharedValue == 0) &#123;</span><br><span class="line">            wait(); // 等待通知</span><br><span class="line">        &#125;</span><br><span class="line">        return sharedValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>BlockingQueue：</strong> 使用<code>java.util.concurrent.BlockingQueue</code>可以方便地实现线程之间的通信。它提供了阻塞操作，当队列为空或已满时，线程会自动阻塞或等待。例如，<code>LinkedBlockingQueue</code>可以用于生产者-消费者问题。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeimport java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">BlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 生产者线程</span><br><span class="line">void producer() throws InterruptedException &#123;</span><br><span class="line">    queue.put(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消费者线程</span><br><span class="line">void consumer() throws InterruptedException &#123;</span><br><span class="line">    int value = queue.take();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>CountDownLatch和CyclicBarrier：</strong> 这两个类用于协调多个线程的执行。<code>CountDownLatch</code>用于等待一个或多个线程的完成，而<code>CyclicBarrier</code>用于等待多个线程到达某个同步点。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeCountDownLatch latch = new CountDownLatch(3);</span><br><span class="line"></span><br><span class="line">// 多个线程执行任务</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        // 执行任务</span><br><span class="line">        latch.countDown(); // 任务完成，计数减一</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主线程等待所有任务完成</span><br><span class="line">latch.await();</span><br></pre></td></tr></table></figure><ol><li><strong>Semaphore：</strong> <code>java.util.concurrent.Semaphore</code>用于控制同时访问的线程数量。它允许多个线程同时访问一个共享资源。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeSemaphore semaphore = new Semaphore(3); // 最多允许3个线程同时访问</span><br><span class="line"></span><br><span class="line">// 线程尝试获取许可</span><br><span class="line">try &#123;</span><br><span class="line">    semaphore.acquire(); // 获取许可</span><br><span class="line">    // 访问共享资源</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    semaphore.release(); // 释放许可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些是Java中常见的多线程通信方式。选择合适的通信方式取决于问题的性质和需求。需要注意，不正确的多线程通信可能导致竞态条件和死锁等问题，因此在设计多线程应用程序时应格外小心。</p><h4 id="乐观锁和悲观锁的区别？"><a href="#乐观锁和悲观锁的区别？" class="headerlink" title="乐观锁和悲观锁的区别？"></a>乐观锁和悲观锁的区别？</h4><h5 id="什么悲观锁？"><a href="#什么悲观锁？" class="headerlink" title="什么悲观锁？"></a><strong>什么悲观锁？</strong></h5><p>顾名思义，悲观锁是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;</p><p>特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p><h5 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a><strong>什么是乐观锁？</strong></h5><p>乐观锁是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);</p><p>特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。</p><h5 id="理论上来说："><a href="#理论上来说：" class="headerlink" title="理论上来说："></a>理论上来说：</h5><ul><li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li><li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li></ul><h4 id="讲一下CAS"><a href="#讲一下CAS" class="headerlink" title="讲一下CAS"></a>讲一下CAS</h4><p>CAS是一种无锁同步机制，其中的关键是 compareAndSet，也有 Compare And Swap 的说法，它必须是原子操作。</p><p><strong>CAS 必须借助 volatile</strong> 才能读取到共享变量的最新值来实现【比较并交换】的效果</p><p>CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。</p><p>CAS指令执行时，<strong>当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。通过发送一个lock指令锁住总线，确保整个比较并替换的操作是一个原子操作。</strong></p><h5 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h5><ul><li>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、竞争较少，多核 CPU 的场景下。</li><li>CAS 是基于乐观锁的思想：最乐观的估计，预计很少出现并发问题，当出现后，再重试。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，当一个线程上了锁，其他线程只能阻塞等待解锁。使得线程只能串行访问同步代码块，效率较低。</li><li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思</li><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p><strong>循环时间长开销很大：</strong>我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</p><p><strong>只能保证一个共享变量的原子操作：</strong>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p><p><strong>ABA*问题</strong>：<strong>通过版本号法解决。</strong>Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p><h5 id="用处："><a href="#用处：" class="headerlink" title="用处："></a>用处：</h5><p>Automic原子类，多线程的互斥同步等</p><h4 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h4><h5 id="LongAdder的成员变量"><a href="#LongAdder的成员变量" class="headerlink" title="LongAdder的成员变量"></a><strong>LongAdder的成员变量</strong></h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// CPU的数量</span><br><span class="line">static final int NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line">// Cell对象的数组，长度一般是2的指数</span><br><span class="line">transient volatile Cell[] cells;</span><br><span class="line">// 基础value值，当并发较低时，只累加该值</span><br><span class="line">transient volatile long base;</span><br><span class="line">// 创建或者扩容Cells数组时使用的自旋锁变量</span><br><span class="line">transient volatile int cellsBusy;</span><br></pre></td></tr></table></figure><p>当并发量较少时，cell数组尚未初始化，所以只调用<code>casBase</code>函数，对base变量进行CAS累加。</p><p>并发量大时，放弃使用base变量，而是从cells数组中随机选择一个cell，CAS累加，这样就可以减少并发冲突，获取值就用base加上cells中所有元素累加获得值，遍历数组不是个原子操作，所以LongAdder取到的值不是最新值，再获取精确计数的场景，可能不适合。</p><h4 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h4 id="线程池的拒绝策略有哪些？"><a href="#线程池的拒绝策略有哪些？" class="headerlink" title="线程池的拒绝策略有哪些？"></a>线程池的拒绝策略有哪些？</h4><p>若线程池中的核心线程数被用完且阻塞队列已排满，则此时线程池的资源已耗尽，线程池将没有足够的线程资源执行新的任务。为了保证操作系统的安全，线程池将通过拒绝策略处理新添加的线程任务。</p><h5 id="1-AbortPolicy（默认策略）"><a href="#1-AbortPolicy（默认策略）" class="headerlink" title="1. AbortPolicy（默认策略）"></a><strong>1. AbortPolicy</strong>（默认策略）</h5><p>第一种拒绝策略是 <code>AbortPolicy</code>，这种拒绝策略在拒绝任务时，会直接抛出一个类型为 RejectedExecutionException的RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。</p><h5 id="2-DiscardPolicy"><a href="#2-DiscardPolicy" class="headerlink" title="2.DiscardPolicy"></a><strong>2.DiscardPolicy</strong></h5><p>第2种拒绝策略是 <code>DiscardPolicy</code>，这种拒绝策略正如它的名字所描述的一样，当新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失。</p><h5 id="3-DiscardOldestPolicy"><a href="#3-DiscardOldestPolicy" class="headerlink" title="3.DiscardOldestPolicy"></a><strong>3.DiscardOldestPolicy</strong></h5><p>第3种拒绝策略是 <code>DiscardOldestPolicy</code>，如果线程池没被关闭且没有能力执行，则会丢弃任务队列中的头结点，通常是存活时间最长的任务，这种策略与第二种不同之处在于它丢弃的不是最新提交的，而是队列中存活时间最长的，这样就可以腾出空间给新提交的任务，但同理它也存在一定的数据丢失风险。</p><h5 id="4-CallerRunsPolicy"><a href="#4-CallerRunsPolicy" class="headerlink" title="4.CallerRunsPolicy"></a><strong>4.CallerRunsPolicy</strong></h5><p>第4种拒绝策略是 CallerRunsPolicy，相对而言它就比较完善了，当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。这样做主要有两点好处。</p><ol><li>第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。</li><li>第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。</li></ol><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>本文中我们学习线程池中的4 种默认的拒绝策略。线程池会在以下两种情况下会拒绝新提交的任务。</p><ul><li>第一种情况是当我们调用 shutdown 等方法关闭线程池后，即便此时可能线程池内部依然有没执行完的任务正在执行，但是由于线程池已经关闭，此时如果再向线程池内提交任务，就会遭到拒绝。</li><li>第二种情况是线程池没有能力继续处理新提交的任务，也就是工作已经非常饱和的时候。</li></ul><p>线程池状态</p><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p><p><img src="/imgs/JUC/image-20231007094447516.png" alt="image-20231007094447516"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c 为旧值， ctlOf 返回结果为新值</span></span><br><span class="line">ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));</span><br><span class="line"><span class="comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><h4 id="线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列"><a href="#线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列" class="headerlink" title="线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列"></a>线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列</h4><ul><li><h5 id="corePoolSize-核心线程数目-最多保留的线程数"><a href="#corePoolSize-核心线程数目-最多保留的线程数" class="headerlink" title="corePoolSize 核心线程数目 (最多保留的线程数)"></a>corePoolSize 核心线程数目 (最多保留的线程数)</h5></li></ul><p>线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。任务提交到线程池后，首先会检查当前线程数是否达到了corePoolSize，如果没有达到的话，则会创建一个新线程来处理这个任务。</p><ul><li><h5 id="maximumPoolSize-最大线程数目"><a href="#maximumPoolSize-最大线程数目" class="headerlink" title="maximumPoolSize 最大线程数目"></a>maximumPoolSize 最大线程数目</h5></li></ul><p>当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务缓存到工作队列（后面会介绍）中。如果队列也已满，则会去创建一个新线程来出来这个处理。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即maximunPoolSize指定</p><ul><li><h5 id="keepAliveTime-生存时间-针对救急线程，当没有任务一段时间会被销毁"><a href="#keepAliveTime-生存时间-针对救急线程，当没有任务一段时间会被销毁" class="headerlink" title="keepAliveTime 生存时间 - 针对救急线程，当没有任务一段时间会被销毁"></a>keepAliveTime 生存时间 - 针对救急线程，当没有任务一段时间会被销毁</h5></li></ul><p>线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 <code>corePoolSize</code> ，回收过程才会停止。</p><ul><li><h5 id="unit-时间单位-针对多余空闲线程，-救急线程存活时间单位"><a href="#unit-时间单位-针对多余空闲线程，-救急线程存活时间单位" class="headerlink" title="unit 时间单位 - 针对多余空闲线程， 救急线程存活时间单位"></a>unit 时间单位 - 针对多余空闲线程， 救急线程存活时间单位</h5></li><li><h5 id="workQueue-阻塞队列"><a href="#workQueue-阻塞队列" class="headerlink" title="workQueue 阻塞队列"></a>workQueue 阻塞队列</h5></li></ul><p>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排<br>队，直到有空闲的线程</p><ul><li><h5 id="threadFactory-线程工厂-可以为线程创建时起个好名字"><a href="#threadFactory-线程工厂-可以为线程创建时起个好名字" class="headerlink" title="threadFactory 线程工厂 - 可以为线程创建时起个好名字"></a>threadFactory 线程工厂 - 可以为线程创建时起个好名字</h5></li></ul><p>创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon（守护线程）线程等等</p><ul><li><h5 id="handler-拒绝策略"><a href="#handler-拒绝策略" class="headerlink" title="handler 拒绝策略"></a>handler 拒绝策略</h5></li></ul><p>当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，就会采用拒绝策略</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="创建多少线程池合适（线程池的参数怎么设计）"><a href="#创建多少线程池合适（线程池的参数怎么设计）" class="headerlink" title="创建多少线程池合适（线程池的参数怎么设计）"></a>创建多少线程池合适（线程池的参数怎么设计）</h4><ul><li>过小会导致程序不能充分地利用系统资源、容易导致饥饿</li><li>过大会导致更多的线程上下文切换，占用更多内存</li></ul><h5 id="CPU-密集型运算"><a href="#CPU-密集型运算" class="headerlink" title="CPU 密集型运算"></a>CPU 密集型运算</h5><p>通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p><h5 id="I-O-密集型运算"><a href="#I-O-密集型运算" class="headerlink" title="I&#x2F;O 密集型运算"></a>I&#x2F;O 密集型运算</h5><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。<br>经验公式如下</p><p>线程数 &#x3D; 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) &#x2F; CPU 计算时间</p><p>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式</p><p>4 * 100% * 100% &#x2F; 50% &#x3D; 8</p><p>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式</p><p>4 * 100% * 100% &#x2F; 10% &#x3D; 40</p><p><strong>公示也只是参考，具体还是要根据项目实际线上运行情况来动态调整</strong>，包括核心线程数、最大线程数、自定义任务队列等等</p><h4 id="假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？"><a href="#假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？" class="headerlink" title="假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？"></a>假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？</h4><ul><li>高并发低延迟业务，低延迟说明大概率是CPU密集型，高并发的情况下为了防止大量的上下文切换，核心线程数不宜设置太高，应该设置大概CPU核数 + 1个线程，</li><li>低并发高延迟业务，高延迟说明所需数据或外部资源需要较长时间等待，大概率是IO密集型，核心线程数应该设置为    CPU 核数 * 总时间(CPU计算时间+等待时间) &#x2F; CPU 计算时间</li></ul><h4 id="Future-类有什么用？"><a href="#Future-类有什么用？" class="headerlink" title="Future 类有什么用？"></a>Future 类有什么用？</h4><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p><p>这其实就是多线程中经典的 <strong>Future 模式</strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p><p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li>取消任务；</li><li>判断任务是否被取消;</li><li>判断任务是否已经执行完成;</li><li>获取任务执行结果。</li></ul><h4 id="讲一讲AQS"><a href="#讲一讲AQS" class="headerlink" title="讲一讲AQS"></a>讲一讲AQS</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p><code>AbstractQueuedSynchronizer(AQS)</code>提供了一套可用于实现锁同步机制的框架，不夸张地说，<code>AQS</code>是<code>JUC</code>同步框架的基石。<code>AQS</code>通过一个<code>FIFO</code>队列维护线程同步状态，实现类只需要继承该类，并重写指定方法即可实现一套线程同步机制。</p><p><code>AQS</code>根据资源互斥级别提供了<strong>独占和共享</strong>两种资源访问模式；同时其定义<code>Condition</code>结构提供了<code>wait/signal</code>等待唤醒机制。</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><code>AQS</code>的原理并不复杂，<code>AQS</code>维护了一个<code>volatile int state</code>变量和一个<code>CLH(三个人名缩写)先进先出的双向队列</code>，队列中的节点持有线程引用，每个节点均可通过<code>getState()</code>、<code>setState()</code>和<code>compareAndSetState()</code>对<code>state</code>进行修改和访问。具有条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet。</p><p>在<code>JUC</code>中，诸如<code>ReentrantLock</code>、<code>CountDownLatch</code>等都基于<code>AQS</code>实现。</p><p><img src="/imgs/JUC/image-20231007094500706.png" alt="image-20231007094500706"></p><p><img src="/imgs/JUC/e22dfb7003ee44afb6f80ddfbce68a93tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-1696303417939-13-1696643106023-2.webp" alt="img"></p><p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul><h4 id="公平锁与非公平锁？底层实现是什么"><a href="#公平锁与非公平锁？底层实现是什么" class="headerlink" title="公平锁与非公平锁？底层实现是什么"></a>公平锁与非公平锁？底层实现是什么</h4><p>底层都是AQS，默认一般使用<strong>非公平锁</strong>，它的效率和吞吐量都比公平锁高的多。由于公平锁需要关心队列的情况，得按照队列里的先后顺序来获取锁(会造成大量的线程上下文切换)，而非公平锁则没有这个限制。所以也就能解释非公平锁的效率会被公平锁更高。</p><p><strong>公平锁</strong>：</p><p>线程在tryAcquire（arg）尝试获得锁之前会利用 hasQueuedPredecessors() 方法来判断 AQS 的队列中中是否有其他线程，如果有则不会尝试获取锁(<strong>这是公平锁特有的情况</strong>)。</p><p>如果队列中没有线程就利用 CAS 来将 AQS 中的 state 修改为1，也就是获取锁，获取成功则将当前线程置为获得锁的独占线程(setExclusiveOwnerThread(current))。</p><p>如果 state 大于 0 时，说明锁已经被获取了，则需要判断获取锁的线程是否为当前线程(ReentrantLock 支持重入)，是则需要将 state + 1，并将值更新。</p><p>如果tryAcquire(arg) 获取锁失败，则需要用 addWaiter(Node.EXCLUSIVE) 将当前线程写入队列中。</p><p>写入之前需要将当前线程包装为一个 Node 对象(addWaiter(Node.EXCLUSIVE))，通过自旋加上 CAS 保证一定能写入队列。</p><p><strong>非公平锁</strong>：尝试获取锁时tryAcquire(arg)，非公平锁是不需要判断队列中是否还有其他线程，也是直接尝试获取锁：</p><p><strong><code>Node</code>主要包含5个核心字段：</strong></p><ul><li><p>waitStatus</p><p>：当前节点状态，该字段共有5种取值：</p><ul><li><code>CANCELLED = 1</code>。节点引用线程由于等待超时或被打断时的状态。</li><li><code>SIGNAL = -1</code>。后继节点线程需要被唤醒时的当前节点状态。当队列中加入后继节点被挂起<code>(block)</code>时，其前驱节点会被设置为<code>SIGNAL</code>状态，表示该节点需要被唤醒。</li><li><code>CONDITION = -2</code>。当节点线程进入<code>condition</code>队列时的状态。(见<code>ConditionObject</code>)</li><li><code>PROPAGATE = -3</code>。仅在释放共享锁<code>releaseShared</code>时对头节点使用。(见共享锁分析)</li><li><code>0</code>。节点初始化时的状态。</li></ul></li><li><p><code>prev</code>：前驱节点。</p></li><li><p><code>next</code>：后继节点。</p></li><li><p><code>thread</code>：引用线程，头节点不包含线程。</p></li><li><p><code>nextWaiter</code>：<code>condition</code>条件队列。(见<code>ConditionObject</code>)</p></li></ul><h4 id="ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？"><a href="#ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？" class="headerlink" title="ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？"></a>ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？</h4><p><img src="/imgs/JUC/image-20231007094516622.png" alt="image-20231007094516622"></p><p>threadLocal 是一个用来解决线程安全性问题的工具。它相当于让每个线程都开辟一块内存空间，用来存储共享变量的副本。<br>然后每个线程只需要访问和操作自己的共享变量副本即可，从而避免多线程竞争同一个共享资源。<br>它的工作原理很简单（如图）</p><p><img src="/imgs/JUC/image-20231007094522052.png" alt="image-20231007094522052"></p><p>每个线程里面有一个成员变量 ThreadLocalMap,<br>当线程访问用 ThreadLocal 修饰的共享数据的时候<br>这个线程就会在自己成员变量 ThreadLocalMap 里面保存一份数据副本。<br>key 指向 ThreadLocal 这个引用，并且是弱引用关系，而 value 保存的是共享数据的副本。<br>因为每个线程都持有一个副本，所以就解决了线程安全性问题。</p><p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用<strong>弱引用</strong>的ThreadLocal实例，value为线程变量的副本。这些对象之间的引用关系如下,</p><p><img src="/imgs/JUC/image-20231007094528632.png" alt="image-20231007094528632"></p><blockquote><p>实心箭头表示强引用，空心箭头表示弱引用</p></blockquote><h5 id="ThreadLocal-内存泄漏的原因"><a href="#ThreadLocal-内存泄漏的原因" class="headerlink" title="ThreadLocal 内存泄漏的原因"></a>ThreadLocal 内存泄漏的原因</h5><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</p><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>由于Thread中包含变量ThreadLocalMap，因此ThreadLocalMap与Thread的生命周期是一样长，如果都没有手动删除对应key，都会导致内存泄漏。</p><p>但是使用<strong>弱引用</strong>可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set(),get(),remove()的时候会被清除。</p><p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p><h5 id="ThreadLocal正确的使用方法"><a href="#ThreadLocal正确的使用方法" class="headerlink" title="ThreadLocal正确的使用方法"></a>ThreadLocal正确的使用方法</h5><ul><li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li><li>(将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 )</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2023/10/06/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/10/06/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h4 id="java的访问权限有哪些"><a href="#java的访问权限有哪些" class="headerlink" title="java的访问权限有哪些"></a>java的访问权限有哪些</h4><h5 id="类的成员变量和方法访问权限"><a href="#类的成员变量和方法访问权限" class="headerlink" title="类的成员变量和方法访问权限"></a>类的成员变量和方法访问权限</h5><table><thead><tr><th>修饰符</th><th>类内部</th><th>同包</th><th>子类</th><th>任何地方</th></tr></thead><tbody><tr><td>public</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>protected</td><td>Yes</td><td>Yes</td><td>Yes</td><td></td></tr><tr><td>包访问权限</td><td>Yes</td><td>Yes</td><td></td><td></td></tr><tr><td>private</td><td>Yes</td><td></td><td></td><td></td></tr></tbody></table><h5 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h5><p>类的访问权限仅有<strong>public</strong>和<strong>包访问权限</strong>， 如果一个类声明的时候用了<strong>public</strong>，则该类的类名必须与文件名一致，包括大小写，如果不匹配，会有编译错误</p><h4 id="String-str-“abc”-和String-str-new-String-“abc”-的区别"><a href="#String-str-“abc”-和String-str-new-String-“abc”-的区别" class="headerlink" title="String str &#x3D; “abc” 和String str &#x3D; new String(“abc”)的区别"></a><strong>String str &#x3D; “abc” 和String str &#x3D; new String(“abc”)的区别</strong></h4><p><code>String str =&quot;abc&quot;</code>的原理，采用字面值的方式创建时，<code>JVM</code>会先去字符串常量池中去查找是否存在”abc”这个对象，如果不存在就创建这个字符串，并把地址返回给<code>str</code>。如果存在则直接把”abc”这个字符串的地址返回给<code>str</code>。</p><p><img src="/imgs/Java%E5%9F%BA%E7%A1%80/16e1f7c1f13d9561tplv-t2oaga2asx-jj-mark3024000q75-1696302993864-1-1696643234832-1.webp" alt="img"></p><p><code>String str = new String(&quot;abc&quot;)</code>采用<code>new</code>关键字的方式创建，<code>JVM</code>也会去字符串常量池中查找有没有这个字符串，如果没有的话，就先在字符串常量池里创建”abc”这个字符串，然后再复制一份放在堆里并把地址返回给<code>str</code>。如果字符串常量池里存在该字符串，那么就直接复制一份放在堆里并把地址返回给<code>str</code>。</p><p><img src="/imgs/Java%E5%9F%BA%E7%A1%80/16e1f8c6aa324edetplv-t2oaga2asx-jj-mark3024000q75-1696303002110-3-1696643254308-3.webp" alt="img"></p><h4 id="equals-的底层代码是什么"><a href="#equals-的底层代码是什么" class="headerlink" title="equals 的底层代码是什么?"></a>equals 的底层代码是什么?</h4><ol><li>先使用&#x3D;&#x3D; 进行地址值的判断  </li><li>判断equals()中的值是否为字符串  </li><li>判断字符串的长度是否相同  </li><li>循环遍历进行判断两个字符串是否相同</li></ol><h4 id="object中的hashcode-方法是做什么用的"><a href="#object中的hashcode-方法是做什么用的" class="headerlink" title="object中的hashcode()方法是做什么用的"></a>object中的hashcode()方法是做什么用的</h4><p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p><p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><h5 id="那为什么不只提供-hashCode-方法呢？"><a href="#那为什么不只提供-hashCode-方法呢？" class="headerlink" title="那为什么不只提供 hashCode() 方法呢？"></a><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></h5><p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p><h5 id="那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？"><a href="#那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？" class="headerlink" title="那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？"></a><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></h5><p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><h4 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h4><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p>再map集合中，如果只重写equals方法，那么两个相同对象hashcode可能不同，会存在多个key相同的情况。</p><h4 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a><strong>基本类型和包装类型的区别</strong></h4><h5 id="1-基本类型有初始值，而包装类型的默认值是null"><a href="#1-基本类型有初始值，而包装类型的默认值是null" class="headerlink" title="1.基本类型有初始值，而包装类型的默认值是null"></a>1.基本类型有初始值，而包装类型的默认值是null</h5><h5 id="2-包装类型可以为-null，而基本类型不可以"><a href="#2-包装类型可以为-null，而基本类型不可以" class="headerlink" title="2.包装类型可以为 null，而基本类型不可以"></a>2.包装类型可以为 null，而基本类型不可以</h5><p>数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有<a href="https://so.csdn.net/so/search?q=NPE&spm=1001.2101.3001.7020">NPE</a>（NullPointerException）风险。</p><h5 id="3-存储位置有所区别：基本类型是成员变量就存储在堆内存里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用"><a href="#3-存储位置有所区别：基本类型是成员变量就存储在堆内存里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用" class="headerlink" title="3.存储位置有所区别：基本类型是成员变量就存储在堆内存里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用"></a>3.存储位置有所区别：基本类型是成员变量就存储在<a href="https://so.csdn.net/so/search?q=%E5%A0%86%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">堆内存</a>里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用</h5><h5 id="4-包装类型可用于泛型，而基本类型不可以"><a href="#4-包装类型可用于泛型，而基本类型不可以" class="headerlink" title="4.包装类型可用于泛型，而基本类型不可以"></a>4.包装类型可用于泛型，而基本类型不可以</h5><p>如果我们这么写<br>List<int> a &#x3D; new ArrayList&lt;&gt;();<br>编译器会报错：Type argument cannot be of primitive type(类型参数不能为基本类型)<br>这是为什么呢？因为泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类。</p><h5 id="5-在使用“-”进行判断的时候的不同"><a href="#5-在使用“-”进行判断的时候的不同" class="headerlink" title="5.在使用“&#x3D;&#x3D;”进行判断的时候的不同"></a>5.在使用“&#x3D;&#x3D;”进行判断的时候的不同</h5><ol start="6"><li>自动装箱和自动拆箱<br>把基本类型转换成包装类型的过程叫做装箱（boxing）。反之，把包装类型转换成基本类型的过程叫做拆箱（unboxing）。</li></ol><p>1）基本类型和包装类型进行 &#x3D;&#x3D; 比较，包装类型会自动拆箱，直接和基本类型比较值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 9;</span><br><span class="line">Integer b = 9;</span><br><span class="line">System.out.println(a == b);</span><br></pre></td></tr></table></figure><p>上述代码的结果为 true。</p><p>2）当需要进行自动装箱时，如果数字在 -128 至 127 之间，会直接使用缓存中的对象，而不是重新创建一个对象。<br>这个知识我之前从未听闻，正是在写这篇文章的时候查看相关技术博客才了解到的，又学到了新知识！<br>我们先来看这么一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer A = 199;  </span><br><span class="line">int a = A;  </span><br></pre></td></tr></table></figure><p>执行第一句代码的时候，系统为我们执行了：<br>Integer A &#x3D; Integer.valueOf(199);<br>执行第二句代码的时候，系统为我们执行了：<br>int a &#x3D; A.intValue();</p><h4 id="object类中的常用方法的用处："><a href="#object类中的常用方法的用处：" class="headerlink" title="object类中的常用方法的用处："></a>object类中的常用方法的用处：</h4><p>1、 getClass()：获取类的class对象。<br>2、 hashCode:获取对象的hashCode值<br>3、 equals():比较对象是否相等，比较的是值和地址，子类可重写以自定义。<br>4、 clone()：克隆方法。<br>5、 toString():如果没有重写，应用对象将打印的是地址值。<br>6、 notify():随机选择一个在该对象上调用wait方法的线程，解除其阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>7、 notifyall():解除所有那些在该对象上调用wait方法的线程的阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>8、 wait():导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在同步方法中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>9、 finalize()：对象回收时调用</p><h4 id="包装类的缓存"><a href="#包装类的缓存" class="headerlink" title="包装类的缓存"></a>包装类的缓存</h4><p>1、前提：发生自动装箱的过程（基本类型–&gt;包装类型）<br>创建一个包装类对象有两种方法：<br>（1）构造器方法（就是new出来）；<br>（2）自动装箱（就是编译器自动调用包装类的valueOf方法）；</p><h5 id="两种方法的区别："><a href="#两种方法的区别：" class="headerlink" title="两种方法的区别："></a>两种方法的区别：</h5><p>构造器方法：不论值的大小，返回的将都会是一个新对象；<br>自动装箱会先经过判断，再决定返回的是一个新对象还是常量池中已存在的对象。</p><p>2、机制：当通过自动装箱机制创建包装类对象时，首先会判断数值是否在缓存范围内，如果满足条件，则会从  该包装类中的静态内部类xxCache包装类 类型数组（放在方法区的常量池）中寻找指定数值，并返回缓存的对象，否则创建一个新的对象返回。</p><p>3、原理：<br>（1）当包装类加载时，该包装类中的内部类xxCache会初始化一个包装类类型数组，最小值（固定值）为-128,而最大值（默认值）为127【可修改】，是所有线程共享的。</p><h5 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h5><p>在缓存值范围内的对象可以直接在常量池中取出，不用创建新的对象；<br>当需要频繁的使用同一对象的时候，如果有缓存，则可以避免重复创建同一对象，节省空间开销和时间消耗，提升了性能。</p><p><img src="/imgs/Java%E5%9F%BA%E7%A1%80/image-20231007094746373.png" alt="image-20231007094746373"></p><h4 id="数组和链表的不同"><a href="#数组和链表的不同" class="headerlink" title="数组和链表的不同"></a>数组和链表的不同</h4><table><thead><tr><th></th><th>数组</th><th>链表</th></tr></thead><tbody><tr><td>逻辑结构</td><td>（1）数组在内存中连续； (2)使用数组之前，必须事先固定数组长度，不支持动态改变数组大小；(3) 数组元素增加时，有可能会数组越界；(4) 数组元素减少时，会造成内存浪费；（5）数组增删时需要移动其它元素</td><td>（1）链表采用动态内存分配的方式，在内存中不连续 (2)支持动态增加或者删除元素</td></tr><tr><td>访问效率</td><td>数组在内存中顺序存储，可通过下标访问，访问效率高</td><td>链表访问效率低，如果想要访问某个元素，需要从头遍历</td></tr><tr><td>越界问题</td><td>数组的大小是固定的，所以存在访问越界的风险</td><td>只要可以申请得到链表空间，链表就无越界风险</td></tr><tr><td>使用场景</td><td>存储的大小变化不大，且可以事先确定大小，主要是进行查找，很少插入和删除时</td><td>长度变化较大时，事先无法估量数据规模，当线性表要求频繁插入和删除时</td></tr></tbody></table><h4 id="抽象类接口什么不同"><a href="#抽象类接口什么不同" class="headerlink" title="抽象类接口什么不同"></a>抽象类接口什么不同</h4><p><strong>抽象类</strong>：在Java中被abstract关键字修饰的类称为抽象类，被abstract关键字修饰的方法称为抽象方法，抽象方法只有方法的声明，没有方法体。抽象类的特点：</p><p>a、抽象类不能被实例化只能被继承；</p><p>b、包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法；</p><p>c、抽象类中的抽象方法的修饰符只能为public或者protected，默认为public；</p><p>d、一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类；</p><p>e、抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。</p><p>*<strong>接口*：</strong>Java中接口使用interface关键字修饰，特点为:</p><p>a、接口可以包含变量、方法；变量被隐士指定为public static final，方法被隐士指定为public abstract（JDK1.8之前）；</p><p>b、接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题；</p><p>c、一个类可以实现多个接口；</p><h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a><strong>相同点</strong></h5><p>（1）都不能被实例化 （2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。</p><h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a><strong>不同点</strong></h5><p>（1）接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。</p><p>（2）实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</p><p>（3）接口强调特定功能的实现，而抽象类强调所属关系。</p><h4 id="Java的基本类型的成员变量在栈还是堆？"><a href="#Java的基本类型的成员变量在栈还是堆？" class="headerlink" title="Java的基本类型的成员变量在栈还是堆？"></a><strong>Java的基本类型的成员变量在栈还是堆？</strong></h4><ul><li><p><strong>第一种</strong>: 在方法中声明的变量，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因</p><p>（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中</p><p>（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。</p></li><li><p><strong>第二种</strong> 在类中声明的变量是成员变量(全局变量),放在堆中</p><ol><li>声明的是基本类型的变量,其变量名及其值放在堆内存中</li><li>声明的是引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中。但与对象中的普通成员变量（局部变量）不同的是，它们的生命周期是在对象销毁时才结束的</li></ol></li><li><p><strong>第三种</strong> 静态变量：</p><p>​静态变量随着类的加载而存在，是存储在方法区（Method Area）中的，而不是存储在栈或堆上，所以它的生命周期与程序的生命周期一样长。</p><p><img src="/imgs/Java%E5%9F%BA%E7%A1%80/image-20231007094805132.png" alt="image-20231007094805132"></p></li></ul><h4 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h4><p>深拷贝和浅拷贝是只针对引用数据类型的</p><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存（分支）。</p><p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。<br>如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。</p><p>深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象，是“值”而不是“引用”（不是分支）</p><p>拷贝第一层级的对象属性或数组元素<br>递归拷贝所有层级的对象属性和数组元素<br>深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。</p><p><strong>引用拷贝</strong>: 引用拷贝就是直接赋值，只在栈中创建一个新的引用，拷贝引用的地址，所以指向的是堆中同一个对象。</p><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p><p><img src="/imgs/Java%E5%9F%BA%E7%A1%80/image-20231007094842954.png" alt="image-20231007094842954"></p><p><img src="/imgs/Java%E5%9F%BA%E7%A1%80/image-20231007094847027.png" alt="image-20231007094847027"></p><h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><p>首先，我认为，之所以需要序列化，核心目的是为了解决网络通信之间的对象传输问题。<br>也就是说，如何把当前 JVM 进程里面的一个对象，跨网络传输到另外一个 JVM进程里面。<br>而序列化，就是把内存里面的对象转化为字节流，以便用来实现存储或者传输。<br>反序列化，就是根据从文件或者网络上获取到的对象的字节流，根据字节流里面保存的对象描述信息和状态。重新构建一个新的对象。</p><p><img src="/imgs/Java%E5%9F%BA%E7%A1%80/image-20231007094855585.png" alt="image-20231007094855585"></p><p>其次呢，序列化的前提是保证通信双方对于对象的可识别性，所以很多时候，我们会把对象先转化为通用的解析格式，比如 json、xml 等。然后再把他们转化为数据流进行网络传输，从而实现跨平台和跨语言的可识别性。</p><h4 id="Java反射有了解吗？举几个Java反射的应用案例"><a href="#Java反射有了解吗？举几个Java反射的应用案例" class="headerlink" title="Java反射有了解吗？举几个Java反射的应用案例"></a>Java反射有了解吗？举几个Java反射的应用案例</h4><p>反射是java语言的一个特性，它允程序在运行时（注意不是编译的时候），获取任意一个类的成员变量、成员方法和属性,调用任意一个对象的方法和属性,，这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p><ul><li>获取任意类的名称、package信息、所有属性、方法、注解、类型、类加载器等</li><li>获取任意对象的属性，并且能改变对象的属性</li><li>调用任意对象的方法</li><li>判断任意一个对象所属的类</li><li>实例化任意一个类的对象</li><li>通过反射我们可以实现动态装配，降低代码的耦合度,动态代理等。</li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>可以增加程序的灵活性，在运行过程中可以动态堆类进行修改和操作</li><li>提高代码复用率，比如动态代理</li><li>可以在运行是轻松获取任意一个类的方法、属性、并且还能通过反射进行动态调用</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>使用反射后，可读性较差</li><li>反射可以绕过一些限制访问的属性和方法，可能回导致一些安全性问题</li><li>反射回设计动态类型的解析，所以JVM无法对这些代码进行优化，导致性能要比非反射调用更低</li></ul><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>AOP动态代理的场景中，使用动态生成的代理类来提升代码复用性。</li><li>IOC：用反射来实例化bean对象等</li></ul><h4 id="String-、StringBuffer和StringBuilder的区别"><a href="#String-、StringBuffer和StringBuilder的区别" class="headerlink" title="String 、StringBuffer和StringBuilder的区别"></a>String 、StringBuffer和StringBuilder的区别</h4><h5 id="1-可变性"><a href="#1-可变性" class="headerlink" title="1.可变性"></a>1.可变性</h5><p>​String 内部的 value 值是 final 修饰的，所以它是不可变类。所以每次修改 String 的值，都会产生一个新的对象。<br>​StringBuffer 和 StringBuilder 是可变类，字符串的变更不会产生新的对象。</p><h5 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="2.线程安全性"></a>2.线程安全性</h5><p>​String 是不可变类，所以它是线程安全的。<br>​StringBuffer 是线程安全的，因为它每个操作方法都加了 synchronized 同步关键字。<br>​StringBuilder 不是线程安全的。所以在多线程环境下对字符串进行操作，应该使用 StringBuffer，否则使用StringBuilder</p><h5 id="3-性能方面。"><a href="#3-性能方面。" class="headerlink" title="3.性能方面。"></a>3.性能方面。</h5><p>​String 的性能是最低的，因为不可变意味着在做字符串拼接和修改的时候，需要重新创建新的对象以及分配内存。<br>​其次是 StringBuffer 要比 String 性能高，因为它的可变性使得字符串可以直接被修改<br>​最后是 StringBuilder，它比 StringBuffer 的性能高，因为 StringBuffer 加了同步锁。</p><h5 id="4-存储方面。"><a href="#4-存储方面。" class="headerlink" title="4.存储方面。"></a>4.存储方面。</h5><p>​String 存储在字符串常量池里面<br>​StringBuffer 和 StringBuilder 存储在堆内存空间。</p><h4 id="StringBuffer、StringBuilder的扩容原理"><a href="#StringBuffer、StringBuilder的扩容原理" class="headerlink" title="StringBuffer、StringBuilder的扩容原理"></a>StringBuffer、StringBuilder的扩容原理</h4><p>扩容原理：</p><p><code>StringBuffer</code>的底层数组结构用的是<code>char</code>类型的数组如果没有指定大小，默认大小为16，指定了大小，默认大小为（16 + 指定大小）。</p><p>所以，当我们使用<code>StringBuffer</code>对象的<code>append(...)</code>方法追加数据时，</p><ul><li>如果数组长度可以容纳追加的数据，就直接追加到数组</li><li>如果char类型数组的长度无法容纳我们追加的数据，<code>StringBuffer</code>就会进行扩容。</li><li>扩容时会用到<code>Arrays</code>类中的<code>copyOf(...)</code>方法，每次扩容的容量大小是原来的容量的2倍（通过无符号左移）加2。</li></ul><h4 id="说说ArrayList"><a href="#说说ArrayList" class="headerlink" title="说说ArrayList"></a>说说ArrayList</h4><p>ArrayList 是一个数组结构的存储容器，所以ArrayList是支持随机存取的，默认情况下，数组的长度是 10.当然我们也可以在构建 ArrayList 对象的时候自己指定初始长度。随着在程序里面不断的往 ArrayList 中添加数据，当添加的数据达到 10 个的时候，ArrayList 就没有多余容量可以存储后续的数据。这个时候 ArrayList 会自动触发扩容。扩容的具体流程很简单：</p><ol><li>首先，创建一个新的数组，这个新数组的长度是原来数组长度的 1.5 倍。</li><li>然后使用 Arrays.copyOf 方法把老数组里面的数据拷贝到新的数组里面。<br>扩容完成后再把当前要添加的元素加入到新的数组里面，从而完成动态扩容的过程。</li></ol><h4 id="Map的遍历方式"><a href="#Map的遍历方式" class="headerlink" title="Map的遍历方式"></a>Map的遍历方式</h4><p>1）在 for 循环中使用 entries 实现 Map 的遍历（最常见和最常用的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;Java入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;C语言入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapKey</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapValue</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        System.out.println(mapKey + <span class="string">&quot;：&quot;</span> + mapValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）使用 for-each 循环遍历 key 或者 values，一般适用于只需要 Map 中的 key 或者 value 时使用。性能上比 entrySet 较好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Java入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;C语言入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line"><span class="comment">// 打印键集合</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印值集合</span></span><br><span class="line"><span class="keyword">for</span> (String value : map.values()) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）使用迭代器（Iterator）遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Java入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;C语言入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;    </span><br><span class="line">    Entry&lt;String, String&gt; entry = entries.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;:&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）通过键找值遍历，这种方式的效率比较低，因为本身从键取值是耗时的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hash怎么扩容有了解吗？"><a href="#hash怎么扩容有了解吗？" class="headerlink" title="hash怎么扩容有了解吗？"></a>hash怎么扩容有了解吗？</h4><ul><li>HashMap的底层是采用数组来存储数据，当 HashMap 中元素个数超过（大于）临界值时会自动触发扩容，这个临界值有一个计算公式。</li><li>threashold&#x3D;loadFactor*capacity。loadFactor 的默认值是 0.75，capacity 的默认值是 16。当元素个数超过临界值就会触发Hash扩容（resize函数），默认扩容的大小是原来数组长度的 2 倍，HashMap 的最大容量是Integer.MAX_VALUE，也就是 2 的 31 次方-1。</li><li>然后会进行数据迁移，会伴随着一次重新 hash 分配（reHash),是非常耗时的，并且会遍历 hash 表中所有的元素，HasMap让容量为2的幂次方，就是方便数据迁移，元素的位置是  元素的hash&amp;（n - 1），此时n是全为1的二进制数，那么元素根据hash值的的位置要么不变，要么加上原来的长度, 底层的行为都是给 table 赋值一个两倍长度的新数组。</li></ul><h4 id="为什么扩容因子是-0-75？"><a href="#为什么扩容因子是-0-75？" class="headerlink" title="为什么扩容因子是 0.75？"></a>为什么扩容因子是 0.75？</h4><p>扩容因子表示 Hash 表中元素的填充程度，扩容因子的值越大，那么触发扩容的元素个数更多，<br>虽然空间利用率比较高，但是 hash 冲突的概率会增加。<br>扩容因子的值越小，触发扩容的元素个数就越少，也意味着 hash 冲突的概率减少，<br>但是对内存空间的浪费就比较多，而且还会增加扩容的频率。<br>因此，扩容因子的值的设置，本质上就是在 冲突的概率 以及 空间利用率之间的平衡。<br>0.75 这个值的来源，和统计学里面的泊松分布有关。</p><p>当扩容因子在 0.75 的时候，链表长度达到 8 的可能性几乎为 0，也就是比较好的达到了空间成本和时间成本的平衡。</p><h4 id="HashMap的Hash值如何计算"><a href="#HashMap的Hash值如何计算" class="headerlink" title="HashMap的Hash值如何计算"></a>HashMap的Hash值如何计算</h4><p> <strong>h &#x3D; (key.hashCode ()) ^ (key.hashCode()&gt;&gt;16)</strong>,让hashCode的高16位和低16位进行异或，这样可以让hash值得散列度更高，尽可能区减少hash冲突的情况，从而去提升数据查找性能。</p><h4 id="HashMap怎么解决hash冲突的"><a href="#HashMap怎么解决hash冲突的" class="headerlink" title="HashMap怎么解决hash冲突的"></a>HashMap怎么解决hash冲突的</h4><p>首先，HashMap 底层采用了数组的结构来存储数据元素，数组的默认长度是 16，当我们通过 put 方法添加数据的时候，HashMap 根据 Key 的 hash 值进行取模运算,最终保存到数组的指定位置。<br>但是这种设计会存在 hash 冲突问题，也就是两个不同 hash 值的 key，最终取模后会落到同一个数组下标。所以 HashMap 引入了链式寻址法来解决 hash 冲突问题， 对于存在冲突的key，HashMap 把这些 key 组成一个单向链表。然后采用尾插法把这个 key 保存到链表的尾部。另外，为了避免链表过长的问题，当链表长度大于 8 并且数组长度大于等于 64 的时候，HashMap 会把链表转化为红黑树,从而减少链表数据查询的时间复杂度问题，提升查询性能</p><p>解决 hash 冲突问题的方法有很多，比如</p><ul><li>再 hash 法，就是如果某个 hash 函数产生了冲突，再用另外一个 hash 进行计算，</li><li>开放寻址法，就是直接从冲突的数组位置往下寻找一个空的数组下标进行数据存储，(这个在 ThreadLocal 里面有使用到)。</li><li>建立公共溢出区，也就是把存在冲突的 key 统一放在一个公共溢出区里面。</li></ul><h4 id="HashMap在多线程情况下会产生哪些问题？会产生死锁吗？"><a href="#HashMap在多线程情况下会产生哪些问题？会产生死锁吗？" class="headerlink" title="HashMap在多线程情况下会产生哪些问题？会产生死锁吗？"></a>HashMap在多线程情况下会产生哪些问题？会产生死锁吗？</h4><ul><li>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</li><li>为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题。并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</li></ul><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><ul><li><p>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。</p><p>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。</p><p>随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</p></li><li><p>还有一种情况是这两个线程同时 <code>put</code> 操作导致 <code>size</code> 的值不正确，进而导致数据覆盖的问题：</p><ol><li>线程 1 执行 <code>if(++size &gt; threshold)</code> 判断时，假设获得 <code>size</code> 的值为 10，由于时间片耗尽挂起。</li><li>线程 2 也执行 <code>if(++size &gt; threshold)</code> 判断，获得 <code>size</code> 的值也为 10，并将元素插入到该桶位中，并将 <code>size</code> 的值更新为 11。</li><li>随后，线程 1 获得时间片，它也将元素放入桶位中，并将 size 的值更新为 11。</li><li>线程 1、2 都执行了一次 <code>put</code> 操作，但是 <code>size</code> 的值只增加了 1，也就导致实际上只有一个元素被添加到了 <code>HashMap</code> 中。</li></ol></li></ul><h4 id="说一说HashMap-get元素的完整流程"><a href="#说一说HashMap-get元素的完整流程" class="headerlink" title="说一说HashMap get元素的完整流程"></a>说一说HashMap get元素的完整流程</h4><p>先计算key的hashcode值，然后计算key的hash值，通过（n - 1） &amp; hash 找到对应的桶的位置。</p><ul><li><p>如果位置上没有结点，直接返回null。</p></li><li><p>有结点，，判断头结点的hash值是否等于key的hash值</p><ul><li><p>hash值相等，继续用 “&#x3D;&#x3D;” 和equals（）判断key是否相等，相等就返回</p></li><li><p>hash值不相等，遍历整个链表或者红黑树结点，还是判断hash值和key是否相等</p></li><li><p>头结点hash值 &lt; 0, 说明map正在扩容，需要到新的table中用一个 find() 方法去查找</p></li></ul></li></ul><h4 id="说一说HashMap-put元素的完整流程"><a href="#说一说HashMap-put元素的完整流程" class="headerlink" title="说一说HashMap put元素的完整流程"></a>说一说HashMap put元素的完整流程</h4><ol><li>根据key的hashcode 获得hash值（hashcode ^ (hashcode  &gt;&gt;&gt; 16)）</li><li>通过hash &amp; (n - 1) 找到对应桶的位置</li><li>如果桶为空，就直接put</li><li>如果桶不为空就遍历桶中所有元素，通过比较hashcode –&gt; “&#x3D;&#x3D;”判断 –&gt;equals 判断是否已存在，存在就更新value值， 不存在，就插入，size++     判断是否需要转化为红黑树      是否需要扩容</li></ol><h4 id="ConcurrentHashMap为什么能保证线程安全？"><a href="#ConcurrentHashMap为什么能保证线程安全？" class="headerlink" title="ConcurrentHashMap为什么能保证线程安全？"></a>ConcurrentHashMap为什么能保证线程安全？</h4><p>添加元素时首先会判断容器是否为空，</p><ul><li><p>如果为空则使用 volatile 加 CAS 来初始化，防止多个线程同时初始化，造成并发问题，</p></li><li><p>如果容器不为空，则根据存储的元素计算该位置是否为空。</p><ul><li><p>如果根据存储的元素计算结果桶为空，则利用 CAS 设置该节点，避免并发冲突；</p></li><li><p>如果根据存储的元素计算桶为空不为空，则使用 synchronized 锁住这个桶链表的头结点，然后，遍历桶中的数据，根据hash值与key，更新或新增节点到桶中，</p></li><li><p>如果桶中头结点的hash值为 MOVED（-1），就说明map正在进行扩容，此时会锁住这个桶中的链表来帮助扩容，避免扩容的并发问题，等待扩容完成再put入新的table</p></li><li><p>最后再判断是否需要转为红黑树。这样就能保证并发访问时的线程安全了。</p></li></ul></li></ul><p>设置多个累加单元来计算size()的值，防止并发下计数错误。</p><ul><li>当线程竞争不激烈时，直接采用 CAS 对baseCount操作实现元素个数的原子递增。</li><li>如果线程竞争激烈，使用一个数组来维护元素个数，如果要增加总的元素个数，则直接从数组中随机选择一个，再通过 CAS 实现原子递增，之后遍历数组中所有的值与baseCount累加。它的核心思想是引入了数组来实现对并发更新的负载。</li></ul><p>总结： ConcurrentHashMap 通过<strong>对数组头结点加锁</strong>和<strong>加CAS的初始化</strong>来保证线程安全的。</p><h4 id="为什么-ConcurrentHashMap-不允许插入-null值？"><a href="#为什么-ConcurrentHashMap-不允许插入-null值？" class="headerlink" title="为什么 ConcurrentHashMap 不允许插入 null值？"></a>为什么 ConcurrentHashMap 不允许插入 null值？</h4><p><code>ConcurrentHashMap</code> 的 key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，表示没有对象或没有引用。（如果你用 null 作为键，那么你就无法区分这个键是否存在于 <code>ConcurrentHashMap</code> 中，还是根本没有这个键。）同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储<code>ConcurrentHashMap</code> 中的，还是因为找不到对应的键而返回的。</p><p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p><ul><li>值没有在集合中 ；</li><li>值本身就是 null。</li></ul><p>这也就是二义性的由来。</p><p>多线程环境下，存在一个线程操作该 <code>ConcurrentHashMap</code> 时，其他的线程将该 <code>ConcurrentHashMap</code> 修改的情况，所以无法通过 <code>containsKey(key)</code> 来判断否存在这个键值对，也就没办法解决二义性问题了。</p><p>与此形成对比的是，<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入 null 作为参数，就会返回 hash 值为 0 的位置的值。HashMap 的设计是给单线程使用的，所以如果取到 null（空） 值，我们可以通过HashMap 的 containsKey(key)方 法来区分这个 null（空） 值到底是插入值是 null（空），还是本就没有才返回的 null（空） 值。单线程环境下，不存在一个线程操作该 HashMap 时，其他的线程将该 <code>HashMap</code> 修改的情况，所以可以通过 <code>contains(key)</code>来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。</p><p>也就是说，多线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。</p><p>如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>举个例子，现在有线程 T1 调用了 ConcurrentHashMap 的 containsKey(key) 方法，<br>我们期望返回的结果是 false，也就是说，T1 并没有往 ConcurrentHashMap 中 put null（空）值。<br>但是，恰恰出了个意外，在线程 T1 还没有得到返回结果之前，线程 T2 又调用了<br>ConcurrentHashMap 的 put() 方法，插入了一个 Key，并且存入的 Value 是 null（空） 值。那么，线程 T1 最终得到的返回结果就变成 true 了。</p><h4 id="JDK新特性"><a href="#JDK新特性" class="headerlink" title="JDK新特性"></a>JDK新特性</h4><h5 id="JDK1-8的新特性-、"><a href="#JDK1-8的新特性-、" class="headerlink" title="JDK1.8的新特性:、"></a><strong>JDK1.8的新特性:、</strong></h5><ol><li><p>stream流</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;def&quot;, &quot;gkh&quot;, &quot;abc&quot;);</span><br><span class="line">    //返回符合条件的stream</span><br><span class="line">    Stream&lt;String&gt; stringStream = strings.stream().filter(s -&gt; &quot;abc&quot;.equals(s));</span><br><span class="line">    //计算流符合条件的流的数量</span><br><span class="line">    long count = stringStream.count();</span><br><span class="line"></span><br><span class="line">    //forEach遍历-&gt;打印元素</span><br><span class="line">    strings.stream().forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>2、Lambda 表达式<br>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">return b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、函数式接口</p><p>Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p><p>4、方法与构造函数引用</p><p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(&quot;Java&quot;);</span><br><span class="line">System.out.println(converted);</span><br></pre></td></tr></table></figure><ol start="5"><li>日期 Date-timeAPI</li></ol><ul><li>增强了时区处理</li><li>增强各种格式化、和时间计算</li></ul><h5 id="JDK9新特性"><a href="#JDK9新特性" class="headerlink" title="JDK9新特性"></a>JDK9新特性</h5><ol><li><p>JShell，为 Java 提供了类似于 Python 的实时命令行交互工具。</p><p><img src="/imgs/Java%E5%9F%BA%E7%A1%80/image-20231007094914235.png" alt="image-20231007094914235"></p></li><li><p>String 改为用byte[]存储。</p></li></ol><h5 id="jdk10新特性"><a href="#jdk10新特性" class="headerlink" title="jdk10新特性"></a>jdk10新特性</h5><p><strong>局部变量类型推断(var)</strong>***</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var id =0;</span><br><span class="line">var codefx =newURL(&quot;https://mp.weixin.qq.com/&quot;);</span><br><span class="line">var list =newArrayList&lt;&gt;();</span><br><span class="line">var list =List.of(1,2,3);</span><br></pre></td></tr></table></figure><h5 id="JDK11新特性"><a href="#JDK11新特性" class="headerlink" title="JDK11新特性"></a>JDK11新特性</h5><h5 id="String增强"><a href="#String增强" class="headerlink" title="String增强"></a>String增强</h5><p>增加了一系列的字符串处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断字符串是否为空</span></span><br><span class="line"><span class="string">&quot; &quot;</span>.isBlank();<span class="comment">//true</span></span><br><span class="line"><span class="comment">//去除字符串首尾空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.strip();<span class="comment">// &quot;Java&quot;</span></span><br><span class="line"><span class="comment">//去除字符串首部空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.stripLeading();   <span class="comment">// &quot;Java &quot;</span></span><br><span class="line"><span class="comment">//去除字符串尾部空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.stripTrailing();  <span class="comment">// &quot; Java&quot;</span></span><br><span class="line"><span class="comment">//重复字符串多少次</span></span><br><span class="line"><span class="string">&quot;Java&quot;</span>.repeat(<span class="number">3</span>);             <span class="comment">// &quot;JavaJavaJava&quot;</span></span><br><span class="line"><span class="comment">//返回由行终止符分隔的字符串集合。</span></span><br><span class="line"><span class="string">&quot;A\nB\nC&quot;</span>.lines().count();    <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;A\nB\nC&quot;</span>.lines().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/10/03/hello-world/"/>
      <url>/2023/10/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
