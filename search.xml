<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JUC</title>
      <link href="/2024/04/19/JUC/"/>
      <url>/2024/04/19/JUC/</url>
      
        <content type="html"><![CDATA[<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>进程作为资源分配的基本单位,线程作为调度的基本单位。</p><ul><li>进程可看做是正在执行的程序,每个进程都有独立的代码和数据空间，所以进程间的切换会有较大的开销。一个进程在其执行的过程中可以产生多个线程。</li><li>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器（</strong>线程切换后能恢复到正确的执行位置<strong>）</strong>、<strong>虚拟机栈（</strong>保证线程中的局部变量不被别的线程访问到<strong>）</strong>和<strong>本地方法栈</strong>（包含局部变量，本地方法），所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul><p>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响,因为它们共享了堆和方法区资源。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231016143302701.png" alt="image-20231016143302701"></p><ul><li>堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存）</li><li>方法区保存在着被加载过的每一个类的信息，包括类的方法、构造器，成员方法，属性等，这些信息由<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">类加载</a>器在加载类时，从类的源文件中抽取出来；<strong>运行时常量池</strong>：当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址转换为真实地址。</li></ul><h4 id="线程创建方法"><a href="#线程创建方法" class="headerlink" title="线程创建方法"></a>线程创建方法</h4><ol><li>继承Thread类并重写run方法</li></ol><ul><li><p>d定义Thread类的子类，并重写该类的run()方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。</p></li><li><p>创建Thread子类的实例，也就是创建了线程对象</p></li><li><p>启动线程，即调用线程的start()方法，本质上调用的是runable接口中的run方法</p></li></ul><p>代码实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;<span class="comment">//继承Thread类</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">new</span> <span class="title class_">MyThread</span>().start();<span class="comment">//创建并启动线程</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过实现Runnable接口并重写run方法</li></ol><ul><li><p>定义Runnable接口的实现类，一样要重写run()方法，这个run（）方法和Thread中的run()方法一样是线程的执行体</p></li><li><p>创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象</p></li><li><p>第三部依然是通过调用线程对象的start()方法来启动线程</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;<span class="comment">//实现Runnable接口</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　　<span class="comment">//创建并启动线程</span></span><br><span class="line">　　　　MyThread2 myThread=<span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">　　　　Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">　　　　thread().start();</span><br><span class="line">　　　　<span class="comment">//或者    new Thread(new MyThread2()).start();</span></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>实现Callable接口并实现call()方法</li></ol><ul><li><p>创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。</p></li><li><p>使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值</p></li><li><p>使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）</p></li><li><p>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread3</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　MyThread3 th=<span class="keyword">new</span> <span class="title class_">MyThread3</span>();</span><br><span class="line">      th.start();</span><br><span class="line">　　　<span class="comment">//也可以直接使用Lambda表达式创建Callable对象</span></span><br><span class="line">　　   <span class="comment">//使用FutureTask类来包装Callable对象</span></span><br><span class="line">　　　FutureTask&lt;Integer&gt; future=<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(</span><br><span class="line">　　　　(Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　  );</span><br><span class="line"></span><br><span class="line">　　　<span class="keyword">new</span> <span class="title class_">Thread</span>(future,<span class="string">&quot;有返回值的线程&quot;</span>).start();<span class="comment">//实质上还是以Callable对象来创建并启动线程</span></span><br><span class="line">　　  <span class="keyword">try</span> &#123;</span><br><span class="line">　　　　System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span>+future.get());<span class="comment">//get()方法会阻塞，直到子线程执行结束才返回</span></span><br><span class="line"> 　　 &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">　　　　ex.printStackTrace();</span><br><span class="line">　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用线程池来创建线程</li></ol><h4 id="Future-类有什么用？"><a href="#Future-类有什么用？" class="headerlink" title="Future 类有什么用？"></a>Future 类有什么用？</h4><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p><p>这其实就是多线程中经典的 <strong>Future 模式</strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p><p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li>取消任务；</li><li>判断任务是否被取消;</li><li>判断任务是否已经执行完成;</li><li>获取任务执行结果。</li></ul><h4 id="Java内存区域，内存模型？"><a href="#Java内存区域，内存模型？" class="headerlink" title="Java内存区域，内存模型？"></a>Java内存区域，内存模型？</h4><p><strong>Java内存模型（JMM）</strong></p><p>可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112214089.png" alt="image-20231003112214089"></p><p>在当前的 Java 内存模型下，线程可以把变量保存 <strong>本地内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p><p><strong>Java内存区域</strong></p><p>Java的内存区域和内存模型是不一样的东西，内存区域是指 JVM 运行时将数据分区域存储，强调对内存空间的划分。</p><p>Java内存区域主要由栈、堆、方法区组成</p><p><strong>栈</strong>：每个线程有自己独立、不共享的虚拟机栈，由多个栈帧（每个方法运行时需要的内存）组成，其中存放参数、局部变量，返回地址等，每个线程只能有一个活动栈帧，对应当前正在执行的那个方法。</p><p><strong>堆</strong>：多个线程共享同一个堆，通过new关键字构建的对象都需要使用堆内存，里面存放了实例对象、字符串常量池，静态变量等。</p><p><strong>方法区</strong>：保存在着被加载过的每一个类的信息，包括类的方法、构造器，成员方法，属性等，这些信息由<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">类加载</a>器在加载类时，从类的源文件中抽取出来；<strong>运行时常量池</strong>：当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址转换为真实地址。</p><p><strong>程序计数器：</strong>每个线程都有一个独立的程序计数器，记录下一条JVM指令的执行地址</p><p><strong>本地方法栈：</strong>调用本地方法（由C或者C++编写的底层的方法，与操作系统的底层API打交道）时给本地方法提供的内存空间</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112225692.png" alt="image-20231003112225692"></p><h4 id="线程的上下文切换是什么"><a href="#线程的上下文切换是什么" class="headerlink" title="线程的上下文切换是什么"></a>线程的上下文切换是什么</h4><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 CPU 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行，CPU被抢占</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li><li>主动让出CPU调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li></ul><p>线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念<br>就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><p>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等<br>Context Switch 频繁发生会影响性能</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112229884.png" alt="image-20231003112229884"></p><h4 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h4><p>多个线程同时被阻塞，处于相互等待的状态，如果没有外界干预，线程会被无限期地阻塞，因此程序不可能正常终止</p><h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><p>互斥条件：该资源任意一个时刻只由一个线程占用。</p><p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p><p>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系</p><h5 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h5><p><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</p><p><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><ul><li><h4 id="同步、异步、阻塞、非阻塞的理解"><a href="#同步、异步、阻塞、非阻塞的理解" class="headerlink" title="同步、异步、阻塞、非阻塞的理解"></a>同步、异步、阻塞、非阻塞的理解</h4><p>同步与异步关注的是<strong>消息通信机制</strong>（synchronous communication&#x2F; asynchronous communication）关注的<strong>是在发出调用后需不需要等待调用结果再返回调用</strong>。</p><p>阻塞和非阻塞关注的是<strong>程序在等待调用结果</strong>（消息，返回值）时的状态，关注的<strong>是等待调用结果时线程能否处理其他事情</strong>。</p><p><strong>阻塞</strong>调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<strong>非阻塞</strong>调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p><strong>(1)阻塞(blocking)、非阻塞（non-blocking）：</strong>可以简单理解为需要做一件事能不能立即得到返回应答，如果不能立即获得返回，需要等待，那就阻塞了(进程或线程就阻塞在那了，不能做其它事情)，否则就可以理解为非阻塞(在等待的过程中可以做其它事情)。</p><p><strong>(2)同步(synchronous)、异步(asynchronous)：</strong> 总是做完一件再去做另一件，不管是否需要时间等待，这就是同步(在发出一个功能调用时，在没有得到结果之前，该调用就不返回,即此时不能做下一件事情)；异步则反之，可以同时做几件事，并非一定需要一件事做完再做另一件事(当一个异步过程调用发出后，调用者不能立刻得到结果,此时可以接着做其它事情)。</p><p>同步简单理解成一问一答同步进行，异步可以简单理解为不必等一个问题有了答案再去问另一个问题，尽管问，有答了再通知你。</p></li></ul><h4 id="start和-run方法的区别"><a href="#start和-run方法的区别" class="headerlink" title="start和 run方法的区别"></a>start和 run方法的区别</h4><ul><li><p>直接调用 run 是在主线程中执行了 run，没有启动新的线程</p></li><li><p>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</p></li></ul><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p><h4 id="java里面线程有几种状态？"><a href="#java里面线程有几种状态？" class="headerlink" title="java里面线程有几种状态？"></a>java里面线程有几种状态？</h4><h5 id="操作系统-层面来描述"><a href="#操作系统-层面来描述" class="headerlink" title="操作系统 层面来描述"></a>操作系统 层面来描述</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112235300.png" alt="image-20231003112235300"></p><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li><li>【运行状态】指获取了 CPU 时间片运行中的状态 ：当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li><li>【阻塞状态】：如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】：等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】，阻塞状态与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h5 id="Java-API-层面来描述"><a href="#Java-API-层面来描述" class="headerlink" title="Java API 层面来描述"></a>Java API 层面来描述</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112238774.png" alt="image-20231003112238774"></p><ul><li><p>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code>。</p><p>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</p><p>BLOCKED：阻塞状态，需要等待锁释放。</p><p>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</p><p>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</p><p>TERMINATED：终止状态，表示该线程已经运行完毕.</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112242092.png" alt="image-20231003112242092"></p></li></ul><h4 id="阻塞和等待有什么区别？"><a href="#阻塞和等待有什么区别？" class="headerlink" title="阻塞和等待有什么区别？"></a>阻塞和等待有什么区别？</h4><p>造成原因不同：线程因为对共享资源竞争失败进入阻塞，而等待是因为api调用而进入等待</p><p>我们说一个操作是”阻塞”的，我们的意思是这个操作会<strong>停止线程的执行</strong>，直到某个条件得到满足。例如，在传统的同步I&#x2F;O中，一个读操作会阻塞线程，直到数据可用为止。<strong>在阻塞期间，线程不能做任何其他的事情，它只是停在那里，等待读操作完成。</strong></p><p>当我们说一个操作是”等待”的，我们的意思是这个操作会<strong>让出线程的控制权</strong>，直到某个条件得到满足。例如，在异步I&#x2F;O中，一个读操作（如ReadAsync）会立即返回一个任务，代表这个操作的完成情况。<strong>在等待这个任务时，线程可以去做其他的事情。这就是所谓的”非阻塞”行为。</strong></p><h4 id="什么情况下会让线程进入-block-状态"><a href="#什么情况下会让线程进入-block-状态" class="headerlink" title="什么情况下会让线程进入 block 状态"></a>什么情况下会让线程进入 block 状态</h4><ul><li>t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED</li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED</li></ul><h4 id="线程调用sleep方法，sleep-10s-，结束后，调用sleep的线程处于什么状态？"><a href="#线程调用sleep方法，sleep-10s-，结束后，调用sleep的线程处于什么状态？" class="headerlink" title="线程调用sleep方法，sleep(10s)，结束后，调用sleep的线程处于什么状态？"></a>线程调用sleep方法，sleep(10s)，结束后，调用sleep的线程处于什么状态？</h4><p><strong>Runable状态</strong></p><p>在sleep的时间内，线程不会释放临界资源，在sleep结束之后，线程正常运行，sleep一般是模拟一些业务，之后unlock就释放了临界资源，比如锁</p><h4 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h4><p><strong>使用位置不同</strong>：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用</p><p><strong>释放资源不同</strong>：调用wait方法时，该线程必须持有锁资源，<strong>wait 方法会主动的释放锁，而 sleep 方法则不会</strong></p><p><strong>源头不同</strong>：wait 方法属于 Object 类的方法，而 sleep 属于 Thread 类的方法</p><p>sleep 方法必须要传递一个超时时间的参数，且过了超时时间之后，线程会自动唤醒。而 wait 方法可以不传递任何参数，不传递任何参数时表示永久休眠，直到另一个线程调用了 notify 或 notifyAll 之后，休眠的线程才能被唤醒。也就是说 <strong>sleep 方法具有主动唤醒功能，而不传递任何参数的 wait 方法只能被动的被唤醒</strong>。<strong>调用 sleep 方法线程会进入 TIMED_WAITING 有时限等待状态，而调用无参数的 wait 方法，线程会进入 WAITING 无时限等待状态</strong></p><h4 id="为什么wait和notify方法要写在synchronized同步代码块中？"><a href="#为什么wait和notify方法要写在synchronized同步代码块中？" class="headerlink" title="为什么wait和notify方法要写在synchronized同步代码块中？"></a>为什么wait和notify方法要写在synchronized同步代码块中？</h4><p>这是Java设计者为了避免使用者出现lost wake up(可能导致线程陷入永久等待)问题而搞出来的。</p><p>列举下面永久等待的场景：</p><p>所以需要synchronized这样的同步机制来避免多线程并发修改这个共享变量，造成永久等待的问题</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112303623.png" alt="image-20231003112303623"></p><p>问题的根源在于，消费者在检查count到调用wait()之间，count就可能被改掉了。</p><p>常见的解决方式是加锁</p><p> wait 和 notify 用来实现多线程之间的协调，wait 表示让线程进入到阻塞状态，notify 表示让阻塞的线程唤醒。</p><p>wait 和 notify 必然是成对出现的，如果一个线程被 wait()方法阻塞，那么必然需要另外一个线程通过 notify()方法来唤醒这个被阻塞的线程，从而实现多线程之间的通信。</p><p>在多线程里面，要实现多个线程之间的通信，除了管道流以外，只能通过共享变量的方法来实现，也就是线程 t1 修改共享变量 s，线程 t2 获取修改后的共享变量 s，从而完成数据通信。</p><p>但是多线程本身具有并行执行的特性，也就是在同一时刻，多个线程可以同时执行。在这种情况下，线程 t2 在访问共享变量 s 之前，必须要知道线程 t1 已经修改过了共享变量 s，否则就需要等待。<br>同时，线程 t1 修改过了共享变量 S 之后，还需要通知在等待中的线程 t2。所以要在这种特性下要去实现线程之间的通信，就必须要有一个竞争条件控制线程在什么条件下等待，什么条件下唤醒。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231015195346379.png" alt="image-20231015195346379"></p><p>而 Synchronized 同步关键字就可以实现这样一个互斥条件，也就是在通过共享变量来实现多个线程通信的场景里面，参与通信的线程必须要竞争到这个共享变量的锁资源，才有资格对共享变量做修改，修改完成后就释放锁，那么其他的线程就可以再次来竞争同一个共享变量的锁来获取修改后的数据，从而完成线程之前的通信。</p><p>所以这也是为什么 wait&#x2F;notify 需要放在 Synchronized 同步代码块中的原因，有了 Synchronized 同步锁，就可以实现对多个通信线程之间的互斥，实现条件等待和条件唤醒。</p><h3 id="关键字与锁"><a href="#关键字与锁" class="headerlink" title="关键字与锁"></a>关键字与锁</h3><h4 id="类锁与对象锁的区别："><a href="#类锁与对象锁的区别：" class="headerlink" title="类锁与对象锁的区别："></a>类锁与对象锁的区别：</h4><h5 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a><strong>类锁</strong></h5><p>用synchronized修饰静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> method（）</span><br></pre></td></tr></table></figure><p>作用在代码块上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> method（）&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(object.class)&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类锁是加载类上的，而类信息是存在 JVM 方法区的，并且整个 JVM 只有一份，方法区又是所有线程共享的，所以类锁是所有线程共享的，所以同一时刻，只能有一个线程使用加了类锁的方法或方法体，不管是不是同一个实例。</p><h5 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h5><p>作用在实例方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> method（）&#123;&#125;</span><br></pre></td></tr></table></figure><p>作用在代码块上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> method（）&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">   <span class="comment">//这里是需要同步的部分</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用对象锁的情况，只有使用同一实例的线程才会受对象锁的影响，多个实例调用同一方法也不会受影响。</p><p><strong>类锁和对象锁不存在冲突</strong>，<strong>对象锁和类锁互不影响</strong>，可同时申请一个类的类锁、和该类某实例的对象锁</p><h4 id="说一下synchronized关键字底层原理"><a href="#说一下synchronized关键字底层原理" class="headerlink" title="说一下synchronized关键字底层原理"></a>说一下synchronized关键字底层原理</h4><p>synchronized的底层是通过monitor对象来实现的。</p><p>Java对象在内存中的布局大致可以分为三部分：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>填充对齐</strong>。因为<code>synchronized</code>用的锁是存在对象头里的，这里我们需要重点了解对象头。如果对象头是数组类型，则对象头由<strong>Mark Word</strong>、<strong>Class MetadataAddress</strong>和<strong>Array length</strong>组成，如果对象头非数组类型，对象头则由<strong>Mark Word</strong>和<strong>Class MetadataAddress</strong>组成。</p><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112246654.png" alt="image-20231003112246654"></p><p>monitor对象中有owner用来指示拥有锁的线程，entrylist来存放阻塞的线程（竞争失败的线程），waitSet来存放wating的线程（wait()方法），初始时，Monitor中的Owner为null，当第一个竞争锁的线程获得锁，其他的竞争这个锁的线程就会被放入EntryList等待，当获得锁的线程执行完同步代码块中的内容，就会唤醒EntryList中等待的线程，发生非公平竞争这个锁。<br>注意：<br>synchronized 必须是进入同一个对象的 monitor 才有上述的效果</p><p><strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p><p>上面的字节码中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 **对象监视器 <code>monitor</code>**（每个Java对象都可以关联一个monitor对象） 的持有权。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由[ObjectMonitoropen in new window](https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp)实现的。每个对象中都内置了一个 `ObjectMonitor`对象。</span><br><span class="line"></span><br><span class="line">另外，`wait/notify`等方法也依赖于`monitor`对象，这就是为什么只有在同步的块或者方法中才能调用`wait/notify`等方法，否则会抛出`java.lang.IllegalMonitorStateException`的异常的原因。</span><br></pre></td></tr></table></figure><p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112249933.png" alt="image-20231003112249933"></p><p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112256314.png" alt="image-20231003112256314"></p><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><h5 id="synchronized-修饰方法的的情况"><a href="#synchronized-修饰方法的的情况" class="headerlink" title="synchronized 修饰方法的的情况"></a>synchronized 修饰方法的的情况</h5><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p><p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p><h4 id="讲一讲AQS"><a href="#讲一讲AQS" class="headerlink" title="讲一讲AQS"></a>讲一讲AQS</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p><code>AbstractQueuedSynchronizer(AQS)</code>提供了一套可用于实现锁同步机制和其他同步组件的框架。<code>AQS通过一个</code>FIFO<code>队列维护线程同步状态，实现类只需要继承该类，并重写指定方法即可实现一套线程同步机制</code>。在JUC<code>中，诸如</code>ReentrantLock<code>、</code>CountDownLatch<code>等都基于</code>AQS&#96;实现。</p><p><code>AQS</code>根据资源互斥级别提供了<strong>独占和共享</strong>两种资源访问模式；同时其定义<code>Condition</code>结构提供了<code>wait/signal</code>等待唤醒机制。</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><code>AQS</code>维护了一个<code>volatile int state</code>变量（state &#x3D; 0 表示锁可用， state &#x3D;&gt; 1 表示锁已被占用）用来记录锁竞争的状态。</p><ul><li>一个线程来获得锁资源的时候首先会判断state是否等于0，如果是就把state更新为1，表示获得这个锁，为了防止多个线程同时更新state，AQS使用CAS保障state互斥变量更新的原子性。</li><li>未获得到锁的线程会阻塞，并按照先进先出的原则加入到双向链表中。</li></ul><p>当获得锁资源的线程释放锁后会从双向链表唤醒阻塞的线程。 </p><ul><li>AQS获取锁有公平竞争和非公平竞争，公平竞争就是在获取锁的时候，需要判断双向链表是否有阻塞的线程，如果有就需要去排队等待。 </li><li>非公平锁不管双向链表是否存在阻塞的线程，都会直接尝试更改state去获取锁。对于双向队列中阻塞的线程是不公平的</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112335241.png" alt="image-20231003112335241"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/e22dfb7003ee44afb6f80ddfbce68a93tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-1696303417939-13.webp" alt="img"></p><p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul><p><strong><code>Node</code>主要包含5个核心字段：</strong></p><ul><li><p>waitStatus</p><p>：当前节点状态，该字段共有5种取值：</p><ul><li><code>CANCELLED = 1</code>。节点引用线程由于等待超时或被打断时的状态。</li><li><code>SIGNAL = -1</code>。后继节点线程需要被唤醒时的当前节点状态。当队列中加入后继节点被挂起<code>(block)</code>时，其前驱节点会被设置为<code>SIGNAL</code>状态，表示该节点需要被唤醒。</li><li><code>CONDITION = -2</code>。当节点线程进入<code>condition</code>队列时的状态。(见<code>ConditionObject</code>)</li><li><code>PROPAGATE = -3</code>。仅在释放共享锁<code>releaseShared</code>时对头节点使用。(见共享锁分析)</li><li><code>0</code>。节点初始化时的状态。</li></ul></li><li><p><code>prev</code>：前驱节点。</p></li><li><p><code>next</code>：后继节点。</p></li><li><p><code>thread</code>：引用线程，头节点不包含线程。</p></li><li><p><code>nextWaiter</code>：<code>condition</code>条件队列。(见<code>ConditionObject</code>)</p></li></ul><h4 id="jdk1-7对synchorinzed的优化？"><a href="#jdk1-7对synchorinzed的优化？" class="headerlink" title="jdk1.7对synchorinzed的优化？"></a>jdk1.7对synchorinzed的优化？</h4><p>JDK1.6为了减少获得锁和释放锁所带来的性能消耗，引入了<strong>“偏向锁”</strong>和<strong>“轻量级锁”</strong>，所以在JDK1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。<strong>锁可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率</p><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁，顾名思义，它会偏向于第一个访问锁的线程</p><p>如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。线程第二次到达同步代码块时，会判断此时持有锁的线程是否就是自己，如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。<br>如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。<br>级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致<code>STW(stop the word)</code>操作</p><ul><li><h6 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h6><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象<br>的 Thread ID<br>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程</p></li><li><h6 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h6><p>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p></li></ul><h5 id="轻量级锁（还未关联monitor对象）"><a href="#轻量级锁（还未关联monitor对象）" class="headerlink" title="轻量级锁（还未关联monitor对象）"></a>轻量级锁（还未关联monitor对象）</h5><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以<br>使用轻量级锁来优化。当存在竞争时，锁膨胀升级为重量级锁来互斥访问。</p><p>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164622798.png" alt="image-20240322164622798"></p><p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164644569.png" alt="image-20240322164644569"></p><p>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164712066.png" alt="image-20240322164712066"></p><p>如果 cas 失败，有两种情况</p><ol><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li><li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li></ol><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164748554.png" alt="image-20240322164748554"></p><p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164814658.png" alt="image-20240322164814658"></p><p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</p><ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164905678.png" alt="image-20240322164905678"></p><p>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<strong>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</strong><br>然后自己进入 Monitor 的 EntryList BLOCKED</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164942030.png" alt="image-20240322164942030"></p><p>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁<br>流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</p><h5 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h5><p>重量级锁竞争的时候，如果竞争锁失败，该线程不会马上阻塞，使用自旋重试来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p><h4 id="Reentrantlock-与-synchronized-的区别"><a href="#Reentrantlock-与-synchronized-的区别" class="headerlink" title="Reentrantlock 与 synchronized 的区别"></a>Reentrantlock 与 synchronized 的区别</h4><p>Synchronized 可以通过两种方式来控制锁的粒度</p><ul><li>一种是把 synchronized 关键字修饰在方法层面，</li><li>另一种是修饰在代码块上，并且我们可以通过 Synchronized 加锁对象的声明周期来控制锁的作用范围，比如锁对象是静态对象或者类对象，那么这个锁就是全局锁。如果锁对象是普通实例对象，那这个锁的范围取决于这个实例的声明周期。</li></ul><p>Lock 锁的粒度是通过它里面提供的 lock()和 unlock()方法决定的（贴图），包裹在这两个方法之间的代码能够保证线程安全性。而锁的作用域取决于 Lock 实例的生命周期</p><p>相对于 synchronized 它具备如下特点</p><ul><li><strong>可以设置超时时间</strong>， Lock 还提供了非阻塞的竞争锁方法 tryLock(int time)方法，在规定时间获取不到锁会返回false</li><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li><li><strong>可实现选择性通知（支持多个条件变量）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul><p>与 synchronized 一样，都支持可重入</p><h4 id="公平锁与非公平锁？底层实现是什么"><a href="#公平锁与非公平锁？底层实现是什么" class="headerlink" title="公平锁与非公平锁？底层实现是什么"></a>公平锁与非公平锁？底层实现是什么</h4><p>底层都是AQS，默认一般使用<strong>非公平锁</strong>，它的效率和吞吐量都比公平锁高的多。由于公平锁需要关心队列的情况，得按照队列里的先后顺序来获取锁(会造成大量的线程上下文切换)，而非公平锁则没有这个限制。所以也就能解释非公平锁的效率会被公平锁更高。</p><p><strong>公平锁</strong>：</p><p>线程在tryAcquire（arg）尝试获得锁之前会利用 hasQueuedPredecessors() 方法来判断 AQS 的队列中中是否有其他线程，如果有则不会尝试获取锁(<strong>这是公平锁特有的情况</strong>)。</p><p>如果队列中没有线程就利用 CAS 来将 AQS 中的 state 修改为1，也就是获取锁，获取成功则将当前线程置为获得锁的独占线程(setExclusiveOwnerThread(current))。</p><p>如果 state 大于 0 时，说明锁已经被获取了，则需要判断获取锁的线程是否为当前线程(ReentrantLock 支持重入)，是则需要将 state + 1，并将值更新。</p><p>如果tryAcquire(arg) 获取锁失败，则需要用 addWaiter(Node.EXCLUSIVE) 将当前线程写入队列中。</p><p>写入之前需要将当前线程包装为一个 Node 对象(addWaiter(Node.EXCLUSIVE))，通过自旋加上 CAS 保证一定能写入队列。</p><p><strong>非公平锁</strong>：尝试获取锁时tryAcquire(arg)，非公平锁是不需要判断队列中是否还有其他线程，也是直接尝试获取锁：</p><h4 id="可中断锁和不可中断锁有什么区别？"><a href="#可中断锁和不可中断锁有什么区别？" class="headerlink" title="可中断锁和不可中断锁有什么区别？"></a>可中断锁和不可中断锁有什么区别？</h4><ul><li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li><li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁</li></ul><h4 id="volatile关键字的原理？怎么用？是否保证原子性？"><a href="#volatile关键字的原理？怎么用？是否保证原子性？" class="headerlink" title="volatile关键字的原理？怎么用？是否保证原子性？"></a>volatile关键字的原理？怎么用？是否保证原子性？</h4><p>由于JVM缓存优化，线程读变量值时，可能会到自己的工作缓存去读而不是到内存，所以当一个线程对变量执行写操作到内存，可能其他线程无法读到最新的变量值。</p><p>用法：在多线程读，一线程写的情况下，用来修饰成员变量和静态成员变量，这就指示 JVM，这个变量是共享且不稳定的，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。</p><h5 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112310433.png" alt="image-20231003112310433"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112313979.png" alt="image-20231003112313979"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112317775.png" alt="image-20231003112317775"></p><p>Volatile关键字底层实现主要是<strong>通过汇编lock指令</strong>，当某个CPU修改了缓存里面的数据，该数据会马上通过总线同步回主存，（lock指令开启其他CPU的总线嗅探机制）其他CPU通过一个<strong>总线嗅探机制</strong>来感知数据的变化从而将自己缓存里面的数据失效，需要使用这个数据，必须重新去内存中获取最新的数据，来保证数据的可见性。</p><h5 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h5><p>当对volatile修饰变量赋值，会加上写屏障，写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当对volatile修饰变量取值，会加上读屏障，读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不能解决指令交错（无法保证原子性）："><a href="#不能解决指令交错（无法保证原子性）：" class="headerlink" title="不能解决指令交错（无法保证原子性）："></a>不能解决指令交错（无法保证原子性）：</h5><p>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去<br>而有序性的保证也只是保证了本线程内相关代码不被重排序</p><h4 id="synchronized关键字保证可见性和有序性"><a href="#synchronized关键字保证可见性和有序性" class="headerlink" title="synchronized关键字保证可见性和有序性"></a>synchronized关键字保证可见性和有序性</h4><p>我们都知道sychronized底层是通过monitorenter的指令来进行加锁的、通过monitorexit指令来释放锁的。</p><p>但是很多人都不知道的一点是，monitorenter指令其实还具有Load屏障的作用。</p><p>也就是通过monitorenter指令之后，synchronized内部的共享变量，每次读取数据的时候被强制从主内存读取最新的数据。</p><p>同样的道理monitorexit指令也具有Store屏障的作用，也就是让synchronized代码块内的共享变量，如果数据有变更的，强制刷新回主内存。</p><p>这样通过这种方式，数据修改之后立即刷新回主内存，其他线程进入synchronized代码块后，使用共享变量的时候强制读取主内存的数据，上一个线程对共享变量的变更操作，它就能立即看到了。</p><p>同时synchronized加的内存屏障也能保证内部代码的有序性</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112322766.png" alt="image-20231003112322766"></p><h4 id="为什么单线程不需要这个volatile关键字多线程需要"><a href="#为什么单线程不需要这个volatile关键字多线程需要" class="headerlink" title="为什么单线程不需要这个volatile关键字多线程需要"></a>为什么单线程不需要这个volatile关键字多线程需要</h4><p>因为在单线程的环境下，只有一个线程会使用修改的变量，变量不存在可见性问题。同时，单线程下，JVM的指令重排序也不会改变执行结果。</p><h4 id="为什么会出现指令重排序："><a href="#为什么会出现指令重排序：" class="headerlink" title="为什么会出现指令重排序："></a>为什么会出现指令重排序：</h4><p>指令还可以再划分成一个个更小的阶段，在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行，从而提高CPU的吞吐率。</p><h4 id="讲一下CAS"><a href="#讲一下CAS" class="headerlink" title="讲一下CAS"></a>讲一下CAS</h4><p>CAS（Compare And Swap）是一种无锁同步机制，基于乐观锁的思想，但是它底层还是有用到锁的，使用总线锁锁住总线，确保在比较替换的过程中没有其他线程对该值进行修改，保障比较并替换的原子性。</p><p><strong>CAS 必须借助 volatile</strong> 才能读取到共享变量的最新值来实现【比较并交换】的效果</p><p>CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。</p><p>CAS指令执行时，通过发送一个lock指令锁住总线，确保整个比较并替换的操作是一个原子操作。<strong>当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则放弃对数据的操作。</strong></p><p>cas可以不用自旋重试机制，失败也可以直接返回false。只是一般应用场景下，cas都会带有重试机制（while和for实现空转，不断尝试）</p><h5 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h5><ul><li>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、竞争较少，多核 CPU 的场景下。</li><li>CAS 是基于乐观锁的思想：最乐观的估计，预计很少出现并发问题，当出现后，再重试。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，当一个线程上了锁，其他线程只能阻塞等待解锁。使得线程只能串行访问同步代码块，效率较低。</li><li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思</li><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到CAS自旋重试必然频繁发生，反而效率会受影响</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p><strong>CAS长时间自旋开销很大：</strong>我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</p><p><strong>只能保证一个共享变量的原子操作：</strong>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p><p><strong>ABA*问题</strong>：<strong>通过版本号法解决。</strong>Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p><h5 id="用处："><a href="#用处：" class="headerlink" title="用处："></a>用处：</h5><p>Automic原子类，多线程的互斥同步等</p><h4 id="乐观锁和悲观锁的区别？"><a href="#乐观锁和悲观锁的区别？" class="headerlink" title="乐观锁和悲观锁的区别？"></a>乐观锁和悲观锁的区别？</h4><h5 id="什么悲观锁？"><a href="#什么悲观锁？" class="headerlink" title="什么悲观锁？"></a><strong>什么悲观锁？</strong></h5><p>悲观锁是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;</p><p>特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p><h5 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a><strong>什么是乐观锁？</strong></h5><p>乐观锁是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);</p><p>特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。</p><h5 id="理论上来说："><a href="#理论上来说：" class="headerlink" title="理论上来说："></a>理论上来说：</h5><ul><li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li><li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li></ul><h4 id="ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？"><a href="#ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？" class="headerlink" title="ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？"></a>ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112342131.png" alt="image-20231003112342131"></p><p>threadLocal 是一个用来解决线程安全性问题的工具。它相当于让每个线程都开辟一块内存空间，用来存储共享变量的副本。<br>然后每个线程只需要访问和操作自己的共享变量副本即可，从而避免多线程竞争同一个共享资源。<br>它的工作原理很简单（如图）</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112345346.png" alt="image-20231003112345346"></p><p>每个线程里面有一个成员变量 ThreadLocalMap,<br>当线程访问用 ThreadLocal 修饰的共享数据的时候<br>这个线程就会在自己成员变量 ThreadLocalMap 里面保存一份数据副本。<br>key 指向 ThreadLocal 这个引用，并且是弱引用关系，而 value 保存的是共享数据的副本。<br>因为每个线程都持有一个副本，所以就解决了线程安全性问题。</p><p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用<strong>弱引用</strong>的ThreadLocal实例，value为线程变量的副本。这些对象之间的引用关系如下,</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112348542.png" alt="image-20231003112348542"></p><blockquote><p>实心箭头表示强引用，空心箭头表示弱引用</p></blockquote><h5 id="ThreadLocal-内存泄漏的原因"><a href="#ThreadLocal-内存泄漏的原因" class="headerlink" title="ThreadLocal 内存泄漏的原因"></a>ThreadLocal 内存泄漏的原因</h5><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>由于Thread中包含变量ThreadLocalMap，因此ThreadLocalMap与Thread的生命周期是一样长，如果都没有手动删除对应key，都会导致内存泄漏。</p><p>但是使用<strong>弱引用</strong>可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set(),get(),remove()的时候会被清除。</p><p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p><h5 id="ThreadLocal正确的使用方法"><a href="#ThreadLocal正确的使用方法" class="headerlink" title="ThreadLocal正确的使用方法"></a>ThreadLocal正确的使用方法</h5><ul><li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li><li>(将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 )</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="单核-CPU-上运行多个线程效率一定会高吗？"><a href="#单核-CPU-上运行多个线程效率一定会高吗？" class="headerlink" title="单核 CPU 上运行多个线程效率一定会高吗？"></a>单核 CPU 上运行多个线程效率一定会高吗？</h4><p>单核CPU同时运行多个线程的效率是否会高，取决于线程的类型和任务的性质。两种类型的线程：CPU密集型和IO密集型。</p><ul><li>CPU密集型的线程主要进行计算和逻辑处理，需要占用大量的CPU资源。</li><li>IO密集型的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待IO设备的响应，而不占用太多的CPU资源。</li></ul><p>在单核CPU上，同一时刻只能有一个线程在运行，其他线程需要等待CPU的时间片分配。如果线程是CPU密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。</p><p>如果线程是IO密集型的，那么多个线程同时运行可以利用CPU在等待IO时的空闲时间，提高了效率。</p><p>因此，对于单核CPU来说，如果任务是CPU密集型的，那么开很多线程会影响效率；如果任务是IO密集型的，那么开很多线程会提高效率。当然，这里的“很多”也要适度，不能超过系统能够承受的上限。</p><h4 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h4 id="线程池的缺点"><a href="#线程池的缺点" class="headerlink" title="线程池的缺点"></a>线程池的缺点</h4><ul><li>可能引发死锁：在使用线程池时，如果任务之间存在依赖关系，或者线程因为资源的竞争，可能会引发死锁问题，需要额外的注意和处理。</li><li>不能对于线程池中任务设置优先级，只能按照先来先服务的策略</li><li><strong>难以调试</strong>: 线程池中的线程是由线程池管理的，因此在出现问题时，很难追踪和调试特定的线程。这可能会增加故障排除的难度。</li></ul><h4 id="线程池的拒绝策略有哪些？"><a href="#线程池的拒绝策略有哪些？" class="headerlink" title="线程池的拒绝策略有哪些？"></a>线程池的拒绝策略有哪些？</h4><p>若线程池中的核心线程数被用完且阻塞队列已排满，则此时线程池的资源已耗尽，线程池将没有足够的线程资源执行新的任务。为了保证操作系统的安全，线程池将通过拒绝策略处理新添加的线程任务。</p><h5 id="1-AbortPolicy（默认策略）"><a href="#1-AbortPolicy（默认策略）" class="headerlink" title="1. AbortPolicy（默认策略）"></a><strong>1. AbortPolicy</strong>（默认策略）</h5><p>第一种拒绝策略是 <code>AbortPolicy</code>，这种拒绝策略在拒绝任务时，会直接抛出一个类型为 RejectedExecutionException的RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。</p><h5 id="2-DiscardPolicy"><a href="#2-DiscardPolicy" class="headerlink" title="2.DiscardPolicy"></a><strong>2.DiscardPolicy</strong></h5><p>第2种拒绝策略是 <code>DiscardPolicy</code>，这种拒绝策略正如它的名字所描述的一样，当新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失。</p><h5 id="3-DiscardOldestPolicy"><a href="#3-DiscardOldestPolicy" class="headerlink" title="3.DiscardOldestPolicy"></a><strong>3.DiscardOldestPolicy</strong></h5><p>第3种拒绝策略是 <code>DiscardOldestPolicy</code>，如果线程池没被关闭且没有能力执行，则会丢弃任务队列中的头结点，通常是存活时间最长的任务，这种策略与第二种不同之处在于它丢弃的不是最新提交的，而是队列中存活时间最长的，这样就可以腾出空间给新提交的任务，但同理它也存在一定的数据丢失风险。</p><h5 id="4-CallerRunsPolicy"><a href="#4-CallerRunsPolicy" class="headerlink" title="4.CallerRunsPolicy"></a><strong>4.CallerRunsPolicy</strong></h5><p>第4种拒绝策略是 CallerRunsPolicy，相对而言它就比较完善了，当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。这样做主要有两点好处。</p><ol><li>第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。</li><li>第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。</li></ol><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>本文中我们学习线程池中的4 种默认的拒绝策略。线程池会在以下两种情况下会拒绝新提交的任务。</p><ul><li>第一种情况是当我们调用 shutdown 等方法关闭线程池后，即便此时可能线程池内部依然有没执行完的任务正在执行，但是由于线程池已经关闭，此时如果再向线程池内提交任务，就会遭到拒绝。</li><li>第二种情况是线程池没有能力继续处理新提交的任务，也就是工作已经非常饱和的时候。</li></ul><p>线程池状态</p><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112330381.png" alt="image-20231003112330381"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c 为旧值， ctlOf 返回结果为新值</span></span><br><span class="line">ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));</span><br><span class="line"><span class="comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><h4 id="Excetors工具类提供了哪些线程池？有什么问题吗？"><a href="#Excetors工具类提供了哪些线程池？有什么问题吗？" class="headerlink" title="Excetors工具类提供了哪些线程池？有什么问题吗？"></a>Excetors工具类提供了哪些线程池？有什么问题吗？</h4><p>四种阻塞队列</p><p>*<strong>基于数组的先进先出队列，有界</strong></p><ul><li>new ArrayBlockingQueue&lt;&gt;(10)</li></ul><p>生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行</p><p><strong>由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列</strong></p><ul><li>new LinkedBlockingQueue&lt;&gt;()</li></ul><p>生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p><p><strong>无缓冲的等待队列，无界</strong></p><ul><li>new SynchronousQueue&lt;&gt;()</li></ul><p>不存储元素的阻塞队列，也即单个元素的队列。</p><p><strong>使用优先级队列实现的延迟无界阻塞队列。</strong></p><p>new DelayQueue&lt;&gt;()<br>DelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p><p>Executors中创建线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Executors</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建固定数量线程的线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这是最后一个参数--阻塞队列调用的方法，长度是Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     * public LinkedBlockingQueue() &#123;</span></span><br><span class="line"><span class="comment">     *    this(Integer.MAX_VALUE);</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建只有一个线程的线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这是最后一个参数--阻塞队列调用的方法，长度也是Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     * public LinkedBlockingQueue() &#123;</span></span><br><span class="line"><span class="comment">     *    this(Integer.MAX_VALUE);</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created single-threaded Executor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *创建一个缓冲线程池 </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这是最后一个参数--阻塞队列调用的方法</span></span><br><span class="line"><span class="comment">     * public SynchronousQueue() &#123;</span></span><br><span class="line"><span class="comment">     *    this(false);</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 它的第二个参数，maximumPoolSize 为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a thread pool that can schedule commands to run after a</span></span><br><span class="line"><span class="comment">     * given delay, or to execute periodically.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 创建一个可以在给定延迟后再执行或定期执行命令的线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ScheduledThreadPoolExecutor 是 ThreadPoolExecutor 的子类，代码如下：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor</span></span><br><span class="line"><span class="comment">        implements ScheduledExecutorService &#123;</span></span><br><span class="line"><span class="comment">            //这是下面调用的构造方法，其实是调用了父类的构造方法,这些参数都是下面分析的参数</span></span><br><span class="line"><span class="comment">            public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span></span><br><span class="line"><span class="comment">               super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span></span><br><span class="line"><span class="comment">               new DelayedWorkQueue());</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FixedThreadPool 和 SingleThreadExecutor 传入的最后一个参数阻塞队列 ”workQueue“，默认的长度是INTEGER.MAX_VALUE，而它们允许的最大线程数量又是有限的，所以当请求线程的任务过多线程不够用时，它们会在队列中等待，又因为队列的长度特别长，所以可能会堆积大量的请求，导致OOM。</p><p>CachedThreadPool 和 ScheduledThreadPool 它们的阻塞队列长度有限，但是传入的第二个参数maximumPoolSize 为Integer.MAX_VALUE，这就意味着当请求线程的任务过多线程不够而且队列也满了的时候，线程池就会创建新的线程，因为它允许的最大线程数量是相当大的，所以可能会创建大量线程，导致OOM。</p><p>Executors类中封装好的创建线程池的方法使用方便，但是也有其局限性和风险性，所以我们可以使用 ThreadPoolExecutor 类中的构造方法手动创建线程池的实例， 从而可以根据我们的使用情况来指定参数，满足使用的同时又能规避风险。<br>所以，说白了，使用Executors类创建线程池与使用ThreadPoolExecutor类的区别就是使用ThreadPoolExecutor类可以自定义传入我们设置的线程池的参数，更加灵活。</p><h4 id="线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列"><a href="#线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列" class="headerlink" title="线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列"></a>线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列</h4><ul><li><h5 id="corePoolSize-核心线程数目-正常情况下最多保留的线程数"><a href="#corePoolSize-核心线程数目-正常情况下最多保留的线程数" class="headerlink" title="corePoolSize 核心线程数目 (正常情况下最多保留的线程数)"></a>corePoolSize 核心线程数目 (正常情况下最多保留的线程数)</h5></li></ul><p>线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。任务提交到线程池后，首先会检查当前线程数是否达到了corePoolSize，如果没有达到的话，则会创建一个新线程来处理这个任务。</p><ul><li><h5 id="maximumPoolSize-最大线程数目"><a href="#maximumPoolSize-最大线程数目" class="headerlink" title="maximumPoolSize 最大线程数目"></a>maximumPoolSize 最大线程数目</h5></li></ul><p>当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务缓存到工作队列（后面会介绍）中。如果队列也已满，则会去创建一个新线程来出来这个处理。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即maximunPoolSize指定</p><ul><li><h5 id="keepAliveTime-生存时间-针对救急线程，当没有任务一段时间会被销毁"><a href="#keepAliveTime-生存时间-针对救急线程，当没有任务一段时间会被销毁" class="headerlink" title="keepAliveTime 生存时间 - 针对救急线程，当没有任务一段时间会被销毁"></a>keepAliveTime 生存时间 - 针对救急线程，当没有任务一段时间会被销毁</h5></li></ul><p>线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 <code>corePoolSize</code> ，回收过程才会停止。</p><ul><li><h5 id="unit-时间单位-针对多余空闲线程，-救急线程存活时间单位"><a href="#unit-时间单位-针对多余空闲线程，-救急线程存活时间单位" class="headerlink" title="unit 时间单位 - 针对多余空闲线程， 救急线程存活时间单位"></a>unit 时间单位 - 针对多余空闲线程， 救急线程存活时间单位</h5></li><li><h5 id="workQueue-阻塞队列"><a href="#workQueue-阻塞队列" class="headerlink" title="workQueue 阻塞队列"></a>workQueue 阻塞队列</h5></li></ul><p>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程</p><ul><li><h5 id="threadFactory-线程工厂-可以为线程创建时起个好名字"><a href="#threadFactory-线程工厂-可以为线程创建时起个好名字" class="headerlink" title="threadFactory 线程工厂 - 可以为线程创建时起个好名字"></a>threadFactory 线程工厂 - 可以为线程创建时起个好名字</h5></li></ul><p>创建一个新线程时使用的工厂，可以用来<strong>设定线程名、是否为daemon（守护线程）线程</strong>等等</p><ul><li><h5 id="handler-拒绝策略"><a href="#handler-拒绝策略" class="headerlink" title="handler 拒绝策略"></a>handler 拒绝策略</h5></li></ul><p>当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，就会采用拒绝策略</p><h4 id="为什么线程池创建新线程需要获取全局锁？"><a href="#为什么线程池创建新线程需要获取全局锁？" class="headerlink" title="为什么线程池创建新线程需要获取全局锁？"></a>为什么线程池创建新线程需要获取全局锁？</h4><ol><li><strong>线程池的状态管理</strong>：线程池需要跟踪已创建的线程数、空闲线程数、正在运行的任务等状态信息。这些状态信息需要在多线程环境下进行更新和访问，因此需要使用全局锁来确保状态的一致性，防止多个线程同时修改状态信息导致的竞态条件。</li><li><strong>线程资源管理</strong>：线程池通常会限制创建的线程数量，以避免因为创建过多线程导致系统资源耗尽或者性能下降。因此，在创建新线程之前需要检查当前已创建的线程数量，这涉及到对线程池状态的读取和更新，需要使用全局锁来确保一致性。</li></ol><h4 id="execute源码步骤"><a href="#execute源码步骤" class="headerlink" title="execute源码步骤"></a>execute源码步骤</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-c2f64c062ff28d9ca7b37a2624367fb3_1440w.webp" alt="img"></p><p>从上图可以把execute方法主要分三个步骤：</p><ul><li>首先如果当前工作线程数小于核心线程，则调用addWorker(command, true)方法创建核心线程执行任务。</li><li>其次如果当前线程大于核心线程数则判断等待队列是否已满，如果没有满则添加任务到等待队列中去，如果工作线程数量为0则调用addWorker(null, false)方法创建非核心线程，并从等待队列中拉取任务执行。</li><li>最后如果队列已满则会调用addWorker(command, false)方法创建一个非核心线程执行任务。如果创建失败则会拒绝任务。</li></ul><p><strong>简单来说就是优先核心线程，其次等待队列，最后非核心线程。</strong></p><h5 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h5><p><strong>可以看到execute中最关键的就是addWorker方法</strong>，它接受两个参数：</p><ul><li>第一个参数是要执行的任务，如果为null那么会从等待队列中拉取任务；</li><li>第二个参数是表示是否核心线程，用来控制addWorker方法流程的；</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-757aff298fc6e148b609037749de418c_1440w.webp" alt="img"></p><p>流程中去除一些异常情况，只留了主要流程，流程中有一步验证线程数大于核心线程或者最大线程数</p><ul><li>如果传递的参数core等于true那么运行线程数量不能大于核心线程数量，</li><li>如果为false则当前线程数量不能大于最大线程数。</li></ul><p><strong>addWorker只有两个作用：增加工作线程数量、创建一个Worker并加到工作线程集合中。</strong></p><h5 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h5><p>Worker类就是线程池中执行任务的类，主要源码和解释如下图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-19a9c0570d56fb82d57680103305496d_1440w.webp" alt="img"></p><p>所以Worker本身就是一个Runnable，它有两个属性thead、firstTask；那我们就可以来梳理一下整体的运行流程了：</p><p><strong>线程池调用execute</strong>—&gt;<strong>创建Worker（设置属性thead、firstTask）</strong>—&gt;**worker.thread.start()**—&gt;**实际上调用的是worker.run()**—&gt;**线程池的runWorker(worker)**—&gt;<strong>worker.firstTask.run()</strong>(如果firstTask为null就从等待队列中拉取一个)。</p><p>转了一大圈最终调用最开始传进来的任务的run方法，不过通过等待队列可以重复利用worker与worker中的线程，变化的只是firstTask；</p><h4 id="submit和execute的区别"><a href="#submit和execute的区别" class="headerlink" title="submit和execute的区别:"></a>submit和execute的区别:</h4><p><font color = gold>execute和submit最大的区别就是execute没有返回值，submit有返回值。submit返回的是一个future ，可以通过这个future取到线程执行的结果或者异常信息。</font></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/637fd0fa146c4bb4be2e6cbaefb9bc6ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="图片"></p><p>submit不打印异常信息，而execute则会打印异常信息！，submit的方式不打印异常信息，显然在生产中，是不可行的，因为我们无法保证线程中的任务永不异常，而如果使用submit的方式出现了异常，直接如上写法，我们将无法获取到异常信息，做出对应的判断和处理，所以下一步需要知道如何获取线程池抛出的异常！</p><p><code>submit()</code>想要获取异常信息就必须使用<code>get()</code>方法！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当线程池抛出异常后 submit无提示，其他线程继续执行</span></span><br><span class="line">Future&lt;?&gt; submit = executorService.submit(<span class="keyword">new</span> <span class="title class_">task</span>());</span><br><span class="line">submit.get();</span><br></pre></td></tr></table></figure><p>submit打印异常信息如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/4cdc421e484c4468ab052ff82c500a39tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="图片"></p><p>submit源码在底层还是调用的execute方法，只不过多一层Future封装，并返回了这个Future，这也解释了为什么submit会有返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//submit()方法</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//execute内部执行这个对象内部的逻辑，然后将结果或者异常 set到这个ftask里面</span></span><br><span class="line">     RunnableFuture&lt;T&gt; ftask = newTaskFor(task); </span><br><span class="line">     <span class="comment">// 执行execute方法</span></span><br><span class="line">     execute(ftask); </span><br><span class="line">     <span class="comment">//返回这个ftask</span></span><br><span class="line">     <span class="keyword">return</span> ftask;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>如果用execute提交的任务，会被封装成了一个runable任务，然后进去 再被封装成一个worker,最后在worker的run方法里面调用runWoker方法， <code>runWoker</code>方法里面执行任务任务，如果任务出现异常，用<code>try-catch</code>捕获异常往外面抛，我们在最外层使用<code>try-catch</code>捕获到了 <code>runWoker</code>方法中抛出的异常。因此我们在execute中看到了我们的任务的异常信息。</li><li><font color = gold>submit是将任务封装成了一个<code>futureTask</code></font> ，然后这个<code>futureTask</code>被封装成worker，在woker的run方法里面，最终调用的是<code>futureTask</code>的run方法， 里面是直接吞掉了异常，并没有抛出异常，因此在worker的<code>runWorker</code>方法里面无法捕获到异常。</li></ul><p>下面来看一下<code>futureTask</code>的run方法，在try-catch中吞掉了异常，将异常放到了 <code>setException(ex);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">         !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                      <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Callable&lt;V&gt; c = callable;</span><br><span class="line">         <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">             V result;</span><br><span class="line">             <span class="type">boolean</span> ran;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 result = c.call();</span><br><span class="line">                 ran = <span class="literal">true</span>;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                 result = <span class="literal">null</span>;</span><br><span class="line">                 ran = <span class="literal">false</span>;</span><br><span class="line">                 <span class="comment">//在此方法中设置了异常信息</span></span><br><span class="line">                 setException(ex);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (ran)</span><br><span class="line">                 set(result);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//省略下文</span></span><br><span class="line">         。。。。。</span><br><span class="line">        <span class="comment">//setException(ex)`方法如下：将异常对象赋予`outcome</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setException</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">//将异常对象赋予outcome，记住这个outcome，</span></span><br><span class="line">           outcome = t;</span><br><span class="line">           UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">           finishCompletion();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>将异常对象赋予<code>outcome</code>有什么用呢？这个<code>outcome</code>是什么呢？当我们使用submit返回Future对象，并使用<code>Future.get()</code>时， 会调用内部的report方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="comment">//注意这个方法</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reoport里面实际上返回的是outcome ,刚好之前的异常就set到了这个outcome里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException &#123;</span><br><span class="line"> <span class="comment">//设置`outcome`</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">     <span class="comment">//返回`outcome`</span></span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color = gold>因此，在用submit提交的时候，runable对象被封装成了future ，future 里面的 run方法在处理异常时， <code>try-catch</code>了所有的异常，通过<code>setException(ex);</code>方法设置到了变量outcome里面， 可以通过<code>future.get</code>获取到outcome。</font></p><p><strong>在submit提交的时候，里面发生了异常， 是不会有任何抛出信息的。而通过<code>future.get（）</code>可以获取到submit抛出的异常！</strong>在submit里面，除了从返回结果里面取到异常之外, 没有其他方法。因此，在不需要返回结果的情况下，<strong>最好用execute ，这样就算没有写<code>try-catch</code>，疏漏了异常捕捉，也不至于丢掉异常信息</strong>。</p><h5 id="解决异常："><a href="#解决异常：" class="headerlink" title="解决异常："></a>解决异常：</h5><p><strong>方案一：在run()方法中使用 try -catch</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">ThreadPoolException</span> &#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个线程池</span></span><br><span class="line">        <span class="title class_">ExecutorService</span> executorService = <span class="title class_">Executors</span>.<span class="title function_">newFixedThreadPool</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当线程池抛出异常后 submit无提示，其他线程继续执行</span></span><br><span class="line">        executorService.<span class="title function_">submit</span>(<span class="keyword">new</span> <span class="title function_">task</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当线程池抛出异常后 execute抛出异常，其他线程继续执行新任务</span></span><br><span class="line">        executorService.<span class="title function_">execute</span>(<span class="keyword">new</span> <span class="title function_">task</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">task</span> implements <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;进入了task方法！！！&quot;</span>);</span><br><span class="line">            int i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) &#123;</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;使用了try -catch 捕获异常&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/52929d67d8707f0909d7b9c3125cf590.png" alt="img"></p><p>可以看到 submit 和 execute都清晰易懂的捕获到了异常，可以知道我们的任务出现了问题，而不是消失的无影无踪。</p><p><strong>实现 ThreadFactory，自定义线程工厂类（推荐）</strong></p><p>第一种方法需要我们在每个任务中手动添加 try-catch 代码块，这样做非常繁琐且不可靠。为了避免重复工作，我们可以通过自定义线程工厂类来实现。线程池创建工作线程时会使用 ThreadFactory 的实现类来创建线程，因此我们只需要实现 ThreadFactory 接口，自定义线程工厂类，并将其传递给创建线程池的构造方法中。</p><p>自定义线程工厂方法，为每一个 run 方法添加 try-catch 代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">poolNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    CustomThreadFactory() &#123;</span><br><span class="line">        namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                poolNumber.getAndIncrement() +</span><br><span class="line">                <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, namePrefix + threadNumber.getAndIncrement()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">super</span>.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;异常信息：&quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color = gold>当使用 submit 方法提交的任务出现异常时，仍然无法进行处理,因为在run()方法中出现异常被内部捕获了，但至少解决了在 execute 方法中任务出现异常的情况。对于 FutureTask 的异常，调用方需要自行处理，因为 FutureTask 设计的本意就是将结果交给调用方处理，这个结果也包含异常。</font></p><h4 id="为什么核心线程池满了后-不直接创建新的线程去执行新任务？而是先交给任务队列呢？"><a href="#为什么核心线程池满了后-不直接创建新的线程去执行新任务？而是先交给任务队列呢？" class="headerlink" title="为什么核心线程池满了后 不直接创建新的线程去执行新任务？而是先交给任务队列呢？"></a>为什么核心线程池满了后 不直接创建新的线程去执行新任务？而是先交给任务队列呢？</h4><p><strong>因为如果核心线程满了就创建新的线程去执行，达到最大线程数之后再放入队列，那么新创建线程就需要获取全局锁，对性能有很大的损耗。</strong>而且如果正在被核心线程执行的任务很快的执行完，就可以直接从任务队列中取出新的任务执行。</p><p>ThreadPoolExecutor 采取上述步 骤 的 总 体 设计 思路，是 为 了在 执 行 execute() 方法时，尽可能地避免获取全局锁 （创建新的线程需要先获取全局锁、销毁线程也需要获取全局锁mainLock）。而从阻塞队列中取任务来执行不需要获取全局锁</p><p> <img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/8477e7c513404fcfa6aa2c57dc335019.png" alt="img"></p><h4 id="阻塞队列的作用是什么"><a href="#阻塞队列的作用是什么" class="headerlink" title="阻塞队列的作用是什么"></a>阻塞队列的作用是什么</h4><ul><li>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使线程进入wait状态，释放CPU资源</li><li>阻塞队列自带阻塞和唤醒的功能，不需要额外处理，无任务执行时，线程池利用阻塞队列的take方法挂起，从而维持核心线程的存活，不至于一直占的CPU资源</li></ul><h4 id="使用阻塞队列需要注意什么"><a href="#使用阻塞队列需要注意什么" class="headerlink" title="使用阻塞队列需要注意什么"></a>使用阻塞队列需要注意什么</h4><ol><li><strong>异常处理</strong>：在使用阻塞队列时，需要注意异常处理机制。例如，在使用有界阻塞队列时，如果队列已满而无法接受新任务，可能会触发拒绝策略，需要合理处理拒绝策略以防止任务丢失。</li><li><strong>选择合适的阻塞队列类型</strong>：Java 提供了多种阻塞队列实现，如 <code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>PriorityBlockingQueue</code> 等。选择合适的队列类型需要考虑线程池的特性、任务处理情况以及性能需求。</li><li><strong>队列容量设置</strong>：阻塞队列的容量设置需要根据系统负载和任务处理速度进行合理的调整。如果任务处理速度远快于任务提交速度，可能会导致队列溢出，从而触发拒绝策略。因此，需要根据具体情况设置合适的队列容量。</li></ol><h4 id="创建多少核心线程数合适（线程池的参数怎么设计）"><a href="#创建多少核心线程数合适（线程池的参数怎么设计）" class="headerlink" title="创建多少核心线程数合适（线程池的参数怎么设计）"></a>创建多少核心线程数合适（线程池的参数怎么设计）</h4><ul><li>过小会导致程序不能充分地利用系统资源、容易导致饥饿</li><li>过大会导致更多的线程上下文切换，占用更多内存</li></ul><h5 id="CPU-密集型运算"><a href="#CPU-密集型运算" class="headerlink" title="CPU 密集型运算"></a>CPU 密集型运算</h5><p>通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p><h5 id="I-O-密集型运算"><a href="#I-O-密集型运算" class="headerlink" title="I&#x2F;O 密集型运算"></a>I&#x2F;O 密集型运算</h5><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。<br>经验公式如下</p><p>线程数 &#x3D; 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) &#x2F; CPU 计算时间</p><p>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式</p><p>4 * 100% * 100% &#x2F; 50% &#x3D; 8</p><p>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式</p><p>4 * 100% * 100% &#x2F; 10% &#x3D; 40</p><p><strong>公示也只是参考，具体还是要根据项目实际线上运行情况来动态调整</strong>，包括核心线程数、最大线程数、自定义任务队列等等</p><h4 id="假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？"><a href="#假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？" class="headerlink" title="假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？"></a>假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？</h4><ul><li>高并发低延迟业务，低延迟说明大概率是CPU密集型，高并发的情况下为了防止大量的上下文切换，核心线程数不宜设置太高，应该设置大概CPU核数 + 1个线程，</li><li>低并发高延迟业务，高延迟说明所需数据或外部资源需要较长时间等待，大概率是IO密集型，核心线程数应该设置为    CPU 核数 * 总时间(CPU计算时间+等待时间) &#x2F; CPU 计算时间</li></ul><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><h4 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h4><h5 id="LongAdder的成员变量"><a href="#LongAdder的成员变量" class="headerlink" title="LongAdder的成员变量"></a><strong>LongAdder的成员变量</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPU的数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">// Cell对象的数组，长度一般是2的指数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="comment">// 基础value值，当并发较低时，只累加该值</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"><span class="comment">// 创建或者扩容Cells数组时使用的自旋锁变量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br></pre></td></tr></table></figure><p>当并发量较少时，cell数组尚未初始化，所以只调用<code>casBase</code>函数，对base变量进行CAS累加。</p><p>并发量大时，放弃使用base变量，而是从cells数组中随机选择一个cell，CAS累加，这样就可以减少并发冲突，获取值就用base加上cells中所有元素累加获得值，遍历数组不是个原子操作，所以LongAdder取到的值不是最新值，再获取精确计数的场景，可能不适合。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240329130947920.png" alt="image-20240329130947920"></p><h4 id="CountdownLatch和CyclicBarrier的区别使用场景与具体实现"><a href="#CountdownLatch和CyclicBarrier的区别使用场景与具体实现" class="headerlink" title="CountdownLatch和CyclicBarrier的区别使用场景与具体实现"></a>CountdownLatch和CyclicBarrier的区别使用场景与具体实现</h4><p><a href="https://zhuanlan.zhihu.com/p/139020914">CountdownLatch和CyclicBarrier的区别使用场景与具体实现 - 知乎 (zhihu.com)</a></p><p><strong>CountdownLatch 使用场景</strong></p><p>顾名思义CountdownLatch可以当做一个计数器来使用,比如主线程需要等待其他几个线程都执行过某个时间节点后才能继续执行 我们来模拟一个场景,某公司一共有十个人,门卫要等十个人都来上班以后,才可以休息,代码实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//lambda中只能只用final的变量</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在赶路&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> * times);</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;到公司了&quot;</span>);</span><br><span class="line">                    <span class="comment">//调用latch的countDown方法使计数器-1</span></span><br><span class="line">                    latch.countDown();</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始工作&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;门卫等待员工上班中...&quot;</span>);</span><br><span class="line">            <span class="comment">//主线程阻塞等待计数器归零</span></span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;员工都来了,门卫去休息了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行后结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">子线程Thread-<span class="number">0</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">2</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">0</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">0</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">1</span>正在赶路</span><br><span class="line">门卫等待员工上班中...</span><br><span class="line">子线程Thread-<span class="number">4</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">9</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">5</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">6</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">7</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">8</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">3</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">1</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">1</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">2</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">2</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">3</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">3</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">4</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">4</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">5</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">5</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">6</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">6</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">7</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">7</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">8</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">8</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">9</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">9</span>开始工作</span><br><span class="line">员工都来了,门卫去休息了</span><br></pre></td></tr></table></figure><h5 id="CyclicBarrier-使用场景"><a href="#CyclicBarrier-使用场景" class="headerlink" title="CyclicBarrier 使用场景"></a>CyclicBarrier 使用场景</h5><p>我们重新模拟一个新的场景,就用已经被说烂的跑步场景吧,十名运动员各自准备比赛,需要等待所有运动员都准备好以后,裁判才能说开始然后所有运动员一起跑,代码实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">10</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有人都准备好了裁判开始了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//lambda中只能只用final的变量</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在准备&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> * times);</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备好了&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始跑了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>执行结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">子线程Thread-<span class="number">0</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">2</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">1</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">3</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">4</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">0</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">5</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">6</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">7</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">8</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">9</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">1</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">2</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">3</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">4</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">5</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">6</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">7</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">8</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">9</span>准备好了</span><br><span class="line">所有人都准备好了裁判开始了</span><br><span class="line">子线程Thread-<span class="number">9</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">0</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">2</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">1</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">7</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">6</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">5</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">4</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">3</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">8</span>开始跑了</span><br></pre></td></tr></table></figure><h5 id="CountdownLatch-底层实现"><a href="#CountdownLatch-底层实现" class="headerlink" title="CountdownLatch 底层实现"></a>CountdownLatch 底层实现</h5><p>我们先来看看CountdownLatch的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先保证了count一定要大于零,然后初始化了一个Sync对象,在看看这个Sync对象是个什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">        Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Sync是CountdownLatch的静态内部类,继承了AbstractQueuedSynchronizer(即AQS,提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的工具,回头单讲)抽象类, 在Sync的构造方法中,调用了setState方法,可以视作初始化了一个标记来记录当前计数器的数量</p><p>我们来看CountdownLatch的两个核心方法,await和countdown,先来看await</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//可以视作将线程阻塞</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>await调用的是AQS的方法,可以视作阻塞线程,具体实现在分析AQS的章节中展开 再来看看countdown方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用了sync的一个方法,再来看看这个方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再来看这个tryReleaseShared方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取标记位</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//用cas的方式更新标记位</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以看到在调用tryReleaseShared实际上是将标记位-1并且返回标记位是否为0,如果标记位为0 那么调用的doReleaseShared可以视作将阻塞的线程放行,这样整个的流程就通了</p><h5 id="CyclicBarrier-底层实现"><a href="#CyclicBarrier-底层实现" class="headerlink" title="CyclicBarrier 底层实现"></a>CyclicBarrier 底层实现</h5><p>老规矩先看构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="built_in">this</span>.parties = parties;</span><br><span class="line">        <span class="built_in">this</span>.count = parties;</span><br><span class="line">        <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这边传入了两个对象简单的记录了一下存值,我们直接查看一下关键的await方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再来看dowait的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">trip</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">/** 省略部分代码 **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">               TimeoutException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line">            <span class="comment">//判断是否被打断</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将计数器-1 即在构造方法中赋值的count</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="comment">//如果所有的线程都执行完毕即count=0时</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行传入的方法</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    ranAction = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//唤醒所有线程</span></span><br><span class="line">                    nextGeneration();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果count没有到0那么阻塞当前线程</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        trip.await();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                        <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到,CyclicBarrier是利用Lock的condition方法来进行线程的阻塞和唤醒,类似Object.wait()和notifyAll()在count不为0时阻塞,在count&#x3D;0时唤醒所有线程</p><p><strong>总结</strong></p><p>1,CountdownLatch适用于所有线程通过某一点后通知方法,而CyclicBarrier则适合让所有线程在同一点同时执行</p><p> 2,CountdownLatch利用继承AQS的共享锁来进行线程的通知,利用CAS来进行–state，当state变成0之后才放行这个调用latch.await()的线程,而CyclicBarrier则利用ReentrantLock的Condition来阻塞和通知线程，count不为0时阻塞,在count&#x3D;0时唤醒所有被阻塞线程</p><h3 id="手撕线程题"><a href="#手撕线程题" class="headerlink" title="手撕线程题"></a>手撕线程题</h3><h4 id="实现’A’、’B’、’C’循环打印ABCABC，每个线程打印时其他线程不能打印"><a href="#实现’A’、’B’、’C’循环打印ABCABC，每个线程打印时其他线程不能打印" class="headerlink" title="实现’A’、’B’、’C’循环打印ABCABC，每个线程打印时其他线程不能打印"></a>实现’A’、’B’、’C’循环打印ABCABC，每个线程打印时其他线程不能打印</h4><h5 id="使用lock"><a href="#使用lock" class="headerlink" title="使用lock"></a>使用lock</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCUsingLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times; <span class="comment">// 控制打印次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;   <span class="comment">// 当前状态值：保证三个线程之间交替打印</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintABCUsingLock</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.times = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String name, <span class="type">int</span> targetNum)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (state % <span class="number">3</span> == targetNum) &#123;</span><br><span class="line">                state++;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.print(name);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintABCUsingLock</span> <span class="variable">loopThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintABCUsingLock</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            loopThread.printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            loopThread.printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            loopThread.printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用wait-notify"><a href="#使用wait-notify" class="headerlink" title="使用wait&#x2F;notify"></a><strong>使用wait&#x2F;notify</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCUsingWaitNotify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintABCUsingWaitNotify</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.times = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintABCUsingWaitNotify</span> <span class="variable">printABC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintABCUsingWaitNotify</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printABC.printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printABC.printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printABC.printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String name, <span class="type">int</span> targetState)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">while</span> (state % <span class="number">3</span> != targetState) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                state++;</span><br><span class="line">                System.out.print(name);</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两个线程交替打印奇数和偶数"><a href="#两个线程交替打印奇数和偶数" class="headerlink" title="两个线程交替打印奇数和偶数"></a>两个线程交替打印奇数和偶数</h4><p>使用对象监视器实现，两个线程 A、B 竞争同一把锁，只要其中一个线程获取锁成功，就打印 ++i，并通知另一线程从等待集合中释放，然后自身线程加入等待集合并释放锁即可。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-9731382f3dfea5a4be6a5b4ef8ccdc87_1440w.webp" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OddEvenPrinter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    OddEvenPrinter(<span class="type">int</span> initCount, <span class="type">int</span> times) &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = initCount;</span><br><span class="line">        <span class="built_in">this</span>.limit = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">OddEvenPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OddEvenPrinter</span>(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::print, <span class="string">&quot;odd&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::print, <span class="string">&quot;even&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; limit) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;线程[%s]打印数字:%d&quot;</span>, Thread.currentThread().getName(), ++count));</span><br><span class="line">                    monitor.notifyAll();</span><br><span class="line">                    monitor.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//防止有子线程被阻塞未被唤醒，导致主线程不退出</span></span><br><span class="line">            monitor.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的思路，来解决下第 5 题：用两个线程，一个输出字母，一个输出数字，交替输出 1A2B3C4D…26Z</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumAndLetterPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printer(), <span class="string">&quot;numThread&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printer(), <span class="string">&quot;letterThread&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().getName() == <span class="string">&quot;numThread&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">//打印数字1-26</span></span><br><span class="line">                    System.out.print((i + <span class="number">1</span>));</span><br><span class="line">                    <span class="comment">// 唤醒其他在等待的线程</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 让当前线程释放锁资源，进入wait状态</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Thread.currentThread().getName() == <span class="string">&quot;letterThread&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 打印字母A-Z</span></span><br><span class="line">                    System.out.print((<span class="type">char</span>) (<span class="string">&#x27;A&#x27;</span> + i));</span><br><span class="line">                    <span class="comment">// 唤醒其他在等待的线程</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 让当前线程释放锁资源，进入wait状态</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用-Lock-Condition"><a href="#使用-Lock-Condition" class="headerlink" title="使用 Lock&#x2F;Condition"></a>使用 Lock&#x2F;Condition</h5><p>还是以第一题为例，使用 Condition 来实现，其实和 wait&#x2F;notify 的思路一样。</p><blockquote><p>Condition 中的 <code>await()</code> 方法相当于 Object 的 <code>wait()</code> 方法，Condition 中的 <code>signal()</code> 方法相当于Object 的 <code>notify()</code> 方法，Condition 中的 <code>signalAll()</code> 相当于 Object 的 <code>notifyAll()</code> 方法。<br>不同的是，Object 中的 <code>wait(),notify(),notifyAll()</code>方法是和<code>&quot;同步锁&quot;</code>(synchronized关键字)捆绑使用的；而 Condition 是需要与<code>&quot;互斥锁&quot;/&quot;共享锁&quot;</code>捆绑使用的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCUsingLockCondition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintABCUsingLockCondition</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.times = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintABCUsingLockCondition</span> <span class="variable">print</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintABCUsingLockCondition</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>, c1, c2);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>, c2, c3);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>, c3, c1);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String name, <span class="type">int</span> targetState, Condition current, Condition next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (state % <span class="number">3</span> != targetState) &#123;</span><br><span class="line">                    current.await();</span><br><span class="line">                &#125;</span><br><span class="line">                state++;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.print(name);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Lock 锁的多个 Condition 可以实现精准唤醒，所以碰到那种多个线程交替打印不同次数的题就比较容易想到，比如解决第四题：多线程按顺序调用，A-&gt;B-&gt;C，AA 打印 5 次，BB 打印10 次，CC 打印 15 次，重复 10 次</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2024/04/19/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/04/19/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="基本数据类型与权限"><a href="#基本数据类型与权限" class="headerlink" title="基本数据类型与权限"></a>基本数据类型与权限</h3><h4 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a><strong>基本类型和包装类型的区别</strong></h4><h5 id="1-基本类型有初始值，而包装类型的默认值是null"><a href="#1-基本类型有初始值，而包装类型的默认值是null" class="headerlink" title="1.基本类型有初始值，而包装类型的默认值是null"></a>1.基本类型有初始值，而包装类型的默认值是null</h5><h5 id="2-包装类型可以为-null，而基本类型不可以"><a href="#2-包装类型可以为-null，而基本类型不可以" class="headerlink" title="2.包装类型可以为 null，而基本类型不可以"></a>2.包装类型可以为 null，而基本类型不可以</h5><p>数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有<a href="https://so.csdn.net/so/search?q=NPE&spm=1001.2101.3001.7020">NPE</a>（NullPointerException）风险。</p><h5 id="3-存储位置有所区别：基本类型是成员变量就存储在堆内存里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用"><a href="#3-存储位置有所区别：基本类型是成员变量就存储在堆内存里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用" class="headerlink" title="3.存储位置有所区别：基本类型是成员变量就存储在堆内存里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用"></a>3.存储位置有所区别：基本类型是成员变量就存储在<a href="https://so.csdn.net/so/search?q=%E5%A0%86%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">堆内存</a>里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用</h5><h5 id="4-包装类型可用于泛型，而基本类型不可以"><a href="#4-包装类型可用于泛型，而基本类型不可以" class="headerlink" title="4.包装类型可用于泛型，而基本类型不可以"></a>4.包装类型可用于泛型，而基本类型不可以</h5><p>如果我们这么写<br>List<int> a &#x3D; new ArrayList&lt;&gt;();<br>编译器会报错：Type argument cannot be of primitive type(类型参数不能为基本类型)<br>这是为什么呢？因为泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类。</p><h5 id="5-在使用“-”进行判断的时候的不同"><a href="#5-在使用“-”进行判断的时候的不同" class="headerlink" title="5.在使用“&#x3D;&#x3D;”进行判断的时候的不同"></a>5.在使用“&#x3D;&#x3D;”进行判断的时候的不同</h5><p>基本数据类型会直接比较值是否相同，而包装数据类型用“&#x3D;&#x3D;”判断比较的是地址值（在-128 – 127之间会共用内部类的cache），真正判断是否相等需要用equals()。</p><p><strong>6.自动装箱和自动拆箱</strong><br>把基本类型转换成包装类型的过程叫做装箱（boxing）。反之，把包装类型转换成基本类型的过程叫做拆箱（unboxing）。</p><p>1）基本类型和包装类型进行 &#x3D;&#x3D; 比较，包装类型会自动拆箱，直接和基本类型比较值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">System.out.println(a == b);</span><br></pre></td></tr></table></figure><p>上述代码的结果为 true。</p><p>2）当需要进行自动装箱时，如果数字在 -128 至 127 之间，会直接使用缓存中的对象，而不是重新创建一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">199</span>;  </span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> A;  </span><br></pre></td></tr></table></figure><p>执行第一句代码的时候，系统为我们执行了：<br>Integer A &#x3D; Integer.valueOf(199);<br>执行第二句代码的时候，系统为我们执行了：<br>int a &#x3D; A.intValue();</p><h4 id="java的访问权限有哪些"><a href="#java的访问权限有哪些" class="headerlink" title="java的访问权限有哪些"></a>java的访问权限有哪些</h4><h5 id="类的成员变量和方法访问权限"><a href="#类的成员变量和方法访问权限" class="headerlink" title="类的成员变量和方法访问权限"></a>类的成员变量和方法访问权限</h5><table><thead><tr><th>修饰符</th><th>类内部</th><th>同包（package）</th><th>子类</th><th>任何地方</th></tr></thead><tbody><tr><td>public</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>protected</td><td>Yes</td><td>Yes</td><td>Yes</td><td></td></tr><tr><td>缺省</td><td>Yes</td><td>Yes</td><td></td><td></td></tr><tr><td>private</td><td>Yes</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th align="left">权限修饰符</th><th align="left">类</th><th align="left">变量&#x2F;方法</th></tr></thead><tbody><tr><td align="left">public</td><td align="left">包内外的类都可以访问</td><td align="left">包内外的类都可以访问</td></tr><tr><td align="left">protected</td><td align="left">类不可以声明为protected</td><td align="left">本包内的类和子类可以访问</td></tr><tr><td align="left">不写</td><td align="left">本包中的类可以访问</td><td align="left">本包中的类可以访问</td></tr><tr><td align="left">private</td><td align="left">类不可以声明为private</td><td align="left">只允许本类访问</td></tr></tbody></table><h5 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h5><p>类的访问权限仅有<strong>public</strong>和<strong>default</strong>， 如果一个类声明的时候用了<strong>public</strong>，则该类的类名必须与文件名一致，包括大小写，如果不匹配，会有编译错误</p><h4 id="Java的基本类型存储位置"><a href="#Java的基本类型存储位置" class="headerlink" title="Java的基本类型存储位置"></a><strong>Java的基本类型存储位置</strong></h4><ul><li><p><strong>第一种</strong>: 在方法中声明的变量，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因</p><p>（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中</p><p>（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。</p></li><li><p><strong>第二种</strong> 在类中声明的变量是类的成员变量(全局变量),放在堆中</p><ol><li>声明的是基本类型的变量,其变量名及其值放在堆内存中</li><li>声明的是引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中。但与对象中的普通成员变量（局部变量）不同的是，它们的生命周期是在对象销毁时才结束的</li></ol></li><li><p><strong>第三种</strong> 静态变量：</p><p>​静态变量随着类的加载而存在，是存储在方法区（Method Area）中的，而不是存储在栈或堆上，所以它的生命周期与程序的生命周期一样长。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjcxMjE2,size_16,color_FFFFFF,t_70.png" alt="img"></p></li></ul><h4 id="包装类的缓存"><a href="#包装类的缓存" class="headerlink" title="包装类的缓存"></a>包装类的缓存</h4><p>1、前提：发生自动装箱的过程（基本类型–&gt;包装类型）<br>创建一个包装类对象有两种方法：<br>（1）构造器方法（就是new出来）；<br>（2）自动装箱（就是编译器自动调用包装类的valueOf方法）；</p><h5 id="两种方法的区别："><a href="#两种方法的区别：" class="headerlink" title="两种方法的区别："></a>两种方法的区别：</h5><p>构造器方法：不论值的大小，返回的将都会是一个新对象；<br>自动装箱会先经过判断，再决定返回的是一个新对象还是常量池中已存在的对象。</p><p>2、机制：当通过自动装箱机制创建包装类对象时，首先会判断数值是否在缓存范围内，如果满足条件，则会从  该包装类中的静态内部类xxCache包装类（例如IntegerCache类）类型数组（例如static final Integer cache[]）（放在方法区的常量池）中寻找指定数值，并返回缓存的对象，否则创建一个新的对象返回。</p><p>3、原理：<br>（1）当包装类加载时，该包装类中的静态内部类xxCache会初始化一个静态包装类类型数组，最小值（固定值）为-128,而最大值（默认值）为127【可修改】，是所有线程共享的。</p><h5 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h5><p>在缓存值范围内的对象可以直接在常量池中取出，不用创建新的对象；<br>当需要频繁的使用同一对象的时候，如果有缓存，则可以避免重复创建同一对象，节省空间开销和时间消耗，提升了性能。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111615708.png" alt="image-20231003111615708"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h4><ol><li>重写必须依赖于继承(父子关系) 将父类的的方法给完善。而重载不需要依赖继承关系，在自己的类中就可以实现。</li><li>重写的方法名和参数列表必须和父类相同，如果父类没有这个方法，那么就不算重写。重载是在自身类中创建多个方法名相同但是参数类型或者个数不同的方法。</li><li>重写的参数不能修改，而重载的参数必须修改。</li></ol><h4 id="object中的hashcode-方法是做什么用的"><a href="#object中的hashcode-方法是做什么用的" class="headerlink" title="object中的hashcode()方法是做什么用的"></a>object中的hashcode()方法是做什么用的</h4><p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p><p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><h5 id="那为什么不只提供-hashCode-方法呢？"><a href="#那为什么不只提供-hashCode-方法呢？" class="headerlink" title="那为什么不只提供 hashCode() 方法呢？"></a><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></h5><p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p><h5 id="那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？"><a href="#那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？" class="headerlink" title="那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？"></a><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></h5><p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><h4 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h4><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p>再map集合中，如果只重写equals方法，那么两个相同对象hashcode可能不同，会存在多个key相同的情况。</p><h4 id="object类中的常用方法的用处："><a href="#object类中的常用方法的用处：" class="headerlink" title="object类中的常用方法的用处："></a>object类中的常用方法的用处：</h4><p>1、 getClass()：获取类的class对象。<br>2、 hashCode():获取对象的hashCode值<br>3、 equals():比较对象是否相等，先比较存储地址再比较对象，子类可重写以自定义。<br>4、 clone()：浅拷贝一个新的对象。<br>5、 toString():如果没有重写，应用对象将打印的是地址值。<br>6、 notify():随机选择一个在该对象上调用wait方法的线程，解除其阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>7、 notifyall():解除所有那些在该对象上调用wait方法的线程的阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>8、 wait():导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在同步方法中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>9、 finalize()：对象回收时调用</p><h4 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h4><ol><li><p>final修饰符（关键字）。被<strong>final修饰的类</strong>，就意味着<strong>不能再派生出新的子类</strong>，不能作为父类而被子类继承。因此一个类不能既被abstract声明，又被final声明。将<strong>变量或方法声明为final</strong>，可以保证他们在<strong>使用的过程中不被修改</strong>。被声明为final的变量必须在声明时<strong>给出变量的初始值</strong>，而在以后的引用中只能读取。被final声明的方法也同样只能使用，即不能方法重写。</p></li><li><p>finally是在<strong>异常处理时提供finally块来执行任何清除操作</strong>。不管有没有异常被抛出、捕获，finally块都会被执行。try块中的内容是在无异常时执行到结束。catch块中的内容，是在try块内容发生catch所声明的异常时，跳转到catch块中执行。<strong>finally块则是无论异常是否发生，都会执行finally块的内容，所以在代码逻辑中有需要无论发生什么都必须执行的代码，就可以放在finally块中</strong>。</p></li><li><p>finalize是方法名。java技术允许使用finalize（）方法<strong>在垃圾收集器将对象从内存中清除出去之前做必要的清理工作</strong>。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在object类中定义的，因此所有的类都继承了它。子类覆盖finalize（）方法以整理系统资源或者被执行其他清理工作。<strong>finalize（）方法是在垃圾收集器删除对象之前对这个对象调用的。</strong></p></li></ol><h4 id="Return与finally的使用顺序"><a href="#Return与finally的使用顺序" class="headerlink" title="Return与finally的使用顺序"></a>Return与finally的使用顺序</h4><p><strong>如果程序是从try代码块或者catch代码块中返回时，finally中的代码总会执行。而且finally语句在return语句执行之后return返回之前执行的。可以使用编译器的Debug功能查看详细过程。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally模块被执行&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">//结果 finally模块被执行 1</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>/<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally模块被执行&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//结果： finally模块被执行 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>/<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally模块被执行&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">//结果 finally模块被执行 0；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally模块被执行&quot;</span>);</span><br><span class="line">          result = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//结果 finally模块被执行 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>*<strong>如果try和catch的return是一个变量时且函数的是从其中一个返回时，后面finally中语句即使有对返回的变量进行赋值的操作时，也不会影响返回的值，因为返回值已经被保存到局部变量表中，赋值操作无法修改到返回值。*</strong></p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String为什么不可变"><a href="#String为什么不可变" class="headerlink" title="String为什么不可变"></a>String为什么不可变</h4><ul><li>将 class 自身声明为 final，这样别人就不能通过扩展来绕过限制了。</li><li>将所有成员变量定义为 private 和 final（使得byte[]引用不可变），并且没有实现 setter 方法来修改byte[]（使得byte[]值不可变）。</li><li>通过构造对象时，成员变量使用深拷贝来初始化，而不是直接赋值，这是一种防御措施，因为该输入对象被其他变量引用，你无法确定输入对象不被其他人修改。</li></ul><p>可以通过反射修改String的值，相当于使用set方法修改byte[];</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString3</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">strObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;反射执行前字符串：&quot;</span> + strObj);</span><br><span class="line">    System.out.println(<span class="string">&quot;反射执行前的hash值：&quot;</span> + strObj.hashCode());</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> strObj.getClass().getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">char</span>[] value = (<span class="type">char</span>[]) field.get(strObj);</span><br><span class="line">    value[<span class="number">2</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;反射执行后字符串：&quot;</span> + strObj);</span><br><span class="line">    System.out.println(<span class="string">&quot;反射执行后的hash值：&quot;</span> + strObj.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1的内存地址：<span class="number">1922154895</span></span><br><span class="line">执行+=后str1的内存地址：<span class="number">883049899</span></span><br><span class="line">拼接之后str1的值：helloworld</span><br><span class="line">str3的值：<span class="number">123</span></span><br><span class="line">str4的值：<span class="number">123456</span></span><br><span class="line">str5的值：ABC</span><br><span class="line">str6的值：BBC</span><br></pre></td></tr></table></figure><h4 id="String-类设计成不可变的原因及好处？"><a href="#String-类设计成不可变的原因及好处？" class="headerlink" title="String 类设计成不可变的原因及好处？"></a><strong>String 类设计成不可变的原因及好处？</strong></h4><p>其实好处就是原因，String 设计成不可变，主要是从性能和安全两方面考虑。</p><h5 id="1、常量池的需要"><a href="#1、常量池的需要" class="headerlink" title="1、常量池的需要"></a><strong>1、常量池的需要</strong></h5><p>这个方面很好理解，Java 中的字符串常量池的存在就是为了性能优化。</p><p>字符串常量池（String pool）是 Java 堆内存中一个特殊的存储区域，当创建一个 String 对象时，假如此字符串已经存在于常量池中，则不会创建新的对象，而是直接引用已经存在的对象。这样做能够减少 JVM 的内存开销，提高效率。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span> s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="title class_">String</span> s2 = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><p>比如引用 s1和 s2 都是指向常量池的同一个对象 “abc”，如果 String 是可变类，引用 s1 对 String 对象的修改，会直接导致引用 s2 获取错误的值。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/43vmfn3rmu.png" alt="img"></p><p>所以，如果字符串是可变的，那么常量池就没有存在的意义了。</p><h5 id="2、hashcode-缓存的需要"><a href="#2、hashcode-缓存的需要" class="headerlink" title="2、hashcode 缓存的需要"></a><strong>2、hashcode 缓存的需要</strong></h5><p>String有一个属性用来缓存hash值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p>因为字符串不可变，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就使得字符串很适合作为 HashMap 中的 key，效率大大提高。</p><h5 id="3、多线程安全"><a href="#3、多线程安全" class="headerlink" title="3、多线程安全"></a><strong>3、多线程安全</strong></h5><p>多线程中，可变对象的值很可能被其他线程改变，造成不可预期的结果。而不可变的 String 可以自由在多个线程之间共享，不需要同步处理。</p><h4 id="String-、StringBuffer和StringBuilder的区别"><a href="#String-、StringBuffer和StringBuilder的区别" class="headerlink" title="String 、StringBuffer和StringBuilder的区别"></a>String 、StringBuffer和StringBuilder的区别</h4><h5 id="1-可变性"><a href="#1-可变性" class="headerlink" title="1.可变性"></a>1.可变性</h5><p>​String 内部的 value 值是 final 修饰的，所以它是不可变类。所以每次修改 String 的值，都会产生一个新的对象。<br>​StringBuffer 和 StringBuilder 是可变类，字符串的变更不会产生新的对象。</p><h5 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="2.线程安全性"></a>2.线程安全性</h5><p>​String 是不可变类，所以它是线程安全的。<br>​StringBuffer 是线程安全的，因为它每个操作方法都加了 synchronized 同步关键字。<br>​StringBuilder 不是线程安全的。所以在多线程环境下对字符串进行操作，应该使用 StringBuffer，否则使用StringBuilder</p><h5 id="3-性能方面。"><a href="#3-性能方面。" class="headerlink" title="3.性能方面。"></a>3.性能方面。</h5><p>​String 的性能是最低的，因为不可变意味着在做字符串拼接和修改的时候，需要重新创建新的对象以及分配内存。<br>​其次是 StringBuffer 要比 String 性能高，因为它的可变性使得字符串可以直接被修改<br>​最后是 StringBuilder，它比 StringBuffer 的性能高，因为 StringBuffer 加了同步锁。</p><h5 id="4-存储方面。"><a href="#4-存储方面。" class="headerlink" title="4.存储方面。"></a>4.存储方面。</h5><p>​String 存储在字符串常量池里面<br>​StringBuffer 和 StringBuilder 存储在堆内存空间。</p><h4 id="StringBuffer、StringBuilder的扩容原理"><a href="#StringBuffer、StringBuilder的扩容原理" class="headerlink" title="StringBuffer、StringBuilder的扩容原理"></a>StringBuffer、StringBuilder的扩容原理</h4><p>扩容原理：</p><p><code>StringBuffer</code>的底层数组结构用的是<code>char</code>类型的数组如果没有指定大小，默认大小为16，指定了大小，默认大小为（16 + 指定大小）。</p><p>所以，当我们使用<code>StringBuffer</code>对象的<code>append(...)</code>方法追加数据时，</p><ul><li>如果数组长度可以容纳追加的数据，就直接追加到数组</li><li>如果char类型数组的长度无法容纳我们追加的数据，<code>StringBuffer</code>就会进行扩容。</li><li>扩容时会用到<code>Arrays</code>类中的<code>copyOf(...)</code>方法，每次扩容的容量大小是原来的容量的2倍（通过无符号左移）加2。</li></ul><h4 id="String-str-“abc”-和String-str-new-String-“abc”-的区别"><a href="#String-str-“abc”-和String-str-new-String-“abc”-的区别" class="headerlink" title="String str &#x3D; “abc” 和String str &#x3D; new String(“abc”)的区别"></a><strong>String str &#x3D; “abc” 和String str &#x3D; new String(“abc”)的区别</strong></h4><p><code>String str =&quot;abc&quot;</code>的原理，采用字面值的方式创建时，<code>JVM</code>会先去字符串常量池中去查找是否存在”abc”这个对象，如果不存在就创建这个字符串，并把地址返回给<code>str</code>。如果存在则直接把”abc”这个字符串的地址返回给<code>str</code>。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/16e1f7c1f13d9561tplv-t2oaga2asx-jj-mark3024000q75-1696302993864-1.webp" alt="img"></p><p><code>String str = new String(&quot;abc&quot;)</code>采用<code>new</code>关键字的方式创建，能被看成”abc”和new String()，<code>JVM</code>也会去字符串常量池中查找有没有这个字符串，如果没有的话，就先在字符串常量池里创建”abc”这个字符串，然后再复制一份放在堆里并把地址返回给<code>str</code>。如果字符串常量池里存在该字符串，那么就直接复制一份放在堆里并把地址返回给<code>str</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = original.value;</span><br><span class="line">        <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">    &#125;<span class="comment">//浅拷贝</span></span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/16e1f8c6aa324edetplv-t2oaga2asx-jj-mark3024000q75-1696303002110-3.webp" alt="img"></p><h4 id="（String的）equals-的底层代码是什么"><a href="#（String的）equals-的底层代码是什么" class="headerlink" title="（String的）equals 的底层代码是什么?"></a>（String的）equals 的底层代码是什么?</h4><ol><li>先使用&#x3D;&#x3D; 进行地址值的判断  </li><li>判断equals()中的值是否为字符串  instanceof()方法</li><li>判断字符串的长度是否相同  </li><li>循环遍历进行判断两个字符串是否相同</li></ol><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="集合顶层是什么，各个接口实现类有哪些"><a href="#集合顶层是什么，各个接口实现类有哪些" class="headerlink" title="集合顶层是什么，各个接口实现类有哪些"></a>集合顶层是什么，各个接口实现类有哪些</h4><p><strong>Java 集合框架架构图如下图所示</strong>：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1711439392899-248.png" alt="图片"></p><p><code>List</code> 接口实现类：</p><ul><li><code>ArrayList</code>: 底层基于可调节大小的数组实现。</li><li><code>LinkedList</code>: 底层基于双向链表实现，链表实现类。</li><li><code>Vector</code>: 和<code>ArrayList</code>类似，但线程安全。</li><li><code>Stack</code>: 继承自 <code>Vector</code>，栈实现类。</li></ul><p><code>Set</code> 接口实现类：</p><ul><li><code>HashSet</code>: 底层基于哈希表实现，没有排序保证。</li><li><code>LinkedHashSet</code>: 底层基于哈希表和链表实现，元素的插入和取出顺序满足 FIFO</li><li><code>TreeSet</code>: 底层基于红黑树实现，元素是有序的，排序的方式有自然排序和定制排序。</li></ul><p><code>Map</code> 接口实现类：</p><ul><li><code>HashMap</code>: 仅用于存储键值对，JDK1.8 之前 <code>HashMap</code> 底层基于数组和链表实现，JDK1.8 之前基于数组和红黑树。</li><li><code>LinkedHashMap</code>: 继承自 <code>HashMap</code>，并在 <code>HashMap</code> 基础上维护一条双向链表，支持遍历时会按照插入顺序有序进行迭代，支持按照元素访问顺序排序，迭代效率比<code>HashMap</code>更高。</li><li><code>TreeMap</code>: 相比于 <code>HashMap</code> 来说，<code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</li><li><code>Hashtable</code>: 与 <code>HashMap</code> 类似，但线程安全。</li></ul><p><code>Queue</code> 接口实现类：</p><ul><li><code>LinkedList</code>: 同时实现了 <code>List</code> 和 <code>Queue</code> 接口。</li><li><code>PriorityQueue</code>：元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</li><li><code>ArrayDeque</code> ：底层基于可变长的数组和双指针实现，允许我们在队列的两端进行元素的插入和移除操作。</li></ul><h4 id="数组和链表的不同"><a href="#数组和链表的不同" class="headerlink" title="数组和链表的不同"></a>数组和链表的不同</h4><table><thead><tr><th></th><th>数组</th><th>链表</th></tr></thead><tbody><tr><td>逻辑结构</td><td>（1）数组在内存中连续； (2)使用数组之前，必须事先固定数组长度，不支持动态改变数组大小；(3) 数组元素增加时，有可能会数组越界；(4) 数组元素减少时，会造成内存浪费；（5）数组增删时需要移动其它元素</td><td>（1）链表采用动态内存分配的方式，在内存中不连续 (2)支持动态增加或者删除元素</td></tr><tr><td>访问效率</td><td>数组在内存中顺序存储，可通过下标访问，访问效率高</td><td>链表访问效率低，如果想要访问某个元素，需要从头遍历</td></tr><tr><td>越界问题</td><td>数组的大小是固定的，所以存在访问越界的风险</td><td>只要可以申请得到链表空间，链表就无越界风险</td></tr><tr><td>使用场景</td><td>存储的大小变化不大，且可以事先确定大小，主要是进行查找，很少插入和删除时</td><td>长度变化较大时，事先无法估量数据规模，当线性表要求频繁插入和删除时</td></tr></tbody></table><h4 id="说说ArrayList"><a href="#说说ArrayList" class="headerlink" title="说说ArrayList"></a>说说ArrayList</h4><p>ArrayList 是一个数组结构的存储容器，所以ArrayList是支持随机存取的，默认情况下，数组的长度是 10.也可以在构建 ArrayList 对象的时候自己指定初始长度。随着在程序里面不断的往 ArrayList 中添加数据，当添加的数据达到 10 个的时候，ArrayList 就没有多余容量可以存储后续的数据。这个时候 ArrayList 会自动触发扩容。扩容的具体流程很简单：</p><ol><li>首先，创建一个新的数组，这个新数组的长度是原来数组长度的 1.5 倍。</li><li>然后使用 Arrays.copyOf 方法把老数组里面的数据拷贝到新的数组里面。<br>扩容完成后再把当前要添加的元素加入到新的数组里面，从而完成动态扩容的过程。</li></ol><h4 id="常见的树"><a href="#常见的树" class="headerlink" title="常见的树"></a>常见的树</h4><p><a href="https://zhuanlan.zhihu.com/p/531299726#%E5%89%8D%E8%A8%80">为什么红黑树的效率比较高 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/361961175">红黑树 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/91960960">一文带你彻底读懂红黑树（附详细图解） - 知乎 (zhihu.com)</a></p><h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><strong>平衡二叉树</strong></h5><p>特点：<strong>任意节点的左子树和右子树高度差不能超过1</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-db8cdc6ff692f73cb4984ff80e45ef34_720w.webp" alt="img"></p><h5 id="非平衡二叉树"><a href="#非平衡二叉树" class="headerlink" title="非平衡二叉树"></a><strong>非平衡二叉树</strong></h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-07b3c6b4c4d2d524555fb739bf599981_720w.webp" alt="img"></p><p>高度差已经大于1 了。平衡树解决的问题就是 能够最大限度的增加访问的每个节点的的平均性。保证每个节点被访问的次数平衡。</p><h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a><strong>完全二叉树</strong></h5><p>除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-db8cdc6ff692f73cb4984ff80e45ef34_720w.webp" alt="img"></p><p>堆排序 结构其实就是一个完全二叉树的结构，倒序和正序就是用的 大根堆 小根堆的原理。</p><h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a><strong>满二叉树</strong></h5><p>每个节点是叶节点或者度为2.</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-c24507d5ab42fa1a9de508aea129bacc_720w.webp" alt="img"></p><h5 id="二叉搜索树（Binary-Search-Tree）"><a href="#二叉搜索树（Binary-Search-Tree）" class="headerlink" title="二叉搜索树（Binary Search Tree）"></a><strong>二叉搜索树（Binary Search Tree）</strong></h5><p>特点是每个根节点大于左子树上的任意一个节点，小于等于右子树上的任意一个节点。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-bc1985e7abdd4871d0d0709f02a64725_720w.webp" alt="img"></p><p>可以利用二叉搜索树的大小关系，有点类似于二分查找。二叉搜索树查询的时间复杂度为O(logn)，因为每次查找都能将范围缩小一半。</p><p><strong>二叉搜索树的不足：</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-b43c0ec9893114064c891d5b3b2ee383_720w.webp" alt="img"></p><p>极端的二叉搜索树：如果二叉搜索树每个节点都只有左节点或者都只有右节点，那么这颗树就会降级为链表结构，使得时间复杂度为O(n),所以引出了平衡排序树(AVL树).</p><h5 id="平衡二叉搜索树（AVL树）"><a href="#平衡二叉搜索树（AVL树）" class="headerlink" title="平衡二叉搜索树（AVL树）"></a>平衡二叉搜索树（AVL树）</h5><p><strong>特点</strong></p><ul><li>任意节点的左右子树的高度差都小于等于1</li><li>常见的平衡树包括B树（MySQL中的索引），AVL树等</li></ul><p><strong>平衡二叉搜索树能同时满足平衡树和二叉搜索树的特点：</strong></p><ul><li>优点：AVL树可以有效减少二叉树的深度，从而提升查询的效率。</li><li>缺点：AVL树为了达到平衡（任意节点的左右子树的高度差都小于等于1，这属于<strong>绝对平衡</strong>，维持起来并不容易），需要付出额外代价。在插入和删除操作时，AVL树都需要进行再平衡。</li></ul><p>所以AVL树还有待改进——红黑树。</p><table><thead><tr><th>平衡二叉树类型</th><th>平衡度</th><th>调整频率</th><th>适用场景</th></tr></thead><tbody><tr><td>AVL树</td><td>高</td><td>高</td><td>查询多，增&#x2F;删少</td></tr><tr><td>红黑树</td><td>低</td><td>低</td><td>增&#x2F;删频繁</td></tr></tbody></table><hr><h5 id="红黑树（R-B树）"><a href="#红黑树（R-B树）" class="headerlink" title="红黑树（R-B树）"></a>红黑树（R-B树）</h5><p>红黑树是一种特化的AVL树，查询与AVL树基本相同，在插入和删除时通过特定操作保持二叉搜索树的<strong>相对平衡</strong>（红黑树与AVL树不同，AVL是绝对平衡）， 因为这种相对平衡的条件，红黑树在插入和删除时，对于树的调整的频率低于AVL树，对于树的旋转的次数也比AVL树少，从而获得较高的性能。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-d5a84583be75cd748b2a979e27a911ec_720w.webp" alt="img"></p><p><strong>由图可以看出红黑树不是严格的AVL树，只是黑色平衡</strong></p><p><strong>红黑树的特点</strong>：</p><ol><li><strong>首先必须满足二叉搜索树</strong></li><li><strong>节点非黑即红</strong></li><li><strong>根节点是黑色的，叶子节点是黑色的（都是空节点，为了简单起见，红黑树一般会省略叶子结点）</strong></li><li><strong>相邻父子节点不能同为红色，每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。</strong>）</li><li><strong>从一个节点到该节点的叶子结点的所有路径上包含的黑节点数量相等（这是平衡关键）</strong></li></ol><p><strong>红黑树特点总结成一句口诀：黑根黑叶红不邻，通祖等高只数黑</strong></p><p><strong>红黑树相关定理</strong></p><ol><li>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</li></ol><p>要满足从根节点到叶节点每条路径的黑色节点数量一致。最短路径：全是黑色 最长路径：黑红相间</p><p>对于给定的黑色高度为n的红黑树，从根结点到叶结点的简单路径的最短长度为n-1，最大长度为2(n-1)，从这一点我们可以看出红黑树是 大致平衡的。(当然比平衡二叉树要差一些，AVL的平衡因子最多为1)</p><ol start="2"><li>红黑树的树高(h)不大于两倍的红黑树的黑深度(bd)，即h&lt;&#x3D;2bd</li></ol><p>根据定理1，我们不难说明这一点。bd是红黑树的最短路径长度。而可能的最长路径长度(树高的最大值)就是红黑相间的路径，等于2bd。因此h&lt;&#x3D;2bd。</p><ol start="3"><li>一棵拥有n个内部结点(不包括叶子结点)的红黑树的树高h&lt;&#x3D;2log(n+1)</li></ol><p>下面我们首先证明一颗有n个内部结点的红黑树满足n&gt;&#x3D;2^bd-1。这可以用数学归纳法证明，施归纳于树高h。当h&#x3D;0时，这相当于是一个叶结点，黑高度bd为0，而内部结点数量n为0，此时0&gt;&#x3D;2^0-1成立。假设树高h&lt;&#x3D;t时，n&gt;&#x3D;2^bd-1成立，我们记一颗树高 为t+1的红黑树的根结点的左子树的内部结点数量为nl，右子树的内部结点数量为nr，记这两颗子树的黑高度为bd’（注意这两颗子树的黑高度必然一 样），显然这两颗子树的树高&lt;&#x3D;t，于是有nl&gt;&#x3D;2^bd’-1以及nr&gt;&#x3D;2^bd’-1，将这两个不等式相加有nl+nr&gt;&#x3D;2^(bd’+1)-2，将该不等式左右加1，得到n&gt;&#x3D;2^(bd’+1)-1，很显然bd’+1&gt;&#x3D;bd，于是前面的不等式可以 变为n&gt;&#x3D;2^bd-1，这样就证明了一颗有n个内部结点的红黑树满足n&gt;&#x3D;2^bd-1。</p><p>在根据定理2，h&lt;&#x3D;2bd。即n&gt;&#x3D;2^(h&#x2F;2)-1，那么h&lt;&#x3D;2log(n+1)</p><p>从这里我们能够看出，红黑树的查找长度最多不超过2log(n+1)，因此其查找时间复杂度也是O(log N)级别的。</p><p><strong>红黑树的复杂度分析</strong></p><ul><li><p>一棵含有n个节点（内部节点，不包含空的叶子节点）的红黑树的高度至多为2log(n+1)</p></li><li><p>查找时间复杂度为O(logn),红黑树上的查找操作与普通二叉查找树上的查找操作相同</p></li><li><p>插入时间复杂度为O(1)+O(logn)</p></li><li><p>删除时间复杂度为O(1)+O(logn)</p></li></ul><p><strong>AVL vs 红黑树</strong></p><ul><li>插入：AVL和红黑树都是最多两次旋转实现复衡，旋转的量级是O(1)，恢复红黑树的属性需要O(log n)的颜色变更</li><li>删除：AVL旋转的量级是O(logn)，红黑树最多旋转3次实现复衡只要O(1)</li><li>红黑树插入和删除效率更高，AVL的查找效率更高.</li><li>红黑树成本较低，AVL成本较高</li></ul><p><strong>两者没有谁好谁坏，关键看使用场景</strong></p><p><strong>红黑树的实际应用</strong></p><ul><li><strong>Java中的HashMap、TreeMap、TreeSet等</strong></li></ul><p><strong>红黑树的基本操作</strong></p><p><strong>查找节点（二叉搜索树一样的查找）</strong></p><ol><li>选择根节点作为当前节点</li><li>按照二叉搜索树特点进行循环查找（若值与当前节点值相等，则返回该节点；若值小于当前节点，左节点作为当前节点；否则，右节点作为当前节点）</li><li>未找到，为null</li></ol><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-f90edcb09cc58e310e2047ba8d6af772_720w.webp" alt="img"></p><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>[B+ 树搜索时间复杂度到底是什么：mlogmN &#x2F; logN？ - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/402951">https://zhuanlan.zhihu.com/p/402951</a></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231023104558443.png" alt="image-20231023104558443"></p><p>第一种，按照B+树数据结构来算，要访问节点数 * 节点内的搜索时间复杂度，其中节点内搜索时间有线性查找、二分查找两种</p><p>第二种：</p><p>说一个结论：非叶子节点的大小 &#x3D; 页大小。下面是证明</p><blockquote><p>B+ 树在搜索过程中，需要从磁盘IO来读取节点的数据。我们知道磁盘IO一次读取的数据大小为一页。</p><ul><li>非叶子节点的大小 &gt; 页大小：那么意味着搜索过程中，为了获取一个完整节点来查找数据，我们需要多次IO来获取这个节点，这显然非常消耗时间。所以非叶子节点的大小不能超过一页。</li><li>非叶子节点的体积非常小：这就意味着B+树的分叉就少，B+树的总节点数会变多、深度变大。B+树利用指针构成的树形结构，意味着每个节点在磁盘上是不连续的，B+树的深度变大了，意味着搜索时访问的节点数量变多，IO次数也变多了。</li><li>因此，非叶子节点过大、过小，都会导致IO次数增加。所以最合适的非叶子节点大小 &#x3D; 页大小。</li></ul></blockquote><p>因为</p><p>1 B+树的节点，即非叶子节点大小 &#x3D; 页大小</p><p>2 读取一页需要一次IO</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231023105000623.png" alt="image-20231023105000623"></p><h4 id="有哪些线程安全的容器？"><a href="#有哪些线程安全的容器？" class="headerlink" title="有哪些线程安全的容器？"></a>有哪些线程安全的容器？</h4><h5 id="不可变类："><a href="#不可变类：" class="headerlink" title="不可变类："></a>不可变类：</h5><ul><li>String：String的各个substring、replace、reverse 等方法都是重新new一个String对象，不会改变源对象，而且用final修饰，不会有子类覆盖String的方法，不会出现线程安全问题</li><li>Integer 类似String</li><li>Random 类似String</li></ul><h5 id="遗留的线程安全集合"><a href="#遗留的线程安全集合" class="headerlink" title="遗留的线程安全集合"></a>遗留的线程安全集合</h5><ul><li>StringBuﬀer 对方法加上了synchronized锁，保证线程安全，但是效率比StringBuilder低一些</li><li>Vector 每个方法都加上了synchronized 关键字，串行化执行，效率低下。而且多线程下组合调用这些方法还是会出现线程不安全。</li><li>Hashtable： 每个方法都加上了synchronized 关键字，串行化执行，效率低下。而且多线程下组合调用这些方法还是会出现线程不安全。</li></ul><h5 id="经过修饰的线程安全的集合"><a href="#经过修饰的线程安全的集合" class="headerlink" title="经过修饰的线程安全的集合"></a>经过修饰的线程安全的集合</h5><ul><li>synchronizedList 、synchronizedMap 、 synchronizedSet等等， 把不安全的list、map、set等作为构造的参数， 其方法使用synchronized(mutex) {map.get();} 使用的还是原本集合中的方法，但是通过synchronized和信号量来实现同步</li></ul><h5 id="java-util-concurrent-包下的类"><a href="#java-util-concurrent-包下的类" class="headerlink" title="java.util.concurrent 包下的类"></a>java.util.concurrent 包下的类</h5><ul><li><p>concurrentHashMap。</p></li><li><p>BlockingQueue的实现类:阻塞队列（<code>BlockingQueue</code>）被广泛使用在“生产者-消费者”问题中，其原因是 <code>BlockingQueue</code> 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p></li><li><p>copyOnWriteArrayList: <code>CopyOnWriteArrayList</code> 中的读取操作是完全无需加锁的。更加厉害的是，写入操作也不会阻塞读取操作，只有写写才会互斥。这样一来，读操作的性能就可以大幅度提升。</p></li></ul><p>线程安全的类不一定能保证线程安全，只能保证单个方法执行是线程安全的，但是多个方法的组合还是会出现不安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">concurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.get(str);</span><br><span class="line"><span class="comment">//在此处时间片结束，线程不安全</span></span><br><span class="line">map.put(str,count == <span class="number">0</span> : <span class="number">1</span> ? count + <span class="number">1</span>);;</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="CopyOnWriteArrayList详情"><a href="#CopyOnWriteArrayList详情" class="headerlink" title="CopyOnWriteArrayList详情"></a>CopyOnWriteArrayList详情</h4><p><code>CopyOnWriteArrayList</code> 线程安全的核心在于其采用了 <strong>写时复制（Copy-On-Write）</strong> 的策略，<strong>采用读写分离的思想</strong></p><p>当需要修改（ <code>add</code>，<code>set</code>、<code>remove</code> 等操作） <code>CopyOnWriteArrayList</code> 的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将原容器的引用指向新的容器，这样就可以保证写操作不会影响读操作了。</p><ul><li>在修改数组时(add、remove、set),需要先获取锁，实现多线程写同步</li><li>读的时候不需要加锁，如果读的时候多个线程正在修改数据，读操作还是会读到旧的数据，因为在读的那一刻就已经确定了读的对象是旧对象。</li></ul><p><strong>适用于读多写少的并发场景</strong>：如白名单、黑名单、商品类目的访问和变更等</p><p><strong>缺点</strong></p><p><strong>内存占用问题</strong>。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p><p>　　针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如<a href="http://ifeve.com/concurrenthashmap/">ConcurrentHashMap</a>。</p><p>　　<strong>数据一致性问题</strong>。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p><h4 id="线程不安全的集合"><a href="#线程不安全的集合" class="headerlink" title="线程不安全的集合"></a>线程不安全的集合</h4><ul><li>HashMap</li><li>HashSet</li><li>ArrayList:put方法中，elementData[size++] &#x3D; e，不是一个原子操作</li><li>LinkedList:add方法可能出现指针指向错误节点</li></ul><h4 id="List、Map、Set能不能存NULL？"><a href="#List、Map、Set能不能存NULL？" class="headerlink" title="List、Map、Set能不能存NULL？"></a>List、Map、Set能不能存NULL？</h4><h5 id="List-——-允许为null"><a href="#List-——-允许为null" class="headerlink" title="List —— 允许为null"></a><strong>List —— 允许为null</strong></h5><ul><li>ArrayList底层是数组，可以添加null</li><li>LinkedList底层是双向链表，可以node.value &#x3D; null</li><li>Vector底层是数组，可以存储NULL</li></ul><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h5><ul><li>HashMap只允许有一个key为null的节点，因为Map的key相同，后面节点会替换相同key的节点，可以有多个value为null的节点，当key为null，计算出的hash值为0，放在第一个桶中。可以有多个value为null的节点，这是因为 HashMap 的设计是给单线程使用的，所以如果查询到了 null 值，我们可以通过 hashMap.containsKey(key) 的方法来区分这个 null 值到底是存入的 null？还是压根不存在的 null？这样二义性问题就得到了解决，所以 HashMap 不怕二义性问题。</li><li>TreeMap会调用compareTo方法，当对象为null，会报空指针</li><li>HashTable底层为散列表，需要对value进行判空，会调用key.hashCode()来计算桶的位置，key和value都不能为空。</li></ul><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h5><ul><li>HashSet底层是HashMap，可以有一个key为NULL的元素。</li><li>LinkedHashSet底层也是HashMap，允许一个key为NULL</li><li>TreeSet底层是TreeMap，底层是红黑树，需要对节点的value进行比对排序，不能有key为null的元素</li></ul><h4 id="ConcurrentHashMap为什么key和value都不能存入null？"><a href="#ConcurrentHashMap为什么key和value都不能存入null？" class="headerlink" title="ConcurrentHashMap为什么key和value都不能存入null？"></a>ConcurrentHashMap为什么key和value都不能存入null？</h4><p>从代码层面来看：ConcurrentHashMap在put方法的起始位置就判断Key和Value是否为空，如果是就抛出空指针异常。</p><p><code>ConcurrentHashMap</code> 的 key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，表示没有对象或没有引用。（如果你用 null 作为键，那么你就无法区分这个键是否存在于 <code>ConcurrentHashMap</code> 中，还是根本没有这个键。）同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储<code>ConcurrentHashMap</code> 中的，还是因为找不到对应的键而返回的。</p><p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p><ul><li>值没有在集合中 ；</li><li>值本身就是 null。</li></ul><p>这也就是二义性的由来。</p><p>多线程环境下，存在一个线程操作该 <code>ConcurrentHashMap</code> 时，其他的线程将该 <code>ConcurrentHashMap</code> 修改的情况，所以无法通过 <code>containsKey(key)</code> 来判断否存在这个键值对，也就没办法解决二义性问题了。</p><p>与此形成对比的是，<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入 null 作为参数，就会返回 hash 值为 0 的位置的值。HashMap 的设计是给单线程使用的，所以如果取到 null（空） 值，我们可以通过HashMap 的 containsKey(key)方 法来区分这个 null（空） 值到底是插入值是 null（空），还是本就没有才返回的 null（空） 值。单线程环境下，不存在一个线程操作该 HashMap 时，其他的线程将该 <code>HashMap</code> 修改的情况，所以可以通过 <code>contains(key)</code>来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。</p><p>也就是说，多线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。</p><p>如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>举个例子，现在有线程 T1 调用了 ConcurrentHashMap 的 containsKey(key) 方法，<br>我们期望返回的结果是 false，也就是说，T1 并没有往 ConcurrentHashMap 中 put null（空）值。<br>但是，恰恰出了个意外，在线程 T1 还没有得到返回结果之前，线程 T2 又调用了<br>ConcurrentHashMap 的 put() 方法，插入了一个 Key，并且存入的 Value 是 null（空） 值。那么，线程 T1 最终得到的返回结果就变成 true 了。</p><h4 id="Map的遍历方式"><a href="#Map的遍历方式" class="headerlink" title="Map的遍历方式"></a>Map的遍历方式</h4><p>1）在 for 循环中使用 entries 实现 Map 的遍历（最常见和最常用的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;Java入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;C语言入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapKey</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapValue</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        System.out.println(mapKey + <span class="string">&quot;：&quot;</span> + mapValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）使用 for-each 循环遍历 key 或者 values，一般适用于只需要 Map 中的 key 或者 value 时使用。性能上比 entrySet 较好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Java入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;C语言入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line"><span class="comment">// 打印键集合</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印值集合</span></span><br><span class="line"><span class="keyword">for</span> (String value : map.values()) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）使用迭代器（Iterator）遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Java入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;C语言入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;    </span><br><span class="line">    Entry&lt;String, String&gt; entry = entries.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;:&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）通过键找值遍历，这种方式的效率比较低，因为本身从键取值是耗时的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hash怎么扩容有了解吗？"><a href="#hash怎么扩容有了解吗？" class="headerlink" title="hash怎么扩容有了解吗？"></a>hash怎么扩容有了解吗？</h4><ul><li>HashMap的底层是采用数组来存储数据，当 HashMap 中元素个数超过（大于）临界值时会自动触发扩容，这个临界值有一个计算公式。</li><li>threashold&#x3D;loadFactor*capacity。loadFactor 的默认值是 0.75，capacity 的默认值是 16。当元素个数超过临界值就会触发Hash扩容（resize函数），默认扩容的大小是原来数组长度的 2 倍，HashMap 的最大容量是Integer.MAX_VALUE，也就是 2 的 31 次方-1。</li><li>然后会进行数据迁移，会伴随着一次重新 hash 分配（reHash),是非常耗时的，并且会遍历 hash 表中所有的元素，HasMap让容量为2的幂次方，就是方便数据迁移，元素的位置是  元素的hash&amp;（n - 1），此时n是全为1的二进制数，那么元素根据hash值的的位置要么不变，要么加上原来的长度, 底层的行为都是给 table 赋值一个两倍长度的新数组。</li></ul><h4 id="为什么扩容因子是-0-75？"><a href="#为什么扩容因子是-0-75？" class="headerlink" title="为什么扩容因子是 0.75？"></a>为什么扩容因子是 0.75？</h4><p>扩容因子表示 Hash 表中元素的填充程度，扩容因子的值越大，那么触发扩容的元素个数更多，<br>虽然空间利用率比较高，但是 hash 冲突的概率会增加。<br>扩容因子的值越小，触发扩容的元素个数就越少，也意味着 hash 冲突的概率减少，<br>但是对内存空间的浪费就比较多，而且还会增加扩容的频率。<br>因此，扩容因子的值的设置，本质上就是在 冲突的概率 以及 空间利用率之间的平衡。<br>0.75 这个值的来源，和统计学里面的泊松分布有关。</p><p>当扩容因子在 0.75 的时候，链表长度达到 8 的可能性几乎为 0，也就是比较好的达到了空间成本和时间成本的平衡。</p><h4 id="HashMap的Hash值如何计算"><a href="#HashMap的Hash值如何计算" class="headerlink" title="HashMap的Hash值如何计算"></a>HashMap的Hash值如何计算</h4><p> <strong>h &#x3D; (key.hashCode ()) ^ (key.hashCode()&gt;&gt;16)</strong>,让hashCode的高16位和低16位进行异或，这样可以让hash值得散列度更高，尽可能区减少hash冲突的情况，从而去提升数据查找性能。</p><h4 id="HashMap为什么一定大小要是2的幂次方？"><a href="#HashMap为什么一定大小要是2的幂次方？" class="headerlink" title="HashMap为什么一定大小要是2的幂次方？"></a>HashMap为什么一定大小要是2的幂次方？</h4><p>HashMap为了提高存取效率，减少hash冲突，就是要尽量把数据分配均匀，使得每个链表长度大致相同，就可以通过hash值 % 数组长度 来实现。<br>但直接取模运算的效率不如位运算&amp;，当容量为2的n次方时，hash &amp; (capacity - 1) &#x3D;&#x3D; hash % capacity，通过 hash &amp; (capacity - 1) 来替代取模运算，而前提就是容量必须为2的n次方。</p><h4 id="HashMap怎么解决hash冲突的"><a href="#HashMap怎么解决hash冲突的" class="headerlink" title="HashMap怎么解决hash冲突的"></a>HashMap怎么解决hash冲突的</h4><p>hash 冲突问题 : 也就是两个不同 hash 值的 key，最终&amp;运算会落到同一个数组下标。所以 HashMap 引入了链式寻址法来解决 hash 冲突问题， 对于存在冲突的key，HashMap 把这些 key 组成一个单向链表。然后采用尾插法把这个 key 保存到链表的尾部。另外，为了避免链表过长的问题，当链表长度大于 8 并且数组长度大于等于 64 的时候，HashMap 会把链表转化为红黑树,从而减少链表数据查询的时间复杂度问题，提升查询性能</p><p>解决 hash 冲突问题的方法有很多，比如</p><ul><li>再 hash 法，就是如果某个 hash 函数产生了冲突，再用另外一个 hash 进行计算，</li><li>开放寻址法，就是直接从冲突的数组位置往下寻找一个空的数组下标进行数据存储，(这个在 ThreadLocal 里面有使用到)。</li><li>建立公共溢出区，也就是把存在冲突的 key 统一放在一个公共溢出区里面。</li></ul><h4 id="为什么HashMap将链表转化为红黑树的阈值是8？"><a href="#为什么HashMap将链表转化为红黑树的阈值是8？" class="headerlink" title="为什么HashMap将链表转化为红黑树的阈值是8？"></a>为什么HashMap将链表转化为红黑树的阈值是8？</h4><p>这是因为在实践中，当链表中的元素数量达到8时，使用红黑树进行查找的效率会超过链表。具体来说，当链表中的元素数量为8时，平均查找长度为8&#x2F;2&#x3D;4。而红黑树的平均查找长度为log(8)，大约是3。因此，将链表转换为红黑树可以提高查找效率。</p><p>然而，红黑树并不是在所有情况下都比链表更优。当红黑树中的元素数量较少时，树结构的维护成本会变得相对较高。这是因为每次插入或删除元素，都可能需要调整树的平衡。因此，当红黑树中的元素数量减少到一定程度时，HashMap会将其转换回链表。在JDK 1.8的实现中，这个阈值是6。</p><p>为何选择6作为红黑树转换回链表的阈值呢？这是因为在实践中，当红黑树中的元素数量小于等于6时，使用链表进行查找的效率会超过红黑树。具体来说，当红黑树中的元素数量为6时，平均查找长度为log(6)，大约是2.58。而链表的平均查找长度为6&#x2F;2&#x3D;3。因此，将红黑树转换回链表可以提高效率。 同时，选择6相比于7和8能避免频繁发生链表和红黑树的转换，造成大量性能消耗</p><h4 id="HashMap在多线程情况下会产生哪些问题？会产生死锁吗？"><a href="#HashMap在多线程情况下会产生哪些问题？会产生死锁吗？" class="headerlink" title="HashMap在多线程情况下会产生哪些问题？会产生死锁吗？"></a>HashMap在多线程情况下会产生哪些问题？会产生死锁吗？</h4><ul><li>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</li><li>为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题。并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</li></ul><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><ul><li><p>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。</p><p>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。</p><p>随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</p></li><li><p>还有一种情况是这两个线程同时 <code>put</code> 操作导致 <code>size</code> 的值不正确，进而导致数据覆盖的问题：</p><ol><li>线程 1 执行 <code>if(++size &gt; threshold)</code> 判断时，假设获得 <code>size</code> 的值为 10，由于时间片耗尽挂起。</li><li>线程 2 也执行 <code>if(++size &gt; threshold)</code> 判断，获得 <code>size</code> 的值也为 10，并将元素插入到该桶位中，并将 <code>size</code> 的值更新为 11。</li><li>随后，线程 1 获得时间片，它也将元素放入桶位中，并将 size 的值更新为 11。</li><li>线程 1、2 都执行了一次 <code>put</code> 操作，但是 <code>size</code> 的值只增加了 1，也就导致实际上只有一个元素被添加到了 <code>HashMap</code> 中。</li></ol></li></ul><h4 id="说一说HashMap-get元素的完整流程"><a href="#说一说HashMap-get元素的完整流程" class="headerlink" title="说一说HashMap get元素的完整流程"></a>说一说HashMap get元素的完整流程</h4><p>先计算key的hashcode值，然后计算key的hash值，通过（n - 1） &amp; hash 找到对应的桶的位置。</p><ul><li><p>如果位置上没有结点，直接返回null。</p></li><li><p>有结点，判断头结点的hash值是否等于key的hash值</p><ul><li><p>hash值相等，继续用 “&#x3D;&#x3D;” 和equals（）判断key是否相等，相等就返回</p></li><li><p>hash值不相等，遍历整个链表或者红黑树结点，还是判断hash值和key是否相等</p></li><li><p>头结点hash值 &lt; 0, 说明map正在扩容，需要到新的table中用一个 find() 方法去查找</p></li></ul></li></ul><h4 id="说一说HashMap-put元素的完整流程"><a href="#说一说HashMap-put元素的完整流程" class="headerlink" title="说一说HashMap put元素的完整流程"></a>说一说HashMap put元素的完整流程</h4><ol><li>根据key的hashcode 获得hash值（hashcode ^ (hashcode  &gt;&gt;&gt; 16)),也就是高十六位与低十六位进行异或运算</li><li>通过hash &amp; (n - 1) 找到对应桶的位置</li><li>如果桶为空，就直接put</li><li>如果桶不为空就遍历桶中所有元素，通过比较hashcode –&gt; “&#x3D;&#x3D;”判断 –&gt;equals 判断是否已存在，存在就更新value值， 不存在，就插入，size++     </li><li>判断是否需要转化为红黑树，是否需要扩容</li></ol><h4 id="ConcurrentHashMap为什么能保证线程安全？"><a href="#ConcurrentHashMap为什么能保证线程安全？" class="headerlink" title="ConcurrentHashMap为什么能保证线程安全？"></a>ConcurrentHashMap为什么能保证线程安全？</h4><p>添加元素时首先会判断容器是否为空，</p><ul><li><p>如果为空则使用 volatile 加 CAS 来初始化，防止多个线程同时初始化，造成并发问题，</p></li><li><p>如果容器不为空，则根据存储的元素计算该位置是否为空。</p><ul><li><p>如果根据存储的元素计算结果桶为空，则利用 CAS 设置该节点，避免并发冲突；</p></li><li><p>如果根据存储的元素计算桶为空不为空，则使用 synchronized 锁住这个桶链表的头结点，然后，遍历桶中的数据，根据hash值与key，更新或新增节点到桶中，</p></li><li><p>如果桶中头结点的hash值为 MOVED（-1），就说明map正在进行扩容，此时会锁住这个桶中的链表来帮助扩容，避免扩容的并发问题，等待扩容完成再put入新的table</p></li><li><p>最后再判断是否需要转为红黑树。这样就能保证并发访问时的线程安全了。</p></li></ul></li></ul><p>设置多个累加单元来计算size()的值，防止并发下计数错误。</p><ul><li>当线程竞争不激烈时，直接采用 CAS 对baseCount操作实现元素个数的原子递增。</li><li>如果线程竞争激烈，使用一个数组来维护元素个数，如果要增加总的元素个数，则直接从数组中随机选择一个，再通过 CAS 实现原子递增，之后遍历数组中所有的值与baseCount累加。它的核心思想是引入了数组来实现对并发更新的负载。</li></ul><p>总结： ConcurrentHashMap 通过<strong>对数组头结点加锁</strong>和<strong>加CAS的初始化</strong>来保证线程安全的。</p><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p><strong>特点</strong></p><ul><li>PriorityQueue 的底层是堆，堆的底层是数组</li><li>PriorityQueue中放置的元素必须要能够比较大小 （只有实现了 Comparable 和 Comparator 接口的类才能比较大小），不能插入无法比较大小的对象，否则会抛出 ClassCastException 异常</li><li>不能插入 null 对象，否则会抛出 NullPointerException 异常</li><li>没有容量限制，可以插入任意多个元素，其内部可以自动扩容</li><li>插入和删除元素的时间复杂度均为 O(log2N)</li><li>PriorityQueue底层使用了堆数据结构</li></ul><p>插入&#x2F;删除&#x2F;获取优先级最高的元素</p><table><thead><tr><th align="left">函数名</th><th>功能介绍</th></tr></thead><tbody><tr><td align="left">boolean offer(E e)&#x2F;add()</td><td>插入元素 e，插入成功返回 true，如果 e 对象为空，抛出 NullPointerException 异常，时间复杂度为 O(log2N) ，注意：空间不够时会自动扩容</td></tr><tr><td align="left">E peek()&#x2F;element()</td><td>获取优先级最高的元素，如果优先级队列为空，返回 null</td></tr><tr><td align="left">E poll()&#x2F;remove()</td><td>移除优先级最高的元素并返回，如果优先级队列为空，返回 null</td></tr><tr><td align="left">int size()</td><td>获取有效元素的个数</td></tr><tr><td align="left">void clean()</td><td>清空</td></tr><tr><td align="left">boolean isEmpty()</td><td>检测优先级队列是否为空，空返回 true</td></tr></tbody></table><h4 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h4><p>前提知识：二叉树的顺序存储<br>使用数组存储二叉树的方式，就是将二叉树按照层序遍历放入数组<br>一般只适合完全二叉树，因为非完全二叉树会有空间的浪费<br>这种方式的主要用法就是堆的表示</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知双亲(parent)的下标</span><br><span class="line">左孩子(left)下标 = 2 * parent + 1;</span><br><span class="line">右孩子(right)下标 = 2 * parent + 2;</span><br><span class="line">已知孩子（不区分左右）(child)下标</span><br><span class="line">双亲(parent)下标 = (child - 1) / 2;</span><br></pre></td></tr></table></figure><p><strong>1、概念</strong><br>概括：堆就是一颗顺序存储的完全二叉树，底层是一个数组</p><p>堆逻辑上是一颗完全二叉树</p><p>堆物理上是保存在数组中</p><p>堆满足任意结点的值都大于其子树中结点的值，也就是所有根节点 &gt; 其左右孩子结点，叫做大堆，或者大根堆、最大堆</p><p>反之则是小堆，或者小根堆、最小堆</p><p>堆的基本作用是快速找到集合中的最值</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70-1710494617676-3.png" alt="img"></p><p><strong>2、性质</strong></p><ul><li>堆中某个节点的值总是不大于或不小于其父结点的值</li><li>堆总是一颗完全二叉树</li></ul><p><strong>3、向下调整</strong></p><p>找左右孩子最大值，然后和父亲结点进行交换</p><p><strong>4、建堆</strong></p><p>这里我们从倒数的第一个非叶子节点的子树开始调整，一直调整到根节点的树，就可以调整成堆。</p><p>具体做法就是，从最后一个非叶子结点子树开始，比较左右孩子结点，较大的孩子结点和父亲结点比较，比父亲结点大的话就进行交换，直到这棵子树已经成了一个堆<br>    <img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70-1710494806954-6.jpeg" alt="img"></p><p><strong>插入一个元素</strong></p><ul><li><strong>过程（以大堆为例）：</strong></li></ul><ol><li>首先按尾插方式放入数组（空间不够时需要扩容）</li><li>比较其和其双亲的值的大小，如果双亲的值大，则满足堆的性质，插入结束</li><li>否则，交换其和双亲位置的值，重新进行 2、3 步骤（2、3就是向上调整的过程）</li><li>直到根结点</li></ol><ul><li><p><strong>图示</strong><br><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70-1710494847608-9.jpeg" alt="在这里插入图片描述"><br>是一个向上调整的过程</p><p><strong>删除一个元素</strong></p><p>为了防止破坏堆的结构，删除时并不是直接将堆顶元素删除，而是</p><ol><li>用数组的最后一个元素替换堆顶元素 ，usedSize–</li><li>然后从堆顶<strong>0号位置</strong>下标的元素开始，通过<strong>向下调整</strong>方式重新调整成堆<br><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70-1710494869532-12.jpeg" alt="在这里插入图片描述"></li></ol></li></ul><p>​</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h4><p>面向过程：把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。</p><p>面向对象：将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p><p>好处：</p><p><strong>易扩展</strong>：由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，增加或修改业务时，只需要改变小部分代码，使得系统更灵活、更容易扩展，而且成本较低。</p><p><strong>代码复用率高</strong>：可重用现有的已被测试过的类使系统满足业务需求并具有较高的质量。</p><p><strong>效率高</strong>：根据设计的需要对现实世界的事物进行抽象，产生类。使用这样的方法解决问题，接近于日常生活和自然的思考方式，势必提高软件开发的效率和质量。</p><h4 id="Java-基础有哪些核心模块"><a href="#Java-基础有哪些核心模块" class="headerlink" title="Java 基础有哪些核心模块"></a>Java 基础有哪些核心模块</h4><p>这里简单对我觉得 Java 基础比较核心的模块做一下总结：</p><ul><li><strong>异常</strong>：定义了 Java 运行中可能出现的异常，提供了异常处理手段。</li><li><strong>泛型</strong>：使用泛型参数，可以增强代码的可读性以及稳定性。</li><li><strong>反射</strong>：赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</li><li><strong>注解</strong>：可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</li><li><strong>集合</strong>：Java 集合，也叫作容器，可以用于保存数据，主要分为 List, Set, Queue, Map 四大类，这四类分别由不同的用途。</li><li><strong>IO 流</strong>：用于处理输入和输出，比如文件读写。</li><li><strong>多线程</strong>：除了 <code>Thread</code> 类和 <code>Runnable</code> 接口这些基础外，最重要的就是 JUC 了，这个包中包含并发编程中很常用的实用工具类，包括线程池、异步 IO、各种锁等等。</li></ul><h4 id="Java三大特性"><a href="#Java三大特性" class="headerlink" title="Java三大特性"></a>Java三大特性</h4><p><strong>封装</strong></p><blockquote><p>封装指的是属性和方法私有化，根据需要提供setter和getter方法来访问属性。即隐藏具体属性和实现细节，仅对外开放接口，控制程序中属性的访问级别。</p><p>封装目的：增强安全性和简化编程，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员与方法。</p></blockquote><p><strong>继承</strong></p><blockquote><p>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，使用extends关键字实现继承；子类中可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。</p><p>• 继承的出现减少了代码冗余，提高了代码的复用性。<br>• 继承的出现，更有利于功能的扩展。<br>• 继承的出现让类与类之间产生了的关系，为多态的使用提供了前提。</p></blockquote><p><strong>多态</strong></p><blockquote><p>多态就是在声明时使用父类，在实现或调用时使用具体的子类；即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态。</p><p>在 Java 中的体现：父类的引用指向子类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure><p><strong>多态的条件：</strong></p><p><strong>继承</strong>: 在多态中必须存在有继承关系的子类和父类。</p><p><strong>方法重写</strong>: 子类对父类中某些方法进行重新定义,在调用这些方法时就会调用子类的方法。</p><p><strong>向上转型</strong>: 在多态中需要将子类的引用赋给父类对象,只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p></blockquote><blockquote><p>好处：父类变量引用的子类对象不同，执行的方法就不同，实现动态绑定。代码编写更灵活、功能更强大，可维护性和扩展性更好了。<br>弊端：一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法（父类中没有的属性和方法）。</p></blockquote><h4 id="抽象类接口什么不同"><a href="#抽象类接口什么不同" class="headerlink" title="抽象类接口什么不同"></a>抽象类接口什么不同</h4><p><strong>抽象类</strong>：在Java中被abstract关键字修饰的类称为抽象类，被abstract关键字修饰的方法称为抽象方法，抽象方法只有方法的声明，没有方法体。抽象类的特点：</p><p>a、抽象类不能被实例化只能被继承；</p><p>b、包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法，抽象类中可以包含普通方法；</p><p>c、抽象类中的抽象方法的修饰符只能为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），默认为public；</p><p>d、一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类；</p><p>e、抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。</p><p>*<strong>接口*：</strong>Java中接口使用interface关键字修饰，特点为:</p><p>a、接口可以包含变量、方法；变量被隐式指定为public static final，方法被隐式指定为public abstract（JDK1.8之前）；</p><p>b、接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题；</p><p>c、一个类可以实现多个接口；</p><h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a><strong>相同点</strong></h5><p>（1）都不能被实例化 （2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。</p><h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a><strong>不同点</strong></h5><p>（1）接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现（普通方法），方法可在抽象类中实现。</p><p>（2）实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</p><p>（3）接口强调特定功能的实现，而抽象类强调所属关系。</p><h4 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h4><p>深拷贝和浅拷贝是只针对引用数据类型的</p><p><strong>引用拷贝</strong>: 引用拷贝就是直接赋值，只在栈中创建一个新的引用，拷贝引用的地址，所以指向的是堆中同一个对象。</p><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），这个对象有着原始对象属性值的一份精确拷贝。如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。深拷贝会递归拷贝对象所有层级的对象属性和数组元素。深拷贝相比于浅拷贝速度较慢并且花销较大。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111716166.png" alt="image-20231003111716166"></p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111721557.png" alt="image-20231003111721557" style="zoom:150%;" /><h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><p>序列化核心目的是为了解决网络通信之间的对象传输问题。<br>也就是说，如何把当前 JVM 进程里面的一个对象，跨网络传输到另外一个 JVM进程里面。<br>序列化：把内存里面的<strong>对象转化为字节流</strong>，以便用来<strong>实现存储或者传输</strong>。<br>反序列化：根据从<strong>文件或者网络上获取到的对象的字节流</strong>，根据字节流里面保存的<strong>对象描述信息和状态</strong>，重新构建一个新的对象。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111810871.png" alt="image-20231003111810871"></p><p>其次呢，序列化的前提是保证通信双方对于对象的可识别性，所以很多时候，我们会把对象先转化为通用的解析格式，比如 json、xml 等。然后再把他们转化为字节流进行网络传输，从而实现跨平台和跨语言的可识别性。</p><h4 id="Java反射有了解吗？举几个Java反射的应用案例"><a href="#Java反射有了解吗？举几个Java反射的应用案例" class="headerlink" title="Java反射有了解吗？举几个Java反射的应用案例"></a>Java反射有了解吗？举几个Java反射的应用案例</h4><p>反射是java语言的一个特性，<strong>反射功能通常用于检查或修改Java虚拟机运行中（runtime）的应用程序的行为</strong>,它允程序在运行时（注意不是编译的时候），获取任意一个类的成员变量、成员方法和属性,调用任意一个对象的方法和属性,，这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p><ul><li>获取任意类的名称、package信息、所有属性、方法、注解、类型、类加载器等</li><li>获取任意对象的属性，并且能改变对象的属性</li><li>调用任意对象的方法</li><li>判断任意一个对象所属的类</li><li>实例化任意一个类的对象</li><li>通过反射我们可以实现动态装配，降低代码的耦合度,动态代理等。</li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>可以增加程序的灵活性，在运行过程中可以动态对类进行修改和操作</li><li>提高代码复用率，比如动态代理</li><li>可以在运行时轻松获取任意一个类的方法、属性、并且还能通过反射进行动态调用</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>使用反射后，可读性较差</li><li>反射可以绕过一些限制访问的属性和方法，可能会导致一些安全性问题</li><li>反射会涉及动态类型的解析，所以JVM无法对这些代码进行优化，导致性能要比非反射调用更低</li></ul><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>AOP动态代理的场景中，使用动态生成的代理类来提升代码复用性。</li><li>IOC：组件扫描后，用反射来实例化bean对象等</li></ul><h5 id="反射的原理"><a href="#反射的原理" class="headerlink" title="反射的原理"></a>反射的原理</h5><p>通常，java在编译之后，会将Java代码生成为class源文件，JVM启动时，将会载入所有的源文件，并将类信息存放到方法区中；将所有对象实例存放在Java堆中，同时也会保存指向类型信息的指针。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rad5bGx6YGT5aOr,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>以下分两种情况来分析，直接使用类和使用反射的区别，以此理解反射的实现原理。</p><p><strong>直接使用类</strong><br>正常流程下，我们要创建一个类的实例，是一定确定这个类的类型信息的，我们知道这个类的名字、方法、属性等等。我们可以很容易的创建实例，也可以通过实例很容易的获取属性、调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br></pre></td></tr></table></figure><p><strong>使用反射</strong><br>在一个方法中，如果我们不知道在实际运行（runtime）时，它将要处理的对象是谁，它的类型信息是怎么样的，那我们如何访问这个对象或为这个对象创建一个新的实例呢？</p><p>与直接使用类相反，我们需要<strong>先获取到对象在方法区的类型信息</strong>（通过实例对象的getClass方法、全限定类名等限定条件），获取到类型信息后，我们就知道这个类的构造器、属性、方法、注解、子类、父类等等信息了，这个时候，<strong>我们就可以通过这些类型信息来回调处理对象，来完成自己想要的操作了。</strong></p><p><strong>反射在运行时，通过读取方法区中的字节码，来动态的找到其反射的类以及类的方法和属性等（实际上就是在运行时，根据全类型名、对象的getClass()等，在方法区找对应的类）</strong>，用这些类型信息完成对该类实例的操作，其实就是直接使用类的一个逆向使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">void</span> <span class="title function_">reflectMethod</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理这个无法明确类型的实例对象</span></span><br><span class="line">        <span class="comment">// 获取类型信息</span></span><br><span class="line">        Class&lt;?&gt; aClass = obj.getClass();</span><br><span class="line">        Field[] fields = aClass.getFields();</span><br><span class="line">        Method[] methods = aClass.getMethods();</span><br><span class="line">        Annotation[] annotations = aClass.getAnnotations();</span><br><span class="line">        Constructor&lt;?&gt;[] constructors = aClass.getConstructors();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = aClass.getInterfaces();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 操作属性或方法</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> fields[<span class="number">0</span>];</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> field.get(obj); <span class="comment">// 获取obj的属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在实际开发过程会遇到很多这种情况，譬如常用到的Bean属性工具类org.springframework.beans.BeanUtils.copyProperties(Object source, Object target)，在复制对象属性前，它是并不知道source、target这两个对象有什么属性的，那么这个工具类是如何完成属性复制呢？这里其实就用到了反射功能。可以简单了解下流程：</p><ul><li><p>获取target的类型</p></li><li><p>获取target类中属性、getter和setter方法</p></li><li><p>遍历target中的属性，查询source中是否有属性名相同且支持getter和setter的属性</p></li><li><p>通过source.getter.invoke方法读取值</p></li><li><p>最后通过target.setter.invoke(source.getter.invoke) 设置刚刚从source读取的值</p></li><li><p>循环遍历target所有属性后，就完成了整个属性的复制</p></li><li><p>这里只是一个简单的反射运用，感兴趣的可以看看源码</p></li></ul></blockquote><p><strong>总结</strong></p><ul><li><p>直接使用是在运行前就明确类型信息，然后在运行时根据这个类来操作对象；</p></li><li><p>而反射是运行时先拿到对象，根据对象得到方法区中的类型信息后，<strong>再根据属性、方法来操作该对象。</strong></p></li></ul><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p><strong>什么是代理模式</strong></p><p>定义：为其他对象提供一种代理以控制对这个对象的访问。</p><p>如果<strong>根据字节码的创建时机</strong>来分类，可以分为静态代理和动态代理：</p><ul><li>所谓<strong>静态</strong>也就是在<strong>程序运行前</strong>就已经存在代理类的<strong>字节码文件</strong>，代理类和真实主题角色的关系在运行前就确定了。</li><li>而动态代理的源码是在程序运行期间由<strong>JVM</strong>根据<strong>反射</strong>等机制<strong>动态的生成</strong>，所以在运行前并不存在代理类的字节码文件</li></ul><p><strong>静态代理</strong></p><p>我们先通过实例来学习静态代理，然后理解静态代理的缺点，再来学习本文的主角：动态代理</p><p>编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span>;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;查询 selectById&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新 update&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将通过静态代理对 UserServiceImpl 进行功能增强，在调用<code>select</code>和<code>update</code>之前记录一些日志。写一个代理类 UserServiceProxy，代理类需要实现 UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceProxy</span><span class="params">(UserService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        target.select();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        target.update();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;     <span class="comment">// 在执行方法之前执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log start time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;      <span class="comment">// 在执行方法之后执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log end time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userServiceImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceProxy</span>(userServiceImpl);</span><br><span class="line"></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br></pre></td></tr></table></figure><p>通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。</p><p>静态代理的缺点<br>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。</p><p>1、 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</p><ul><li>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致<strong>代理类过于庞大</strong>,方法过多</li><li>新建多个代理类，每个目标对象对应一个代理类，但是这样会<strong>产生过多的代理类</strong></li></ul><p>2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，<strong>不易维护。</strong></p><p><strong>动态代理就是让代理类动态的生成，最常见的就是使用反射实现</strong>，使用反射（依据被代理类、被代理类的所有接口、被代理类的ClassLoader）来加载代理类</p><p>&#x2F;&#x2F;动态代理：使⽤JDK提供的api（InvocationHandler、Proxy实现），此种⽅式实现，要求被代理类必须实现接⼝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayServiceJDKInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"><span class="comment">//⽬标对象即就是被代理对象</span></span><br><span class="line"><span class="keyword">private</span> Object target;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PayServiceJDKInvocationHandler</span><span class="params">( Object target)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//proxy代理对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"> <span class="comment">//1.安全检查</span></span><br><span class="line"> System.out.println(<span class="string">&quot;安全检查&quot;</span>);</span><br><span class="line"> <span class="comment">//2.记录⽇志</span></span><br><span class="line"> System.out.println(<span class="string">&quot;记录⽇志&quot;</span>);</span><br><span class="line"><span class="comment">//3.时间统计开始</span></span><br><span class="line">System.out.println(<span class="string">&quot;记录开始时间&quot;</span>);</span><br><span class="line"><span class="comment">//通过反射调⽤被代理类的⽅法</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"><span class="comment">//4.时间统计结束</span></span><br><span class="line">System.out.println(<span class="string">&quot;记录结束时间&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">PayService target= <span class="keyword">new</span> <span class="title class_">AliPayService</span>();</span><br><span class="line"><span class="comment">//⽅法调⽤处理器</span></span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PayServiceJDKInvocationHandler</span>(target);</span><br><span class="line"><span class="comment">//创建⼀个代理类：通过被代理类、被代理实现的接⼝、⽅法调⽤处理器来创建</span></span><br><span class="line"><span class="type">PayService</span> <span class="variable">proxy</span> <span class="operator">=</span> (PayService) Proxy.newProxyInstance(</span><br><span class="line">target.getClass().getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;PayService.class&#125;,handler);</span><br><span class="line">proxy.pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK动态代理</strong></p><p>从 UserServiceProxy 的代码中我们可以发现：</p><ul><li>UserServiceProxy 继承了 Proxy 类，并且实现了被代理的所有接口，以及equals、hashCode、toString等方法</li><li>由于 UserServiceProxy 继承了 Proxy 类，所以每个代理类都会关联一个 InvocationHandler 方法调用处理器</li><li>类和所有方法都被 <code>public final</code> 修饰，所以代理类只可被使用，不可以再被继承</li><li>每个方法都有一个 Method 对象来描述，Method 对象在static静态代码块中创建，以 <code>m + 数字</code> 的格式命名</li><li>调用方法的时候通过 <code>super.h.invoke(this, m1, args)</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 xxxHandler 对象，它继承 InvocationHandler 类，负责实际的调用处理逻辑</li></ul><p>而 LogHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，<strong>然后通过反射让被代理的对象 target 执行方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    before();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);       <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">    after();</span><br><span class="line">    <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以车站卖票的例子来看</strong></p><pre><code>1. 通过代理对象调用sell()方法2. 根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法3. 代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法，传入调用的方法以及参数4. invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法</code></pre><p>JDK动态代理执行方法调用的过程简图如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-776369e13e295f3c8e33489251bd4927_1440w.webp" alt="img"></p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="Error与Exception的区别"><a href="#Error与Exception的区别" class="headerlink" title="Error与Exception的区别"></a>Error与Exception的区别</h4><p>(1)Error类和Exception类都是继承Throwable类<br>(2)Error（错误）<strong>是系统中的错误</strong>，程序员是不能改变的和处理的，是在<strong>程序编译时出现的错误</strong>，只能通过修改程序才能修正。一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。<br>(3)Exception（异常）表示程序可以处理的异常，<strong>可以捕获且可能恢复</strong>。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。<br><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY5ODU2MQ==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><h4 id="异常顶层是什么，有哪些接口实现类"><a href="#异常顶层是什么，有哪些接口实现类" class="headerlink" title="异常顶层是什么，有哪些接口实现类"></a>异常顶层是什么，有哪些接口实现类</h4><p><strong>Java 异常类层次结构图概览</strong>：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640.png" alt="图片"></p><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong><code>Exception</code></strong>: 程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。</li><li>分为 Checked Exception 非运行时异常（编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义unchecked异常。通俗的话说，就是在写代码时出现红线，需要try catch或者throws时出现的异常。</li><li>Unchecked Exception(运行时异常)，都是RuntimeException类及其子类异常，就是我们在开发中测试功能时程序终止，控制台出现的异常，比如：<br>NullPointerException(空指针异常)<br>IndexOutOfBoundsException(下标越界异常)<br>ClassCastException(类转换异常)<br>ArrayStoreException(数据存储异常，操作数组时类型不一致)<br>IO操作的BufferOverflowException异常</li><li><strong><code>Error</code></strong>: <code>Error</code> 属于程序无法处理的错误 ，不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h4 id="全局异常处理器如何实现？"><a href="#全局异常处理器如何实现？" class="headerlink" title="全局异常处理器如何实现？"></a>全局异常处理器如何实现？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用ControllerAdvice注解标识该类为异常处理类</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常处理，指定该方法处理的异常类型为Exception</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="comment">//将返回的Result转化为Json格式，在controller中已经包含此注解</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">error</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.build(<span class="literal">null</span> , <span class="number">201</span>,<span class="string">&quot;出现了异常&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常处理，指定该方法处理的异常类型为GuiguException</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = GuiguException.class)</span><span class="comment">// 处理自定义异常</span></span><br><span class="line">    <span class="comment">//将返回的Result转化为Json格式，在controller中已经包含此注解</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">error</span><span class="params">(GuiguException exception)</span> &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.build(<span class="literal">null</span> , exception.getResultCodeEnum()) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么情况下会报ClassNotFound的异常？"><a href="#什么情况下会报ClassNotFound的异常？" class="headerlink" title="什么情况下会报ClassNotFound的异常？"></a>什么情况下会报ClassNotFound的异常？</h4><p>当应用程序运行的过程中尝试使用类加载器去加载Class文件的时候，如果没有在classpath中查找到指定的类，就会抛出ClassNotFoundException。一般情况下，当我们使用Class.forName()或者ClassLoader.loadClass以及使用ClassLoader.findSystemClass()在运行时加载类的时候，如果类没有被找到，那么就会导致JVM抛出ClassNotFoundException。</p><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><h4 id="字符流与字节流"><a href="#字符流与字节流" class="headerlink" title="字符流与字节流"></a>字符流与字节流</h4><p><strong>流</strong><br>流是一个抽象的概念，可以看作是一连串的数据，在程序中所有的数据都是以流的方式进行传输或保存的，程序需要数据的时候要使用输入流读取数据，而当程序需要将一些数据保存起来的时候，就要使用输出流完成。程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。</p><p>Java中的流是对字节序列的抽象，我们可以想象有一个水管，只不过现在流动在水管中的不再是水，而是字节序列。和水流一样，Java中的流也具有一个“流动的方向”，通常可以从中读入一个字节序列的对象被称为输入流；能够向其写入一个字节序列的对象被称为输出流。</p><blockquote><p>知识补充1：<br>计算机能存储的唯一东西就是 bytes,为了在计算机中存储东西,我们首先得将其编码(encode),例如将其转化为 bytes。<br>比如：要想保存音乐(以字节形式保存),我们首先得用 MP3, WAV 等将其编码；要想保存图片,我们首先得用 PNG, JPEG 等将其编码；要想保存文本,我们首先得用 ASCII, UTF-8 等将其编码.<br>知识补充2:<br>Unicode 是字符集,不是字符编码。Unicode 把全世界的字符都搜集并且编号了,但是没有规定具体的编码规则。编码规则有 UTF-8、GBK等。</p></blockquote><p><strong>字节流</strong><br>Java中的字节流处理的最基本单位为单个字节，它通常用来处理二进制数据。Java中最基本的两个字节流类是InputStream和OutputStream，它们分别代表了最基本的输入字节流和输出字节流。InputStream是所有字节输入流的祖先，而OutputStream是所有字节输出流的祖先，它们都是抽象类。</p><p><strong>字节流在默认情况下是不支持缓存的，字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，这意味着每调用一次read方法都会请求操作系统来读取一个字节，这往往会伴随着一次磁盘IO</strong>，因此效率会比较低。要使用内存缓冲区以提高读取的效率，我们应该使用BufferedInputStream。</p><p>需注意，使用BufferedOutputStream输出数据时如果没有关闭流，数据也是不会输出到文件当中的，即并不是所有字节流都不用到缓冲区，输入缓冲字节流BufferedInputStream和输出缓冲字节流BufferedOutputStream还是要用到缓冲区的。</p><p><strong>字符流</strong></p><p><strong>为什么要有字符流？</strong></p><p>Java中字符是采用Unicode标准，Unicode 编码中，一个英文为一个字节，一个中文为两个字节。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-bc6b06e4cf29ecb425f56eb3e72d6e40_1440w.webp" alt="img"></p><p>而在UTF-8编码中，一个中文字符是3个字节。例如下面图中，“云深不知处”5个中文对应的是15个字节：-28-70-111-26-73-79-28-72-115-25-97-91-27-92-124</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-d10f2fb7a759d08a233fb04dd7ca7b95_1440w.webp" alt="img"></p><p>那么问题来了，如果使用字节流处理中文，如果一次读写一个字符对应的字节数就不会有问题，一旦将一个字符对应的字节分裂开来，就会出现乱码了。为了更方便地处理中文这些字符，Java就推出了字符流。</p><p>Java中的字符流处理的最基本的单元是Unicode码元（大小2字节），它通常<strong>用来处理文本数据</strong>，例如字符、字符数组或字符串。Java中的String类型默认就把字符以Unicode规则编码而后存储在内存中。存储在磁盘上的数据通常有着各种各样的编码方式，不同的编码方式最终输出的字节内容是不同的，所以，字节流的读取和写入都要<strong>设置相应的编码方式。</strong></p><p>由于<strong>字符流在输出前</strong>实际上是要完成<strong>Unicode码元序列</strong>到相应编码方式的<strong>字节序列的转换</strong>，所以它会使用<strong>内存缓冲区</strong>来存放转换后得到的<strong>字节序列</strong>，等待都转换完毕再一同写入磁盘文件中。</p><p>所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列。</p><p>字符流与字节流的区别：</p><ul><li><p>字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元（通常为两个字节）。<br>字节流默认不使用缓冲区；字符流使用缓冲区(用于保存由字符转化为的字节)。</p></li><li><p>字节流在操作的时候本身是不会用到缓冲区的，是与文件本身直接操作的，所以字节流在操作文件时，即使不关闭资源，文件也能输出；字符流在操作的时候是使用到缓冲区的。如果字符流不调用close或flush方法，则不会输出任何内容。</p></li><li><p>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</p></li><li><p>字节流按字节读数据,而字节不需要编码、解码,只有字节与字符之间转换时才需要编码、解码！</p></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="单例模式（重要）"><a href="#单例模式（重要）" class="headerlink" title="单例模式（重要）"></a>单例模式（重要）</h4><p><strong>何为单例模式</strong><br>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。<br><strong>实现思路</strong><br>如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将 类的构造器的访问权限设置为 private ，这样，就不能用 new 操作符在类的外部产生类的对<br>象了，但在类内部仍可以产生该类的对象。</p><p>因为在类的外部开始还无法得到类的对象， 只能调用该类的某个静态方法 以返回类内部创建的对象，</p><p>静态方法只能访问类中的静态成员变量，所以，指向类内部产生的 该类对象的变量也必须定义成静态的 。</p><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 私有化构造器，防止使用构造器new对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 内部提供一个当前类的实例</span></span><br><span class="line">    <span class="comment">// 4. 此实例也必须静态化，才能让静态方法返回该实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 3. 提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="懒汉式-多线程环境下多个线程同时初始化对象会出现线程安全问题，需要加上类锁"><a href="#懒汉式-多线程环境下多个线程同时初始化对象会出现线程安全问题，需要加上类锁" class="headerlink" title="懒汉式(多线程环境下多个线程同时初始化对象会出现线程安全问题，需要加上类锁)"></a>懒汉式(多线程环境下多个线程同时初始化对象会出现线程安全问题，需要加上类锁)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyOne</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyOne instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyOne</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方式 1 ：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazyOne <span class="title function_">getInstance1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式 2 ：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title function_">getInstance2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazyOne.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式 3 ：存在线程安全问题，当线程1获得锁，new instance并不是一个原子操作</span></span><br><span class="line"><span class="comment">//线程2判断instance不为空可能返回未初始化完成的instance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title function_">getInstance2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyOne.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">                    <span class="comment">//分配空间</span></span><br><span class="line">                    <span class="comment">//初始化</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要解决双重检查锁模式带来空指针异常的问题，只需要使用 `volatile` 关键字, `volatile` 关键字可以保证可见性和有序性。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过静态内部类实现懒汉式单例模式，不需要加锁，较为推荐</strong></p><p>静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder</p><p>并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p><h5 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h5><p>使用<strong>序列化与反序列化</strong>可以生成多个实例对象，会破坏单例设计模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//往文件中写对象</span></span><br><span class="line">        <span class="comment">//writeObject2File();</span></span><br><span class="line">        <span class="comment">//从文件中读取对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断两个反序列化后的对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title function_">readObjectFromFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建对象输入流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//第一个读取Singleton对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeObject2File</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="comment">//创建对象输出流</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//将instance对象写出到文件中</span></span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决</strong>：在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面是为了解决序列化反序列化破解单例模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：反射能够调用private的构造方法，破坏单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的字节码对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Singleton.class;</span><br><span class="line">        <span class="comment">//获取Singleton类的私有无参构造方法对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//取消访问检查</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Singleton类的对象s1</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line">        <span class="comment">//创建Singleton类的对象s2</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断通过反射创建的两个Singleton对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决</strong>：在构造器中添加判断逻辑，如果instance不为空，就抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           反射破解单例模式需要添加的代码</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>饿汉式</strong>：</p><ul><li><strong>特点</strong>： 立即加载 ，即在使用类的时候已经将对象创建完毕。</li><li><strong>优点</strong>：实现起来 简单 ；没有多线程安全问题。</li><li><strong>缺点</strong>：当类被加载的时候，会初始化 static 的实例，静态变量被创建并分配内存空间，从这以后，这个 static 的实例便一直占着这块内存，直到类被卸载时，静态变量被摧毁，并释放所占有的内存。因此在某些特定条件下会 耗费内存 。</li></ul><p><strong>懒汉式</strong>：</p><ul><li><strong>特点</strong>： 延迟加载 ，即在调用静态方法时实例才被创建。</li><li><strong>优点</strong>：实现起来比较简单；当类被加载的时候，static 的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会节约内存 。</li><li><strong>缺点</strong>：在多线程环境中，这种实现方法是完全错误的， 线程不安全 ，需要加锁保证单例的唯一性。</li></ul><p><strong>单例模式的优点及应用场景</strong><br>由于单例模式只生成一个实例，减少了 系统性能开销 ，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时，直接产生一个单例对象，然后永久驻留内存的方式来解决。</p><h4 id="Strategy策略模式"><a href="#Strategy策略模式" class="headerlink" title="Strategy策略模式"></a><strong>Strategy策略模式</strong></h4><p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们之间可以相互替换，策略模式可以在不影响客户端的情况下发生变化。 策略模式是处理算法不同变体的一种成熟模式，策略模式通过接口或抽象类封装算法的标识，即在接口中定义一个抽象方法，实现该接口的类将实现接口中的抽象方法。策略模式把针对一个算法标识的一系列具体算法分别封装在不同的类中，使得各个类给出的具体算法可以相互替换。</p><p>策略模式的结构：</p><ul><li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li></ul><p>【例】促销活动</p><p>一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p>代码如下：</p><p>定义百货公司所有促销活动的共同接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为春节准备的促销活动A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买一送一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为中秋准备的促销活动B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满200元减50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为圣诞准备的促销活动C</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalesMan</span> &#123;                        </span><br><span class="line">    <span class="comment">//持有抽象策略角色的引用                              </span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;                 </span><br><span class="line">                                               </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SalesMan</span><span class="params">(Strategy strategy)</span> &#123;       </span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;              </span><br><span class="line">    &#125;                                          </span><br><span class="line">                                               </span><br><span class="line">    <span class="comment">//向客户展示促销活动                                </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">salesManShow</span><span class="params">()</span>&#123;                </span><br><span class="line">        strategy.show();                       </span><br><span class="line">    &#125;                                          </span><br><span class="line">&#125;                                              </span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p><strong>1，优点：</strong></p><ul><li><p>策略类之间可以自由切换</p><p>由于策略类都实现同一个接口，所以使它们之间可以自由切换。</p></li><li><p>易于扩展</p><p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“</p></li><li><p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想。</p></li></ul><p><strong>2，缺点：</strong></p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li></ul><p><strong>使用场景</strong></p><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li></ul><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><strong>工厂模式</strong></h4><p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。现在在以一个具体的例子来简单简化下工厂模式。假如我现在去餐馆吃饭，餐馆有回锅肉，有鱼，有烤鸭可供我选择，然后我点餐餐馆为我做出具体的菜。</p><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>首先我们来创建一个餐馆的接口,因为这里只要有做菜就行，所以写一个cook的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Resaurant</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来写三个实现类，分别是做回锅肉的，做鱼的，做烤鸭的，用这三个实现类去实现餐馆的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> <span class="keyword">implements</span> <span class="title class_">Resaurant</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来一份烤鸭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">implements</span> <span class="title class_">Resaurant</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来一份红烧鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Meet</span> <span class="keyword">implements</span> <span class="title class_">Resaurant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来一份回锅肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在餐馆已经具备了做回锅肉，做鱼，做烤鸭的功能，但是客人来了并不知道餐馆有这些菜，这时候就需要我们来给餐馆做一个菜单，客人来了就可以根据菜单点餐；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wait</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MEAN_MEET</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MEAN_FISH</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MEAN_DUCK</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Resaurant <span class="title function_">getMean</span><span class="params">(<span class="type">int</span> meantype)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (meantype)&#123;</span><br><span class="line">            <span class="keyword">case</span> MEAN_MEET :</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Meet</span>();</span><br><span class="line">            <span class="keyword">case</span> MEAN_FISH :</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">            <span class="keyword">case</span> MEAN_DUCK :</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>菜单也有了，现在客人来了可以点餐了，假如客人根据菜单点了一份烤鸭，那餐馆就可以直接给客人制作一份美味的烤鸭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//简单工厂模式</span></span><br><span class="line">        <span class="type">Resaurant</span> <span class="variable">resaurant</span> <span class="operator">=</span> Wait.getMean(Wait.MEAN_DUCK);</span><br><span class="line">        resaurant.cook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看执行结果</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-fdb9586dea3ad2f16c5e3ba1289117c1_1440w.webp" alt="img"></p><h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>工厂模式除了简单工厂模式还有工厂方法模式和抽象工厂模式，下面我再已餐馆这个例子给大家扩展一下工厂方法模式。工厂方法模式就是把简单工厂中具体的工厂类，划分成两层：抽象工厂层+具体的工厂子类层。</p><p>首先我们来创建一个抽象工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CookFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Resaurant <span class="title function_">createRestaurant</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建两个具体需要的产品实现类去继承上面这个抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DuckFactory</span> <span class="keyword">extends</span> <span class="title class_">CookFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Resaurant <span class="title function_">createRestaurant</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FishFactory</span> <span class="keyword">extends</span> <span class="title class_">CookFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Resaurant <span class="title function_">createRestaurant</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>烤鸭和鱼都做好了，开始享用吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cook</span> &#123;</span><br><span class="line">    <span class="comment">//工厂方法模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Resaurant</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DuckFactory</span>().createRestaurant();</span><br><span class="line">        duck.cook();</span><br><span class="line">        <span class="type">Resaurant</span> <span class="variable">fish</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FishFactory</span>().createRestaurant();</span><br><span class="line">        fish.cook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下执行结果</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-6f3165566e6db1dc7ac0a40aabd93d9e_1440w.webp" alt="img"></p><p><strong>优点和缺点</strong></p><p>优点：</p><ul><li><strong>一个调用者想创建一个对象，只要知道其名称就可以了。</strong></li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li><li>屏蔽产品的具体实现，调用者只关心产品的接口。</li></ul><p>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p><strong>概述</strong>：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p><p><strong>结构</strong>：原型模式包含如下角色：</p><ul><li>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ul><p>接口类图如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png"></p><p><strong>用原型模式生成“三好学生”奖状</strong></p><p>同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。</p><p>类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F1.png" style="zoom:80%;" /><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奖状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试访问类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        c1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制奖状</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> c1.clone();</span><br><span class="line">        <span class="comment">//将奖状的名字修改李四</span></span><br><span class="line">        c2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>对象的创建非常复杂，可以使用原型模式快捷的创建对象。</li><li>性能和安全要求比较高。</li></ul><h5 id="扩展（深克隆）"><a href="#扩展（深克隆）" class="headerlink" title="扩展（深克隆）"></a>扩展（深克隆）</h5><p>将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奖状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStu</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stu = stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(stu.getName() + <span class="string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line">        c1.setStu(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制奖状</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> c1.clone();</span><br><span class="line">        <span class="comment">//获取c2奖状所属学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> c2.getStu();</span><br><span class="line">        stu1.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断stu对象和stu1对象是否是同一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F2.png" style="zoom:80%;" /><p><font color="red">说明：</font></p><p>​stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，</p><p>可以重写clone方法实现。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// constructors, getters and setters</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) <span class="built_in">super</span>.clone();</span><br><span class="line">        user.setAddress(<span class="built_in">this</span>.address.clone());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用序列化实现深拷贝</p><p>Java提供了序列化的能力，我们可以先将源对象进行序列化，再反序列化生成拷贝对象。但是，使用序列化的前提是拷贝的类（包括其成员变量）需要实现Serializable接口。Apache Commons Lang包对Java序列化进行了封装，我们可以直接使用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String country;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// constructors, getters and setters</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// constructors, getters and setters</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serializableCopy</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;杭州&quot;</span>, <span class="string">&quot;中国&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;大山&quot;</span>, address);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 使用Apache Commons Lang序列化进行深拷贝</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">copyUser</span> <span class="operator">=</span> (User) SerializationUtils.clone(user);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 修改源对象的值</span></span><br><span class="line">    user.getAddress().setCity(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 检查两个对象的值不同</span></span><br><span class="line">    assertNotSame(user.getAddress().getCity(), copyUser.getAddress().getCity());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="序列化为JSON"><a href="#序列化为JSON" class="headerlink" title="序列化为JSON"></a>序列化为JSON</h5><p>Gson可以将对象序列化成JSON，也可以将JSON反序列化成对象，所以我们可以用它进行深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gsonCopy</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;杭州&quot;</span>, <span class="string">&quot;中国&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;大山&quot;</span>, address);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 使用Gson序列化进行深拷贝</span></span><br><span class="line">    <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    <span class="type">User</span> <span class="variable">copyUser</span> <span class="operator">=</span> gson.fromJson(gson.toJson(user), User.class);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 修改源对象的值</span></span><br><span class="line">    user.getAddress().setCity(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 检查两个对象的值不同</span></span><br><span class="line">    assertNotSame(user.getAddress().getCity(), copyUser.getAddress().getCity());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p><strong>定义：</strong></p><p>​运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p><p>【例】俄罗斯方块</p><p>下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.jpeg" style="zoom:60%;" /><p><strong>先来看类图：</strong></p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p><strong>代码如下：</strong></p><p>俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getShape</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方块形状：&quot;</span> + <span class="built_in">this</span>.getShape() + <span class="string">&quot; 颜色：&quot;</span> + color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;L&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, AbstractBox&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BoxFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, AbstractBox&gt;();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">iBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">lBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">oBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OBox</span>();</span><br><span class="line">        map.put(<span class="string">&quot;I&quot;</span>, iBox);</span><br><span class="line">        map.put(<span class="string">&quot;L&quot;</span>, lBox);</span><br><span class="line">        map.put(<span class="string">&quot;O&quot;</span>, oBox);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BoxFactory <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BoxFactory</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BoxFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AbstractBox <span class="title function_">getBox</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优缺点和使用场景"><a href="#优缺点和使用场景" class="headerlink" title="优缺点和使用场景"></a>优缺点和使用场景</h5><p><strong>优点</strong></p><ul><li>极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</li></ul><p><strong>使用场景：</strong></p><ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li></ul><h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p><strong>定义：</strong></p><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p><p>【例】炒菜</p><p>炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">cookProcess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//第一步：倒油</span></span><br><span class="line">        <span class="built_in">this</span>.pourOil();</span><br><span class="line">        <span class="comment">//第二步：热油</span></span><br><span class="line">        <span class="built_in">this</span>.heatOil();</span><br><span class="line">        <span class="comment">//第三步：倒蔬菜</span></span><br><span class="line">        <span class="built_in">this</span>.pourVegetable();</span><br><span class="line">        <span class="comment">//第四步：倒调味料</span></span><br><span class="line">        <span class="built_in">this</span>.pourSauce();</span><br><span class="line">        <span class="comment">//第五步：翻炒</span></span><br><span class="line">        <span class="built_in">this</span>.fry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;倒油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：热油是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heatOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;热油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：倒调味料是不一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五步：翻炒是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;炒啊炒啊炒到熟啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_BaoCai</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是包菜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是辣椒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_CaiXin</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是菜心&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是蒜蓉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//炒手撕包菜</span></span><br><span class="line">        <span class="type">ConcreteClass_BaoCai</span> <span class="variable">baoCai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass_BaoCai</span>();</span><br><span class="line">        baoCai.cookProcess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//炒蒜蓉菜心</span></span><br><span class="line">        <span class="type">ConcreteClass_CaiXin</span> <span class="variable">caiXin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass_CaiXin</span>();</span><br><span class="line">        caiXin.cookProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：为防止恶意操作，一般模板方法都加上 final 关键词。</p></blockquote><p><strong>优点：</strong></p><ul><li><p>提高代码复用性</p><p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p></li><li><p>实现了反向控制</p><p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。</p></li></ul><p><strong>缺点：</strong></p><ul><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li></ul><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><p><strong>定义：</strong></p><p>​指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p><p><strong>例子</strong></p><p>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。</p><p>使用继承的方式存在的问题：</p><ul><li><p>扩展性不好</p><p>如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。</p></li><li><p>产生过多的子类</p></li></ul><p>我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.png" style="zoom:75%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快餐接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> price;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">(<span class="type">float</span> price, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">float</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDesc</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span>;  <span class="comment">//获取价格</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒饭</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRice</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedRice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">10</span>, <span class="string">&quot;炒饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedNoodles</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedNoodles</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">12</span>, <span class="string">&quot;炒面&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配料类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Garnish</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FastFood fastFood;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FastFood <span class="title function_">getFastFood</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFastFood</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Garnish</span><span class="params">(FastFood fastFood, <span class="type">float</span> price, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(price,desc);</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鸡蛋配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Egg</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Egg</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(fastFood,<span class="number">1</span>,<span class="string">&quot;鸡蛋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//培根配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bacon</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bacon</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(fastFood,<span class="number">2</span>,<span class="string">&quot;培根&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//点一份炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">&quot; &quot;</span> + food.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加鸡蛋的炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line"></span><br><span class="line">        food1 = <span class="keyword">new</span> <span class="title class_">Egg</span>(food1);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food1.getDesc() + <span class="string">&quot; &quot;</span> + food1.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加培根的炒面</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedNoodles</span>();</span><br><span class="line">        food2 = <span class="keyword">new</span> <span class="title class_">Bacon</span>(food2);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food2.getDesc() + <span class="string">&quot; &quot;</span> + food2.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>好处：</strong></p><ul><li><p>装饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</p></li><li><p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p></li></ul><p><strong>使用场景</strong></p><ul><li><p>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</p><p>不能采用继承的情况主要有两类：</p><ul><li>第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；</li><li>第二类是因为类定义不能继承（如final类）</li></ul></li><li><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p></li><li><p>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</p></li></ul><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p><strong>定义</strong>：又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p>【例】现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。</p><p>类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请假条</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//请假天数</span></span><br><span class="line">    <span class="keyword">private</span> String content;<span class="comment">//请假内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeaveRequest</span><span class="params">(String name, <span class="type">int</span> num, String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理者抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_ONE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_THREE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_SEVEN</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该领导处理的请假天数区间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//领导上面还有领导</span></span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围 上不封顶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart, <span class="type">int</span> numEnd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">        <span class="built_in">this</span>.numEnd = numEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置上级领导</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(Handler nextHandler)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交请假条</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(LeaveRequest leave)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">this</span>.numStart)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果请假天数达到该领导者的处理要求</span></span><br><span class="line">        <span class="keyword">if</span>(leave.getNum() &gt;= <span class="built_in">this</span>.numStart)&#123;</span><br><span class="line">            <span class="built_in">this</span>.handleLeave(leave);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果还有上级 并且请假天数超过了当前领导的处理范围</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> != <span class="built_in">this</span>.nextHandler &amp;&amp; leave.getNum() &gt; numEnd)&#123;</span><br><span class="line">                <span class="built_in">this</span>.nextHandler.submit(leave);<span class="comment">//继续提交</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;流程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各级领导处理请假条方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小组长</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupLeader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//小组长处理1-3天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_ONE, Handler.NUM_THREE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小组长审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//部门经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理3-7天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_THREE, Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;部门经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GeneralManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理7天以上的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//请假条来一张</span></span><br><span class="line">        <span class="type">LeaveRequest</span> <span class="variable">leave</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="string">&quot;小花&quot;</span>,<span class="number">5</span>,<span class="string">&quot;身体不适&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//各位领导</span></span><br><span class="line">        <span class="type">GroupLeader</span> <span class="variable">groupLeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>();</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        <span class="type">GeneralManager</span> <span class="variable">generalManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralManager</span>();</span><br><span class="line"></span><br><span class="line">        groupLeader.setNextHandler(manager);<span class="comment">//小组长的领导是部门经理</span></span><br><span class="line">        manager.setNextHandler(generalManager);<span class="comment">//部门经理的领导是总经理</span></span><br><span class="line">        <span class="comment">//之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交申请</span></span><br><span class="line">        groupLeader.submit(leave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p><strong>优点：</strong></p><ul><li><p>降低了对象之间的耦合度</p><p>该模式降低了请求发送者和接收者的耦合度。</p></li><li><p>增强了系统的可扩展性</p><p>可以根据需要增加新的请求处理类，满足开闭原则。</p></li><li><p>增强了给对象指派职责的灵活性</p><p>当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。</p></li><li><p>责任链简化了对象之间的连接</p><p>一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</p></li><li><p>责任分担</p><p>每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</p></li></ul><p><strong>缺点：</strong></p><ul><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li></ul><p>使用案例：Filter的链式调用</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p><strong>定义：</strong></p><p>又被称为发布-订阅（Publish&#x2F;Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><p><strong>结构</strong></p><ul><li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li><li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li><li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li><li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li></ul><p>【例】微信公众号</p><p>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。</p><p>类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p>代码如下：</p><p>定义抽象观察者类，里面定义一个更新的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体观察者类，微信用户是观察者，里面实现了更新的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeixinUser</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 微信用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeixinUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象主题类，提供了attach、detach、notify三个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//增加订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通知订阅者更新消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//储存订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; weixinUserlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserlist.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserlist.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : weixinUserlist) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SubscriptionSubject mSubscriptionSubject=<span class="keyword">new</span> <span class="title class_">SubscriptionSubject</span>();</span><br><span class="line">        <span class="comment">//创建微信用户</span></span><br><span class="line">        WeixinUser user1=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;孙悟空&quot;</span>);</span><br><span class="line">        WeixinUser user2=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;猪悟能&quot;</span>);</span><br><span class="line">        WeixinUser user3=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;沙悟净&quot;</span>);</span><br><span class="line">        <span class="comment">//订阅公众号</span></span><br><span class="line">        mSubscriptionSubject.attach(user1);</span><br><span class="line">        mSubscriptionSubject.attach(user2);</span><br><span class="line">        mSubscriptionSubject.attach(user3);</span><br><span class="line">        <span class="comment">//公众号更新发出消息给订阅的微信用户</span></span><br><span class="line">        mSubscriptionSubject.notify(<span class="string">&quot;传智黑马的专栏更新了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p><strong>优点：</strong></p><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】</li></ul><p><strong>缺点：</strong></p><ul><li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时</li><li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</li></ul><p><strong>使用场景</strong></p><ul><li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。</li></ul><h3 id="JDK新特性"><a href="#JDK新特性" class="headerlink" title="JDK新特性"></a>JDK新特性</h3><h5 id="JDK1-8的新特性"><a href="#JDK1-8的新特性" class="headerlink" title="JDK1.8的新特性:"></a><strong>JDK1.8的新特性:</strong></h5><ol><li><p>stream流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;gkh&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="comment">//返回符合条件的stream</span></span><br><span class="line">    Stream&lt;String&gt; stringStream = strings.stream().filter(s -&gt; <span class="string">&quot;abc&quot;</span>.equals(s));</span><br><span class="line">    <span class="comment">//计算流符合条件的流的数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringStream.count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//forEach遍历-&gt;打印元素</span></span><br><span class="line">    strings.stream().forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>2、Lambda 表达式<br>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、函数式接口</p><p>Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p><p>4、方法与构造函数引用</p><p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">converter = something::startsWith;</span><br><span class="line"><span class="type">String</span> <span class="variable">converted</span> <span class="operator">=</span> converter.convert(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">System.out.println(converted);</span><br></pre></td></tr></table></figure><ol start="5"><li>日期 Date-timeAPI</li></ol><ul><li>增强了时区处理</li><li>增强各种格式化、和时间计算</li></ul><h5 id="JDK9新特性"><a href="#JDK9新特性" class="headerlink" title="JDK9新特性"></a>JDK9新特性</h5><ol><li><p>JShell，为 Java 提供了类似于 Python 的实时命令行交互工具。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111847441.png" alt="image-20231003111847441"></p></li><li><p>String 改为用byte[]存储。</p></li></ol><h5 id="jdk10新特性"><a href="#jdk10新特性" class="headerlink" title="jdk10新特性"></a>jdk10新特性</h5><p><strong>局部变量类型推断(var)</strong>***</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">id</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">codefx</span> <span class="operator">=</span>newURL(<span class="string">&quot;https://mp.weixin.qq.com/&quot;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span>newArrayList&lt;&gt;();</span><br><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span>List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h5 id="JDK11新特性"><a href="#JDK11新特性" class="headerlink" title="JDK11新特性"></a>JDK11新特性</h5><h5 id="String增强"><a href="#String增强" class="headerlink" title="String增强"></a>String增强</h5><p>增加了一系列的字符串处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断字符串是否为空</span></span><br><span class="line"><span class="string">&quot; &quot;</span>.isBlank();<span class="comment">//true</span></span><br><span class="line"><span class="comment">//去除字符串首尾空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.strip();<span class="comment">// &quot;Java&quot;</span></span><br><span class="line"><span class="comment">//去除字符串首部空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.stripLeading();   <span class="comment">// &quot;Java &quot;</span></span><br><span class="line"><span class="comment">//去除字符串尾部空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.stripTrailing();  <span class="comment">// &quot; Java&quot;</span></span><br><span class="line"><span class="comment">//重复字符串多少次</span></span><br><span class="line"><span class="string">&quot;Java&quot;</span>.repeat(<span class="number">3</span>);             <span class="comment">// &quot;JavaJavaJava&quot;</span></span><br><span class="line"><span class="comment">//返回由行终止符分隔的字符串集合。</span></span><br><span class="line"><span class="string">&quot;A\nB\nC&quot;</span>.lines().count();    <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;A\nB\nC&quot;</span>.lines().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2024/04/19/JVM/"/>
      <url>/2024/04/19/JVM/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM分区"><a href="#JVM分区" class="headerlink" title="JVM分区"></a>JVM分区</h3><h4 id="jvm堆的分区"><a href="#jvm堆的分区" class="headerlink" title="jvm堆的分区"></a>jvm堆的分区</h4><p>堆中有字符串常量池</p><p>Java堆从GC的角度可以细分为新生代YoungGeneration（Eden区、From Survivor、To Survivor，空间比例8:1:1）和老年代OldGeneration（空间比例1:2）。</p><p><img src="/./../imgs/JVM/v2-108fca6ca82b85d2d6f559d0d469c770_1440w.webp" alt="img"></p><h4 id="jvm各种区域介绍"><a href="#jvm各种区域介绍" class="headerlink" title="jvm各种区域介绍"></a>jvm各种区域介绍</h4><p><strong>Java内存区域</strong></p><p>Java的内存区域和内存模型是不一样的东西，内存区域是指 JVM 运行时将数据分区域存储，强调对内存空间的划分。</p><p>Java内存区域主要由栈、堆、方法区组成</p><p><strong>栈</strong>：每个线程有自己独立、不共享的虚拟机栈，由多个栈帧（每个方法运行时需要的内存）组成，其中存放参数、局部变量，返回地址等，每个线程只能有一个活动栈帧，对应当前正在执行的那个方法。</p><p><strong>堆</strong>：多个线程共享同一个堆，通过new关键字构建的对象都需要使用堆内存，里面存放了实例对象、字符串常量池，类对象、静态变量（存放在_java_mirror后面）等。</p><p><strong>方法区</strong>：保存在着被加载过的每一个类的信息，包括类的方法、构造器，成员方法，属性等，这些信息由<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">类加载</a>器在加载类时，从类的源文件中抽取出来；<strong>运行时常量池</strong>：当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址转换为真实地址。</p><p><strong>程序计数器：</strong>每个线程都有一个独立的程序计数器，记录下一条JVM指令的执行地址</p><p><strong>本地方法栈：</strong>调用本地方法（由C或者C++编写的底层的方法，与操作系统的底层API打交道）时给本地方法提供的内存空间</p><p><img src="/./../imgs/JVM/image-20231003112352559.png" alt="image-20231003112352559"></p><p><strong>直接内存：</strong>操作系统的内存，分配回收成本较高，读写性能高，不受JVM内存回收管理</p><h3 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h3><h4 id="强引用、弱引用、软引用、虚引用的区别"><a href="#强引用、弱引用、软引用、虚引用的区别" class="headerlink" title="强引用、弱引用、软引用、虚引用的区别"></a>强引用、弱引用、软引用、虚引用的区别</h4><p>在Java中提供了四个级别的引用：<strong>强引用</strong>，<strong>软引用</strong>，<strong>弱引用</strong>和<strong>虚引用</strong>。在这四个引用类型中，只有强引用FinalReference类是包内可见，其他三种引用类型均为public，可以在应用程序中直接使用。引用类型的类结构如图所示。</p><p><img src="/./../imgs/JVM/image-20231003111728261.png" alt="image-20231003111728261"></p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a><strong>强引用</strong></h5><p>Java中默认声明的就是强引用，例如以下代码，如果M对象被回收了，会打印 finalize() 方法中的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">M</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">M</span>();  <span class="comment">//只要m还指向M对象，M对象就不会被回收</span></span><br><span class="line">        <span class="comment">// m = null;   //手动置null</span></span><br><span class="line">        System.gc();  <span class="comment">// 进行垃圾回收</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象被回收了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/./../imgs/JVM/v2-e5f1836efa6748c371bcd126823414f7_1440w-1696303052906-5.webp" alt="img"></p><p>只要强引用存在，垃圾收集器将永远不会回收被引用的对象，哪怕<strong>内存不足</strong>时，JVM也会直接抛出OutOfMemoryError，<strong>不会去回收</strong>。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了。例如上面的代码，将 m &#x3D; null; 注释放开时，运行结果如下：</p><p><img src="/./../imgs/JVM/image-20231003111738987.png" alt="image-20231003111738987"></p><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a><strong>软引用</strong></h5><p>软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在垃圾回收后，<strong>内存仍然不足</strong>时，系统则<strong>会回收</strong>软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出OutOfMemoryError。这种特性常常被用来实现<strong>缓存技术</strong>，比如网页缓存，图片缓存等。</p><p>在 JDK1.2 之后，用 SoftReference 类来表示软引用。下面以一个例子来进一步说明强引用和软引用的区别。</p><p>在运行下面的Java代码之前，需要先配置参数 -Xms2M -Xmx2M，将 JVM 的初始内存设为2M，最大可用内存为 2M。</p><p>首先先来测试一下强引用，在限制了 JVM 内存的前提下，下面的代码运行正常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 当 new byte为 1M 时，程序运行正常</span></span><br><span class="line">        <span class="type">byte</span>[] buff1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// byte[] buff2 = new byte[1024 * 1024 * 1];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果我们再创建一个1M大小的 byte数组时，则内存不够使用，程序直接报错。因为强引用不会被回收。</p><p><img src="/./../imgs/JVM/image-20231003111745645.png" alt="image-20231003111745645"></p><p>接着来看一下软引用会有什么不一样，在下面的示例中先创建一个大小为 1M 的软引用对象，打印m的地址，然后进行垃圾回收，休眠500ms后打印m的地址。最后又创建了一个1M的字节数组，打印m的地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SoftReference&lt;<span class="type">byte</span>[]&gt; m = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line"> </span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        <span class="comment">// 再分配一个数组，heap将装不下，</span></span><br><span class="line">        <span class="comment">// 这时系统会进行垃圾回收，如果内存不够，会把软引用干掉</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1</span>];</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/./../imgs/JVM/v2-210fffb5827e8aea4115430e5b373238_1440w-1696303070608-7.webp" alt="img"></p><p>根据运行结果，我们可以看到，在内存不足的情况下，软引用才会被回收。</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a><strong>弱引用</strong></h5><p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够</strong>，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象<strong>都会被回收</strong>。在 JDK1.2 之后，用 WeakReference 来表示弱引用。</p><p>我们以与软引用同样的方式来测试一下弱引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        WeakReference&lt;<span class="type">byte</span>[]&gt; m = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line"> </span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/./../imgs/JVM/image-20231003111756526.png" alt="image-20231003111756526"></p><p>根据运行结果，可以发现垃圾回收后被弱引用关联的对象被回收了。</p><p>在 Java 集合中有一种特殊的 Map 类型：<strong>WeakHashMap</strong>， 在这种 Map 中存放了键对象的弱引用，当一个键对象被垃圾回收，那么相应的值对象的引用会从 Map 中删除。WeakHashMap 能够节约存储空间，可用来缓存那些非必须存在的数据。</p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象。</p><p>虚引用必须要和 ReferenceQueue 引用队列一起使用，主要配合ByteBuffer使用，在引用对象被回收时，会将虚引用入队，Reference Handler线程调用虚引用相关方法释放直接内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PhantomReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Object&gt; LIST = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReferenceQueue</span> <span class="variable">QUEUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        PhantomReference&lt;M&gt; m = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">M</span>(), QUEUE);<span class="comment">//关联软引用对象和引用队列</span></span><br><span class="line"> <span class="comment">//当软引用所关联的byte数组被回收时，软引用会自己加入到queue中</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                LIST.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>]);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(m.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Reference</span> <span class="variable">poll</span> <span class="operator">=</span> QUEUE.poll();</span><br><span class="line">                <span class="keyword">if</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//获取queue中的无用的软引用对象，并移除</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;虚引用对象：&quot;</span> + poll + <span class="string">&quot; 被jvm回收了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象被回收了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/./../imgs/JVM/v2-db69836fc83d1e8d39f5088bc1a4b8a9_1440w-1696303085353-9.webp" alt="img"></p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>JVM中的垃圾回收器通过可达性分析来探索所有存活的对象<br>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果找不到，则表示可以回收</p><h5 id="可以作为GC-Root的对象"><a href="#可以作为GC-Root的对象" class="headerlink" title="可以作为GC Root的对象"></a>可以作为GC Root的对象</h5><ul><li>系统类System Class（Object、String等）</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li><li>所有被同步锁（synchronized关键字）持有的对象。</li><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li></ul><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><p><strong>1.标记-清除算法</strong>：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</p><ul><li>该算法分为两个阶段，<strong>标记和清除</strong>。标记阶段标记所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。该算法最大的问题就是内存碎片严重化，后续可能发生对象不能找到利用空间的问题。</li></ul><p><img src="/./../imgs/JVM/v2-7389d400dc04abb145a67fa86a662e33_1440w.webp" alt="img"></p><p><strong>2.复制算法</strong>：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</p><ul><li>按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。</li></ul><p><img src="/./../imgs/JVM/v2-20adb8ac4c5deb44fc27e30c8381281d_1440w.webp" alt="img"></p><p><img src="/./../imgs/JVM/image-20240322203226141.png" alt="image-20240322203226141"></p><p><strong>3.标记-整理算法</strong>：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</p><ul><li>标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。</li></ul><p><img src="/./../imgs/JVM/v2-cc722c4e5b289434d2181451f4fd154c_1440w.webp" alt="img"></p><p><img src="/./../imgs/JVM/image-20240322203239717.png" alt="image-20240322203239717"></p><p><strong>4.分代算法</strong>：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</p><p>minor gc新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</p><p>full gc&#x2F;major gc 老年代的GC，Major GC 的速度一般会比 Minor GC 的慢 10 倍以上</p><p>二 minorGC过程详解<br>1 在初始阶段，新创建的对象被分配到Eden区，survivor的两块空间都为空。</p><p><img src="/./../imgs/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>2 当Eden区满了的时候，minor garbage 被触发 。</p><p><img src="/./../imgs/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111900766-29.png" alt="img"></p><p>3 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。</p><p><img src="/./../imgs/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111908107-32.png" alt="在这里插入图片描述"></p><p>4 在下一次的Minor GC中，Eden区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到survivor区。当Eden 和 s0区空间满了，S0的所有的数据都被复制到S1，需要注意的是，在上次minor GC过程中移动到S0中的两个对象在复制到S1后其年龄要加1。此时Eden区S0区被清空，所有存活的数据都复制到了S1区，并且S1区存在着年龄不一样的对象，过程如下图所示：</p><p><img src="/./../imgs/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111915300-35.png" alt="在这里插入图片描述"></p><p>5 再下一次MinorGC则重复这个过程，这一次survivor的两个区对换，存活的对象被复制到S0，存活的对象年龄加1，Eden区和另一个survivor区被清空。</p><p><img src="/./../imgs/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111922409-38.png" alt="在这里插入图片描述"></p><p>6 再经过几次Minor GC之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold默认是15），就会被从年轻代Promotion到老年代。</p><p><img src="/./../imgs/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111929062-41.png" alt="在这里插入图片描述"></p><p>7 随着MinorGC一次又一次的进行，不断会有新的对象被promote到老年代。</p><p><img src="/./../imgs/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111935557-44.png" alt="在这里插入图片描述"></p><p>8 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记整理)。</p><ul><li><p>从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。</p></li><li><p>老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-整理算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；<strong>如果不允许，则仍然进行Full GC（</strong>这代表着如果设置-XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。</p></li></ul><p>整体描述<br>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次GC后，Eden区和”From”区已经被清空。这个时候，“From”和”To”会交换他们的角色，也就是新的”To”就是上次GC前的“From”，新的”From”就是上次GC前的”To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，**”To”区被填满之后，会将所有对象移动到年老代**中。</p><p>三 GC触发条件<br>Minor GC触发条件：Eden区满时</p><p>Full GC触发条件：<br>（1）调用System.gc时，系统建议执行Full GC，但是不必然执行<br>（2）老年代空间不足<br>（3）方法区空间不足<br>（4）通过Minor GC后进入老年代的大小大于老年代的可用内存<br>（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</p><p><img src="/./../imgs/JVM/image-20231004144129340.png" alt="image-20231004144129340"></p><p>新生代分为伊甸园和幸存区，幸存区由from space 与 to space 两块相等的内存区域组成。eden ：from ：to &#x3D; 8 : 1 : 1;</p><p>新生代回收之后内存足够使用的话就不会扫描老年代，否则会扫描老年代。</p><h4 id="年轻代怎么升级为老年代"><a href="#年轻代怎么升级为老年代" class="headerlink" title="年轻代怎么升级为老年代"></a>年轻代怎么升级为老年代</h4><h5 id="担保机制"><a href="#担保机制" class="headerlink" title="担保机制"></a>担保机制</h5><p>新生代内存不足的时候（当MinorGC时，如果存活对象过多，无法完全放入Survivor From区），可以通过担保分配的方式让存活对象直接分配进老年代。</p><h5 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h5><p>-XX：PretenureSizeThreshould &#x3D; 3145728，可以设置超过3M的对象直接进入老年代</p><h5 id="长期存活的对象"><a href="#长期存活的对象" class="headerlink" title="长期存活的对象"></a>长期存活的对象</h5><p>在年轻代的对象在minor GC后没有被淘汰年龄就会加1，年龄增加到一定程度就会晋升为老年代，这个晋升的年龄是可以设置的。</p><h5 id="动态年龄判断"><a href="#动态年龄判断" class="headerlink" title="动态年龄判断"></a>动态年龄判断</h5><p>当survivor空间中相同年龄所有<strong>对象的大小总和****大于</strong>survivor空间的一半，年龄大于或等于该年龄的对象就会直接进入老年代，无需等到晋升年龄。</p><h4 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h4><p><a href="https://juejin.cn/post/6974281849031884830">JVM调优——GC 调优 - 掘金 (juejin.cn)</a></p><h5 id="确定合适回收器"><a href="#确定合适回收器" class="headerlink" title="确定合适回收器"></a>确定合适回收器</h5><p>“低延迟”还是“高吞吐量”，选择合适的回收器CMS，G1，ZGC </p><h5 id="降低GC次数，最快的GC是不发生GC"><a href="#降低GC次数，最快的GC是不发生GC" class="headerlink" title="降低GC次数，最快的GC是不发生GC"></a>降低GC次数，最快的GC是不发生GC</h5><p>尽量减少堆内存的使用，减少对象大小、避免数据冗余、排查是否存在内存泄漏</p><h5 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h5><p>新生代的特点</p><ul><li>所有的new操作分配内存都是非常廉价的</li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>MInor GC 所用时间远小于Full GC</li></ul><p><strong>选择合适新生代内存大小</strong></p><ul><li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li><li>新生代内存设置为能容纳**[并发量*(请求-响应)]**的数据为宜</li><li>幸存区大到能保留【当前活跃对象+需要晋升对象】</li><li>晋升阈值配置得当，让长时间存活对象尽快晋升</li></ul><h5 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h5><p>如果fullGC频率不高，就挺适合的</p><p>如果频繁发生fullGC，可以调高老年代空间占用比率，增大堆空间</p><p>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1&#x2F;4 ~ 1&#x2F;3<br>-XX:CMSInitiatingOccupancyFraction&#x3D;percent</p><h4 id="GC调优实战"><a href="#GC调优实战" class="headerlink" title="GC调优实战"></a>GC调优实战</h4><h5 id="分析GC日志-GCEasy"><a href="#分析GC日志-GCEasy" class="headerlink" title="分析GC日志 - GCEasy"></a>分析GC日志 - GCEasy</h5><p>GCeasy是业界首款使用AI机器学习技术在线进行GC分析和诊断的工具。定位内存泄漏、GC延迟高的问题，提供JVM参数优化建议，支持在线的可视化工具图表展示。 官方网站：<a href="https://gceasy.io/">https://gceasy.io/</a> </p><p><img src="/./../imgs/JVM/1712369115106-34.png" alt="img"></p><p>使用方法：</p><p>1、选择文件，找到GC日志并上传</p><p><img src="/./../imgs/JVM/1712369115050-28.png" alt="img"></p><p>2、点击Analyze分析就可以看到报告，每个账号每个月能免费上传5个GC日志。</p><p>建议部分：</p><p><img src="/./../imgs/JVM/1712369115050-29.png" alt="img"></p><p>内存情况：</p><p><img src="/./../imgs/JVM/1712369115050-30.png" alt="img"></p><p>GC关键性指标：</p><p><img src="/./../imgs/JVM/1712369115050-31.png" alt="img"></p><p>GC的趋势图：</p><p><img src="/./../imgs/JVM/1712369115050-32.png" alt="img"></p><p>引发GC的原因：</p><p><img src="/./../imgs/JVM/1712369115050-33.png" alt="img"></p><h4 id="垃圾收集器cms和g1比较"><a href="#垃圾收集器cms和g1比较" class="headerlink" title="垃圾收集器cms和g1比较"></a>垃圾收集器cms和g1比较</h4><h5 id="CMS（仅作用于老年代，基于标记-清除算法）"><a href="#CMS（仅作用于老年代，基于标记-清除算法）" class="headerlink" title="CMS（仅作用于老年代，基于标记-清除算法）"></a>CMS（仅作用于老年代，基于标记-清除算法）</h5><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。这是因为 CMS 收集器工作时，GC 工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的。</p><ul><li>初始标记（CMS initial mark）需要 Stop-the-world，标记一下 GC Roots 能直接关联到的对象，速度很快</li><li>并发标记（CMS concurrent mark）进行 GC Roots Tracing 的过程</li><li>重新标记（CMS remark）需要 Stop-the-world，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始阶段稍长一些，但远比并发标记的时间短。</li><li>并发清除（CMS concurrent sweep）</li></ul><p><img src="/./../imgs/JVM/59307b3ead7530e2f9fedaaf71f5608f.png" alt="img"></p><p>CMS 收集器优点：并发收集、低停顿。</p><p>CMS 收集器缺点：</p><ul><li>CMS 收集器对 CPU 资源非常敏感。</li><li>CMS 收集器无法处理浮动垃圾（Floating Garbage）（CMS在 并发标记 时是并发的，GC 线程和用户线程并发执行，这个过程当然可能会因为线程的交替执行而导致新产生的垃圾（可回收对象，即浮动垃圾）没有被标记到；而 重新标记 只是对之前 并发标记 所获得的不可达对象的更正，所以是没有办法处理 “浮动垃圾” 的。）。</li><li>CMS 收集器是基于标记-清除算法，该算法的缺点都有（内存碎片）。</li><li>停顿时间是不可预期的。</li></ul><h5 id="G1-分为年轻代回收（复制算法），混合回收（年轻代与老年代（标记整理suan’fa）都会回收）"><a href="#G1-分为年轻代回收（复制算法），混合回收（年轻代与老年代（标记整理suan’fa）都会回收）" class="headerlink" title="G1(分为年轻代回收（复制算法），混合回收（年轻代与老年代（标记整理suan’fa）都会回收）)"></a>G1(分为年轻代回收（复制算法），混合回收（年轻代与老年代（标记整理suan’fa）都会回收）)</h5><ul><li>G1 算法取消了堆中年轻代与老年代的物理划分，而是一个逻辑分代，但它仍然属于分代收集器。</li><li>G1 算法将堆划分为若干个区域，称作 Region，</li><li>同时注重**吞吐量（**Throughput）和**低延迟**（Low latency），默认的暂停目标是 200 ms</li><li>G1 采用每次只清理一部分而不是全部的 Region 的增量式清理，由此来保证每次 GC 停顿时间不会过长。</li><li>G1 算法允许通过 JVM 参数设置 Region 的大小，范围是 1～32MB，可以设置期望的最大 GC 停顿时间，根据这个停顿时间来制定回收计划，所以G1的垃圾<font color = gold>回收是可预期的</font>。</li></ul><img src="./../imgs/JVM/image-20231011213513010.png" alt="image-20231011213513010" style="zoom: 50%;" /><p><strong>G1垃圾回收器的垃圾回收方式分为两种。</strong></p><ul><li><strong>一就是YoungGC，主要回收的是年轻代Region中的垃圾，采用<font color = gold>复制算法</font></strong></li><li><strong>第二种就是混合回收模式（Mix GC），这种回收模式会回收年轻代跟老年代中的所有垃圾，采用<font color = gold>标记-整理算法</font>。</strong></li></ul><p>G1 回收过程如下。</p><ul><li><strong>初始标记(Initial Marking)：</strong>这阶段仅仅只是<font color = gold>标记GC Roots能直接关联到的对象</font>，让下一阶段用户程序并发运行时，能在正确的可用的Region中创建新对象，这阶段需要<font color = gold>停顿线程(STW)</font>，但是<font color = gold>耗时很短</font>&gt;。而且是借用<font color = gold>进行Minor GC的时候同步完成的</font>&gt;，所以G1收集器在这个阶段实际并没有额外的停顿。</li><li><strong>并发标记(Concurrent Marking)：</strong>从GC Roots开始对堆的对象进行<font color = gold>可达性分析</font>，并进行三色标记，标记开始时创建一个快照，记录当前所有对象，递归扫描整个堆里的对象图，找出存活的对象，（在此过程中新创建的对象会直接标记为黑色），这阶段<font color = gold>耗时较长</font>，但是可以<font color = gold>与用户程序并发执行,不会STW</font>。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象，将这些对象放入STAB队列中。</li><li><strong>最终标记(Final Marking)：</strong>对<font color = gold>用户线程做另一个短暂的暂停</font>，用于标记并发阶段结束后仍遗留下来的最后那少量的 SATB队列中的对象记录。</li><li><strong>筛选回收(Live Data Counting and Evacuation)：</strong>负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，优先对可回收空间较大的 Region 进行回收，即 garbage first，这也是 G1 名称的由来，根据用户所<font color = gold>期望的停顿时间来制定回收计划</font>。可以<font color = gold>自由选择多个Region来构成回收集</font>，然后把回收的那一部分Region中的存活对象复制到空的Region中，再对那些Region进行清空。</li></ul><p>除了并发标记外，其余过程都要 STW</p><img src="./../imgs/JVM/20200608151109.png" alt="img" style="zoom:50%;" /><h5 id="年轻代回收详情（复制算法）"><a href="#年轻代回收详情（复制算法）" class="headerlink" title="年轻代回收详情（复制算法）"></a>年轻代回收详情（复制算法）</h5><p>年轻代回收<strong>只扫描年轻代对象（Eden + Survivor）</strong>，所以从GC Root到年轻代的对象或者年轻代对象引用了其他年轻代的对象都很容易扫描出来。</p><p><img src="/./../imgs/JVM/1711165442927-26.png" alt="img"></p><p>这里就存在一个问题，年轻代回收只扫描年轻代对象（Eden + Survivor），如果有老年代中的对象引用了年轻代中的对象，我们又如何知道呢？</p><p><img src="/./../imgs/JVM/1711165442928-27.png" alt="img"></p><p>比如上图中，E对象被对象引用了，那么显然在垃圾回收时E对象是不应该被回收的。</p><p><strong>方案1：从GC Root开始，扫描所有对象，如果年轻代对象在引用链上，就标记为存活。</strong></p><p><img src="/./../imgs/JVM/1711165442928-28.png" alt="img"></p><p>重新扫描一遍GC Root关联的所有对象，包括老年代的。这个方案显然不可行，需要遍历引用链上所有对象，效率太低。</p><p><strong>方案2：维护一个详细的表，记录哪个对象被哪个老年代引用了。在年轻代中被引用的对象，不进行回收。</strong></p><p><img src="/./../imgs/JVM/1711165442928-29.png" alt="img"></p><p>如上图中，通过引用详情表记录F和E对象分别被A和B对象引用了。问题：如果对象太多这张表会占用很大的内存空间。存在错标的情况</p><p>方案2的第一次优化：只记录Region被哪些对象引用了。这种引用详情表称为记忆集 RememberedSet（简称RS或RSet）：是一种记录了从非收集区域对象引用收集区域对象的这些关系的数据结构。扫描时将记忆集中的对象也加入到GC Root中，就可以根据引用链判断哪些对象需要回收了。</p><p>问题：如果区域中引用对象很多，还是占用很多内存。</p><p><img src="/./../imgs/JVM/1711165442928-30.png" alt="img"></p><p>方案2的第二次优化：将所有区域中的内存按一定大小划分成很多个块（每个块的大小为512kb），每个块进行编号。记忆集中只记录对块的引用关系。如果一个块中有多个对象，只需要引用一次，减少了内存开销。</p><p><img src="/./../imgs/JVM/1711165442928-31.png" alt="img"></p><p>每一个Region都拥有一个自己的卡表，如果产生了跨代引用（老年代引用年轻代），此时这个Region对应的卡表上就会将字节内容进行修改,用一个字节来代表区域内的一个512字节的块，JDK8源码中0代表被引用了称为脏卡。这样就可以标记出当前Region被老年代中的哪些部分引用了。那么要生成记忆集就比较简单了，只需要遍历整个卡表，找到所有脏卡。</p><p><img src="/./../imgs/JVM/1711165442928-32.png" alt="img"></p><p>那么怎么样去维护这个卡表呢？或者说怎么知道A对F引用了？</p><p><strong>JVM使用写屏障（Write Barrier）技术</strong>，在执行引用关系建立的代码时，可以在代码前和代码后插入一段指令，从而维护卡表。</p><p>记忆集中不会记录新生代到新生代的引用，同一个Region中的引用也不会记录。</p><p><img src="/./../imgs/JVM/1711165442928-33.png" alt="img"></p><p>记忆集的生成流程分为以下几个步骤：</p><p>1、通过写屏障获得引用变更的信息。</p><p>2、将引用关系记录到卡表中，并记录到一个脏卡队列中。</p><p>3、JVM中会由Refinement 线程定期从脏卡队列中获取数据，生成记忆集。不直接写入记忆集的原因是避免过多线程并发访问记忆集。</p><p><img src="/./../imgs/JVM/1711165442928-34.png" alt="img"></p><h6 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h6><p>更详细的分析下年轻代回收的步骤，整个过程是STW的：</p><p>1、Root扫描，将所有的静态变量、局部变量扫描出来。</p><p>2、处理脏卡队列中的没有处理完的信息，更新记忆集的数据，此阶段完成后，记忆集中包含了所有老年代对当前Region的引用关系。</p><p><img src="/./../imgs/JVM/1711165442929-35.png" alt="img"></p><p>3、标记存活对象。记忆集中的对象会加入到GC Root对象集合中，在GC Root引用链上的对象也会被标记为存活对象。</p><p>4、根据设定的最大停顿时间，选择本次收集的区域，称之为回收集合Collection Set。</p><p><img src="/./../imgs/JVM/1711165442929-36.png" alt="img"></p><p>5、复制对象：将标记出来的对象复制到新的区中，将年龄加1，如果年龄到达15则晋升到老年代。老的区域内存直接清空。</p><p>6、处理软、弱、虚、终结器引用，以及JNI中的弱引用。</p><p><img src="/./../imgs/JVM/1711165442929-37.png" alt="img"></p><p><strong>G1年轻代回收核心技术</strong></p><p><strong>1、卡表 Card Table</strong></p><p>每一个Region都拥有一个自己的卡表，卡表是一个字节数组，如果产生了跨代引用（老年代引用年轻代），G1会将卡表上引用对象所在的位置字节内容进行修改为0, 称为脏卡。卡表的主要作用是生成记忆集。</p><p>卡表会占用一定的内存空间，堆大小是1G时，卡表大小为1G &#x3D; 1024 MB &#x2F; 512 &#x3D; 2MB</p><p><strong>2、记忆集 RememberedSet（简称RS或RSet）</strong></p><p>每一个Region都拥有一个自己的记忆集，如果产生了跨代引用，记忆集中会记录引用对象所在的卡表位置。标记阶段将记忆集中的对象加入GC ROOT集合中一起扫描，就可以将被引用的对象标记为存活。</p><p><strong>3、写屏障 Write Barrier</strong></p><p>G1使用写屏障技术，在执行引用关系建立的代码执行后插入一段指令，完成卡表的维护工作。</p><p>会损失一部分的性能，大约在5%~10%之间。</p><h5 id="混合回收"><a href="#混合回收" class="headerlink" title="混合回收"></a>混合回收</h5><p>多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值（默认45%）时会触发混合回收MixedGC。</p><p>混合回收会由年轻代回收之后或者大对象分配之后触发，混合回收会回收 <strong>整个年轻代 + 部分老年代。</strong></p><p>老年代很多时候会有大量对象，要标记出所有存活对象耗时较长，所以整个标记过程要尽量能做到和用户线程并行执行。</p><h5 id="混合回收的步骤："><a href="#混合回收的步骤：" class="headerlink" title="混合回收的步骤："></a><strong>混合回收的步骤：</strong></h5><p>1、初始标记，STW，采用三色标记法标记从GC Root可直达的对象。</p><p>2、并发标记，并发执行，对存活对象进行标记。</p><p>3、最终标记，STW，处理SATB相关的对象标记。</p><p>4、清理，STW，如果区域中没有任何存活对象就直接清理。</p><p>5、使用标记整理算法，转移，将存活对象复制到别的区域。</p><h6 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h6><p>初始标记会暂停所有用户线程，只标记从GC Root可直达的对象，所以停顿时间不会太长。采用三色标记法进行标记，三色标记法在原有双色标记（黑也就是1代表存活，白0代表可回收）增加了一种灰色，采用队列的方式保存标记为灰色的对象。</p><p>黑色：存活，当前对象在GC Root引用链上，同时他引用的其他对象也都已经标记完成。</p><p>灰色：待处理，当前对象在GC Root引用链上，他引用的其他对象还未标记完成。</p><p>白色：可回收，不在GC Root引用链上。</p><p>初始所有对象都是默认为白色，初始值为0：</p><p><img src="/./../imgs/JVM/1711166313048-71.png" alt="img"></p><p>三色标记中的黑色和白色是使用位图(bitmap)来实现的,比如8个字节使用1个bit来标识标记的内容，黑色为1，白色为0，灰色不会体现在位图中，会单独放入一个队列中。如果对象超过8个字节，仅仅使用第一个bit位处理。</p><p><img src="/./../imgs/JVM/1711166313051-72.png" alt="img"></p><p>将GC Root可以直到的对象D标记，D没有其他引用对象，所以直接标记为为黑色：</p><p><img src="/./../imgs/JVM/1711166313052-73.png" alt="img"></p><p>接下来将B对象标记，由于B关联了A和C，而A和C没有标记完成，所以B是待处理状态，将B送入灰色队列。</p><p><img src="/./../imgs/JVM/1711166313052-74.png" alt="img"></p><h6 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h6><p>接下来进入并发标记阶段，继续进行未完成的标记任务。此阶段和用户线程并发执行。</p><p>从灰色队列中获取尚未完成标记的对象B。标记B关联的A和C对象，由于A对象并未引用其他对象，可以直接标记成黑色，而B也完成了所有引用对象的标记，也标记为黑色。</p><p><img src="/./../imgs/JVM/1711166313053-75.png" alt="img"></p><p>最后从队列获取C对象，标记为黑色，E也标记为黑色。所以剩余对象F就是白色，可回收。</p><p><img src="/./../imgs/JVM/1711166313053-76.png" alt="img"></p><p>三色标记存在一个比较严重的问题，由于用户线程可能同时在修改对象的引用关系，就会出现错标的情况，比如：</p><p>这个案例中正常情况下，B和C都会被标记成黑色。但是在BC标记前，用户线程执行了 B.c &#x3D; null；将B到C的引用去除了。</p><p><img src="/./../imgs/JVM/1711166313053-77.png" alt="img"></p><p>同时执行了A.c &#x3D; c; 添加了A到C的引用。此时会出现严重问题，C是白色可回收一旦回收代码中再去使用对象会造成重大问题。</p><p><img src="/./../imgs/JVM/1711166313053-78.png" alt="img"></p><p>如果接着处理B：</p><p><img src="/./../imgs/JVM/1711166313054-79.png" alt="img"></p><p>B在GC引用链上，没有引用任何对象，所以B标记为黑色：</p><p><img src="/./../imgs/JVM/1711166313054-80.png" alt="img"></p><p>这样C虽然在引用链上，但是被回收了。</p><p>G1为了解决这个问题，使用了<strong>SATB技术（Snapshot At The Beginning， 初始快照）</strong>。SATB技术是这样处理的：</p><p><img src="/./../imgs/JVM/1711166313054-81.png" alt="img"></p><p>1、标记开始时创建一个快照，记录当前所有对象，标记过程中新生成的对象直接标记为黑色。</p><p><img src="/./../imgs/JVM/1711166313054-82.png" alt="img"></p><p>2、采用前置写屏障技术，在引用赋值前比如B.c &#x3D; null之前，将之前引用的对象c放入SATB待处理队列中。SATB队列每个线程都有一个，最终会汇总到一个大的SATB队列中。</p><p><img src="/./../imgs/JVM/1711166313054-83.png" alt="img"></p><p>最终队列处理完之后，C和F就可以完成标记了。</p><p><img src="/./../imgs/JVM/1711166313055-84.png" alt="img"></p><p>SATB的缺点是在本轮清理时可能会将不存活的对象标记成存活对象，产生了一些所谓的浮动垃圾，等到下一轮清理时才能回收。比如图中的E对象。</p><h5 id="ZGC垃圾回收器"><a href="#ZGC垃圾回收器" class="headerlink" title="ZGC垃圾回收器"></a>ZGC垃圾回收器</h5><p>ZGC 是一种可扩展的低延迟垃圾回收器。ZGC 在垃圾回收过程中，STW的时间不会超过一毫秒，适合需要低延迟的应用。支持几百兆到16TB 的堆大小，堆大小对STW的时间基本没有影响。 </p><p>主要是使用了染色指针+ 读屏障来降低G1在转移对象时候的停顿时间</p><p>ZGC（Garbage Collector）是一种在JVM中实现的低停顿时间垃圾回收器。其垃圾回收流程可以概括为以下几个关键阶段：</p><ol><li><strong>初始标记阶段（Initial Mark）：</strong>与G1垃圾回收器一样，初始标记阶段是一个短暂的STW阶段，目的是标记出根对象直接引用的对象，标记的过程是并发执行的，所以这个阶段的停顿时间很短。</li><li><strong>并发标记阶段（Concurrent Mark）：</strong>在这个阶段，ZGC并发地标记出所有可达的对象，包括从根对象出发的引用链上的对象，这个过程是与应用程序的执行同时进行的，因此对停顿时间的影响很小。</li><li><strong>再标记阶段（Remark）：</strong>如果在并发标记阶段有新的对象被创建或有对象被回收，ZGC可能需要进行一次短暂的STW再标记。这个阶段的停顿时间一般不超过1毫秒。在这个阶段，ZGC会修正并发标记阶段可能由于并发引起的标记不一致。</li><li><strong>并发转移准备（Concurrent Prepare for Relocate）：</strong>在这个阶段ZGC进行整堆扫描，确定收集哪些Region，并将这些Region组成重分配集（Relocation Set）。与G1收集器不同，ZGC的重分配集扫描所有的Region，而不是计算最有价值回收的Region，由于染色指针的存在，扫描过程会很快。这个过程并不是为了计算最优的回收集，而是为了确定存活对象将被复制到其他Region。此阶段还涉及到JDK12支持的类卸载和弱引用的处理。</li><li><strong>初始转移阶段（Initial Relocation）：</strong>这是ZGC垃圾回收的核心阶段之一，ZGC并发地将重分配集中的存活对象复制到新的Region。为了记录从旧对象到新对象的转移关系，ZGC需要为重分配集中的每个Region维护一个转发表（Forward Table）。<br>ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力<br>ZGC的染色指针因为“自愈”（Self-Healing）能力，所以只有第一次访问旧对象会变慢，。 一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于新对象的分配，但是转发表还得留着不能释放掉，因为可能还有访问在使用这个转发表。</li><li><strong>并发转移阶段（Concurrent Relocation）：</strong>并发转移阶段的工作就是修正堆中指向重分配集中旧对象的所有引用，也可以直接认为就是真正进行对象引用修复的一个步骤，从这一点来看shenandoah的并发引用更新阶段是一样的。但是ZGC并不需要马上完成这个操作（因为有指针自愈的特性），ZGC把并发重映射阶段要做的工作巧妙的合并到<strong>下一次垃圾收集循环</strong>中的并发标记阶段中去完成，这样做的好处是节省遍历对象图的开销。一旦所有指针修复，新旧对象的引用关系<strong>转发表</strong>就可以释放了。</li></ol><table><thead><tr><th>优点</th><th>描述</th></tr></thead><tbody><tr><td>1. 低停顿</td><td>ZGC以低停顿为首要目标，几乎所有垃圾回收过程都是并发的，只有短暂的STW。</td></tr><tr><td>2. 高吞吐量</td><td>ZGC在吞吐量方面取得了显著进展，超越了G1，接近Parallel Scavenge。</td></tr><tr><td>3. 内存小</td><td>没有写屏障和卡表等额外的数据结构，收集过程中额外耗费的内存较小。</td></tr><tr><td>4. 局部内存分配</td><td>在多核处理器的某些架构下，优先在当前线程所处的处理器的本地内存上分配对象。</td></tr><tr><td>5. 并发停顿</td><td>并发停顿非常短暂，大部分过程都是与应用线程并发执行。</td></tr><tr><td>6. 无分代</td><td>没有引入分代的概念，简化了内存管理的复杂性。</td></tr><tr><td>7. 无内存碎片</td><td>采用并发的标记-整理算法，没有内存碎片问题。</td></tr></tbody></table><table><thead><tr><th>缺点</th><th>描述</th></tr></thead><tbody><tr><td>1. 浮动垃圾</td><td>承受的对象分配速率不会太高，产生浮动垃圾，难以及时回收。</td></tr><tr><td>2. 执行时间较长</td><td>停顿时间短，但整个垃圾回收过程的执行时间可能较长。</td></tr><tr><td>3. 无分代概念</td><td>没有分代概念，可能导致朝生夕死的对象无法及时回收。</td></tr><tr><td>4. 平台限制</td><td>目前仅在Linux&#x2F;x64上可用，可能限制了在其他平台的应用。</td></tr></tbody></table><h3 id="JVM运行、加载过程"><a href="#JVM运行、加载过程" class="headerlink" title="JVM运行、加载过程"></a>JVM运行、加载过程</h3><h4 id="静态变量的加载过程"><a href="#静态变量的加载过程" class="headerlink" title="静态变量的加载过程"></a>静态变量的加载过程</h4><p>连接的准备阶段</p><p><img src="/./../imgs/JVM/image-20231006121550663.png" alt="image-20231006121550663"></p><h4 id="Java运行一个程序的过程？"><a href="#Java运行一个程序的过程？" class="headerlink" title="Java运行一个程序的过程？"></a>Java运行一个程序的过程？</h4><ol><li><strong>编译阶段</strong></li></ol><p>Java 代码首先需要被编译器编译，Java 编译器首先检查语法和语义的错误，然后将源码转换成字节码。编译生成的字节码被存储在一个或多个 .class 文件中，这些文件可以直接在 JVM 上运行或在网络上传输。</p><ol start="2"><li><strong>运行阶段</strong></li></ol><p><strong>Java 代码的运行分为三个阶段：装载、链接和初始化。</strong></p><p>- 装载：Java 虚拟机装载字节码，通常从 ClassPath 路径中获取，并检查字节码的正确性和合法性。</p><p>- 链接：在链接阶段，Java 虚拟机将其装载的类型与所依赖的类型链接起来，生成实际的可执行代码，主要包括验证、准备、解析三个阶段：</p><ul><li>验证：Java 虚拟机对字节码进行验证，以确保其符合规范和安全标准。验证阶段检查字节码中包含的元数据和字节码是否符合规范和安全标准。</li><li>准备：Java 虚拟机为类变量分配存储空间，并将其初始化为标准初始值。</li><li>解析：Java 虚拟机在准备阶段对常量池进行了解析，以确定每个符号对应的目标，这个过程称为解析。</li></ul><p>- 初始化：在初始化阶段，Java 虚拟机按照程序设定的顺序执行类构造器，以完成类的初始化。类构造器是由编译器自动生成的，它们负责将静态变量初始化并执行静态语句块中的代码。</p><p>在初始化阶段完成后，Java 虚拟机就开始执行字节码指令了，在这个阶段，Java 虚拟机通过解释器将字节码转换为机器码，并开始执行代码逻辑，完成 Java 代码的运行和执行。</p><p>总结</p><p><img src="/./../imgs/JVM/1711175338351-118.png" alt="img"></p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><h5 id="类加载时JVM的区域"><a href="#类加载时JVM的区域" class="headerlink" title="类加载时JVM的区域"></a>类加载时JVM的区域</h5><p><img src="/./../imgs/JVM/image-20231006115620436.png" alt="image-20231006115620436"></p><p>类对象 xxx.class放在堆中， 存放instanceKlass的镜像指针，instanceKlass的中包含类的所有信息</p><h5 id="类加载器-1"><a href="#类加载器-1" class="headerlink" title="类加载器"></a>类加载器</h5><p>1.启动类加载器（Bootstrap ClassLoader）加载核心类</p><p>2.扩展类加载器（Extension ClassLoader）加载扩展类</p><p>3.应用程序类加载器（Application ClassLoader）加载应用classpath中的类</p><p>4.自定义类加载器，重写findClass方法。</p><p><img src="/./../imgs/JVM/image-20231010185648889.png" alt="image-20231010185648889"></p><h4 id="（类的加载机制）双亲委派机制是什么？怎么打破？"><a href="#（类的加载机制）双亲委派机制是什么？怎么打破？" class="headerlink" title="（类的加载机制）双亲委派机制是什么？怎么打破？"></a>（类的加载机制）双亲委派机制是什么？怎么打破？</h4><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><p>当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol><li><p>保证类加载的安全性</p><p>通过双亲委派机制，让顶层的类加载器去加载核心类，避免恶意代码替换JDK中的核心类库（比如Java.lang.String），确保核心类库的完整性和安全性。</p></li><li><p>避免重复加载</p><p>可以避免同一个类被多次记载，上层的类加载器如果记载过类，就会直接返回该类，避免重复加载造成资源浪费，</p></li></ol><h5 id="怎么打破"><a href="#怎么打破" class="headerlink" title="怎么打破"></a>怎么打破</h5><p><img src="/./../imgs/JVM/image-20231010192356056.png" alt="image-20231010192356056"></p><ul><li><p>ClassLoader中包含了4个核心方法，对Java程序员来说，打破双亲委派机制的唯一方法就是实现自定义类加载器重写loadClass方法，将其中的双亲委派机制代码去掉。</p><p><img src="/./../imgs/JVM/1711175083796-113.png" alt="img"></p></li></ul><h5 id="为什么要打破"><a href="#为什么要打破" class="headerlink" title="为什么要打破"></a>为什么要打破</h5><p><strong>用双亲委派也存在一定的局限性</strong>，</p><p>在加载核心类库时，如果需要使用用户代码，双亲委派流程就无法满足；</p><p>比如在使用JDBC时， 利用DriverManager.getConnection获取连接时，就会存在这样的问题。</p><p>DriverManager是由根类加载器Bootstrap加载的，在加载DriverManager时，会执行其静态方法，加载初始驱动程序，也就是Driver接口的实现类；但是这些实现类基本都是第三方厂商提供的，根据双亲委派原则，第三方的类应该是由ApplicationClassLoader来加载</p><h4 id="什么情况下会报ClassNotFound的异常？"><a href="#什么情况下会报ClassNotFound的异常？" class="headerlink" title="什么情况下会报ClassNotFound的异常？"></a>什么情况下会报ClassNotFound的异常？</h4><p>当应用程序运行的过程中尝试使用类加载器去加载Class文件的时候，如果没有在classpath中查找到指定的类，就会抛出ClassNotFoundException。一般情况下，当我们使用Class.forName()或者ClassLoader.loadClass以及使用ClassLoader.findSystemClass()在运行时加载类的时候，如果类没有被找到，那么就会导致JVM抛出ClassNotFoundException。</p><h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><ul><li>默认无参构造</li><li>自动拆装箱</li><li>for-each</li><li>泛型擦除（比如在list集合中put和get都把泛型当作Object）</li><li>可变参数</li><li>枚举类</li><li>重写桥接（子类重写父类方法的返回值可以是父类方法返回值的子类， 通过一个桥接方法来调用子类的重写方法）</li></ul><h4 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h4><p> 内存泄漏（memory leak）：在Java中如果不再使用一个对象，但是该对象依然在GC ROOT的引用链上，这个对象就不会被垃圾回收器回收，这种情况就称之为内存泄漏</p><p> 少量的内存泄漏可以容忍，但是如果发生持续的内存泄漏，就像滚雪球雪球越滚越大，不管有多大的内存迟早会被消耗完，最终导致的结果就是内存溢出。                </p><p><img src="/./../imgs/JVM/1711161957517-1.png" alt="img"></p><p>解决内存泄漏问题总共分为四个步骤，其中前两个步骤是最核心的：</p><p><img src="/./../imgs/JVM/image-20240323104729041.png" alt="image-20240323104729041"></p><h5 id="发现问题-–-堆内存状况的对比"><a href="#发现问题-–-堆内存状况的对比" class="headerlink" title="发现问题 – 堆内存状况的对比"></a>发现问题 – 堆内存状况的对比</h5><p><strong>正常情况</strong></p><p><img src="/./../imgs/JVM/1711162227058-8.png" alt="img"></p><ul><li>处理业务时会出现上下起伏，业务对象频繁创建内存会升高，触发MinorGC之后内存会降下来。</li><li>手动执行FULL GC之后，内存大小会骤降，而且每次降完之后的大小是接近的。</li><li>长时间观察内存曲线应该是在一个范围内。</li></ul><p><strong>出现内存泄漏</strong></p><p><img src="/./../imgs/JVM/1711162227058-9.png" alt="img"></p><ul><li>处于持续增长的情况，即使Minor GC也不能把大部分对象回收</li><li>手动FULL GC之后的内存量每一次都在增长</li><li>长时间观察内存曲线持续增长</li></ul><p>生成方式有两种</p><p>1、内存溢出时自动生成，添加生成内存快照的Java虚拟机参数：</p><p>​    -XX:+HeapDumpOnOutOfMemoryError：发生OutOfMemoryError错误时，自动生成hprof内存快照文件。</p><p>​    -XX:HeapDumpPath&#x3D;<path>：指定hprof文件的输出路径。</p><p><img src="/./../imgs/JVM/1711162274734-14.png" alt="img"></p><p>发生oom之后，就会生成内存快照文件：</p><p><img src="/./../imgs/JVM/1711162274735-15.png" alt="img"></p><p>2、导出运行中系统的内存快照，比较简单的方式有两种，注意只需要导出标记为存活的对象：</p><p>通过JDK自带的jmap命令导出，格式为：</p><p>​      jmap -dump:live,format&#x3D;b,file&#x3D;文件路径和文件名 进程ID</p><p>通过arthas的heapdump命令导出，格式为：</p><p>​      heapdump –live  文件路径和文件名 </p><p><img src="/./../imgs/JVM/1711162274735-16.png" alt="img"></p><p>诊断 – <strong>MAT</strong>定位问题</p><p>使用MAT打开hprof文件，并选择内存泄漏检测功能，MAT会自行根据内存快照中保存的数据分析内存泄漏的根源。</p><p><img src="/./../imgs/JVM/1711162274735-17.png" alt="img"></p><p><strong>修复问题</strong></p><p>修复内存溢出问题的要具体问题具体分析，问题总共可以分成三类：</p><ul><li>代码中的内存泄漏，由于代码的不合理写法存在隐患，导致内存泄漏</li><li>并发引起内存溢出 - 参数不当,由于参数设置不当，比如堆内存设置过小，导致并发量增加之后超过堆内存的上限。解决方案：设置合理参数</li><li>并发引起内存溢出 – 设计不当，系统的方案设计不当，比如：<ul><li>从数据库获取超大数据量的数据</li><li>线程池设计不当</li><li>生产者-消费者模型，消费者消费性能问题</li></ul></li></ul><p>​      解决方案：优化设计方案</p><h4 id="常见JVM参数"><a href="#常见JVM参数" class="headerlink" title="常见JVM参数"></a>常见JVM参数</h4><h5 id="一、堆内存相关配置"><a href="#一、堆内存相关配置" class="headerlink" title="一、堆内存相关配置"></a>一、<strong>堆内存相关配置</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">设置堆初始值</span><br><span class="line">指令<span class="number">1</span>：-Xms2g</span><br><span class="line">指令<span class="number">2</span>：-XX:InitialHeapSize=2048m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">设置堆区最大值</span><br><span class="line">指令<span class="number">1</span>：`-Xmx2g` </span><br><span class="line">指令<span class="number">2</span>： -XX:MaxHeapSize=2048m</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">新生代内存配置</span><br><span class="line">指令<span class="number">1</span>：-Xmn512m</span><br><span class="line">指令<span class="number">2</span>：-XX:MaxNewSize=512m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">缩小堆内存的时机</span><br><span class="line">-XX:MaxHeapFreeRatio=<span class="number">70</span><span class="comment">//堆内存使用率大于70时扩张堆内存，xms=xmx时该参数无效，默认值70</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">扩张堆内存的时机</span><br><span class="line">-XX:MinHeapFreeRatio=<span class="number">40</span><span class="comment">//堆内存使用率小于40时缩减堆内存，xms=xmx时该参数无效，默认值40</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>个survivor区和Eden区大小比率</span><br><span class="line">指令：-XX:SurvivorRatio=<span class="number">6</span>  <span class="comment">//S区和Eden区占新生代比率为1:6,两个S区2:6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">新生代和老年代的占比</span><br><span class="line">-XX:NewRatio=<span class="number">4</span>  <span class="comment">//表示新生代:老年代 = 1:4 即老年代占整个堆的4/5；默认值=2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h5 id="二、方法区内存配置常用参数"><a href="#二、方法区内存配置常用参数" class="headerlink" title="二、方法区内存配置常用参数"></a><strong>二、方法区内存配置常用参数</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">初始化的Metaspace大小，</span><br><span class="line">-XX:MetaspaceSize ：</span><br><span class="line"></span><br><span class="line">Metaspace最大值</span><br><span class="line">-XX:MaxMetaspaceSize</span><br><span class="line">  </span><br></pre></td></tr></table></figure><hr><h5 id="三、线程栈内存配置常用参数"><a href="#三、线程栈内存配置常用参数" class="headerlink" title="三、线程栈内存配置常用参数"></a><strong>三、线程栈内存配置</strong>常用参数</h5><p>每个线程栈最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令<span class="number">1</span>：-Xss256k</span><br><span class="line"></span><br><span class="line">指令<span class="number">2</span>：-XX:ThreadStackSize=256k</span><br></pre></td></tr></table></figure><p>注意：</p><p>栈设置太大，会导致线程创建减少。</p><p>栈设置小，会导致深入不够，深度的递归会导致栈溢出。</p><p>建议栈深度设置在3000-5000</p><h5 id="四、配置垃圾收集器"><a href="#四、配置垃圾收集器" class="headerlink" title="四、配置垃圾收集器"></a><strong>四、配置垃圾收集器</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Serial垃圾收集器（新生代）</span><br><span class="line">开启：-XX:+UseSerialGC</span><br><span class="line">关闭：-XX:-UseSerialGC</span><br><span class="line"><span class="comment">//新生代使用Serial  老年代则使用SerialOld</span></span><br><span class="line"></span><br><span class="line">ParNew垃圾收集器（新生代）</span><br><span class="line">开启 -XX:+UseParNewGC</span><br><span class="line">关闭 -XX:-UseParNewGC</span><br><span class="line"><span class="comment">//新生代使用功能ParNew 老年代则使用功能CMS</span></span><br><span class="line"></span><br><span class="line">Parallel Scavenge收集器（新生代）</span><br><span class="line">开启 -XX:+UseParallelOldGC</span><br><span class="line">关闭 -XX:-UseParallelOldGC</span><br><span class="line"><span class="comment">//新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器</span></span><br><span class="line"></span><br><span class="line">ParallelOl垃圾收集器（老年代）</span><br><span class="line">开启 -XX:+UseParallelGC</span><br><span class="line">关闭 -XX:-UseParallelGC</span><br><span class="line"><span class="comment">//新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器</span></span><br><span class="line"></span><br><span class="line">CMS垃圾收集器（老年代）</span><br><span class="line">开启 -XX:+UseConcMarkSweepGC</span><br><span class="line">关闭 -XX:-UseConcMarkSweepGC</span><br><span class="line"></span><br><span class="line">G1垃圾收集器</span><br><span class="line">开启 -XX:+UseG1GC</span><br><span class="line">关闭 -XX:-UseG1GC</span><br></pre></td></tr></table></figure><hr><h5 id="五、GC策略配置"><a href="#五、GC策略配置" class="headerlink" title="五、GC策略配置"></a><strong>五、GC策略配置</strong></h5><p><strong>GC并行执行线程数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=<span class="number">16</span></span><br></pre></td></tr></table></figure><p><strong>新生代可容纳的最大对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PretenureSizeThreshold=<span class="number">1000000</span> <span class="comment">//大于此值的对象直接会分配到老年代，设置为0则没有限制。</span></span><br><span class="line">    <span class="comment">//避免在Eden区和Survivor区发生大量的内存复制，该参数只对Serial和ParNew收集器有效，Parallel Scavenge并不认识该参数</span></span><br></pre></td></tr></table></figure><p><strong>进入老年代的GC年龄</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">进入老年代最小的GC年龄</span><br><span class="line">-XX:InitialTenuringThreshol=<span class="number">7</span> <span class="comment">//年轻代对象转换为老年代对象最小年龄值，默认值7，对象在坚持过一次Minor GC之后，年龄就加1，每个对象在坚持过一次Minor GC之后，年龄就增加1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进入老年代最大的GC年龄</span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">15</span> <span class="comment">//年轻代对象转换为老年代对象最大年龄值，默认值15</span></span><br></pre></td></tr></table></figure><hr><h5 id="六、GC日志信息配置"><a href="#六、GC日志信息配置" class="headerlink" title="六、GC日志信息配置"></a><strong>六、GC日志信息配置</strong></h5><p><strong>配置GC文件路径</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xloggc:/data/gclog/gc.log<span class="comment">//固定路径名称生成</span></span><br><span class="line">-Xloggc:/home/GCEASY/gc-%t.log <span class="comment">//根据时间生成</span></span><br></pre></td></tr></table></figure><p><strong>滚动生成日志</strong></p><p>日志文件达到一定大小后，生成另一个文件。须配置Xloggc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+UseGCLogFileRotation</span><br><span class="line">关闭 -XX:-UseGCLogFileRotation</span><br><span class="line"></span><br><span class="line">-XX:NumberOfGCLogFiles=<span class="number">4</span>   <span class="comment">//滚动GC日志文件数，默认0，不滚动</span></span><br><span class="line">-XX:GCLogFileSize=100k  <span class="comment">//GC文件滚动大小，需配置UseGCLogFileRotation，设置为0表示仅通过jcmd命令触发</span></span><br></pre></td></tr></table></figure><p><strong>打印详细的GC日志</strong></p><p>打印GC的详细日志，并且在程序运行结束是会打印出JVM的内存占用情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+PrintGCDetails</span><br><span class="line">关闭 -XX:-PrintGCDetails</span><br></pre></td></tr></table></figure><p><strong>打印应用暂停时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+PrintGCApplicationStoppedTime</span><br><span class="line">关闭 -XX:-PrintGCApplicationStoppedTime</span><br></pre></td></tr></table></figure><p><strong>每次GC完成后，打印出JVM堆内存每个区域的使用情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+PrintHeapAtGC</span><br><span class="line">关闭 -XX:-PrintHeapAtGC</span><br></pre></td></tr></table></figure><p><strong>打印存活实例年龄信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+PrintTenuringDistribution</span><br><span class="line">关闭 -XX:-PrintTenuringDistribution</span><br></pre></td></tr></table></figure><hr><h5 id="七、条件触发配置"><a href="#七、条件触发配置" class="headerlink" title="七、条件触发配置"></a><strong>七、条件触发配置</strong></h5><p><strong>OutOfMemory异常时输出文件</strong></p><p>抛出内存溢出错误时导出堆信息到指定文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">关闭 -XX:-HeapDumpOnOutOfMemoryError</span><br><span class="line"><span class="comment">//可以通过jinfo -flag [+|-]HeapDumpOnOutOfMemoryError &lt;pid&gt; 或 jinfo -flag HeapDumpOnOutOfMemoryError=&lt;value&gt; &lt;pid&gt; 来动态开启或设置值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-XX:HeapDumpPath=/data/dump/jvm.dump<span class="comment">//设置文件路径</span></span><br><span class="line"><span class="comment">//当HeapDumpOnOutOfMemoryError开启的时候，dump文件的保存路径，默认为工作目录下的</span></span><br></pre></td></tr></table></figure><p><strong>在Full GC时生成dump文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpBeforeFullGC       <span class="comment">//实现在Full GC前dump</span></span><br><span class="line">-XX:+HeapDumpAfterFullGC        <span class="comment">//实现在Full GC后dump。</span></span><br><span class="line">-XX:HeapDumpPath=e:\dump        <span class="comment">//设置Dump保存的路径</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">&quot;-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=/data/dump/jvm.dump&quot;</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><p><strong>查看JVM所有参数</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsInitial</span><br></pre></td></tr></table></figure><hr><h5 id="九、常用启动参数"><a href="#九、常用启动参数" class="headerlink" title="九、常用启动参数"></a><strong>九、常用启动参数</strong></h5><p><strong>1、设置堆内大小</strong></p><p>设置堆内存大小，Xms 最小内存，Xmx最大内存，不设置默认为物理机内存的四分之一。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms2g   -Xmx2g`     </span><br></pre></td></tr></table></figure><p><strong>2、GC日志参数</strong></p><p>生成GC滚动日志记录 ，当需要对GC排查问题时候需要对此日志分析。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+UseGCLogFileRotation  -XX:+PrintHeapAtGC -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M    -Xloggc:/opt/ard-user-gc-%t.log </span><br><span class="line">-Xloggc:/opt/app/ard-user/ard-user-gc-%t.log   设置日志目录和日志名称</span><br><span class="line">-XX:+UseGCLogFileRotation           开启滚动生成日志</span><br><span class="line">-XX:NumberOfGCLogFiles=5            滚动GC日志文件数，默认0，不滚动</span><br><span class="line">-XX:GCLogFileSize=20M               GC文件滚动大小，需开启UseGCLogFileRotation</span><br><span class="line">-XX:+PrintGCDetails                 开启记录GC日志详细信息（包括GC类型、各个操作使用的时间）,并且在程序运行结束打印出JVM的内存占用情况</span><br><span class="line">-XX:+ PrintGCDateStamps             记录系统的GC时间           </span><br><span class="line">-XX:+PrintGCCause                   产生GC的原因(默认开启)</span><br></pre></td></tr></table></figure><p><strong>3、异常时记录内存日志</strong></p><p>抛出内存溢出错误时导出堆信息到指定文件，内存溢出时需要对此日志进行分析</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=/data/dump/jvm.dump</span><br><span class="line">HeapDumpOnOutOfMemoryError  异常后打印堆内存信息</span><br><span class="line">HeapDumpPath                生成的堆内存日志的路径</span><br></pre></td></tr></table></figure><hr><h5 id="十、各种场景的参数设置方式"><a href="#十、各种场景的参数设置方式" class="headerlink" title="十、各种场景的参数设置方式"></a><strong>十、各种场景的参数设置方式</strong></h5><p><strong>Idea</strong></p><p><img src="/./../imgs/JVM/v2-d78c1b323328416df15ae0d49f782edd_1440w.webp" alt="img"></p><p><img src="/./../imgs/JVM/v2-542d3d81b989240197ba520b9fa9ff29_1440w.webp" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2024/04/19/MySQL/"/>
      <url>/2024/04/19/MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL："><a href="#MySQL：" class="headerlink" title="MySQL："></a>MySQL：</h2><h3 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h3><h4 id="执行一条-SQL-查询语句，期间发生了什么？"><a href="#执行一条-SQL-查询语句，期间发生了什么？" class="headerlink" title="执行一条 SQL 查询语句，期间发生了什么？"></a>执行一条 SQL 查询语句，期间发生了什么？</h4><ul><li><p>连接器：建立连接，管理连接、校验用户身份；</p></li><li><p>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</p></li><li><p>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</p></li><li><p>执行 SQL：执行 SQL 共有三个阶段：</p><ul><li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul><p><img src="/./../../imgs/MySQL/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p></li></ul><h4 id="为什么禁止使用select"><a href="#为什么禁止使用select" class="headerlink" title="为什么禁止使用select *"></a>为什么禁止使用select *</h4><ul><li>增加查询分析器解析成本。</li><li>增减字段容易与 resultMap 配置不一致。</li><li>无用字段增加网络 消耗，尤其是 text 类型的字段。</li></ul><h4 id="SQL语句执行顺序"><a href="#SQL语句执行顺序" class="headerlink" title="SQL语句执行顺序"></a>SQL语句执行顺序</h4><ol><li><p>from 子句组装来自不同数据源的数据；</p></li><li><p>where 子句基于指定的条件对记录行进行筛选；  </p></li><li><p>group by 子句将数据划分为多个分组；  </p></li><li><p>使用聚集函数进行计算； </p></li><li><p>使用 having 子句筛选分组；</p></li><li><p>计算所有的表达式后，select；  </p></li><li><p>使用 order by 对结果集进行排序。</p></li><li><p>limit限制查询数量、查询偏移量</p><p><img src="/./../../imgs/MySQL/image-20231003111856990.png" alt="image-20231003111856990"></p></li></ol><h4 id="Mysql表字段限制"><a href="#Mysql表字段限制" class="headerlink" title="Mysql表字段限制"></a>Mysql表字段限制</h4><p>（1）innodb引擎对于列的硬性要求是不能超过1017列，MyISAM引擎能达到4096的限制</p><p>（2）一个表最多可以包含64个 二级索引,两种引擎都有这个限制。</p><p>（3）索引键前缀长度限制为767个字节 ，<strong>当某一列中的数据非常多的话，在数据页中只会存储该列的前767个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做行溢出，存储超出767字节的那些页面也被称为溢出页。</strong>主键是聚集索引，也是其他二级索引的基础，所以每个主键要在一个数据页存储，不能分布在其他的溢出页，不能像其他大字段一样溢出数据页</p><p>（4）MySQL本身对所有列的组合大小强加了65535的行大小限制，这个更多对应单个列的字段长度不能大于65535字节</p><p><img src="/./../../imgs/MySQL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xKRlBIUA==,size_16,color_FFFFFF,t_70.png" alt="img"></p><h4 id="行溢出后怎么处理"><a href="#行溢出后怎么处理" class="headerlink" title="行溢出后怎么处理"></a>行溢出后怎么处理</h4><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</p><p>Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p><p><img src="/./../../imgs/MySQL/%E8%A1%8C%E6%BA%A2%E5%87%BA.png" alt="img"></p><p>Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。</p><h4 id="varchar-n-中-n-最大取值为多少？"><a href="#varchar-n-中-n-最大取值为多少？" class="headerlink" title="varchar(n) 中 n 最大取值为多少？"></a>varchar(n) 中 n 最大取值为多少？</h4><p>行数据保存格式</p><p>变长字段列表存储各个变长字段的长度 null值列表用一个bit表示该行某一列位null</p><p><img src="/./../../imgs/MySQL/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A81.png" alt="img"></p><p><img src="/./../../imgs/MySQL/COMPACT.drawio.png" alt="img"></p><p><strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节</strong>。</p><p>varchar(n) 字段类型的 n 代表的是最多存储的字符数量，不是字节大小。</p><p>要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。</p><p>我们存储字段类型为 varchar(n) 的数据时，其实分成了三个部分来存储：</p><ul><li>真实数据</li><li>真实数据占用的字节数</li><li>NULL 标识，如果不允许为NULL，这部分不需要</li></ul><p><strong>因为我们这个案例是只有 1 个变长字段，所以「变长字段长度列表」&#x3D; 1 个「变长字段长度」占用的字节数，也就是 2 字节</strong>。</p><p>因为我们在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。所以，<strong>在数据库表只有一个 varchar(n) 字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 &#x3D; 65535 - 2 - 1 &#x3D; 65532</strong>。</p><p><strong>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;&#x3D; 65535</strong>。</p><h4 id="Insert-into和replace-into有什么区别"><a href="#Insert-into和replace-into有什么区别" class="headerlink" title="Insert into和replace into有什么区别"></a>Insert into和replace into有什么区别</h4><p>inset into是不允许添加主键重复列的,而replace可以,且影响行数是2,</p><p>replace into用于不知道操作为更新还是新增的时候,使用时,先尝试直接向库中插入数据,遇到主键或唯一索引而引发的重复键错误时,删除掉冲突行并再次尝试插入,这个过程是MySQL自行处理的,并不会存在用户感知之类的</p><h4 id="union和union-all的区别"><a href="#union和union-all的区别" class="headerlink" title="union和union all的区别"></a>union和union all的区别</h4><p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</p><p>union：对两个结果集进行并集操作，不包括重复行，相当于distinct，同时进行默认规则的排序；</p><p>union all：对两个结果集进行并集操作，包括重复行，不进行排序；</p><p>union因为要进行重复值扫描，所以在结果集庞大的情况下，效率极低，因此建议使用union all。</p><p>若结果集去重是强需求，则在应用程序代码上进行去重，因为数据库资源要比应用服务器资源更加珍贵。</p><h4 id="MySQL根据某一个或者多个字段查找重复数据的sql语句（MySQL如何避免查询重复字段）"><a href="#MySQL根据某一个或者多个字段查找重复数据的sql语句（MySQL如何避免查询重复字段）" class="headerlink" title="MySQL根据某一个或者多个字段查找重复数据的sql语句（MySQL如何避免查询重复字段）"></a>MySQL根据某一个或者多个字段查找重复数据的sql语句（MySQL如何避免查询重复字段）</h4><p><strong>1.表中有id和name 两个字段，查询出name重复的所有数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> xi a <span class="keyword">where</span> (a.username) <span class="keyword">in</span> (<span class="keyword">select</span> username  <span class="keyword">from</span> xi <span class="keyword">group</span> <span class="keyword">by</span> username <span class="keyword">having</span> <span class="built_in">count</span> (<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>2、查询出所有数据进行分组之后，查询重复的name字段和重复次数，先列下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span> (username) <span class="keyword">as</span> <span class="string">&#x27;重复次数&#x27;</span>,username <span class="keyword">from</span> xi <span class="keyword">group</span> <span class="keyword">by</span> username <span class="keyword">having</span> <span class="built_in">count</span> (<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> username <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>3、以下为查看别人的 结果，现列下：查询及删除重复记录的方法大全</p><p>1、查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> people <span class="keyword">where</span> peopleId <span class="keyword">in</span> (<span class="keyword">select</span> peopleId <span class="keyword">from</span> people <span class="keyword">group</span> <span class="keyword">by</span> peopleId <span class="keyword">having</span> <span class="built_in">count</span> (peopleId) <span class="operator">&gt;</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>2、删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断，只留有rowid最小的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> people <span class="keyword">where</span> rowid  <span class="keyword">not</span> <span class="keyword">in</span> ( <span class="keyword">select</span> <span class="built_in">min</span>(rowid)  <span class="keyword">from</span> people  <span class="keyword">group</span> <span class="keyword">by</span> peopleId )</span><br></pre></td></tr></table></figure><p>3、删除两个字段重复的数据，只保留一条</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> group_member</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> b.id</span><br><span class="line">  <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(id) <span class="keyword">AS</span> id</span><br><span class="line">    <span class="keyword">FROM</span> group_member</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> group_id, member_id</span><br><span class="line">  ) <span class="keyword">AS</span> b</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>4、查找表中多余的重复记录（多个字段）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> vitae a <span class="keyword">where</span> rowid  <span class="keyword">in</span> ( <span class="keyword">select</span> rowid  <span class="keyword">from</span> vitae  <span class="keyword">group</span> <span class="keyword">by</span> peopleId,seq  <span class="keyword">having</span> <span class="built_in">count</span> (<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>5、查找表中多余的重复记录（多个字段），不包含id最小的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  group_member</span><br><span class="line"><span class="keyword">where</span> id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(g.id) </span><br><span class="line">    <span class="keyword">from</span> group_member g</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> group_id, member_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>6、查询排名前十的数据，包含并列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">s1.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student s1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student s2 <span class="keyword">ON</span> s1.t_id <span class="operator">=</span> s2.t_id </span><br><span class="line"><span class="keyword">AND</span> s1.score <span class="operator">&lt;</span> s2.score </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">s1.id</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="built_in">COUNT</span>( s2.id ) <span class="operator">&lt;</span> <span class="number">10</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">s1.t_id,</span><br><span class="line">s1.score <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h4 id="使用自增id还是UUID来当主键"><a href="#使用自增id还是UUID来当主键" class="headerlink" title="使用自增id还是UUID来当主键"></a>使用自增id还是UUID来当主键</h4><p>应该使用UUID。</p><p>B+树使用双向链表来保存数据，所以使用自增id能够直接加到尾部，不需要页分裂，效率很高，且占用的空间小。但是如果一些敏感信息设置成自增就很容易被推理，暴露机密。</p><p>同时当单表的数据量上来之后我们就需要进行水平分表操作（将一张数据表的数据分成多张表），如果这时我们还是按照之前的自增形式来做主键 id，就有可能会出现 id 重复的问题。</p><p>如果使用UUID，生成的ID不仅是表独立的，而且是库独立的。对以后的数据操作很有好处，可以说一劳永逸。我们可以使用 UUID 来作为不重复的主键 id，但是 UUID 是无序的字符串，所以主键索引就会失效，而且占用空间大。</p><ul><li>全局唯一性：不能出现重复的 id</li><li>递增性：MySQL 的 InnoDB 使用的是聚簇索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，因此在主键的选择上我们还是应该尽可能地使用有序的主键来保证写入性能，我们保证下一个 id 一定大于上一个 id，以此来满足事务版本号、IM 增量消息或者排序的特殊需求</li><li>安全性：如果 id 是连续的，那么我们在知道一些基本规则的情况下就能很轻松地推测出下一份数据，这在一些机密性较高的业务场景是很危险的。所以我们有时会希望 id 是无规则的，最好还能包含有时间戳，这样就能够在开发中快速了解这个分布式 id 的生成时间</li><li>高性能高可用性：确保在任何时候都能正确地生成 id，并且在高并发的环境下也能表现良好</li></ul><p>UUID：我们可以使用 UUID 来作为不重复的主键 id，但是 UUID 是无序的字符串，所以主键索引就会失效</p><p>优点：简单、方便、性能好、出现数据拆分、合并存储的时候，能达到全局的唯一性<br>缺点：占用空间大，无序性、存储的是字符串、查询效率低、传输数据量大</p><p>雪花算法：雪花算法是 Twitter 推出的针对分布式环境下的 id 生成算法，其结果是一个 Long 型的 64bit id。具体实现上使用 41bit 作为毫秒数，10bit 作为机器的 id（5bit 是数据中心，5bit 是机器 id），12bit 作为毫秒内的流水号（这意味着每个节点在每毫秒内可以产生 4096 个 id），最后还有一个符号位永远是 0</p><p>优点：不依赖数据库、完全在内存中生成 id、高性能高可用、容量大、每秒可生成数百万个 id、id 递增、后续插入数据库的索引时性能较高<br>缺点：严重依赖系统时钟，如果某台机器的系统时钟发生回拨，就有可能会造成 id 冲突甚至 id 乱序</p><h4 id="MySQL三大范式"><a href="#MySQL三大范式" class="headerlink" title="MySQL三大范式"></a>MySQL三大范式</h4><ul><li><h5 id="第一范式（1-NF）：字段不可再拆分。"><a href="#第一范式（1-NF）：字段不可再拆分。" class="headerlink" title="第一范式（1 NF）：字段不可再拆分。"></a>第一范式（1 NF）：字段不可再拆分。</h5><p><img src="/./../../imgs/MySQL/image-20231003112028615.png" alt="image-20231003112028615"></p></li><li><h5 id="第二范式（2-NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。"><a href="#第二范式（2-NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。" class="headerlink" title="第二范式（2 NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。"></a>第二范式（2 NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。</h5></li></ul><p>​即一张表只能描述一件事情，学生表中就不要存储成绩，可以专门设计一张成绩表存储学生ID和每一科的成绩。否则造成整张表的数据冗余且更新插入等不方便</p><ol><li>造成整表的数据冗余。</li></ol><p>如，学生表，可能我就只有2个学生，每个学生都有许多的信息，比如，年龄、性别、身高、住址……如果与课程信息放到同一张表中，可能每个学生有3门课程，那数据总条数就会变成6条了。但是通过拆分，学生表我们只需要存储 2 条学生信息，课程表只需要存储 3 条课程信息，成绩表就只需保留学号、课程名称和成绩字段。</p><ol start="2"><li>更新数据不方便。</li></ol><p>假设，课程的学分发生了变更，那我们就需要把整表关于该课程的学分都要更新一次，但如果我们拆分出课程表，那我们就只需要把课程表中的课程信息更新就行。</p><ol start="3"><li>插入数据不方便或产生异常。</li></ol><p>① 假设主键是学号或课程名称，我们新增了某个课程，需要把数据插入到表中，这时，可能只有部分人有选修这门课程，那我们插入数据的时候还要规定给哪些人插入对应的课程信息，同时可能由于成绩还没有，我们需要对成绩置空，后续有成绩后还得重新更新一遍。</p><p>② 假设主键是学号和课程名称的联合主键。同样也是新增了某课程，但是暂时没有人选修这门课，缺少了学号主键字段数据，会导致课程信息无法插入。</p><ul><li><h5 id="第三范式（3-NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段-A-可以获取-某非主键字段-B。"><a href="#第三范式（3-NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段-A-可以获取-某非主键字段-B。" class="headerlink" title="第三范式（3 NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。"></a>第三范式（3 NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。</h5></li></ul><p>如果产生这样情况其实就可以把两者重新建表。如员工表既出现了员工所在的部门id，又出现了部门名称和工作地点，就可以把后面三个单独拆成一张表</p><h4 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h4><table><thead><tr><th>存储引擎</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>InnoDB</td><td>①支持事务②行级锁，提高并发性能③支持外键</td><td>各方面都比较优秀，适合绝大部分的场景</td></tr><tr><td>MyISAM</td><td>①不支持事务②不支持外键③只支持表锁不支持行锁④访问速度快</td><td>适合读操作和插入操作比较频繁的数据，而且对事务和并发要求不高，比如系统配置表等静态表</td></tr><tr><td>Memory</td><td>①存储在内存②hash索引</td><td>通常用于临时表以及缓存</td></tr></tbody></table><h4 id="怎么保证redis和DB的数据一致性"><a href="#怎么保证redis和DB的数据一致性" class="headerlink" title="怎么保证redis和DB的数据一致性"></a>怎么保证redis和DB的数据一致性</h4><h5 id="采用延时双删"><a href="#采用延时双删" class="headerlink" title="采用延时双删"></a>采用延时双删</h5><p><strong>其核心思想是在更新数据库后，先删除缓存中的数据，然后在一段时间后再次删除缓存。这样，即使在这段时间内有新的读请求导致缓存被重建，由于缓存中的数据已经被删除，所以新的读请求会重新从数据库中读取最新数据，从而保证缓存与数据库的一致性。</strong></p><p>这种方案，在并发写的时候，不会出问题。因为都是先更新数据库再删除缓存，不会出现不一致的情况。</p><p>但是在并发读写的时候，还是有可能出现数据不一致。</p><ol><li>读请求查询缓存没数据，然后查询数据库</li><li>写请求更新数据库，删除缓存</li><li>读请求回写缓存</li></ol><p>执行结果是，缓存中是旧数据，而数据库里是新数据，导致数据不一致。</p><p>其实这种情况出现的概率很低，写缓存比写数据库快出几个量级，读写缓存都是内存操作，速度非常快。</p><p>遇到了这种极端场景，我们也需要做一下兜底方案，缓存都要设置过期时间，或者当更新数据后休眠一段时间通过定时任务（可通过整合定时任务框架、创建线程池，从中拿出一个线程休眠一段时间再启动）再删除一次缓存。这种方案属于数据的弱一致性和最终一致性，而不是强一致性。</p><h5 id="异步更新缓存-基于订阅binlog的同步机制"><a href="#异步更新缓存-基于订阅binlog的同步机制" class="headerlink" title="异步更新缓存(基于订阅binlog的同步机制)"></a>异步更新缓存(基于订阅binlog的同步机制)</h5><p>采用缓存淘汰策略，先更新数据库，再删除对应redis缓存后更新缓存。</p><p><img src="/./../../imgs/MySQL/image-20231012113429919.png" alt="image-20231012113429919"></p><p>通过 Canal（消息推送工具也可以用kafka、rabbitMQ等来实现可靠性消息通信更新Redis。） 组件，（伪装成从节点）监控 Mysql 中 binlog（记录MySQL中新的写入、更新、删除等操作） 的日志，把更新后的数据同步到 Redis 里面，canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。</p><p><img src="/./../../imgs/MySQL/image-20231012113453556.png" alt="image-20231012113453556"></p><p>因为这里是基于最终一致性来实现的，如果业务场景不能接受数据的短期不一致性，那就不能使用这个方案来做。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务的四大特性（ACID）："><a href="#事务的四大特性（ACID）：" class="headerlink" title="事务的四大特性（ACID）："></a>事务的四大特性（ACID）：</h4><ul><li>原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性：事务完成时，必须使得所有的数据保持一致状态</li><li>隔离性：数据库系统提供的隔离机制，保证事务不受外部并发操作的影响，在独立的环境下运行。</li><li>持久性：事务一单提交或回滚，会对数据库产生永久的改变</li></ul><table><thead><tr><th>特性</th><th>由什么机制来保证</th></tr></thead><tbody><tr><td>原子性、一致性、持久性</td><td>redo log、 undo log</td></tr><tr><td>隔离性</td><td>MVCC多版本控制、数据库的锁</td></tr></tbody></table><h4 id="并发事务问题："><a href="#并发事务问题：" class="headerlink" title="并发事务问题："></a>并发事务问题：</h4><ol><li><p>脏读：一个事务读到了另一个事务还没有提交的数据。<img src="/./../../imgs/MySQL/image-20231003111916626.png" alt="image-20231003111916626"></p></li><li><p>不可重复读：一个事务先后读取同一条记录，但是两次读取的<strong>数据不同</strong>，强调数据不同</p></li></ol><p><img src="/./../../imgs/MySQL/image-20231003111926058.png" alt="image-20231003111926058"></p><ol start="3"><li>幻读：前后读取的记录数量不一致，强调说的是存不存在的问题：原来不存在的,现在存在了,则是幻读。<img src="/./../../imgs/MySQL/image-20231003111932452.png" alt="image-20231003111932452"></li></ol><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p><img src="/./../../imgs/MySQL/image-20231003111936844.png" alt="image-20231003111936844"></p><h4 id="undo-log（原子性-一致性）"><a href="#undo-log（原子性-一致性）" class="headerlink" title="undo log（原子性 一致性）"></a>undo log（原子性 一致性）</h4><ul><li>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性、一致性) 和MVCC(多版本并发控制) 。</li><li>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undolog中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</li><li>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</li></ul><h4 id="redo-log（持久性、-一致性）"><a href="#redo-log（持久性、-一致性）" class="headerlink" title="redo log（持久性、 一致性）"></a>redo log（持久性、 一致性）</h4><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo logfile）,前者是在内存中，后者在磁盘中。<strong>当事务提交之后</strong>会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p><img src="/./../../imgs/MySQL/image-20231003112038852.png" alt="image-20231003112038852"></p><p>有了redolog之后，<strong>当对缓冲区的数据进行增删改之后</strong>，会首先将操作的数据页的变化，记录在redolog buffer中。<strong>在事务提交时</strong>，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样<strong>就保证了事务的持久性</strong>。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="哪些情况适合创建索引"><a href="#哪些情况适合创建索引" class="headerlink" title="哪些情况适合创建索引"></a>哪些情况适合创建索引</h4><ul><li><strong>字段的数值有唯一性的限制</strong></li></ul><p>具有唯一索引的字段，即使是组合字段，也必须建成唯一索引。唯一索引对 insert 的速度损耗可以忽略，但是提高的查找速度是明显的。</p><ul><li><strong>频繁作为 *<em>where*</em> 查询条件的字段</strong></li><li><strong>经常GROUP BY 或 ORDER BY的列</strong></li><li><strong>UPDATE、DELETE 的 WHERE 条件列</strong></li><li><strong>DISTINCT 字段需要创建索引</strong>,排序后去重自然也更快了！</li></ul><h4 id="哪些情况不适合创建索引"><a href="#哪些情况不适合创建索引" class="headerlink" title="哪些情况不适合创建索引"></a>哪些情况不适合创建索引</h4><ul><li><strong>在 WHERE 中使用不到的字段，不要设置索引</strong></li></ul><p>同理，如GROUP BY 或 ORDER BY 条件里用不到的字段，也不要设置索引。原因也很简单，不需要快速定位，设置索引也没有用！</p><ul><li><strong>数据量小的表最好不要使用索引</strong></li></ul><p>在数据量很小的时候，原本查询时间已经很短了，不必要再添加索引。索引的回表等操作可能会使耗费时间更多！</p><ul><li><p><strong>有大量重复数据的列上不要建立索引</strong>, 比如sex、status，否则查找效率也很低</p></li><li><p><strong>避免对经常需要更新的表创建过多的索引</strong>，在对数据进行修改时，索引也会需要调整更新，造成很大负担</p></li></ul><h4 id="B-Tree-与-B-Tree相比"><a href="#B-Tree-与-B-Tree相比" class="headerlink" title="B+Tree 与 B-Tree相比"></a>B+Tree 与 B-Tree相比</h4><ul><li>所有的数据都会出现在叶子节点。</li><li>叶子节点形成一个双向循环链表。</li><li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。<img src="/./../../imgs/MySQL/image-20231003111941842.png" alt="image-20231003111941842"></li></ul><h4 id="为什么InnoDB存储引擎选择使用B-tree索引结构"><a href="#为什么InnoDB存储引擎选择使用B-tree索引结构" class="headerlink" title="为什么InnoDB存储引擎选择使用B+tree索引结构?"></a>为什么InnoDB存储引擎选择使用B+tree索引结构?</h4><ol><li>相对于二叉树，层级更少，搜索效率高；</li><li>对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；B+树叶子节点有链表，支持排序和范围查询。</li><li>相对Hash索引，Hash索引会发生Hash冲突，B+tree支持范围匹配及排序操作；</li><li>数据都在叶子节点，搜索效率稳定，且叶子节点形成双向循环链表，便于范围查找和排序</li></ol><p><strong>与shipList相比：****B+树</strong>是多叉树结构，每个结点都是一个16k的数据页，能存放较多索引信息，所以非叶子节点度数很大，三层<strong>左右就可以存储<code>2kw</code>左右的数据。也就是说查询一次数据，如果这些数据页都在磁盘里，那么最多需要查询</strong>三次磁盘IO**。</p><p><strong>跳表</strong>是链表结构，查询都要能达到<strong>二分查找</strong>的效果，相当于一颗二叉搜索树，保存相同量的数据，层数远比B+树高，需要更多的磁盘IO，查询效率更慢。</p><p>而针对<strong>写操作</strong>，B+树会出现页分裂，跳表则独立插入，没有旋转和维持平衡的开销，因此<strong>跳表的写入性能会比B+树要好。</strong></p><p>缺点:B+树用页来保存数据，会产生内存碎片。</p><h4 id="聚集索引-二级索引"><a href="#聚集索引-二级索引" class="headerlink" title="聚集索引&amp;二级索引"></a>聚集索引&amp;二级索引</h4><p><img src="/./../../imgs/MySQL/image-20231003111945629.png" alt="image-20231003111945629"></p><p>聚集索引选取规则:</p><ul><li><p>​如果存在主键，主键索引就是聚集索引。</p></li><li><p>​如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p></li><li><p>​如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p><p><img src="/./../../imgs/MySQL/image-20231003111949312.png" alt="image-20231003111949312"></p></li><li><p>聚集索引的叶子节点下挂的是这一行的数据 。</p></li><li><p>二级索引的叶子节点下挂的是该字段值对应的主键值。</p></li></ul><h4 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h4><p><font color = gold>聚簇索引和非聚簇索引不是聚集索引与二级索引，而是两种数据存储方式。</font></p><p>聚簇索引存储（InnoDB）：<font color = gold>行数据和主键B+树存储在一起</font>，辅助键B+树只存储辅助键和主键，主键和非主键B+树几乎是两种类型的树。</p><p>非聚簇索引存储（MySAM）：<font color = gold>表数据存储在独立的地方</font>&gt;,主键B+树在叶子节点存储指向真正数据行的<strong>地址指针</strong>，而非主键。</p><p>InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id &#x3D; 14″这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。</p><p>MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个<strong>地址指向真正的表数据</strong>，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索<strong>无需访问主键的索引树</strong>。</p><p>假想一个表如下图存储了4行数据。其中Id作为主索引，Name作为辅助索引。图示清晰的显示了聚簇索引和非聚簇索引的差异。</p><p><a href="https://kyle.ai/blog/wp-content/uploads/2018/03/9.png"><img src="/./../../imgs/MySQL/9.png" alt="9"></a> <a href="https://kyle.ai/blog/wp-content/uploads/2018/03/10.png"><img src="/./../../../../../../%2525E4%2525B8%2525AA%2525E4%2525BA%2525BA%2525E5%25258D%25259A%2525E5%2525AE%2525A2/hexo/blog/source/imgs/Java%2525E7%25259F%2525A5%2525E8%2525AF%252586%2525E7%252582%2525B9%2525E6%252580%2525BB%2525E7%2525BB%252593/10.png" alt="10"></a></p><h5 id="聚簇索引的优势"><a href="#聚簇索引的优势" class="headerlink" title="聚簇索引的优势"></a>聚簇索引的优势</h5><p>看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，聚簇索引的优势在哪？</p><ol><li><p>行数据和叶子节点存储在一起，这样主键和行数据是一起载入内存，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。</p></li><li><p>辅助索引使用主键作为”指针” 而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB<strong>在移动行时无须更新辅助索引中的这个”指针”</strong>。也就是说行的位置（会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。</p></li></ol><h4 id="为什么非主键索引存放的是主键ID而不是数据行的地址？"><a href="#为什么非主键索引存放的是主键ID而不是数据行的地址？" class="headerlink" title="为什么非主键索引存放的是主键ID而不是数据行的地址？"></a>为什么非主键索引存放的是主键ID而不是数据行的地址？</h4><p><strong>保持一致性：</strong><br>当数据库表进行DML操作时，可能会出现“页分裂”、’’非叶子节点分裂’’情况，同一行记录的页地址会发生改变，因非主键索引保存的是主键的值，无需同步更改，降低二级索引的维护开销。</p><h4 id="为什么存放主键id而不是行数据？"><a href="#为什么存放主键id而不是行数据？" class="headerlink" title="为什么存放主键id而不是行数据？"></a>为什么存放主键id而不是行数据？</h4><p><strong>节省存储空间：</strong><br>Innodb数据本身就已经汇聚到主键索引所在的B+树上了， 如果普通索引还继续再保存一份数据，就会导致有多少索引就要存多少份数据，造成数据冗余。</p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>存储一些比较长的字符串时，如果建立索引会使得索引变得很大，查询时大量的磁盘IO降低查询效率，此时可以提取字符串的一部分前缀来建立索引，这样可以大大节约索引空间，提高索引效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 截取某个字段的前 n 个字符建立索引</span></span><br><span class="line"><span class="keyword">create</span> index index_name <span class="keyword">on</span> table_name(column_name(n));</span><br></pre></td></tr></table></figure><p>具体截取的字符串的长度是 选择性最高的最小的n，选择性即是不重复的索引值和数据表的记录总数的比值</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p> 覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。索引的b+树的叶子节点中保存了我们需要查询的数据，此时无需进行回表查询。</p><h4 id="联合索引在b-树中怎么存储"><a href="#联合索引在b-树中怎么存储" class="headerlink" title="联合索引在b+树中怎么存储"></a>联合索引在b+树中怎么存储</h4><p>联合索引是对多个列（字段）建立的索引(需要满足最左前缀法则)</p><p><font color = gold><strong>前一个条件</strong>相等的情况下 <strong>当前条件</strong>才会是<strong>有序的</strong>，当<strong>前一个条件</strong>不同 那么无法保证<strong>当前条件</strong>为有序的 所以索引失效</font>,也就是说,只有<strong>记录左边的字段都是相等的时,记录的当前字段才会是有序的,才能使用当前字段索引</strong></p><p>联合索引和其他索引的区别就是在非叶子节点存储的是联合索引上全部字段，按照最左前缀法则排序，叶子节点会存储联合索引全部字段和主键id</p><p><img src="/./../../imgs/MySQL/v2-e6c3ce6effabafb1a96e08cffbeb104b_r.jpg" alt="img"></p><h4 id="索引下推？"><a href="#索引下推？" class="headerlink" title="索引下推？"></a><strong>索引下推？</strong></h4><p><a href="https://juejin.cn/post/7005794550862053412">五分钟搞懂MySQL索引下推 - 掘金 (juejin.cn)</a></p><p><a href="https://blog.csdn.net/wang_luwei/article/details/120274064">Mysql性能优化之什么是索引下推？_索引吓退-CSDN博客</a></p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li><p>索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，是针对非聚集索引得优化（聚集索引没有回表查询这一说法）用于减少存储引擎回表查询的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</p></li><li><p>在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</p></li><li><p>在使用ICP的情况下，如果<font color = gold><strong>存在某些被索引的列</strong>是<strong>判断条件</strong>时，MySQL服务器将<strong>这一部分判断条件</strong>传递给<strong>存储引擎</strong>，然后由存储引擎通过<strong>判断索引是否符合</strong>MySQL服务器传递的<strong>条件</strong>，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器</font>。</p></li></ul><h5 id="优化的原理"><a href="#优化的原理" class="headerlink" title="优化的原理"></a>优化的原理</h5><p>我们先简单了解一下MySQL大概的架构：</p><p><img src="/./../../imgs/MySQL/52288fa925f84cef937bb0b46d27c60atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="MySQL大概架构"></p><p>MySQL服务层负责SQL语法解析、生成执行计划等，并调用存储引擎层去执行数据的存储和检索。</p><p><font color = gold><code>索引下推</code>的<strong>下推</strong>其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理，推的是在查数据走联合索引时，将5.6版本之前 （联合）索引中容忽略的字段给添加上，让（联合）索引中的全部字段都用上。</font></p><p>我们来具体看一下，在没有使用ICP的情况下，MySQL的查询：</p><ul><li>存储引擎读取索引记录；</li><li>根据索引中的主键值，定位并读取完整的行记录；</li><li>存储引擎把记录交给<code>Server</code>层去检测该记录是否满足<code>WHERE</code>条件。</li></ul><p>使用ICP的情况下，查询过程：</p><ul><li>存储引擎读取索引记录（不是完整的行记录）；</li><li>判断<code>WHERE</code>条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；</li><li>条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；</li><li>存储引擎把记录交给<code>Server</code>层，<code>Server</code>层检测该记录是否满足<code>WHERE</code>条件的其余部分。</li></ul><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>使用一张用户表<code>tuser</code>，表里创建联合索引（name, age）。</p><p><img src="/./../../imgs/MySQL/1b49ff7a5bff433688d7640d1ca64fb4tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="用户表"></p><p>如果现在有一个需求：检索出表中<code>名字第一个字是张，而且年龄是10岁的所有用户</code>。那么，SQL语句是这么写的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>假如你了解索引最左匹配原则，那么就知道这个语句在搜索索引树的时候，只能用 <code>%张</code>，<font color = gold>会忽略age这个字段</font>，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为1，4，然后拿着取到的id值一次次的回表查询，因此这个过程需要回表两次。</p><p><strong>（忽略的原因是：<font color = gold>组合索引满足最左匹配，但是遇到非等值判断时匹配停止</font>。name like ‘陈%’ 不是等值匹配，所以 age &#x3D; 20 这里就用不上 (name,age) 组合索引了。如果没有索引下推，组合索引只能用到 name，age 的判定就需要回表才能做了。5.6版本之后有了索引下推，age &#x3D; 20 可以直接在组合索引里判定。）</strong></p><p><img src="/./../../imgs/MySQL/a2db6afbc11546fbb4205b2faa64400ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="B+树联合索引"></p><p><strong>没有使用ICP</strong></p><p>存储引擎根据通过联合索引找到<code>name like &#39;张%&#39;</code> 的主键id（1、4），逐一进行回表扫描，去聚簇索引找到完整的行记录，server层再对数据根据<code>age=10进行筛选</code>。</p><p>我们看一下示意图：</p><p><img src="/./../../imgs/MySQL/c97ed6c5e395416181cb57591151fb09tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="未使用ICP"></p><p>可以看到需要回表两次，把我们联合索引的另一个字段<code>age</code>浪费了。</p><p><strong>使用ICP</strong></p><p>存储引擎根据（name，age）联合索引，找到<code>name like &#39;张%&#39;</code>，由于<strong>联合索引中包含<code>age</code>列</strong>，InnoDB并没有忽略索引中age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要回表一次。，所以存储引擎直接再联合索引里按照<code>age=10</code>过滤。按照过滤后的数据再一一进行回表扫描。</p><p>我们看一下示意图：</p><p><img src="/./../../imgs/MySQL/8edc3c9af2e5403da79f77e50adaecd3tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="使用ICP的示意图"></p><p>可以看到只回表了一次。</p><p>除此之外我们还可以看一下执行计划，看到<code>Extra</code>一列里<code> Using index condition</code>，这就是用到了索引下推。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>复制代码<span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tuser <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> na_index      <span class="operator">|</span> na_index <span class="operator">|</span> <span class="number">102</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">25.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure><h5 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h5><ul><li>只能用于<code>range</code>（范围查询）、 <code>ref</code>、 <code>eq_ref</code>、<code>ref_or_null</code>访问方法；</li><li>只能用于<code>InnoDB</code>和 <code>MyISAM</code>存储引擎及其分区表；</li><li>对<code>InnoDB</code>存储引擎来说，索引下推只适用于二级索引（也叫辅助索引）;</li></ul><blockquote><p>索引下推的目的是为了减少回表次数，也就是要减少IO操作。对于<code>InnoDB</code>的<strong>聚簇索引</strong>来说，数据和索引是在一起的，不存在回表这一说。</p></blockquote><ul><li>引用了子查询的条件不能下推；</li><li>引用了存储函数的条件不能下推，因为存储引擎无法调用存储函数。</li></ul><h4 id="为什么范围查找Mysql没有用索引下推优化？"><a href="#为什么范围查找Mysql没有用索引下推优化？" class="headerlink" title="为什么范围查找Mysql没有用索引下推优化？"></a><strong>为什么范围查找Mysql没有用索引下推优化？</strong></h4><p>估计应该是Mysql认为范围查找过滤的结果集过大，like KK% 在绝大多数情况来看，过滤后的结果集比较小，所以这里Mysql选择给 like KK% 用了索引下推优化</p><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><p><a href="https://cloud.tencent.com/developer/article/1992920">15个必知的Mysql索引失效场景，别再踩坑了-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><ol><li><p><strong>在索引列上进行使用内置函数、运算操作（如，+、-、*、&#x2F;）， 索引将失效</strong> ，MySQL 查询优化器无法直接利用索引来定位满足条件的记录，执行全表扫描或使用其他索引进行查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="built_in">SUBSTRING</span>(name, <span class="number">1</span>, <span class="number">5</span>) <span class="operator">=</span> <span class="string">&#x27;Smith&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">-</span> <span class="number">1</span> <span class="operator">&gt;</span> <span class="number">20</span>; </span><br></pre></td></tr></table></figure></li><li><p><strong>发生隐式的类型转换</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> 软件工程 <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>比如字符串不加引号，比如将char转换为int，尽管我们为条件列创建了索引，但由于查询条件中的隐式类型转换，MySQL 将<code>&#39;1&#39;</code>视为一个字符串，而不是整数。这会导致索引无法生效，数据库将会执行全表扫描来搜索匹配的行。</p></li><li><p><strong>头部模糊查询</strong>（尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效） </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%软件%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>因为 % 通配符表示匹配任意数量的字符，导致数据库无法使用索引进行快速查找，而需要执行全表扫描来搜索匹配的行</p></li><li><p><strong>OR连接条件</strong>  OR连接多个条件时，如果一个条件不能使用索引，就需要全表扫描，导致索引失效。这是因为 OR 运算符要求数据库同时检索满足两个条件的数据，而无法利用单一列的索引进行快速查找。我们将查询拆分为两个独立的查询，并分别使用适当的索引，以提高查询性能，可以考虑用union 或者 union all将结果连接起来来替代or</p></li><li><p><strong>联合索引（多列索引）不满足最左前缀法则</strong>。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p></li><li><p>**联合索引中，出现范围查询(&gt;,&lt;)**，范围查询右侧的列索引失效,因为**前一个条件**相等的情况下 **当前条件**才会是**有序的**。<br>当**前一个条件**不同 那么无法保证**当前条件**为有序的 所以索引失效。当范围查询使用&gt;&#x3D; 或 &lt;&#x3D; 时，分为两种， “&#x3D;”走联合索引，不会使右侧的列索引失效， “&lt;” 或者“&gt;”会使索引失效</p></li><li><p><strong>当查询条件使用了is null 或者 is not null</strong>，由于null值不能使用索引，索引也会失效。</p></li><li><p><strong>索引字段上使用 !&#x3D; 或者 &lt;&gt;</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">!=</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure><p>MySQL 的 B-Tree 索引存储的是有序的键值，它只能高效地利用索引来定位特定键值或键值范围的数据。</p><p>但是，使用 !&#x3D; 操作符相当于一个不等条件，无法构建有效的键值范围，因此 MySQL 通常会选择不使用索引，而执行全表扫描来获取结果。</p><p>可以使用等于操作符 &#x3D; 和 NOT 运算符来取代 !&#x3D;，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure><p>或者使用等价的条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="keyword">NOT</span> (age <span class="operator">=</span> <span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>这样可以有效利用索引，提高查询性能。</p></li><li><p><strong>使用not in 或not exists</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_items <span class="keyword">WHERE</span> order_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_id <span class="keyword">FROM</span> orders);</span><br></pre></td></tr></table></figure><p>在这个查询中，子查询 (SELECT order_id FROM orders) 会返回所有的订单ID。如果 orders 表中的订单ID较多，子查询的结果集会很大，导致 MySQL 在执行主查询时需要扫描大量数据，无法高效地利用索引。这可能导致索引失效，性能下降。</p><p>使用 NOT EXISTS：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_items oi <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> orders o <span class="keyword">WHERE</span> o.order_id <span class="operator">=</span> oi.order_id);</span><br></pre></td></tr></table></figure><p>这个查询会查询 order_items 表中的订单项，并使用子查询 (SELECT 1 FROM orders o WHERE o.order_id &#x3D; oi.order_id) 来判断是否存在对应的订单。尽管 NOT EXISTS 子查询只需要找到第一个匹配的结果，就可以确定不存在匹配的结果，但是如果子查询中的条件复杂或执行计划不佳，也可能导致索引失效或影响查询性能。</p><p>为了避免这种情况，可以考虑使用其他方式，比如使用 LEFT JOIN 结合 IS NULL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> oi.<span class="operator">*</span> <span class="keyword">FROM</span> order_items oi <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders o <span class="keyword">ON</span> o.order_id <span class="operator">=</span> oi.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p>这种方式可以利用 LEFT JOIN 并检查 orders 表中的订单ID是否为 NULL，来确定哪些订单项没有对应的订单。这样就能更有效地利用索引，提高查询性能。</p></li><li><p><strong>order by 排序顺序与索引的顺序不匹配</strong>：</p><p>索引是按照升序（ASC）排列的，而我们尝试以降序（DESC）进行排序。虽然数据库可以通过排序结果的逆向扫描来实现降序排序，但这可能会导致索引失效，因为索引无法直接按照所需的顺序匹配。</p></li><li><p>MySQL优化器<strong>评估不走索引比走索引还快</strong>，索引也失效。</p></li></ol><h4 id="如何去合理地创建表的索引"><a href="#如何去合理地创建表的索引" class="headerlink" title="如何去合理地创建表的索引"></a>如何去合理地创建表的索引</h4><ul><li><strong>针对于查询比较频繁建立索引：</strong>常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li><li><strong>尽量选择区分度高的列作为索引</strong>，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li><strong>建立前缀索引</strong>：字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li><strong>建立联合索引</strong>：对进程需要同时查询多个列的语句，建立联合索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li><strong>要控制索引的数量</strong>：索引越多，每次插入删除数据都需要找到多棵B+树进行操作，维护索引结构的代价也就越大，会影响增删改的效率</li><li><strong>定期维护索引</strong>：定期维护索引可以清理无用的索引，以保证数据库的正常运行</li></ul><h4 id="B-树的查询时间复杂度："><a href="#B-树的查询时间复杂度：" class="headerlink" title="B+树的查询时间复杂度："></a>B+树的查询时间复杂度：</h4><p>B+树的搜索过程中的IO次数 &#x3D; 搜索过程中访问节点的数量 &#x3D; B+树的深度 &#x3D; logmN，其中m为B+树一个节点的度数</p><h4 id="通过索引查询数据，会经历几次磁盘IO"><a href="#通过索引查询数据，会经历几次磁盘IO" class="headerlink" title="通过索引查询数据，会经历几次磁盘IO"></a>通过索引查询数据，会经历几次磁盘IO</h4><p>B+树一般高度为3层（3层可以存放约2000W行数据）</p><ul><li><p>如果查询建立了聚集索引，或者能够使用覆盖索引，就不需要回表，也就是需要B+树的层高次，</p></li><li><p>否则要查两次索引，也就是两倍层高次</p></li></ul><p><strong>B+树数据的存储能有多少呢?</strong></p><ol><li>对于非叶子节点，如果key使用的是bigint，则为8字节，指针在mysql中为6字节，一共是14字节，则16k能存放 16 * 1024 &#x2F; 14 &#x3D; 1170 个索引指针。</li><li>对于叶子节点，如果一行数据大小为1k，那么一页就能存16条数据；</li></ol><p><strong>于是可以算出</strong></p><p>高度为2的B+树(18720 条数据)</p><ul><li>根节点存储索引指针节点，那么它有1170个叶子节点存储数据，每个叶子节点可以存储16条数据，一共 1170 x 16 &#x3D; 18720 条数据。</li></ul><p>而对于高度为3的B+树(21902400 条数据)</p><ul><li>就可以存放 1170 x 1170 x 16 &#x3D; 21902400 条数据（两千多万条数据），也就是对于两千多万条的数据，</li></ul><h4 id="为什么Mysql页设置为16KB"><a href="#为什么Mysql页设置为16KB" class="headerlink" title="为什么Mysql页设置为16KB"></a>为什么Mysql页设置为16KB</h4><p>mysql的数据是放在页里面的,一次数据I&#x2F;O至少加载一页数据.这样是为了减少I&#x2F;O资源浪费</p><p> mysql设置16K的大小，数据就可以存<strong>2千多万</strong>就已经足够了吧，既能保证一次磁盘IO不要Load太多的数据 又能保证一次load的性能，即便表的数据在几千万的数量也能保证树的高度在一个可控的范围。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="MySQL锁概述"><a href="#MySQL锁概述" class="headerlink" title="MySQL锁概述"></a>MySQL锁概述</h4><p>锁是计算机协调多个进程或线程并发访问某一资源的机制，在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源，所以数据库也需要使用不同的锁来保证数据并发访问的一致性、有效性，锁冲突也是影响数据库并发访问性能的一个重要因素，所以锁对于数据库是很重要的。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ul><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据</li></ul><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p><strong>锁定数据库中的所有表</strong></p><p>特点：</p><ul><li>加锁后整个数据库实例处于只读状态，</li><li>后续的DML语句，DDL语句，事务提交语句均被阻塞。</li><li>如果在主库上备份，整个数据库处于只读状态，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li></ul><p>应用场景：</p><ul><li>全库的逻辑备份，从而获取一致性视图。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加全局锁</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"><span class="comment">-- 备份文件</span></span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p <span class="number">1234</span> itcast <span class="operator">&gt;</span> itcast.sql</span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p><strong>每次操作锁住整张表</strong>。表级锁主要有三类：<strong>表锁、元数据锁、意向锁</strong>。</p><h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5><p>表锁分为两类，表共享读锁(read lock)和表共享写锁(write lock)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加锁</span></span><br><span class="line">lock <span class="keyword">table</span> table_name read<span class="operator">/</span>write</span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">unlock tables <span class="operator">/</span> 客户端断开连接</span><br></pre></td></tr></table></figure><p><strong>读锁</strong></p><p>客户端A对表a加上读锁，则A和其他客户端均不能执行DDL和DML语句，均可以执行DQL语句，直到客户端A释放读锁。</p><p><img src="/./../../imgs/MySQL/%E8%AF%BB%E9%94%81.png" alt="读锁"></p><p><strong>写锁</strong></p><p>客户端A对表a加上写锁，则A可以执行DDL&#x2F;DML&#x2F;DQL语句，其他客户端均不可以执行DDL&#x2F;DML&#x2F;DQL语句，直到客户端A释放锁。</p><p><img src="/./../../imgs/MySQL/%E5%86%99%E9%94%81.png" alt="写锁"></p><h5 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a>元数据锁（MDL）</h5><p>MDL加锁过程由系统自动控制，不需要显式使用</p><p>在表中有活动事务时，不可以对元数据进行写入操作，元数据简单来说就是一张表的表结构，简单来说就是防止DML语句和DDL语句的冲突，有事务时不能修改表结构，保证读写的正确性。</p><table><thead><tr><th>对表的操作</th><th>加的MDL锁</th></tr></thead><tbody><tr><td>DML和DQL语句(增删改查)</td><td>MDL读锁（共享）</td></tr><tr><td>DDL语句(修改表结构)</td><td>MDL写锁(排他)</td></tr></tbody></table><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p><strong>意向锁是为了防止行锁与表锁发生冲突</strong>，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p><ul><li>当一个事务修改某一行数据时有可能会对表加上行锁，此时如果有另一个事务试图对表加上表锁，就有可能发生锁冲突，表锁需要检查每行数据是否加锁。</li><li>为了防止这种情况，第一个事务在加行锁之前会对整张表加上意向锁，记录行锁信息，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。</li></ul><p>意向锁分为意向共享锁和意向排他锁。意向锁之间不会互斥。</p><p>意向共享锁（IS）：由语句select…lock in share mode添加。与表锁读锁兼容，与表锁写锁互斥。</p><p>意向排他锁（IX）：由insert，update，delect，select…for update添加。与表锁的写锁和读锁都互斥。</p><p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><p><strong>每次操作锁住对应的行数据</strong>。只存在于InnoDB存储引擎之中。行级锁是针对主键索引加锁。行级锁主要分为三类，行锁（Record Lock），间隙锁（Gap Lock），Next-Key Lock。</p><h5 id="行锁-Record-Lock"><a href="#行锁-Record-Lock" class="headerlink" title="行锁 - Record Lock"></a>行锁 - Record Lock</h5><p>锁定单个记录，防止其他事务对此进行update和delete，在读提交和可重复读的隔离级别下均支持。行锁分为两类，<strong>共享锁</strong>和<strong>排他锁</strong>，共享锁之间兼容，排他锁与共享锁和排他锁均不兼容。基本语句的行锁加锁情况如下：</p><p><img src="/./../../imgs/MySQL/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8A%A0%E9%94%81%E6%83%85%E5%86%B5.png" alt="基本语句的行锁加锁情况"></p><p>特点</p><ul><li>使用update或delete针对唯一索引已存在的记录进行等值匹配时，表锁会优化为行锁，只锁目标记录。</li><li>如果不用索引检索数据，语句不走索引，那么InnoDB会对所有的记录加锁，此时行锁升级为表锁。</li></ul><h5 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁 - Gap Lock"></a>间隙锁 - Gap Lock</h5><p>间隙锁 是 <strong>Innodb 在 RR(可重复读) 隔离级别</strong> 下为了解决<code>幻读问题</code>时引入的锁机制。<strong>间隙锁是innodb中行锁的一种</strong>。</p><p>锁定索引之间的间隙，确保索引之间的间隙不变，防止其他事务对这个间隙的insert的操作。</p><p>请务必牢记：<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据</strong>。</p><p>举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,…,100,101，下面的SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empid <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure><p>当我们用条件检索数据，并请求共享或排他锁时，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p><p>这个时候如果你插入empid等于102的数据的，如果那边事物还没有提交，那你就会处于等待状态，无法插入数据。</p><p>间隙锁在innoDB中的唯一作用就是在一定的“间隙”内防止其他事务的插入操作，以此防止幻读的发生：</p><ul><li>使用update或delete针对<strong>唯一索引</strong>上不存在的记录进行等值匹配时，InnoDB会对数据加上间隙锁，左开右闭。此时会阻塞这个间隙中的insert语句。</li><li>间隙锁之间兼容，同一个间隙可以重复加锁</li><li>普通索引（非唯一索引）上的等值查询向右遍历到第一个不满足要求的记录时，next-key退化为间隙锁，锁住 查询的值所在的区间</li></ul><h5 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h5><ul><li>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</li></ul><p><strong>临键锁</strong>只与<strong>非唯一索引列</strong>有关，在<strong>唯一索引列（包括主键列）上不存在临键锁。</strong>当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。</p><p>当查询的索引含有唯一属性（唯一索引，主键索引）时，Innodb存储引擎会对next-key lock进行优化，将其降为record lock,即仅锁住索引本身，而不是范围，因为是唯一索引，不会插入重复的数据，不会造成幻读。</p><h5 id="何时使用行锁，何时产生间隙锁"><a href="#何时使用行锁，何时产生间隙锁" class="headerlink" title="何时使用行锁，何时产生间隙锁"></a>何时使用行锁，何时产生间隙锁</h5><ol><li>只使用<strong>唯一索引查询</strong>，并且<strong>只锁定一条记录</strong>时，innoDB会<strong>使用行锁</strong>，因为是唯一索引，不能插入已经重复的数据，造成幻读。</li><li>只使用<strong>唯一索引查询</strong>，但是检索条件是<strong>范围检索</strong>，或者是<strong>唯一检索然而检索结果不存在</strong>（试图锁住不存在的数据）时，会产生 <strong>Next-Key Lock</strong>。</li><li>使用<strong>普通索引检索</strong>时，不管是何种查询，<strong>只要加锁</strong>，都会<strong>产生间隙锁</strong>。</li><li>同时使用<strong>唯一索引</strong>和<strong>普通索引</strong>时，由于数据行是<strong>优先根据普通索引排序</strong>，再根据唯一索引排序，所以<strong>也会产生间隙锁</strong>。</li></ol><h4 id="mysql：死锁是什么？-实习中你有遇到死锁的情况吗"><a href="#mysql：死锁是什么？-实习中你有遇到死锁的情况吗" class="headerlink" title="mysql：死锁是什么？ 实习中你有遇到死锁的情况吗"></a>mysql：死锁是什么？ 实习中你有遇到死锁的情况吗</h4><p><strong>1、产生原因：</strong></p><p>所谓死锁：是指两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用，它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。</p><ul><li>死锁的关键在于：两个(或以上)的线程加锁的顺序不一致。</li><li>那么对应的解决死锁问题的关键就是：让不同的线程加锁有次序</li></ul><p><strong>2、产生示例：</strong></p><p>案例一</p><p>需求：将投资的钱拆成几份随机分配给借款人。</p><p>起初业务程序思路是这样的：</p><p>投资人投资后，将金额随机分为几份，然后随机从借款人表里面选几个，然后通过一条条select for update 去更新借款人表里面的余额等。</p><p>例如两个用户同时投资，A用户金额随机分为2份，分给借款人1，2</p><p>B用户金额随机分为2份，分给借款人2，1</p><p>由于加锁的顺序不一样，死锁当然很快就出现了。</p><p>对于这个问题的改进很简单，直接把所有分配到的借款人直接一次锁住就行了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> xxx <span class="keyword">where</span> id <span class="keyword">in</span> (xx,xx,xx) <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><h4 id="乐观锁与悲观锁，在MySQL中怎么实现"><a href="#乐观锁与悲观锁，在MySQL中怎么实现" class="headerlink" title="乐观锁与悲观锁，在MySQL中怎么实现"></a>乐观锁与悲观锁，在MySQL中怎么实现</h4><p>悲观锁，比较消极的一种锁处理方式。直接在操作数据时，抢占锁。其他的事务在进行时就会等待，直到占有锁的事务释放锁为止。</p><p>​    这种处理方式能保证数据的最大一致性，但是容易导致锁超时、并发程度低等问题。 首先我们开启事务一，并且对id&#x3D;1的数据进行update操作，此时我们不提交事务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql root@127.0.0.1:demo&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.002s</span><br><span class="line">mysql root@127.0.0.1:demo&gt; update `user` <span class="built_in">set</span> name = <span class="string">&#x27;张三111111&#x27;</span><span class="built_in">where</span> <span class="built_in">id</span> = 1;</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line">Time: 0.004s</span><br></pre></td></tr></table></figure><p>​    接着我们开启事务二，对id&#x3D;1的数据进行update操作，查看此时会发生什么情况？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql root@127.0.0.1:demo&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.002s</span><br><span class="line">mysql root@127.0.0.1:demo&gt; update `user` <span class="built_in">set</span> sex = 1 <span class="built_in">where</span> <span class="built_in">id</span> = 1;</span><br></pre></td></tr></table></figure><p>​    我们执行完update语句之后，就处于等待状态，SQL语句也不会马上被执行，这是因为事务一没有commit，也就没有释放id&#x3D;1的数据对应的写锁。</p><p>乐观锁认为数据一般情况下不会造成冲突，只有当数据去执行修改情况时，才会针对数据冲突做处理。这里是如何发现冲突了呢？常规的方式，都是在数据行上加一个版本号或者时间戳等字段。(本文使用version作为版本号方式，使用时间戳方式同理)</p><p>​    <strong>乐观锁的实现原理：</strong></p><ul><li>一个事务在读取数据时，将对应的版本号字段读取出来，假设此时的版本号是1。    </li><li>另外一个事务也是执行同样的读取操作。当事务一提交时，对版本号执行+1，此时该数据行的版本号就是2。    </li><li>第二个事务执行修改操作时，针对业务数据做条件，并默认增加一个版本号作为where条件。此时修改语句中的版本号字段是不满足where条件，该事务执行失败。通过这种方式来达到锁的功能。</li></ul><h4 id="MySQL如何解决幻读"><a href="#MySQL如何解决幻读" class="headerlink" title="MySQL如何解决幻读"></a>MySQL如何解决幻读</h4><p><strong>快照读</strong></p><p>快照读，读取的是<strong>快照数据</strong>，不加锁的普通 SELECT 都属于快照读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure><p>通过mvcc机制来解决幻读</p><p><strong>当前读</strong></p><p>当前读就是读的是<strong>最新数据</strong>，而不是历史的数据，加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> <span class="keyword">values</span> ...</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ...</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> ...</span><br></pre></td></tr></table></figure><p>在当前读的条件下，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li><li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止，使用间隙锁锁住区间。</li></ul><p><em>间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会</em><br><em>阻止另一个事务在同一间隙上采用间隙锁。</em></p><p><a href="https://juejin.cn/post/7056583607929798692">MySQL 如何解决幻读（MVCC 原理分析） - 掘金 (juejin.cn)</a></p><h4 id="MVCC机制"><a href="#MVCC机制" class="headerlink" title="MVCC机制"></a>MVCC机制</h4><p>详见<a href="https://juejin.cn/post/7016165148020703246#heading-24">看一遍就理解：MVCC原理详解 - 掘金 (juejin.cn)</a></p><p>InnoDB还会自动的给我们每一条数据添加三个隐藏字段及其含义分别是</p><p><img src="/./../../imgs/MySQL/image-20231003112043284.png" alt="image-20231003112043284"></p><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><p>当某个事务执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，<br>并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/./../../imgs/MySQL/image-20231003112046405.png" alt="image-20231003112046405"></p><p>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致<strong>该记录的undolog生成一条记录版本链表</strong>，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><p>ReadView（读视图）是<strong>快照读 SQL执行时MVCC提取数据的依据</strong>，记录并维护系统当前活跃的事务（未提交的）id。</p><p><strong>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</strong></p><p><strong>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView</strong></p><p>ReadView中包含了四个核心字段：</p><p><img src="/./../../imgs/MySQL/image-20231003112049869.png" alt="image-20231003112049869"></p><p>readview中规定版本链数据的访问规则：<br>trx_id 代表当前undolog版本链对应事务ID。</p><p><img src="/./../../imgs/MySQL/image-20231003112052634.png" alt="image-20231003112052634"></p><h4 id="MySQL-事务的可重复读和读已提交，Read-View-时机"><a href="#MySQL-事务的可重复读和读已提交，Read-View-时机" class="headerlink" title="MySQL 事务的可重复读和读已提交，Read View 时机"></a>MySQL 事务的可重复读和读已提交，Read View 时机</h4><ul><li>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li><li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li></ul><h4 id="MVCC完全解决了幻读吗？"><a href="#MVCC完全解决了幻读吗？" class="headerlink" title="MVCC完全解决了幻读吗？"></a>MVCC完全解决了幻读吗？</h4><p>整个发生幻读的时序图如下：</p><p><img src="/./../../imgs/MySQL/%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png" alt="img"></p><p>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id &#x3D; 5 的记录并提交。接着，事务 A 对 id &#x3D; 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</p><p>因为这种特殊现象的存在，所以我们认为 <strong>MySQL Innodb 中的 MVCC 并不能完全避免幻读现象</strong></p><h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><h4 id="SQL优化（常规）"><a href="#SQL优化（常规）" class="headerlink" title="SQL优化（常规）"></a>SQL优化（常规）</h4><h5 id="插入数据优化"><a href="#插入数据优化" class="headerlink" title="插入数据优化"></a>插入数据优化</h5><ol><li><p>批量插入数据 <code>Insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;); </code></p></li><li><p>手动控制事务 ，避免频繁开启、提交事务</p><p><code>start transaction; insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;); insert into tb_test values(4,&#39;Tom&#39;),(5,&#39;Cat&#39;),(6,&#39;Jerry&#39;); insert into tb_test values(7,&#39;Tom&#39;),(8,&#39;Cat&#39;),(9,&#39;Jerry&#39;); commit;</code></p></li><li><p>主键顺序插入，性能要高于乱序插入，乱序插入会出现页分裂会降低效率。</p></li><li><p>一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，可以使用MySQL数据库提供的load指令进行插入</p><p><code>-- 客户端连接服务端时，加上参数 -–local-infile</code><br><code>mysql –-local-infile -u root -p</code><br><code>-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</code><br><code>set global local_infile = 1;</code><br><code>-- 执行load指令将准备好的数据，加载到表结构中</code><br><code>load data local infile &#39;/root/sql1.log&#39; into table tb_user fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39; ;</code></p></li></ol><h5 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h5><ul><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改</li></ul><h5 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h5><ul><li>在分组操作时，可以通过索引来提高效率。</li><li>分组操作时，索引的使用也是满足最左前缀法则的。</li></ul><h5 id="表连接优化"><a href="#表连接优化" class="headerlink" title="表连接优化"></a>表连接优化</h5><ul><li>经常在连接的列上,也是外键上创建索引,可以加快连接的速度；</li><li>合理选择驱动表，小表驱动大表。减少创建连接的次数，因为小表连接一次可以在大表中查询多次。</li><li>合理添加过滤条件可以显著减少扫描次数。</li></ul><p>left join的情况下，对右表加索引，左表是驱动表，左连接就是左边都要查出来，所以左边还是all，但是右边是ref了。</p><h5 id="子查询怎么优化"><a href="#子查询怎么优化" class="headerlink" title="子查询怎么优化"></a>子查询怎么优化</h5><p>把子查询转化为表连接，并在右表的连接字段（外键）建立索引实现优化</p><h5 id="limit优化-深度分页怎么优化？"><a href="#limit优化-深度分页怎么优化？" class="headerlink" title="(limit优化)深度分页怎么优化？"></a>(limit优化)深度分页怎么优化？</h5><p><strong>为什么深度分页比较慢？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,balance <span class="keyword">from</span> account <span class="keyword">where</span> update_time<span class="operator">&gt;</span> <span class="string">&#x27;2020-09-19&#x27;</span> limit <span class="number">100000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这条sql的执行流程:</p><ul><li>先从update_time的索引树中找到100010条满足条件的记录，返回主键id给server，server再从主键树中回表查询100010行记录，然后扔掉前面100000行</li></ul><p>由于扫描了100000行无用的记录，还要回表100010次，所以效率很低。</p><ol><li><strong>子查询优化</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,balance <span class="keyword">FROM</span> account <span class="keyword">where</span> id <span class="operator">&gt;=</span> (<span class="keyword">select</span> a.id <span class="keyword">from</span> account a <span class="keyword">where</span> a.update_time <span class="operator">&gt;=</span> <span class="string">&#x27;2020-09-19&#x27;</span> limit <span class="number">100000</span>, <span class="number">1</span>) LIMIT <span class="number">10</span></span><br></pre></td></tr></table></figure><p>一种优化思路是减少回表次数，即子查询优化。即从二级索引树中取出来记录的第一条的主键ID，这个过程是不用回表的，因为2级树的叶子节点中有ID，取到第一个记录的ID，再回到主键树从这个ID开始取十个数，大大减少了回表次数，从而提高了查询效率。</p><ol start="2"><li><strong>延迟关联</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  acct1.id,acct1.name,acct1.balance <span class="keyword">FROM</span> account acct1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> a.id <span class="keyword">FROM</span> account a <span class="keyword">WHERE</span> a.update_time <span class="operator">&gt;=</span> <span class="string">&#x27;2020-09-19&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a.update_time LIMIT <span class="number">100000</span>, <span class="number">10</span>) <span class="keyword">AS</span>  acct2 <span class="keyword">on</span> acct1.id<span class="operator">=</span> acct2.id;</span><br></pre></td></tr></table></figure><p>这个思路也是和子查询优化差不多，同样是先找好ID再回表，区别是从二级索引树中先找出对应的n条数据再两表联查。</p><ol start="3"><li><strong>游标标记法</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span>  birth_date <span class="operator">&gt;</span><span class="string">&#x27;1955-01-01&#x27;</span> <span class="keyword">and</span> emp_no <span class="operator">&gt;</span> <span class="number">229225</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> emp_no limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>记录上一次查询到的主键ID，下一次直接从主键树中该ID往后查询。缺点是在查询过程中数据库数据变化可能导致查询的数据不准，并且要求字段自增，并且每次查询要知道上一次查询结果中的最大Id，所以不能跳页查看，只能前后翻页。</p><h5 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h5><table><thead><tr><th>count(数字)</th><th>InoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，<strong>放一个数字“1”进去，直接按行进行累加</strong>。</th></tr></thead><tbody><tr><td>count(*)</td><td>InnoDB引擎<strong>并不会把全部字段取出来</strong>，而是专门做了优化，不取值，服务层直接按行进行累加。</td></tr><tr><td>count(字段)</td><td>没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，<strong>服务层判断是否为null.不为null，计数累加</strong>。有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</td></tr></tbody></table><p>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(※)，所以尽量使用 count(*※)。</p><h5 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h5><p>尽量给要Update的字段加索引，将表锁降为行锁，缓解锁冲突阻塞。</p><h5 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h5><p><a href="https://mp.weixin.qq.com/s/BLsd1b57-hlILzFvf9Gf0A">https://mp.weixin.qq.com/s/BLsd1b57-hlILzFvf9Gf0A</a></p><p>order by原理：</p><p>查找1000个杭州人，按照名字排序</p><p><img src="/./../../imgs/MySQL/20190505204141450.png" alt="img"></p><h6 id="全字段索引"><a href="#全字段索引" class="headerlink" title="全字段索引"></a>全字段索引</h6><p>我们需要在city上添加一个索引。 我们在执行explain命令来看看这个语句的执行情况。</p><p><img src="/./../../imgs/MySQL/2019050520441242.png" alt="在这里插入图片描述"></p><p>Extra这个字段中的”Using filesort“ 表示的就是需要排序，MySql会给每个线程分配分配一块内存用于排序，称为sort_buffer。</p><p><img src="/./../../imgs/MySQL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyOTYxNjU=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>从图中可以看到，满足city&#x3D;‘杭州’条件的行，是从ID_X到ID_(X+N)的这些记录。<br>通常情况下，这个语句执行流程如下所示：</p><ol><li>初始化sort_buffer, 确定放入name、city、age这三个字段;</li><li>从索引city找到第一个满足city&#x3D;“杭州” 条件的主键id，也就是图中的ID_X;</li><li>到主建索引取出整行数据（回表查询），取name、city、age 三个 字段的值，存入sort_buffer中;</li><li>从索引city取下一个记录的主键id ;</li><li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y;</li><li>对sort_buffer 中的数据<strong>按照字段name做快速排序</strong>;</li><li>按照排序结果取前1000行返回给客户端;</li></ol><p><img src="/./../../imgs/MySQL/640-1713193636636-6.webp" alt="图片"></p><p><img src="/./../../imgs/MySQL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyOTYxNjU=,size_16,color_FFFFFF,t_70-1711682366199-8.png" alt="在这里插入图片描述"></p><p>按照字段 username 做快速排序这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和 sort_buffer 的大小，由参数 <code>sort_buffer_size</code> 决定。</p><p>如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则就需要利用<strong>磁盘临时文件</strong>来辅助排序。</p><p>解释下这里使用磁盘临时文件来进行辅助排序的含义，外部排序常用的排序算法是<strong>多路归并排序算法</strong>，具体步骤如下：</p><ul><li>到主键 id 索引树上查找到对应的整行数据后，取 city、username、age 三个字段的值，存入 sort_buffer 中，能存多少是多少，当 sort_buffer 快要满时，就对 sort_buffer 中的<strong>数据进行排序</strong>，排完后，把数据<strong>临时放到磁盘的一个小文件</strong>中，然后<strong>清空 sort_buffer</strong>（这样的话，一个很大的数据，就会被分成若干个临时磁盘文件）</li><li>继续回到主键 id 索引树取数据，重复上一步，直到取出所有满足条件的数据</li><li>最后，<strong>归并已经有序的若干个临时磁盘文件</strong>，形成一个完整的有序大文件</li></ul><p>可以看出，整个排序过程，我们要查询的 city、username、age 全都参与了，所以，暂且把这个排序过程，称为<strong>全字段排序</strong></p><p><strong>routId 排序</strong><br>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。但这个算法有一个问题，如果查询返回的数据字段多，那么内存中放的数据就要分成多个临时文件，排序的性能就会很差。</p><p>修改参数 max_length_for_sort_data,是MySql中专门控制用于排序的行数据的长度的一个参数，它的意思是，如果单行的长度超过这个值 ，MySQL就认为单行太大，要换一个算法。</p><p><img src="/./../../imgs/MySQL/2019050521265030.png" alt="在这里插入图片描述"></p><p>city,name,age这三个字段的定义总长度是36，我把max_length_for_sort_data设置为16，那么放入sort_buffer的字段只有要排序的列(即 name 字段 是order by 后面的关键字)和主键id。<br>但这时，排序的结果就因为少了city和age字段的值 ，不能直接返回了，整个执行的流程就变成 如下所示的样子:</p><ol><li><p>初始化sort_buffer，确定放入两个字段，即name和id;</p></li><li><p>从索引city找到第一个满足city&#x3D;’上海’条件的主键,也就是图中的ID_X;</p></li><li><p>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中;</p></li><li><p>从索引city取下一个记录的主键id;</p></li><li><p>重复3、4步骤，直到找到不city!&#x3D;‘杭州’;</p></li><li><p>对sort_buffer中的数据按照name进行排序;</p></li><li><p>遍历排序结果，取前1000行，并按照id的值回到原表中的city、name和age三个字段返回给客户端。</p></li></ol><p><img src="/./../../imgs/MySQL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyOTYxNjU=,size_16,color_FFFFFF,t_70-1711682407937-13.png" alt="在这里插入图片描述"></p><h6 id="对排序进行优化"><a href="#对排序进行优化" class="headerlink" title="对排序进行优化"></a>对排序进行优化</h6><p>很显然，如果不排序就能得到正确的结果，那对系统的消耗会小很多，语句的执行时间也会变得更短。</p><p>从上面分析的执行过程我们可以看到，MySQL 之所以需要 sort_buffer，并且在 sort_buffer 上做排序操作，其原因是原来的数据都是无序的。</p><p>回顾下我们的需求：查询出 city 是 “杭州” 的所有 username，并且按照 username 进行排序，返回前 1000 个人的姓名、年龄。</p><p>那，<strong>如果能够保证从 city 这个索引上取出来的数据行，已经天然就是按照 username 进行递增排序的话，不就不用再排序了吗</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> index_city(city,name);</span><br></pre></td></tr></table></figure><p>这样数据的索引就有按照name进行排序。 这样整个排序过程就变成了下面这样。</p><ul><li><p>从索引(city,name)找到第一个满足city&#x3D;”杭州”条件的主键id;</p></li><li><p><font color = "gold">到主键id索引查找整行数据(回表查询),取name、city、age三个字段的值，作为结果集的一部分直接返回,因为索引中name就已经是有序的了，不需要在内存中继续排序。</font></p></li><li><p>从联合索引取出一个记录主键 id；</p></li><li><p>重复2、3步。</p><p><img src="/./../../imgs/MySQL/640.webp" alt="图片"></p></li></ul><p><img src="/./../../imgs/MySQL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyOTYxNjU=,size_16,color_FFFFFF,t_70-1711682434446-16.png" alt="在这里插入图片描述"></p><p>在使用explain 来分析这个sql</p><p><img src="/./../../imgs/MySQL/20190506211600249.png" alt="在这里插入图片描述"></p><p>可以看到extra字段中没有Using filesort了，也就是不需要排序了。<br>由于覆盖索引的原则，我们可以再进行优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> index_city(city,name,age);</span><br></pre></td></tr></table></figure><p>1）从联合索引 (city, username, age) 树上找到第一个满足 city&#x3D;’杭州’ 条件的记录，把这条记录作为结果集的一部分直接返回；</p><p>2）从联合索引 (city, username, age) 树上取下一个记录，同样将这条记录作为结果集的一部分直接返回</p><p>3）重复执行步骤 2，直到查到第 1000 条记录，或者是不满足 city&#x3D;’南京’ 条件时循环结束</p><p>如下图所示：</p><p><img src="/./../../imgs/MySQL/640-1713193542850-3.webp" alt="图片"></p><p>在使用explain 对sql进行分析</p><p><img src="/./../../imgs/MySQL/20190506211915927.png" alt="在这里插入图片描述"></p><p>发现使用Using index，表示的就是使用了覆盖索引，性能上会快很多。</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li><li>尽量使用覆盖索引，避免fileSort。</li><li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）。</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。</li></ul><ol><li>order by 的基本原理其实就是 MySQL 会给每个线程分配一块内存也就是 sort_buffer 用于排序，sort_buffer 中存储的是 select 涉及到的所有的字段，可以称为全字段排序吧。排序这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和 sort_buffer 的大小，由参数 <code>sort_buffer_size</code> 决定。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，就需要利用磁盘临时文件来辅助排序,临时文件存放的是每一次sort后的有序的部分结果,需要将各个磁盘临时文件归并排序来构成完整的结果集。</li><li>这里其实可以优化下，<strong>只存放排序相关的字段</strong>(包括查询字段和主键id,其中主键id用于回表查询)，而不是 select 涉及的所有字段，这样 sort_buffer 中存放的东西就多一点，就尽可能避免使用磁盘进行外部排序，或者说使得划分的磁盘文件相对变少，减少磁盘访问。这种排序称为 rowid 排序。如果表中单行的长度超过 <code>max_length_for_sort_data</code> 定义的值，那 MySQL 就认为单行太大（那么数据量肯定就越大，sort_buffer 可能不够用），由全字段排序改为 rowid 排序, 再排序结束后再根据id会表查询。</li></ol><p>以上是我们说的关于 order by 的两个参数优化，还可以根据索引进行一些优化</p><ol><li>以 <code>select a, b, c from table where a = xxxx order by b</code> 为例，我们为查询条件 a 和排序条件 b 建立联合索引，联合索引就是 a 是从小到大绝对有序的，如果 a 相同，再按 b 从小到大排序，这样就不需要排序了，直接避免了排序这个操作。</li><li>还可以进一步优化，由于联合索引 (a, b) 中没有 c 的值，所以从联合索引树上获取符合条件的对应主键 id 后，还需要回表查询取出 a b c 的值，这个回表查询的过程可以通过建立 (a,b,c) 覆盖索引来避免。</li></ol><h4 id="SQL优化（技巧）"><a href="#SQL优化（技巧）" class="headerlink" title="SQL优化（技巧）"></a>SQL优化（技巧）</h4><h5 id="使用update更新一个大表，怎么优化"><a href="#使用update更新一个大表，怎么优化" class="headerlink" title="使用update更新一个大表，怎么优化"></a>使用update更新一个大表，怎么优化</h5><ol><li>批量更新，而不是一条一条更新</li><li>在分组、排序之前就过滤，过滤优先于一切</li><li>同时过滤、排序条件的列尽量走索引，过滤走索引才能使用行锁，否则会升级为表锁</li><li>尽量走主键索引，联合索引避免回表查询</li><li>分区表：如果可能的话，考虑将大表分成更小的分区表。这样可以将更新操作限制在特定分区内，减少锁定冲突的机会。</li></ol><h5 id="SQL优化，使用索引的时候怎么优化"><a href="#SQL优化，使用索引的时候怎么优化" class="headerlink" title="SQL优化，使用索引的时候怎么优化"></a>SQL优化，使用索引的时候怎么优化</h5><ol><li><p>避免索引失效：</p><ul><li><p>模糊查询 %放在右边<br>原理：模糊查询的时候尽量在字段后面使用模糊查询最左原则</p></li><li><p>避免使用or</p></li><li><p>在where条件中，等式左侧不要进行表带式、函数操作。</p></li><li><p>查询条件不要用 &lt;&gt; 或者 !&#x3D;</p></li><li><p>使用联合索引要符合最左匹配原则</p></li><li><p>避免出现select *</p></li></ul></li><li><p>优先过滤，尽量避免分组后再过滤</p></li><li><p>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p></li><li><p>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p></li></ol><h4 id="慢sql怎么看-怎么解决"><a href="#慢sql怎么看-怎么解决" class="headerlink" title="慢sql怎么看 怎么解决"></a>慢sql怎么看 怎么解决</h4><h5 id="慢查询日志："><a href="#慢查询日志：" class="headerlink" title="慢查询日志："></a>慢查询日志：</h5><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。如果要开启慢查询日志，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 开启MySQL慢日志查询开关`</span><br><span class="line">slow_query_log<span class="operator">=</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line">#设置慢日志的时间为<span class="number">2</span>秒，<span class="keyword">SQL</span>语句执行时间超过<span class="number">2</span>秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#重启mysql服务</span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>检查慢查询日志 ：在慢查询日志中，只会记录执行时间超多我们预设时间（2s）的SQL，执行较快的SQL是不会记录的。</p><p>那这样，通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化</p><h5 id="profile详情"><a href="#profile详情" class="headerlink" title="profile详情"></a>profile详情</h5><p>可以查看执行时间较长的sql，并且了解时间耗费在哪个步骤</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询数据库是否支持profile</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@have_profiling</span>;</span><br><span class="line"><span class="comment">-- 开启profile的开关</span></span><br><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 查看每一条sql的执行情况</span></span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"><span class="comment">-- 查询指定query_id在sql的各个阶段的耗时</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure><p><strong>用explain分析sql</strong></p><p>[explain有哪些字段，分别有什么含义_explain字段含义-CSDN博客](<a href="https://blog.csdn.net/weixin_50998273/article/details/111938295#:~:text=explain%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89">https://blog.csdn.net/weixin_50998273/article/details/111938295#:~:text=explain有哪些字段，分别有什么含义</a> 1 1. id SQL查询中的序列号。 id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行。 2 2.,查询真正使用到的索引。 … 8 8. key_len 查询用到的索引长度（字节数）。 … 更多项目)</p><p>explain命令可以查看select语句的执行计划，包括表连接顺序以及索引使用情况等等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select_sql;</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/MySQL/explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png" alt="sql的执行计划"></p><ul><li><p>id：指代sql语句中的执行顺序。多表查询中，id相同，执行顺序从上到下，id不同，id值越大越先执行</p></li><li><p>select_type:表示查询类型，常见取值有SIMPLE(简单表，即单表查询)，PRIMARY(子查询中的外层查询)等</p></li><li><p>type：表示查询的连接类型，由好到差依次是<strong>null &gt; system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</strong>。</p><ul><li>system,访问系统表</li><li>const，使用<strong>唯一索引</strong>或者<strong>主键索引</strong>，单表中<strong>最多有一条匹配行</strong>。select * from student where id &#x3D; 1;</li><li>eq_ref ,主键或者唯一索引被连接使用，最多只会返回一个值，常出现在多表查询中。从一个表中查出另一个表的主键然后在另一个表中进行查询。</li><li>ref，使用<strong>普通索引</strong>或者<strong>唯一性索引的部分前缀</strong>，有可能会<strong>返回多条值</strong></li><li>range，使用索引选择行，仅检索给定范围内的行，范围查询。</li><li>index，扫描<strong>全表索引</strong>，比all要快一些</li><li>all，<strong>全表扫描</strong>，效果最差</li></ul></li><li><p>possible_key：查询语句可能用到的索引</p></li><li><p>key：实际使用的索引，如果为NULL则说明没有使用索引</p></li><li><p>key_len：索引使用的字节数，这个值越短越好</p></li><li><p>row：MySQL认为可能扫描的行数，是一个估计值，这个值越小越好</p></li><li><p>filtered：表示返回结果的行数占读取行数的百分比，filtered值越大越好</p></li></ul><p>解决：</p><ol><li>SQL语句优化，尽量精简，去除非必要语句</li><li>索引优化，让所有SQL都能够走索引</li><li>如果是表的瓶颈问题，则分表，单表数据量维持在2000W（理论上）以内</li><li>如果是单库瓶颈问题，则分库，读写分离</li><li>如果是物理机器性能问题，则分多个数据库节点</li></ol><p>第 1 个原因：没有索引或者 导致索引失效。<br>第 2 个原因：单表数据量数据过多，导致查询瓶颈<br>第 3 个原因：网络原因或者机器负载过高。<br>第 4 个原因：热点数据导致单点负载不均衡。</p><p>第 1 种情况：索引失效或者没有没有索引的情况<br>首先，可以打开 MySQL 的慢查询日志，收集一段时间的慢查询日志内容，然后找出耗时最长的 SQL 语句，对这些 SQL 语句进行分析。<br>比如可以利用执行计划 explain 去查看 SQL 是否有命中索引。如果发现慢查询的 SQL 没有命中索引，可以尝试去优化这些 SQL 语句，保证 SQL 走索引执行。如果 SQL 结构没有办法优化的话，可以考虑在表上再添加对应的索引。我们在优化 SQL 或者是添加索引的时候，都需要符合最左匹配原则。</p><p>第 2 种情况：单表数据量数据过多，导致查询瓶颈的情况。即使 SQL 语句走了索引，表现性能也不会特别好。这个时候我们需要考虑对表进行切分。表切分规则一般分为两种，一种是水平切分，一种是垂直切分。水平切分的意思是把一张数据行数达到千万级别的大表，按照业务主键切分为多张小表，这些小表可能达到 100 张甚至 1000 张。</p><p><img src="/./../../imgs/MySQL/image-20240318112030315.png" alt="image-20240318112030315"></p><p>那垂直切分的意思是，将一张单表中的多个列，按照业务逻辑把关联性比较大的列放到同一张表中去。</p><p><img src="/./../../imgs/MySQL/image-20240318112110577.png" alt="image-20240318112110577"></p><p>除了这种分表之外，我们还可以分库，</p><p><img src="/./../../imgs/MySQL/image-20240318112121184.png" alt="image-20240318112121184"></p><p>比如我们已经拆分完 1000 表，然后，把后缀为 0-100 的表放到同一个数据库实例中，然后，100-200 的表放到另一个数据库实例中，依此类推把 1000 表存放到 10 个数据库实例中。这样的话，我们就可以根据业务主键把请求路由到不同数据库实例，从而让每一个数据库实例承担的流量比较小，达到提高数据库性能的目的。</p><p>第 3 种情况：网络原因或者机器负载过高的情况，我们可以进行读写分离.</p><p><img src="/./../../imgs/MySQL/image-20240318112139782.png" alt="image-20240318112139782"></p><p>比如 MySQL 支持一主多从的分布式部署，我们可以将主库只用来处理写数据的操作，而多个从库只用来处理读操作。在流量比较大的场景中，可以增加从库来提高数据库的负载能力，从而提升数据的总体性能。</p><p>第 4 种情况：热点数据导致单点负载不均衡的情况。</p><p><img src="/./../../imgs/MySQL/image-20240318112149545.png" alt="image-20240318112149545"></p><p>这种情况下，除了对数据库本身的调整以外，还可以增加缓存。将查询比较频繁的热点数据预存到缓存当<br>中，比如 Redis、MongoDB、ES 等，以此来缓解数据的压力，从而提高数据库的响应速度。</p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><h4 id="binlog刷盘策略"><a href="#binlog刷盘策略" class="headerlink" title="binlog刷盘策略"></a>binlog刷盘策略</h4><p>mysql只有在事务提交的时候才会记录binlog日志，此时日志还在内存中，那binlog是什么时候被刷到磁盘中的呢？<br>mysql通过sync_binlog控制刷盘，取值范围0~N</p><ul><li>0：不强制要求刷盘，由系统自行判断什么时候将binlog写入磁盘；</li><li>1：每次提交事务就将binlog写入磁盘；</li><li>n：每提交n个事务将binlog写入磁盘；</li></ul><p>显然，sync_binlog为1是最安全的，每次提交事务就将binlog写入磁盘，数据一致性最好。但实际情况中，往往为了提高数据库的性能，会将sync_binlog适当设大，来减少磁盘IO次数，用数据一致性换性能。<br>在对数据库一致性要求不高或数据没那么重要的业务场景，完全可以把sync_binlog设置在100~1000范围内的某个值，以此来提高数据库的性能。而在对数据一致性要求高的业务场景或特别重要的数据，比如订单则建议将sync_binlog的值设置为1，这样可以保证哪怕数据库挂了也不会丢失数据。<br>sync_binlog的默认值是0，这时由系统会自行判断将binlog写入磁盘的时机。数据库可能会在空闲的时候综合考虑缓存的binlog日志大小来决定是否要将binlog写入磁盘。</p><h5 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h5><blockquote><p>由于每一个binlog与事务相关，随事务的提交而提交，所以每一个事务都有一个binlog cache，如果存储内容超过了这个参数，就要暂存到磁盘，待事务提交后一次性写入文件系统的 page cache，而sync_binlog&#x3D;n这个参数表示文件系统积累多少个事务的binlog后一次性刷盘到磁盘，安全性和一致性要求比较高的场景这个值设置为1，磁盘IO压力比较大的情况下可以增大。</p></blockquote><h4 id="binlog组提交"><a href="#binlog组提交" class="headerlink" title="binlog组提交"></a>binlog组提交</h4><p>MySQL引入binlog来实现主从实例之间的数据同步，提高数据库系统的可用性，但同时也增加了事务整体的资源消耗，需要额外的磁盘空间和IO处理能力。尤其是为了保证本地事务的持久性，必须将binlog刷盘控制参数sync_binlog设置为1，设想如果每一次事务提交，都强制进行一次刷盘操作，数据库整体的性能会受到极大的影响。<br>MySQL引入组提交的目的是为了在高并发下合并多个线程的刷盘操作，降低日志刷盘次数，提高数据库的整体性能</p><h4 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog 归档日志"></a>binlog 归档日志</h4><p>binlog是Server层的日志，binlog的主要作用是归档，即可以把数据库恢复到之前一段时间内的任意一天的状态。</p><p>binlog会记录MySQL执行的SQL原始语句，具体流程就是，当MySQL执行一条update语句时，流程如下：</p><ol><li>更新缓存中的对应行，如果缓存中不存在则从数据库中读入内存然后更新。</li><li>将数据页变化写入redo log，此时处于prepare的状态。</li><li>事务提交前，将执行的sql语句写入binlog</li><li>提交事务，redo log处于commit状态</li></ol><p>sync_binlog&#x3D;1时，每次事务的binlog都会持久化到磁盘，建议设置为1.</p><h5 id="binlog-实现-数据库恢复的原理"><a href="#binlog-实现-数据库恢复的原理" class="headerlink" title="binlog 实现 数据库恢复的原理"></a>binlog 实现 数据库恢复的原理</h5><p>数据库一般隔一段时间比如三天或者五天或者七天会做整库备份，而binlog则会保留一段时间的所有sql语句的逻辑操作。所以进行整库备份的流程：</p><ol><li>找到上一次的全量备份的文件，将这个备份恢复到数据库，同时记录备份时间a</li><li>如果想要恢复到时间点b的状态，则将binlog中a和b之间的逻辑操作全部取出来依次执行</li></ol><h5 id="binlog和redo-log的区别"><a href="#binlog和redo-log的区别" class="headerlink" title="binlog和redo log的区别"></a>binlog和redo log的区别</h5><p>binlog用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。binlog是mysql的逻辑日志，并且由Server层进行记录，使用任何存储引擎的mysql数据库都会记录binlog日志。</p><table><thead><tr><th>binlog</th><th>① Server层 ② 逻辑日志，记录原始逻辑 （命令）③ 循环写，空间固定④主从复制，数据恢复</th></tr></thead><tbody><tr><td>redo log</td><td>①引擎层，InnoDB独有 ②物理日志，记录数据页变化 ③追加写，不会覆盖④故障恢复</td></tr></tbody></table><h4 id="讲一讲mysql主从部署"><a href="#讲一讲mysql主从部署" class="headerlink" title="讲一讲mysql主从部署"></a>讲一讲mysql主从部署</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p><p>MySQL 复制的优点主要包含以下三个方面：</p><ul><li>主库出现问题，可以快速切换到从库提供服务。</li><li>实现读写分离，降低主库的访问压力。</li><li>可以在从库中执行备份，以避免备份期间影响主库服务。</li></ul><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>MySQL主从复制的核心就是 二进制日志，具体的过程如下：</p><p><img src="/./../../imgs/MySQL/image-20231003112012277.png" alt="image-20231003112012277"></p><p>从上图来看，复制分成三步：</p><ol><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li><li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ol><h5 id="主从复制的问题？"><a href="#主从复制的问题？" class="headerlink" title="主从复制的问题？"></a>主从复制的问题？</h5><ol><li>同步延迟：由于主从复制是异步执行的，从服务器需要等待主服务器将数据操作记录到二进制日志（BinLog）并传输到从服务器后才能执行。这可能导致从服务器的数据与主服务器存在一定的时间差，从而引起同步延迟。而且从服务器上只有一个 SQL Thread，当主服务器有大量写操作时，复制延时也可能会增大。</li><li>数据一致性：在主从复制过程中，如果主服务器发生故障或网络中断，从服务器可能会丢失部分尚未复制的数据。</li></ol><ul><li><strong>半同步复制</strong>—解决数据丢失的问题</li><li><strong>并行复制</strong>—-解决从库复制延迟的问题</li></ul><p>半同步复制（5.5集成到mysql，以插件的形式存在，需要单独安装）</p><ul><li>该模式下 MySQL 主节点在发送完 BinLog 后不会立刻提交数据，而是至少等待一个从服务器写完 RelayLog 并返回 ACK 消息后，才提交事务</li><li>确保事务提交后binlog至少传输到一个从库</li><li>不保证从库应用完成这个事务的binlog</li><li>性能有一定的降低</li></ul><p><img src="/./../../imgs/MySQL/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2jmn5LlhavkuZ0=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><p><strong>并行复制</strong></p><p>单线程的 SQL Thread Relay 操作在 Master 的 TPS 比较高的情况下，会出现严重的性能瓶颈，进而导致主从同步延迟。</p><p>MySQL 为了解决这个问题，将 SQL Thread 演化成了多个 Worker 的形式，在 Slave 端并行应用 Relay Log 中的事务，从而提升 Relay Log 的应用速度，降低复制延迟</p><p><img src="/./../../imgs/MySQL/curr-relay.webp" alt="relay worker"></p><ul><li>并行是指从库多线程并行应用binlog，同一个库数据更改还是串行的</li></ul><h5 id="搭建主从环境："><a href="#搭建主从环境：" class="headerlink" title="搭建主从环境："></a>搭建主从环境：</h5><p>配置主库，修改配置文件 &#x2F;etc&#x2F;my.cnf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 232-1，默认为1</span><br><span class="line">server-id=1</span><br><span class="line">#是否只读,1 代表只读, 0 代表读写</span><br><span class="line">read-only=0</span><br></pre></td></tr></table></figure><p>重启MySQL服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld </span><br></pre></td></tr></table></figure><p>登录mysql，创建远程连接的账号，并授予主从复制权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#创建itcast用户，并设置密码，该用户可在任意主机连接该MySQL服务</span><br><span class="line">CREATE USER &#x27;itcast&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;Root@123456&#x27;</span><br><span class="line">;</span><br><span class="line">#为 &#x27;itcast&#x27;@&#x27;%&#x27; 用户分配主从复制权限</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;itcast&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>通过指令，查看二进制日志坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status ;</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/MySQL/image-20231003112018880.png" alt="image-20231003112018880"></p><p>字段含义说明：<br>file : 从哪个日志文件开始推送日志文件<br>position ： 从哪个位置开始推送日志<br>binlog_ignore_db : 指定不需要同步的数据库</p><h5 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h5><p>修改配置文件 &#x2F;etc&#x2F;my.cnf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，和主库不一样即可</span><br><span class="line">server-id=2</span><br><span class="line">#是否只读,1 代表只读, 0 代表读写</span><br><span class="line">read-only=1</span><br></pre></td></tr></table></figure><p>重新启动MySQL服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>登录mysql，设置主库配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CHANGE REPLICATION SOURCE TO SOURCE_HOST=&#x27;192.168.200.200&#x27;, SOURCE_USER=&#x27;itcast&#x27;,</span><br><span class="line">SOURCE_PASSWORD=&#x27;Root@123456&#x27;, SOURCE_LOG_FILE=&#x27;binlog.000004&#x27;,</span><br><span class="line">SOURCE_LOG_POS=663;</span><br><span class="line">或者</span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.200.200&#x27;, MASTER_USER=&#x27;itcast&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;Root@123456&#x27;, MASTER_LOG_FILE=&#x27;binlog.000004&#x27;,</span><br><span class="line">MASTER_LOG_POS=663;</span><br></pre></td></tr></table></figure><p>开启同步操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start replica ; #8.0.22之后</span><br><span class="line">start slave ; #8.0.22之前</span><br></pre></td></tr></table></figure><p>查看主从同步状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show replica status ; #8.0.22之后</span><br><span class="line">show slave status ; #8.0.22之前</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/MySQL/image-20231003112023725.png" alt="image-20231003112023725"></p><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><p>分库分表的原因：</p><ul><li>当某一个数据库被访问得特别频繁时，有可能会占用绝大部分的服务器磁盘IO和网络IO，影响同一台服务器上的其他数据，此时可以将数据库进行拆分，将一台服务器上的数据库拆分到多台服务器上。</li><li>当表的数据量特别大或者表中的字段很多时，可以将字段进行拆分或者分散到多张表中，提高查询效率以及更新效率。</li></ul><h5 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h5><p>垂直拆分</p><p>垂直分库：以表为依据，将不同业务的表拆分到不同的数据库中。</p><p><img src="/./../../imgs/MySQL/image-20240318140611487.png" alt="image-20240318140611487"></p><ul><li>每个库的表结构都不一样。</li><li>每个库的数据也不一样。</li><li>所有库的并集是全量数据。</li></ul><p>垂直分表：以字段为依据，将一张表中的字段进行分类拆分到不同的表中。不同表可以通过外键进行关联</p><p><img src="/./../../imgs/MySQL/image-20240318140637932.png" alt="image-20240318140637932"></p><ul><li>每个表的结构都不一样。</li><li>每个表的数据也不一样，一般通过一列（主键&#x2F;外键）关联。</li><li>所有表的并集是全量数据。</li></ul><p>水平拆分</p><ul><li>水平分库，将数据库中的表复制到多个服务器数据库中，每个数据库中的表结构都是一样的，各自存储一部分的数据。</li></ul><p><img src="/./../../imgs/MySQL/image-20240318141105540.png" alt="image-20240318141105540"></p><ul><li>每个库的表结构都一样。</li><li>每个库的数据都不一样。</li><li>所有库的并集是全量数据。</li></ul><ul><li>水平分表：将一张表拆分成多个结构相同的表，每个表中保存一部分数据。</li></ul><p><img src="/./../../imgs/MySQL/image-20240318141154799.png" alt="image-20240318141154799"></p><ul><li>每个表的表结构都一样。</li><li>每个表的数据都不一样。</li><li>所有表的并集是全量数据</li></ul><h5 id="分片规则"><a href="#分片规则" class="headerlink" title="分片规则"></a>分片规则</h5><p>范围分片：根据指定的字段及其配置的范围与数据节点的对应情况， 来决定该数据属于哪一个分片。</p><p><img src="/./../../imgs/MySQL/image-20240318144804381.png" alt="image-20240318144804381"></p><p>取模分片：指定的字段值与节点数量进行求模运算，根据运算结果， 来决定该数据属于哪一个分片</p><p><img src="/./../../imgs/MySQL/image-20240318144846254.png" alt="image-20240318144846254"></p><p>哈希切片：对数据库的某个字段进行来求哈希，再除以分片总数后取模，取模后相同的数据为一个分片，这样将数据分成多个分片的方法叫做哈希分片，我们大多数在数据没有时效性的情况下使用哈希分片，就是数据不管是什么时候产生的，系统都需要处理或者查询；复制table_index &#x3D; hash(order_id) % tables_num</p><ul><li>优点：负载均衡，每个表的数据分布相对均匀。</li><li>缺点：不利于二次扩容。</li></ul><p><img src="/./../../imgs/MySQL/image-20240318145159998.png" alt="image-20240318145159998"></p><p>时间切片：按照时间的范围将数据分布到不同的分片上，比如我们可以将交易数据按照与进行切片，或者按照季度进行切片，由交易数据的多少来决定按照什么样的时间周期来进行切片</p><p>这种切片方式适合明显时间特点的数据，常见的就是订单历史查询</p><p><img src="/./../../imgs/MySQL/image-20240318145310059.png" alt="image-20240318145310059"></p><ul><li><p>一致性hash：计算指定字段的hash值，然后根据hash值不同将数据存储在对应节点。而一致性的意思是即使以后增加节点，原来的数据依然会划分到原来的节点，不会因为节点的增加而发生改变，有效的解决了分布式数据的拓容问题。</p><p><img src="/./../../imgs/MySQL/image-20240318145000616.png" alt="image-20240318145000616"></p></li><li><p>枚举分片：枚举指定字段的值来决定数据会被分配到哪个节点。适用于按照省份，状态，性别等进行分片的场景</p><p><img src="/./../../imgs/MySQL/image-20240318145038787.png" alt="image-20240318145038787"></p></li><li><p>应用指定：根据数据的某个字段的一部分（必须是数字）来直接决定数据存储在哪个节点。如01_xx,02_xx,03_xx</p><p><img src="/./../../imgs/MySQL/image-20240318145106020.png" alt="image-20240318145106020"></p></li></ul><h4 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h4><h5 id="普通-hash-算法的缺陷："><a href="#普通-hash-算法的缺陷：" class="headerlink" title="普通 hash 算法的缺陷："></a>普通 hash 算法的缺陷：</h5><p><strong>hash（key）% N</strong></p><p>​        如果增加或者删除服务器节点，那么n的数量就会改变，所有缓存的位置都要发生改变，也就是说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据。</p><ul><li><p>一致性哈希算法将整个哈希值空间按照顺时针方向组织成一个虚拟的圆环，称为 Hash 环；</p></li><li><p>接着将各个服务器使用 Hash 函数进行哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，从而确定每台机器在哈希环上的位置</p></li><li><p>最后使用算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针寻找，第一台遇到的服务器就是其应该定位到的服务器</p></li></ul><p>哈希环的组织：</p><p>​    我们将 2^32 想象成一个圆，像钟表一样，钟表的圆可以理解成由60个点组成的圆，而此处我们把这个圆想象成由2^32个点组成的圆，示意图如下：</p><p><img src="/./../../imgs/MySQL/1dabc6d21275466885e876058dd81d7a.png" alt="img"></p><p>​    圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第一个点代表2^32-1，我们把这个由 2^32 个点组成的圆环称为hash环。</p><p>（2）步骤二：确定服务器在哈希环的位置：</p><p>哈希算法：hash（服务器的IP） % 2^32</p><p>​    上述公式的计算结果一定是 0 到 2^32-1 之间的整数，那么上图中的 hash 环上必定有一个点与这个整数对应，所以我们可以使用这个整数代表服务器，也就是服务器就可以映射到这个环上，假设我们有 ABC 三台服务器，那么它们在哈希环上的示意图如下：</p><p><img src="/./../../imgs/MySQL/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_14,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p> （3）步骤三：将数据映射到哈希环上：</p><p>​    我们还是使用图片的名称作为 key，所以我们使用下面算法将图片映射在哈希环上：hash（图片名称） % 2^32，假设我们有4张图片，映射后的示意图如下，其中橘黄色的点表示图片：</p><p><img src="/./../../imgs/MySQL/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>​    那么，怎么算出上图中的图片应该被缓存到哪一台服务上面呢？我们只要从图片的位置开始，沿顺时针方向遇到的第一个服务器就是图片存放的服务器了。最终，1号、2号图片将会被缓存到服务器A上，3号图片将会被缓存到服务器B上，4号图片将会被缓存到服务器C上。</p><p>一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，只有部分缓存会失效，不至于将所有压力都在同一时间集中到后端服务器上，具有较好的容错性和可扩展性。</p><p>​    假设服务器B出现了故障，需要将服务器B移除，那么移除前后的示意图如下图所示：</p><p><img src="/./../../imgs/MySQL/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>hash 环的倾斜与虚拟节点：<br>        一致性哈希算法在服务节点太少的情况下，容易因为节点分部不均匀而造成数据倾斜问题，也就是被缓存的对象大部分集中缓存在某一台服务器上，从而出现数据分布不均匀的情况，这种情况就称为 hash 环的倾斜。如下图所示：</p><p><img src="/./../../imgs/MySQL/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_20,color_FFFFFF,t_70,g_se,x_16-1712633028188-13.png" alt="img"></p><p>​     hash 环的倾斜在极端情况下，仍然有可能引起系统的崩溃，为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对<strong>每一个服务节点计算多个哈希</strong>，每个<strong>计算结果位置都放置一个此服务节点，称为虚拟节点</strong>，一个实际物理节点可以对应多个虚拟节点，虚拟节点越多，hash环上的<strong>节点就越多</strong>，缓存被均匀分布的概率就越大，hash环倾斜所带来的影响就越小，同时数据定位算法不变，只是多了一步<strong>虚拟节点到实际节点的映射</strong>。<strong>具体做法可以在服务器ip或主机名的后面增加编号来实现</strong>，加入虚拟节点以后的hash环如下：</p><p><img src="/./../../imgs/MySQL/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_15,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><ul><li><strong>节点数量多了后，节点在哈希环上的分布就相对均匀了</strong>。这时候，如果有访问请求寻址到「A-01」这个虚拟节点，接着再通过「A-01」虚拟节点找到真实节点 A，这样请求就能访问到真实节点 A 了。</li><li>虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。<strong>当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高</strong>。</li><li>有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如对权重更高的节点增加更多的虚拟机节点即可。</li></ul><h4 id="假设有一个用户表，你用ID做的分片键，那么有一个类似于name这样的字段如何查询？"><a href="#假设有一个用户表，你用ID做的分片键，那么有一个类似于name这样的字段如何查询？" class="headerlink" title="假设有一个用户表，你用ID做的分片键，那么有一个类似于name这样的字段如何查询？"></a>假设有一个用户表，你用ID做的分片键，那么有一个类似于name这样的字段如何查询？</h4><p>这里提供几种常见的思路：</p><h5 id="全局索引"><a href="#全局索引" class="headerlink" title="全局索引"></a>全局索引</h5><p>全局索引是一个跨所有分片的索引，它包含了非分片键字段和对应的分片键信息。查询时，先通过全局索引找到相关的分片键，然后在相应的分片中查询详细数据。</p><p>适用场景：适用于查询频率高、数据量大的非分片键字段。</p><p>优点：查询效率高，可以快速定位到数据所在的分片。</p><p>缺点：全局索引维护成本较高，需要定期更新以保持与分片数据的一致性。</p><h5 id="2-数据冗余"><a href="#2-数据冗余" class="headerlink" title="2. 数据冗余"></a>2. 数据冗余</h5><p>在每个分片中存储部分非分片键字段的数据。这样，即使不直接查询分片键，也可以在分片内快速找到相关数据。</p><p>适用场景：适用于查询性能要求极高，且可以接受一定数据冗余的场景。</p><p>优点：查询性能高，无需跨分片查询。</p><p>缺点：数据冗余增加了存储成本和维护复杂性。</p><h5 id="3-应用层处理"><a href="#3-应用层处理" class="headerlink" title="3. 应用层处理"></a>3. 应用层处理</h5><p>在应用层实现复杂的查询逻辑，将多个分片中的查询结果汇总后进行处理。</p><p>适用场景：适用于查询频率不高，或者可以接受一定延迟的场景。</p><p>优点：灵活性高，可以根据业务需求定制查询逻辑。</p><p>缺点：查询性能可能受到网络延迟和分片数量的影响。</p><h5 id="4-使用Elasticsearch（ES）"><a href="#4-使用Elasticsearch（ES）" class="headerlink" title="4. 使用Elasticsearch（ES）"></a>4. 使用Elasticsearch（ES）</h5><p>将非分片键字段的数据同步到Elasticsearch中，利用Elasticsearch强大的搜索和查询能力进行查询。</p><p>适用场景：适用于非结构化数据、全文搜索、复杂查询等场景。</p><p>优点：支持复杂的查询操作，如全文搜索、模糊匹配等；查询性能高，支持分布式部署。</p><p>缺点：需要维护Elasticsearch集群，增加了系统的复杂性；数据同步可能引入一定的延迟。</p><h5 id="5-数据库中间件"><a href="#5-数据库中间件" class="headerlink" title="5. 数据库中间件"></a>5. 数据库中间件</h5><p>使用数据库中间件（如ShardingSphere、MyCAT等）来管理分库分表，中间件可以自动处理非分片键字段的查询，将请求路由到正确的分片。</p><p>适用场景：适用于希望减少应用层复杂性的场景。</p><p>优点：简化了应用层的查询逻辑，减少了开发和维护的工作量。</p><p>缺点：需要配置和维护数据库中间件。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2024/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>进程作为资源分配的基本单位,线程作为调度的基本单位。</p><ul><li>进程可看做是正在执行的程序,每个进程都有独立的代码和数据空间，所以进程间的切换会有较大的开销。一个进程在其执行的过程中可以产生多个线程。</li><li><strong>线程是进程当中的一条执行流程。</strong>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器（</strong>线程切换后能恢复到正确的执行位置<strong>）</strong>、<strong>虚拟机栈（</strong>保证线程中的局部变量不被别的线程访问到<strong>）</strong>和<strong>本地方法栈</strong>（包含局部变量，本地方法），在所以系统在产生一个线程要分配的资源更少，或是在各个线程之间作切换工作时，只需要保存栈和寄存器等不共享的数据，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul><p>线程相比进程能减少开销，体现在：</p><ul><li>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li><li>线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</li><li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li><li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</li></ul><p>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响,因为它们共享了堆和方法区资源。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231016143302701.png" alt="image-20231016143302701"></p><ul><li>堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存</li><li>方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li></ul><h4 id="有了进程为什么还需要线程"><a href="#有了进程为什么还需要线程" class="headerlink" title="有了进程为什么还需要线程?"></a>有了进程为什么还需要线程?</h4><ul><li>进程切换是一个开销很大的操作，线程切换的成本较低。</li><li>线程更轻量，一个进程可以创建多个线程。</li><li>多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。</li><li>同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。</li></ul><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p><strong>协程，又称用户态线程，因为创建一个线程需要调用操作系统的功能（系统调用）, 而创建一个线程则只需要在用户态下完成，一个线程可以有多个协程。</strong></p><p>协程抽象于线程之上，线程是被分割的CPU资源, 协程是组织好的代码流程，可以看作是一种特殊的函数，这个函数可以在某个地方挂起，又可以重新在挂起出继续运行，<strong>协程的调度完全由用户程序控制（也就是在用户态执行）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销。</strong></p><p>协程与线程不同：同一个线程下协程只有并发没有并行，多个协程可以并发地执行任务，在发生IO阻塞地时候就挂起并切换到其他的协程，不需要发生线程的切换，而线程的创建、切换又很消耗系统资源，所以协程能提高效率</p><p>不需要多线程的锁机制。由于只有一个线程，也不存在同时写变量的冲突，在协程中控制共享资源不需要加锁，只需要判断数据的状态，所以执行效率远高于线程</p><h5 id="协程的优点"><a href="#协程的优点" class="headerlink" title="协程的优点"></a>协程的优点</h5><ul><li>由用户程序来控制协程的切换，而不是操作系统的任务调度器来调度，不需要发起系统调用切换到内核态，</li><li>使用寄存器和栈来保存协程的上下文，占用资源少，保存、恢复上下文比线程更高效</li><li>不需要多线程的锁机制。由于只有一个线程，也不存在同时写变量的冲突，在协程中控制共享资源不需要加锁，只需要判断数据的状态，所以执行效率远高于线程。</li></ul><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODQ3NTYxMQ==,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>协程与线程的区别：</p><ol><li>由于协程的特性, 适合执行大量的<strong>I&#x2F;O 密集型任务</strong>, 而线程在这方面弱于协程</li><li>协程涉及到函数的切换, 多线程涉及到线程的切换, 所以都有<strong>执行上下文</strong>切换, 但是协程不是被操作系统内核所管理, 而完全是由用户程序所控制（也就是在<strong>用户态</strong>执行）, 不会像线程那样需要<strong>在内核态进行上下文切换</strong>来消耗资源，因此<strong>协程的开销远远小于线程的开销</strong></li><li>同一时间, 在多核处理器的环境下, <strong>多个线程是可以并行的</strong>，但是<strong>运行的协程的函数却只能有一个</strong>，<strong>其他的协程的函数都被挂起</strong>, 即<strong>协程是并发的</strong></li><li>由于协程在同一个线程中,也不存在同时写变量的冲突，在协程中控制共享资源不需要加锁。</li></ol><p>使用场景：</p><p><strong>协程适用于IO密集型任务</strong>，有了协程，我们在函数的执行过程中，如果遇到了<strong>I&#x2F;O密集型任务</strong>，函数可以临时让出控制权，<strong>让 CPU 执行其他函数</strong>，等 I&#x2F;O 操作执行完毕以后再收回其他函数的控制权.</p><h4 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h4><h5 id="内核态：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。其他的属于用户态。用户程序运行在用户态-操作系统运行在内核态-（操作系统内核运行在内核态，而服务器运行在用户态）。用户态不能干扰内核态"><a href="#内核态：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。其他的属于用户态。用户程序运行在用户态-操作系统运行在内核态-（操作系统内核运行在内核态，而服务器运行在用户态）。用户态不能干扰内核态" class="headerlink" title="内核态：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。其他的属于用户态。用户程序运行在用户态,操作系统运行在内核态.（操作系统内核运行在内核态，而服务器运行在用户态）。用户态不能干扰内核态."></a>内核态：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。其他的属于用户态。用户程序运行在用户态,操作系统运行在内核态.（操作系统内核运行在内核态，而服务器运行在用户态）。用户态不能干扰内核态.</h5><h5 id="用户态："><a href="#用户态：" class="headerlink" title="用户态："></a>用户态：</h5><p>不能直接使用系统资源，也不能改变 CPU 的工作状态，并且只能访问这个用户程序自己的存储空间！</p><h5 id="内核态："><a href="#内核态：" class="headerlink" title="内核态："></a>内核态：</h5><p>内核态可以使用计算机所有的硬件资源，操作系统运行在内核态。为了安全性和稳定性，操作系统的程序不能随便访问，这就是内核态。即需要执行操作系统的程序就必须转换到内核态才能执行</p><h5 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h5><p>在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。如果所有的程序都能使用这些指令，那么你的系统一天死机N回就不足为奇了。<br>所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。<br>如此设计的本质意义是进行权限保护。 限定用户的程序不能乱搞操作系统，如果人人都可以任意读写任意地址空间软件管理便会乱套.</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg5a2f5rWpX2pheQ==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h4 id="使用哪个命令去查看一个进程的信息"><a href="#使用哪个命令去查看一个进程的信息" class="headerlink" title="使用哪个命令去查看一个进程的信息"></a>使用哪个命令去查看一个进程的信息</h4><h5 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h5><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li>tasklist 查看进程</li><li>taskkill 杀死进程</li></ul><h5 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h5><ul><li>ps -fe 查看所有进程</li><li>ps -fT -p <PID> 查看某个进程（PID）的所有线程</li><li>kill 杀死进程</li><li>top 按大写 H 切换是否显示线程</li><li>top -H -p <PID> 查看某个进程（PID）的所有线程</li></ul><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><ul><li>jps 命令查看所有 Java 进程</li><li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</li><li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li></ul><h4 id="多线程通信方式"><a href="#多线程通信方式" class="headerlink" title="多线程通信方式"></a>多线程通信方式</h4><p>在Java中，多线程通信是通过一些机制和方法来实现的，以确保不同线程之间能够协同工作。以下是一些常见的多线程通信方式：</p><ol><li><strong>共享变量：</strong> 多个线程可以共享一个变量，通过读写该变量来进行通信。为了确保线程安全，通常需要使用<code>volatile</code>关键字或者<code>synchronized</code>关键字来控制访问。例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeclass SharedResource &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> sharedValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        sharedValue = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sharedValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>wait()和notify()：</strong> 这是基于对象监视器（Object Monitor）的机制，用于线程之间的等待和通知。<code>wait()</code>方法让一个线程等待，而<code>notify()</code>方法通知等待的线程继续执行。通常与<code>synchronized</code>关键字一起使用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeclass SharedResource &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sharedValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        sharedValue = value;</span><br><span class="line">        notify(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (sharedValue == <span class="number">0</span>) &#123;</span><br><span class="line">            wait(); <span class="comment">// 等待通知</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sharedValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>BlockingQueue：</strong> 使用<code>java.util.concurrent.BlockingQueue</code>可以方便地实现线程之间的通信。它提供了阻塞操作，当队列为空或已满时，线程会自动阻塞或等待。例如，<code>LinkedBlockingQueue</code>可以用于生产者-消费者问题。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code<span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    queue.put(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> queue.take();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>CountDownLatch和CyclicBarrier：</strong> 这两个类用于协调多个线程的执行。<code>CountDownLatch</code>用于等待一个或多个线程的完成，而<code>CyclicBarrier</code>用于等待多个线程到达某个同步点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个线程执行任务</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        latch.countDown(); <span class="comment">// 任务完成，计数减一</span></span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程等待所有任务完成</span></span><br><span class="line">latch.await();</span><br></pre></td></tr></table></figure><ol><li><strong>Semaphore：</strong> <code>java.util.concurrent.Semaphore</code>用于控制同时访问的线程数量。它允许多个线程同时访问一个共享资源。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javaCopy <span class="type">codeSemaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>); <span class="comment">// 最多允许3个线程同时访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程尝试获取许可</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    semaphore.acquire(); <span class="comment">// 获取许可</span></span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些是Java中常见的多线程通信方式。选择合适的通信方式取决于问题的性质和需求。需要注意，不正确的多线程通信可能导致竞态条件和死锁等问题，因此在设计多线程应用程序时应格外小心。</p><h4 id="虚拟内存的作用"><a href="#虚拟内存的作用" class="headerlink" title="虚拟内存的作用"></a>虚拟内存的作用</h4><p>如果直接使用物理内存，可能多个进程会同时使用同一个物理内存导致冲突。</p><p>我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「<strong>虚拟地址</strong>」，大家自己玩自己的地址就行，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，<strong>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</strong></p><p>如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/298fb68e3da94d767b02f2ed81ebf2c4.png" alt="进程的中间层"></p><h4 id="进程间通信方式，进程通信的时候信号量是如何实现的"><a href="#进程间通信方式，进程通信的时候信号量是如何实现的" class="headerlink" title="进程间通信方式，进程通信的时候信号量是如何实现的"></a>进程间通信方式，进程通信的时候信号量是如何实现的</h4><p><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E6%80%BB%E7%BB%93">5.2 进程间有哪些通信方式？ | 小林coding (xiaolincoding.com)</a></p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-%E6%8F%90%E7%BA%B2.jpg" alt="img"></p><p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4.jpg" alt="img"></p><h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>其实，<strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-%E7%AE%A1%E9%81%93-pipe.jpg" alt="img"></p><p>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8-%E7%AE%A1%E9%81%93-pipe-shell.jpg" alt="img"></p><p>所以说，在 shell 里通过「<code>|</code>」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。</p><p>我们可以得知，<strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p><p>另外，<strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p><p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><hr><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="#消息队列"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">#</a>消息队列</h5><p>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。</p><p>对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p><p>再来，<strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p><p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</p><p>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p><p>但邮件的通信方式存在不足的地方有两点，<strong>一是通信不及时，二是附件也有大小限制</strong>，这同样也是消息队列通信不足的点。</p><p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 <code>MSGMAX</code> 和 <code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p><p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p><hr><h5 id="共享内存"><a href="#共享内存" class="headerlink" title="#共享内存"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98">#</a>共享内存</h5><p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</p><p>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p><p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.jpg" alt="img"></p><hr><h5 id="信号量"><a href="#信号量" class="headerlink" title="#信号量"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E4%BF%A1%E5%8F%B7%E9%87%8F">#</a>信号量</h5><p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p><p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p><p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p><p>接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 <code>1</code>。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10-%E4%BF%A1%E5%8F%B7%E9%87%8F-%E4%BA%92%E6%96%A5.jpg" alt="img"></p><p>具体的过程如下：</p><ul><li>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。</li><li>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。</li><li>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的进程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。</li></ul><p>可以发现，信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p><p>另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。</p><p>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。</p><p>那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 <code>0</code>。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11-%E4%BF%A1%E5%8F%B7%E9%87%8F-%E5%90%8C%E6%AD%A5.jpg" alt="img"></p><p>具体过程：</p><ul><li>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；</li><li>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；</li><li>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。</li></ul><p>可以发现，信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p><hr><h5 id="信号"><a href="#信号" class="headerlink" title="#信号"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E4%BF%A1%E5%8F%B7">#</a>信号</h5><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p><p>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。</p><p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 命令，查看所有的信号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -l</span></span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p><ul><li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li><li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li></ul><p>如果进程在后台运行，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p><ul><li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li></ul><p>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</p><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p><p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。</p><p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p><p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p><hr><h5 id="Socket"><a href="#Socket" class="headerlink" title="#Socket"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#socket">#</a>Socket</h5><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p><p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p><p>我们来看看创建 socket 的系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocal)</span></span><br></pre></td></tr></table></figure><p>三个参数分别代表：</p><ul><li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL&#x2F;AF_UNIX 用于本机；</li><li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；</li><li>protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；</li></ul><p>根据创建 socket 类型的不同，通信的方式也就不同：</p><ul><li>实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；</li><li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li><li>实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li></ul><p>接下来，简单说一下这三种通信的编程模式。</p><blockquote><p>针对 TCP 协议通信的 socket 编程模型</p></blockquote><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12-TCP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" alt="img"></p><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li></ul><p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p><p>所以，监听的 socket 和真正用来传送数据的 socket，是「<strong>两个</strong>」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><blockquote><p>针对 UDP 协议通信的 socket 编程模型</p></blockquote><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/13-UDP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" alt="img"></p><p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p><p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p><p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。</p><blockquote><p>针对本地进程间通信的 socket 编程模型</p></blockquote><p>本地 socket 被用于在<strong>同一台主机上进程间通信</strong>的场景：</p><ul><li>本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；</li><li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</li></ul><p>对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。</p><p>对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。</p><p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</p><hr><h5 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E6%80%BB%E7%BB%93">#</a>总结</h5><p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。</p><p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。</p><p><strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「<code>|</code>」竖线就是匿名管道，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来<strong>匿名管道是只能用于存在父子关系的进程间通信</strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</p><p><strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是<strong>缓存在内核</strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><p><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></p><p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p><p>那么，就需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p><p>与信号量名字很相似的叫<strong>信号</strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是<strong>异步通信机制</strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，<strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SIGSTOP</code>，这是为了方便我们能在任何时候结束或停止某个进程。</p><p>前面说到的通信机制，都是工作于同一台主机，如果<strong>要与不同主机的进程间通信，那么就需要 Socket 通信了</strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p><h4 id="线程崩溃了进程也会崩溃吗"><a href="#线程崩溃了进程也会崩溃吗" class="headerlink" title="线程崩溃了进程也会崩溃吗"></a>线程崩溃了进程也会崩溃吗</h4><p>线程崩溃了，在正常情况下，操作系统为了保证系统安全，所以针对非法内存访问会发送一个 SIGSEGV 信号，而操作系统一般会调用默认的信号处理函数（一般会让相关的进程崩溃）。</p><p>但如果进程觉得”罪不致死”，那么它也可以选择自定义一个信号处理函数，这样的话它就可以做一些自定义的逻辑，比如记录 crash 信息等有意义的事。</p><p>回过头来看为什么JVM虚拟机会针对 StackoverflowError 和 NullPointerException 做额外处理让线程恢复呢，针对 stackoverflow 其实它采用了一种栈回溯的方法保证线程可以一直执行下去，而捕获空指针错误主要是这个错误实在太普遍了。</p><p>为了这一个很常见的错误而让 JVM 崩溃那线上的 JVM 要宕机多少次，所以出于工程健壮性的考虑，与其直接让 JVM 崩溃倒不如让线程起死回生，并且将这两个错误&#x2F;异常抛给用户来处理。</p><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><h5 id="传统的文件传输有多糟糕？"><a href="#传统的文件传输有多糟糕？" class="headerlink" title="传统的文件传输有多糟糕？"></a>传统的文件传输有多糟糕？</h5><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p><p>传统 I&#x2F;O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I&#x2F;O 接口从磁盘读取或写入。</p><p>代码通常如下，一般会需要两个系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure><p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png" alt="img"></p><p>首先，期间共<strong>发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 <code>read()</code> ，一次是 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p><p>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p><p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p><ul><li><em>第一次拷贝</em>，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li><li><em>第二次拷贝</em>，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li><li><em>第三次拷贝</em>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li><li><em>第四次拷贝</em>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li></ul><p>我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。</p><p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p><p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p><ul><li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li><li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li></ul><p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="img"></p><p>这就是所谓的<strong>零拷贝（*Zero-copy*）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</strong>。</p><p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p><p>所以，总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法记录</title>
      <link href="/2024/04/19/%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/04/19/%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>UPDATING…</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2024/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络："><a href="#计算机网络：" class="headerlink" title="计算机网络："></a>计算机网络：</h2><h4 id="网络的构成"><a href="#网络的构成" class="headerlink" title="网络的构成"></a>网络的构成</h4><p><strong>节点</strong></p><ul><li><p>主机及其上运行的应用程序</p></li><li><p>路由器、交换机等网络交换设备</p></li></ul><p><strong>边：通信链路</strong></p><ul><li><p>接入网链路：主机连接到互联网的链路</p></li><li><p>主干链路：路由器间的链路</p></li></ul><p><strong>协议</strong></p><ul><li>传输层TCP、UDP协议</li><li>网络层IP协议</li><li>应用层FTP、SMTP、HTTP、DNS协议等</li></ul><p><strong>协议的定义</strong>：对等层实体，在通信过程中，需要遵守的规则的集合、包括语法、语义、报文格式以及次序。</p><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20231003112121217.png" alt="image-20231003112121217"></p><p>1、物理层：发送时将数据bit流转化为物理信号（电磁波，光波），接收时将物理信号转换为bit流数据。实现计算机节点之间比特流的传输，规定传输媒体接口的标准，屏蔽掉具体传输介质和物理设备的差异，使数据链路层不必关心网络的具体传输介质，按照物理层规定的标准传输数据就行</p><p>2、数据链路层：向上:将物理层的一个个bit，组合转换为帧包括帧头和帧尾，向下:把网络层数据报加头和尾，封装成帧，帧头中包括源MAC地址和目的MAC地址。 提供相邻两个节点之间的数据传输</p><p>通过差错控制、流量控制等方法，使有差错的物理线路变为无差错的数据链路。</p><p>数据链路层的几个基本方法：数据封装成桢、透明传输、差错控制、流量控制。</p><p>封装成桢：把网络层数据报加头和尾，封装成帧，帧头中包括源MAC地址和目的MAC地址。<br>透明传输：零比特填充、转义字符。<br>差错控制：接收者检测错误,如果发现差错，丢弃该帧，差错控制方法有 CRC 循环冗余码<br>流量控制：控制发送的传输速度，使得接收方来得及接收。传输层TCP也有流量控制功能，但TCP是端到端的流量控制，链路层是点到点（比如一个路由器到下一个路由器）<br>3、网络层：<strong>实现网络地址与物理地址的转换</strong>，并通过<strong>路由选择算法为分组通过通信子网选择最适当的路径</strong></p><p>网络层最重要的一个功能就是：路由选择。路由一般包括路由表和路由算法两个方面。每个路由器都必须建立和维护自身的路由表，一种是静态维护，也就是人工设置，适用于小型网络；另一种就是动态维护，是在运行过程中根据网络情况自动地动态维护路由表。</p><p>4、传输层：提供源端与目的端之间提供可靠的透明数据传输，传输层协议为不同主机上运行的进程提供逻辑通信。</p><p>网络层协议负责的是提供主机间的逻辑通信，而传输层协议负责的是提供进程间的逻辑通信。</p><p>5、会话层：管理（建立、维护、重连）应用之间的会话，是用户<strong>应用程序和网络之间的接口</strong>，负责在网络中的<strong>两节点之间建立、维持、终止通信</strong>。</p><p>6、表示层：<strong>处理用户数据的表示问题</strong>，如数据的编码、<strong>格式转换、加密和解密、压缩和解压缩</strong>。</p><p>7、应用层(FTP、SMTP、HTTP、DNS)：传输层基础上实现网络应用，为<strong>用户的应用进程提供网络通信服务</strong>，完成和实现用户请求的各种服务。</p><h4 id="各个设备工作在哪一层"><a href="#各个设备工作在哪一层" class="headerlink" title="各个设备工作在哪一层"></a>各个设备工作在哪一层</h4><ul><li><p>网桥：工作在<strong>数据链路层</strong>，在不同或相同类型的LAN之间存储并转发数据帧，必要时进行链路层上的协议转换。可连接两个或多个网络，在其中传送信息包。</p></li><li><p>交换机：工作在<strong>数据链路层</strong>，原理等同于多端口网桥。作用是连接数个相同网段的不同主机，减少网内冲突，隔离冲突域。利用存储转发和过滤技术来从物理上分割网段。</p></li><li><p>路由器：工作在<strong>网络层</strong>，在不同的网络间存储并转发分组。可在异种网络之间（即不同类型的局域网互连，局域网与广域网，广域网与广域网）传输数据并进行路径选择，使用专门的软件协议从逻辑上对整个网络进行划分。</p></li><li><p>网关：对高层协议（包括传输层及更高层次）进行转换的网间连接器。允许使用不兼容的协议，比如SPX&#x2F;IPX和TCP&#x2F;IP的系统和网络互连。因为协议转换是网关最重要的功能，所以答案是工作<strong>在传输层及以上层次</strong>。</p></li><li><p>网卡：在物理层上网卡主要是完成物理接口的连接,电信号的传送以及将数据分解为适当大小的数据包之后向网络上发送的功能. 数据链路层功能包括链路建立和拆除，帧定界同步顺序差错控制这些。大多认为主要工作在物理层。通常包含<strong>物理层以及链路层</strong></p></li></ul><h4 id="TCP粘包拆包问题"><a href="#TCP粘包拆包问题" class="headerlink" title="TCP粘包拆包问题"></a>TCP粘包拆包问题</h4><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><p>TCP在接受数据的时候，有一个滑动窗口来控制接受数据的大小，这个滑动窗口你就可以理解为一个缓冲区的大小。缓冲区满了就会把数据发送。数据包的大小是不固定的，有时候比缓冲区大有时候小。</p><ul><li>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题；</li><li>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包</li></ul><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/864571e427ea43eeb8db63e4bcd53455.png" alt="img"></p><h5 id="为什么会发生"><a href="#为什么会发生" class="headerlink" title="为什么会发生"></a>为什么会发生</h5><p>1.TCP会发生粘包问题：TCP 是面向连接的传输协议,TCP 传输的数据是以流的形式,而流数据是没有明确的开始结尾边界,所以 TCP 也没办法判断哪一段流属于一个消息;内容与内容之间没有明确的分界标志,需要认为手动地去给这些协议划分边界。<br>粘包时：发送方每次写入数据 &lt; 接收方套接字(Socket)缓冲区大小。<br>拆包时：发送方每次写入数据 &gt; 接收方套接字(Socket)缓冲区大小。</p><p>2.UDP不会发生粘包问题：UDP具有保护消息边界,在每个UDP包中就有了消息头(UDP长度、源端口、目的端口、校验和)。</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>1、客户端在发送数据包的时候，每个包都固定长度，比如1024个字节大小，如果客户端发送的数据长度不足1024个字节，则通过补充空格的方式补全到指定长度；</p><p>2、客户端在每个包的末尾使用固定的分隔符，例如\r\n，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的\r\n，然后对其拆分后的头部部分与前一个包的剩余部分进行合并，这样就得到了一个完整的包；</p><p>3、将消息分为头部和消息体，在头部中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；</p><h4 id="HTTP如何解决粘包问题的？"><a href="#HTTP如何解决粘包问题的？" class="headerlink" title="HTTP如何解决粘包问题的？"></a>HTTP如何解决粘包问题的？</h4><p>http请求报文格式<br>1）请求行：以\r\n结束；<br>2）请求头：以\r\n结束；<br>3）\r\n；<br>3）数据；</p><p>http响应报文格式<br>1）响应行：以\r\n结束；<br>2）响应头：以\r\n结束；<br>3）\r\n；<br>4）数据；</p><p>4.1、读取请求行&#x2F;请求头、响应行&#x2F;响应头<br>1、遇到第一个\r\n表示读取请求行或响应行结束；<br>2、遇到\r\n\r\n表示读取请求头或响应头结束；</p><p>4.2、 怎么读取body数据呢？<br>HTTP协议通常使用Content-Length来标识body的长度。在服务器端，需要先申请对应长度的buffer，然后再赋值。</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1279a01571164f2ba3c2a8141a0e996a.png" alt="img"></p><p>如果需要一边生产数据一边发送数据，就需要使用”Transfer-Encoding: chunked” 来代替Content-Length，也就是对数据进行分块传输。</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/de563592ba4c4d42b9d1acfbda2af5f5.png" alt="img"></p><p>4.2.1、 Content-Length 描述<br>http server接收数据时，发现header中有Content-Length属性，则读取Content-Length的值，确定需要读取body的长度。<br>http server发送数据时，根据需要发送byte的长度，在header中增加Content-Length项，其中value为byte的长度，然后将byte数据当做body发送到客户端。<br>4.2.2、 chunked描述<br>http server接收数据时，发现header中有Transfer-Encoding: chunked，则会按照chunked协议分批读取数据。<br>http server发送数据时，如果需要分批发送到客户端，则需要在header中加上Transfer-Encoding:chunked，然后按照chunked协议分批发送数据。<br>chunked协议具体如下图：</p><p> <img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/8ba16c3c85684457a1bfa01ce4014491.png" alt="img"></p><p>1、主要包含三部分: chunk，last-chunk和trailer。如果分多次发送，则chunk有多份。</p><p>2、 chunk主要包含大小和数据，大小表示这个这个chunk包的大小，使用16进制标示。其中chunk之间的分隔符为CRLF。</p><p>3、通过last-chunk来标识chunk发送完成。一般读取到last-chunk(内容为0)的时候，代表chunk发送完成。</p><p>4、trailer表示增加header等额外信息，一般情况下header是空。通过CRLF来标识整个chunked数据发送完成。</p><p>4.2.3 优&#x2F;缺点<br>优点</p><p>1、假如body的长度是10K，对于Content-Length则需要申请10K连续的buffer，而对于Transfer-Encoding:chunked可以申请1k的空间，然后循环使用10次。节省了内存空间的开销。</p><p>2、如果内容的长度不可知，则可使用chunked方式能有效的解决Content-Length的问题</p><p>3、http服务器压缩可以采用分块压缩，而不是整个块压缩。分块压缩可以一边进行压缩，一般发送数据，来加快数据的传输时间。</p><p>缺点</p><p>1、chunked协议解析比较复杂。</p><p>2、在http转发的场景下(比如nginx)难以处理，比如如何对分块数据进行转发。</p><h4 id="TCP队头阻塞问题"><a href="#TCP队头阻塞问题" class="headerlink" title="TCP队头阻塞问题"></a>TCP队头阻塞问题</h4><p>客户端接收端可能会先收到窗口末端的数据，这个时候 TCP 是不会向上层应用交付数据的，它得等到前面的数据都接收到了才向上交付，所以这就出现了队头阻塞，即队头的包如果发生延迟或者丢失，队尾必须等待发送端重新发送并接收到数据后才会一起向上交付。</p><h4 id="TCP和UDP的区别和应用场景"><a href="#TCP和UDP的区别和应用场景" class="headerlink" title="TCP和UDP的区别和应用场景"></a>TCP和UDP的区别和应用场景</h4><ul><li><p><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</p></li><li><p><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，确保通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p></li><li><p><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了</p></li><li><p><strong>传输效率</strong>：由于使用 TCP 建立连接有握手的机制，进行传输的时候多了连接、确认、重传等机制，TCP 的使用效率会比 UDP 要低</p></li><li><p><strong>传输形式</strong>：TCP 是面向字节流（把应用程序交下来的数据看成无结构的字节流）的，UDP 是面向报文（对应用层的报文既不合并也不拆分，对长度大小都不做任何改变）的。</p></li><li><p><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</p></li><li><p><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</p></li></ul><h5 id="TCP使用场景"><a href="#TCP使用场景" class="headerlink" title="TCP使用场景"></a>TCP使用场景</h5><p>效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</p><h5 id="UDP使用场景"><a href="#UDP使用场景" class="headerlink" title="UDP使用场景"></a>UDP使用场景</h5><p>效率要求相对高，对准确性要求相对低的场景。举几个例子：游戏、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播），即使出现传输错误也可以容忍。</p><h4 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h4><p>QUIC 全称：Quick UDP Internet Connections，是一种基于 UDP 的传输层协议。</p><p><strong>可靠传输</strong></p><p>QUIC 是基于 UDP 协议的，而 UDP 是不可靠传输协议，那 QUIC 是如何实现可靠传输的呢？</p><p>可靠传输有 2 个重要特点：</p><p>（1）完整性：发送端发出的数据包，接收端都能收到</p><p>（2）有序性：接收端能按序组装数据包，解码得到有效的数据</p><p>问题 1：发送端怎么知道发出的包是否被接收端收到了？</p><p>解决方案：通过包号（PKN）和确认应答（SACK）</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-aace93419dd55c73ab4b5fd2976e1375_1440w.webp" alt="img"></p><p>（1）客户端：发送 3 个数据包给服务器（PKN &#x3D; 1，2，3）</p><p>（2）服务器：通过 SACK 告知客户端已经收到了 1 和 3，没有收到 2</p><p>（3）客户端：重传第 2 个数据包（PKN&#x3D;4）</p><p>由此可以看出，QUIC 的数据包号是单调递增的。也就是说，之前发送的数据包（PKN&#x3D;2）和重传的数据包（PKN&#x3D;4），虽然数据一样，但包号不同。</p><p>问题 2：既然包号是单调递增的，那接收端怎么保证数据的有序性呢？</p><p>解决方案：通过数据偏移量 offset</p><p>每个数据包都有一个 offset 字段，表示在整个数据中的偏移量。</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-e6abef5bc9316fd87905a5e97b547050_1440w.webp" alt="img"></p><p>接收端根据 offset 字段就可以对异步到达的数据包进行排序了。为什么 QUIC 要将 PKN 设计为单调递增？解决 TCP 的重传歧义问题：</p><p>由于原始包和重传包的序列号是一样的，客户端不知道服务器返回的 ACK 包到底是原始包的，还是重传包的。但 QUIC 的原始包和重传包的序列号是不同的，也就可以判断 ACK 包的归属。</p><h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><strong>流量控制</strong></h5><p>和 TCP 一样，QUIC 也是利用滑动窗口机制实现流量控制：</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-2b659a36da1993c1a65bed4830606997_1440w.webp" alt="img"></p><p>发送端的窗口大小由接收端告知，包括发送窗口和可用窗口，如果发送端收到了接收端的 ACK 确认应答（比如 ACK 36），那整个窗口就会向右滑动，发送新的数据包。</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-62c627de56caf4617f97628215c4fa03_1440w.webp" alt="img"></p><p>和 TCP 不同的是，QUIC 的滑动窗口分为 Connection 和 Stream 两种级别。Connection 流量控制：规定了所有数据流的总窗口大小；Stream 流量控制：规定了每个流的窗口大小。</p><p>假设现在有 3 个 Stream，滑动窗口分别如下：</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-a5f95afac0935ae11f4672d3fdf9bf3e_1440w.webp" alt="img"></p><p>则整个 Connection 的可用窗口大小为：20+30+10 &#x3D; 60</p><h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><strong>拥塞控制</strong></h5><p>拥塞控制是通过拥塞窗口限制发送方的数据量，避免整个网络发生拥塞。那拥塞窗口（cwnd）和滑动窗口（发送窗口：swnd，接收窗口：rwnd）有什么关系呢？</p><p>swnd &#x3D; min（cwnd，rwnd）</p><p>也就是说，发送窗口的大小是由接收窗口和拥塞窗口共同决定的。那拥塞窗口的大小是如何计算的？通过 4 个拥塞控制算法：慢启动、拥塞避免、拥塞发生、快速恢复</p><h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a><strong>慢启动</strong></h5><p>初始拥塞窗口大小 cwnd&#x3D;1，也就是可以传输 1 个 MDS（Max Datagram Size）大小的数据包，一般网卡允许传输的最大数据单元 MTU 的大小是 1500 字节。对于 UDP 数据报而言：MDS &#x3D; 1500（MTU）- 20（IP 首部）- 8（UDP 首部） &#x3D; 1472 字节</p><p><strong>慢启动算法</strong>： 当发送方每收到一个 ACK，拥塞窗口就加 1（cwnd++）</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-54d7f3cc6ec67a9ae47fa5dfa3fccfc0_1440w.webp" alt="img"></p><p>由此可以看出，慢启动阶段，拥塞窗口呈指数增长，那增长到多少是个头？</p><p>有一个上限值：ssthresh（slow start threshold），从源码看，这个值是 2000 * MDS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const QuicPacketCount kDefaultMaxCongestionWindowPackets = 2000;</span><br></pre></td></tr></table></figure><ul><li>当 <strong>cwnd &lt; ssthresh</strong> 时，使用慢启动算法</li><li>当 <strong>cwnd &gt;&#x3D; ssthresh</strong> 时，使用拥塞避免算法</li></ul><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a><strong>拥塞避免</strong></h5><p>当拥塞窗口大小超过慢启动上限后，就会进入拥塞避免阶段。</p><p><strong>拥塞避免算法：</strong> 当发送方每收到一个 ACK，拥塞窗口就加 1&#x2F;cwnd</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-1072c63fd6e97e671affe2d9346c3836_1440w.webp" alt="img"></p><p>假设现在的 cwnd&#x3D;8，可以发送 8 个数据包，当收到这 8 个包的 ACK 时，拥塞窗口才会加 1，由此可知，在拥塞避免阶段，拥塞窗口是线性增长的。</p><p>那啥时候是个头呢？不管，让它继续增长，直到网络发生拥塞，出现丢包，这时就会触发重传机制，进入拥塞发生阶段</p><h5 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a><strong>拥塞发生</strong></h5><p>重传有 2 种：超时重传和快速重传</p><p>如果发生超时重传，使用的拥塞发生算法为：</p><ul><li>ssthresh &#x3D; cwnd &#x2F; 2</li><li>cwnd &#x3D; 1</li></ul><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-dcefc32fcbaca9acf5a347580b56ff3c_1440w.webp" alt="img"></p><p>重新使用慢启动和拥塞避免算法增加拥塞窗口的大小。</p><p>如果发生快速重传（发送方收到 3 个相同的 ACK），使用的拥塞发生算法为：</p><ul><li>cwnd &#x3D; cwnd &#x2F; 2</li><li>ssthresh &#x3D; cwnd</li></ul><p>接下来就会进入快速恢复阶段。</p><h5 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a><strong>快速恢复</strong></h5><p>快速恢复算法：cwnd &#x3D; ssthresh + 3（因为收到 3 个 ACK），然后进入拥塞避免阶段。</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-9158217fe2e02f6b17a29aadf649cdd2_1440w.webp" alt="img"></p><h4 id="QUIC相比于TCP的优势"><a href="#QUIC相比于TCP的优势" class="headerlink" title="QUIC相比于TCP的优势"></a>QUIC相比于TCP的优势</h4><p>安全性:QUIC它完全以加密形式通信，未加密的通信是完全被禁止的</p><p><strong>0-RTT 握手</strong>:其实原理很简单：客户端缓存了 ServerConfig（B&#x3D;b*G%P），下次建连直接使用缓存数据计算通信密钥。</p><p>多路复用方面，QUIC可以复用多个stream，同时其中一个stream的丢包并不会影响其他stream，这也说明了在QUIC中，每个stream是相对独立的,解决了TCP协议中队头阻塞问题。</p><h4 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h4><p>建立一个 TCP 连接需要“三次握手”，缺一不可：</p><ul><li><strong>一次握手</strong>:客户端发送带有 SYN（SEQ&#x3D;x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</li><li><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态</li><li><strong>三次握手</strong>:客户端发送带有 ACK(ACK&#x3D;y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成 TCP 三次握手。</li></ul><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p><ol><li><strong>第一次握手</strong>：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li><li><strong>第二次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li><li><strong>第三次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li><li>防止失效的请求报文又请求建立连接，浪费服务器资源</li></ol><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20240104135112905.png" alt="image-20240104135112905"></p><p>三次握手就能确认双方收发功能都正常，缺一不可。</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20231003112124898.png" alt="image-20231003112124898"></p><h5 id="第-2-次握手传回了-ACK，为什么还要传回-SYN？"><a href="#第-2-次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="第 2 次握手传回了 ACK，为什么还要传回 SYN？"></a>第 2 次握手传回了 ACK，为什么还要传回 SYN？</h5><p>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信也是正常的。</p><blockquote><p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP&#x2F;IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p></blockquote><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20231003112128868.png" alt="image-20231003112128868"></p><p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p><ol><li><strong>第一次挥手</strong>：客户端发送一个 FIN（SEQ&#x3D;x） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li><li><strong>第二次挥手</strong>：服务器收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （ACK&#x3D;x+1）标志的数据包-&gt;客户端 。然后服务端进入 <strong>CLOSE-WAIT</strong> 状态，客户端进入 <strong>FIN-WAIT-2</strong> 状态。</li><li><strong>第三次挥手</strong>：服务端发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 <strong>LAST-ACK</strong> 状态。</li><li><strong>第四次挥手</strong>：客户端发送 ACK (ACK&#x3D;y+1)标志的数据包-&gt;服务端，然后客户端进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (ACK&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li></ol><p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p><h5 id="为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？"><a href="#为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？" class="headerlink" title="为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？"></a>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</h5><p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p><h5 id="如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？"><a href="#如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？" class="headerlink" title="# 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？"></a><a href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84-ack-%E6%B2%A1%E6%9C%89%E9%80%81%E8%BE%BE%E5%AE%A2%E6%88%B7%E7%AB%AF-%E4%BC%9A%E6%80%8E%E6%A0%B7">#</a> 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h5><p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p><h5 id="为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？"><a href="#为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？" class="headerlink" title="# 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85-2-msl-%E6%8A%A5%E6%96%87%E6%AE%B5%E6%9C%80%E9%95%BF%E5%AF%BF%E5%91%BD-%E6%97%B6%E9%97%B4%E5%90%8E%E6%89%8D%E8%BF%9B%E5%85%A5-closed-%E7%8A%B6%E6%80%81">#</a> 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h5><p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p><blockquote><p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接，可根据具体实现动态调整MSL。</p></blockquote><h4 id="讲一讲SYN洪泛攻击，以及解决策略"><a href="#讲一讲SYN洪泛攻击，以及解决策略" class="headerlink" title="讲一讲SYN洪泛攻击，以及解决策略"></a>讲一讲SYN洪泛攻击，以及解决策略</h4><p>洪泛攻击： 在 TCP 的三次握手机制的第一步中，客户端会向服务器发送 SYN 报文段。服务器接收到 SYN 报文段后会为该 TCP分 配缓存和变量，如果攻击分子大量地往服务器发送 SYN 报文段，服务器的连接资源终将被耗尽，导致内存溢出无法继续服务。</p><p>解决策略：当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源 IP，目的 IP，端口号以及只有服务器自己知道的一个秘密函数生成一个 cookie，并把 cookie 作为序列号响应给客户端。</p><p>如果客户端是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段。接下来服务器会根据确认报文的源 Id，目的 Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1 等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源。</p><p>这样一来就不会为恶意攻击的 SYN 报文段分配资源空间，避免了攻击。</p><h4 id="详细介绍一下-TCP-的四次挥手机制，为什么要有-TIME-WAIT-状态，为什么需要四次握手？服务器出现了大量-CLOSE-WAIT-状态如何解决"><a href="#详细介绍一下-TCP-的四次挥手机制，为什么要有-TIME-WAIT-状态，为什么需要四次握手？服务器出现了大量-CLOSE-WAIT-状态如何解决" class="headerlink" title="详细介绍一下 TCP 的四次挥手机制，为什么要有 TIME_WAIT 状态，为什么需要四次握手？服务器出现了大量 CLOSE_WAIT 状态如何解决"></a>详细介绍一下 TCP 的四次挥手机制，为什么要有 TIME_WAIT 状态，为什么需要四次握手？服务器出现了大量 CLOSE_WAIT 状态如何解决</h4><p>当客户端要服务器断开连接时，客户端 TCP 会向服务器发送一个特殊的报文段，该报文段的 FIN 标志位会被置 1，接着服务器会向客户端发送一个确认报文段。然后服务器也会客户端发送一个 FIN 标志位为 1 的终止报文段，随后客户端回送一个确认报文段，服务器立即断开连接。客户端等待一段时间后也断开连接。</p><p>为什么要有 TIME_WAIT 状态？因为客户端最后向服务器发送的确认 ACK 是有可能丢失的，当出现超时，服务端会再次发送 FIN 报文段，如果客户端已经关闭了就收不到了。</p><p>大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。</p><p>详情可参考以下博客：<a href="https://www.cnblogs.com/sunxucool/p/3449068.html">https://www.cnblogs.com/sunxucool/p/3449068.html</a></p><h4 id="TCP的可靠传输是如何保障的"><a href="#TCP的可靠传输是如何保障的" class="headerlink" title="TCP的可靠传输是如何保障的"></a>TCP的可靠传输是如何保障的</h4><ul><li><strong>基于数据块传输</strong>：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li><li><strong>连接稳定可靠</strong>：通过三次握手四次挥手，保证了连接的可靠性，数据传输的完整性。</li><li><strong>序号机制，对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号（序列号是数据第一个字节的序号），有了序列号能够将接收到的数据<strong>根据序列号排序</strong>，并且<strong>去掉重复序列号的数据</strong>就可以实现数据包去重。</li><li><strong>校验和</strong> : TCP添加伪首部，TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个<strong>相应的确认信息</strong>（ACK）。<strong>超过该定时器时间依旧未收到对方确认，那么对应的数据包就被假设为已丢失并进行重传，便会重新发送该数据</strong></li><li><strong>流量控制</strong> : <strong>接收方根据自己接收缓冲的大小，可在设置确认报文字段的窗口字段，动态调整发送方发送窗口大小。</strong>TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制，窗口大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值）。</li><li><strong>拥塞控制</strong> : 通过慢启动，当网络拥塞时（发送方的数据迟迟无法到达接收方），发送方估算网络拥堵程度减少数据的发送。</li></ul><p>总结：TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20231003112139329.png" alt="image-20231003112139329"></p><p>udp第四个字段为17</p><h4 id="详细讲一下TCP的滑动窗口"><a href="#详细讲一下TCP的滑动窗口" class="headerlink" title="详细讲一下TCP的滑动窗口"></a>详细讲一下TCP的滑动窗口<img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp-send-window.png" alt="TCP发送窗口结构"></h4><p>从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。</p><h5 id="先讲流量控制："><a href="#先讲流量控制：" class="headerlink" title="先讲流量控制："></a>先讲流量控制：</h5><p><strong>接收方根据自己接收缓冲的大小，可在设置确认报文字段的窗口字段，动态调整发送方发送窗口大小。</strong>TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失</p><h5 id="接着讲解拥塞控制："><a href="#接着讲解拥塞控制：" class="headerlink" title="接着讲解拥塞控制："></a>接着讲解拥塞控制：</h5><p>拥塞控制是指发送方先设置一个小的窗口值作为发送速率，当成功发包并接收到 ACK 时，便以<strong>指数速率增大发送窗口的大小</strong>，直到遇到丢包（超时&#x2F;三个冗余 ACK ），才停止并调整窗口的大小。这么做能最大限度地利用带宽，又不至于让网络环境变得太过拥挤。</p><p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p><p><a href="https://blog.csdn.net/qq_41431406/article/details/97926927">TCP的拥塞控制（详解）-CSDN博客</a></p><p><strong>UDP接收缓冲区</strong></p><p>每个UDP socket都有一个接收缓冲区，没有发送缓冲区，从概念上来说就是只要有数据就发，不管对方是否可以正确接收，所以不缓冲，不需要发送缓冲区。</p><p>UDP：当套接口接收缓冲区满时，新来的数据报无法进入接收缓冲区，此数据报就被丢弃。UDP是没有流量控制的；快的发送者可以很容易地就淹没慢的接收者，导致接收方的UDP丢弃数据报。</p><h4 id="讲述浏览器中输入一个网址之后背后的过程："><a href="#讲述浏览器中输入一个网址之后背后的过程：" class="headerlink" title="讲述浏览器中输入一个网址之后背后的过程："></a><strong>讲述浏览器中输入一个网址之后背后的过程：</strong></h4><ol><li><p>URL 解析：</p><p><strong>地址解析</strong>：首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，（如果是关键词就直接按照关键词搜索）并且根据你输入的内容进行自动完成、字符编码等操作。浏览器还会进行一些额外的操作，比如安全检查、访问限制</p></li><li><p>DNS 查询</p><p><strong>1</strong>.<strong>浏览器缓存</strong>：浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p><p><strong>2. 操作系统缓存</strong>：操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p><p><strong>3. 路由器缓存</strong>：路由器也有自己的缓存。</p><p><strong>4. 本地 DNS 缓存</strong>：ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，也就是本地DNS服务器，它们在大多数情况下都会有缓存。</p><p><strong>5.根域名服务器查询</strong>：本地 DNS 服务器会将请求转发到互联网上的根域,再查询顶级域名服务器，权威域名服务器，找到对应服务器的ip地址</p></li><li><p>通过ip地址找到服务器，并与服务器建立TCP 连接</p></li><li><p>浏览器向web服务器发送一个HTTP请求</p></li><li><p>服务器对发送的请求进行处理，并发回一个HTML响应</p></li><li><p>浏览器接收到来自服务器的响应资源后，会对资源进行分析接受响应，浏览器渲染页面，得到我们看到的网页</p></li></ol><h4 id="一个请求达到后端整个过程"><a href="#一个请求达到后端整个过程" class="headerlink" title="一个请求达到后端整个过程"></a>一个请求达到后端整个过程</h4><ol><li><strong>建立连接</strong>：客户端通过TCP&#x2F;IP协议与服务器建立连接，这是HTTP的基础。</li><li><strong>发送请求</strong>：客户端向服务器发送一个HTTP请求，其中包含请求方法（例如GET或POST）和要访问的资源的URL。</li><li><strong>处理请求</strong>：服务器接收到请求后，会解析请求，查找所请求的资源，并准备好将其发送回客户端的响应。</li><li><strong>发送响应</strong>：服务器将响应发送回客户端，响应通常包括状态码、响应头和响应体。</li><li><strong>关闭连接</strong>：连接在请求和响应之后通常会被关闭，但HTTP&#x2F;1.1引入了持久连接以改善性能。</li></ol><h4 id="讲讲TCP的表头有哪些字段，这些字段你是背的还是了解过有什么作用，有过对每个字段的功能的测试吗"><a href="#讲讲TCP的表头有哪些字段，这些字段你是背的还是了解过有什么作用，有过对每个字段的功能的测试吗" class="headerlink" title="讲讲TCP的表头有哪些字段，这些字段你是背的还是了解过有什么作用，有过对每个字段的功能的测试吗"></a>讲讲TCP的表头有哪些字段，这些字段你是背的还是了解过有什么作用，有过对每个字段的功能的测试吗</h4><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20231003112148772.png" alt="image-20231003112148772"></p><ol><li><p>源端口和目的端口       各占2个字节，分别写入源端口和目的端口。</p></li><li><p>序号 在一个TCP连接中传送的字节流中的每一个字节都按照顺序编号，本字段表示本报文段所发送数据的第一个字节的序号。</p></li><li><p>确认号 起到收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则证明到序号N-1为止的所有数据都已正确收到。</p></li><li><p>数据偏移（TCP首部长度） TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B为单位，即一个数值是4B</p></li><li><p>保留          占6位，保留为今后使用，但目前应置为0 。</p></li><li><p>当URG置为1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。</p></li><li><p>确认ACK（ACKnowledgment）      仅当ACK &#x3D; 1时确认号字段才有效，当ACK &#x3D; 0时确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。</p></li><li><p>推送 PSH（PuSH）    当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。接收方TCP收到PSH&#x3D;1的报文段，就尽快地（即“推送”向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付。</p></li><li><p>复位RST（ReSeT）       当RST&#x3D;1时，表明 TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。</p></li><li><p>同步SYN（SYNchronization）       在连接建立时用来同步序号。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN&#x3D;1和ACK&#x3D;1，因此SYN置为1就表示这是一个连接请求或连接接受报文。</p></li><li><p>终止FIN（FINis，意思是“完”“终”）          用来释放一个连接。当FIN&#x3D;1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p></li><li><p>窗口             占2字节。窗口值是【0，2^16-1】之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。</p></li><li><p>检验和       占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式和UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）；把第5字段中的UDP中的长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用IPv6,则相应的伪首部也要改变。</p></li><li><p>紧急指针            占2字节。紧急指针仅在URG&#x3D;1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0时也可以发送紧急数据。</p></li><li><p>选项       长度可变，最长可达4字节。当没有使用“选项”时，TCP的首部长度是20字节。</p></li></ol><h4 id="IP头部"><a href="#IP头部" class="headerlink" title="IP头部"></a>IP头部</h4><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzM5NDMw,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>一行32bit</p><p>版本号（4bit）：告知IP地址是ipv4地址还是ipv6地址</p><p>首部长度（4bit）：告知这个数据包头的长度，由此推断出有无可选项</p><p>服务类型（8bit）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">按位被定义为 PPP DTRM0</span><br><span class="line">PPP：定义包的优先级，取值越大数据越重要</span><br><span class="line"> 000 普通 (Routine)</span><br><span class="line">   001 优先的 (Priority)</span><br><span class="line"> 010 立即的发送 (Immediate)</span><br><span class="line"> 011 闪电式的 (Flash)</span><br><span class="line">  100 比闪电还闪电式的 (Flash Override)</span><br><span class="line"> 101 CRI/TIC/ECP(找不到这个词的翻译)</span><br><span class="line"> 110 网间控制 (Internetwork Control)</span><br><span class="line"> 111 网络控制 (Network Control)</span><br><span class="line">D 时延: 0:普通 1:延迟尽量小</span><br><span class="line">T 吞吐量: 0:普通 1:流量尽量大</span><br><span class="line">R 可靠性: 0:普通 1:可靠性尽量大</span><br><span class="line">M 传输成本: 0:普通 1:成本尽量小</span><br><span class="line">0 最后一位被保留，恒定为0</span><br></pre></td></tr></table></figure><p>总长度（16bit）：告知IP数据报文的总长度（包括被分片数据在内），最大承载量为1500字节，超过将进行数据分片</p><p>片偏移量（13bit）：决定IP分片数据的先后顺序，只能是0或1480的倍数，第一个分片数据发送时偏移量为0，第二个为1480，第三个为2960，以此类推。目的端重组数据包时靠偏移量来按顺序组合分片数据</p><p>标志位（3bit）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一位bit未启用为0               </span><br><span class="line">第二位bit如果需要分片第二位为0，不需要分片第二位为1               </span><br><span class="line">第三位比特为1代表还有后续分片，为0代表为最后一个分片 </span><br><span class="line">共有三种情况：</span><br><span class="line">001（需要分片且还有后续分片）</span><br><span class="line">000（需要分片且当前为最后一个分片）</span><br><span class="line">010（不需要分片）</span><br></pre></td></tr></table></figure><p>标识符（16bit）：区分不同的IP数据包的分片数据，在目的端重组分片数据时能快速找到同一数据包的分片数据</p><p>生存时间TTL（8bit）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">范围为1-255；</span><br><span class="line">单位为跳数，数据包每经过一台路由器即为一跳，TTL值减一；当TTL为0时，丢弃数据包。</span><br><span class="line">作用是防止数据包在网络中永久的循环</span><br><span class="line">Windows系统TTL一般为128，Linux系统TTL为1-128之间，通常为56,64。</span><br><span class="line">注：跳点跟踪命令：tracert IP地址</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>协议（8bit）：区分上层协议；6代表TCP协议，17代表UDP协议</p><p>首部校验和（16bit）：校验三层IP包头是否有误</p><p>源IP地址（32bit）：指发送数据包的主机地址</p><p>目标IP地址（32bit）：指接收数据包的目标主机地址</p><p>选项字段（长度可变，0-40Byte）：通常不会使用到，因为IP包头部分的长度单位为32bit，因此可选项字段的长度必须为32bit的整数倍，当使用时且剩余部分不足32bit会自动填充无用数据来补足32bit。</p><h4 id="http和tcp的区别，分别在哪一层"><a href="#http和tcp的区别，分别在哪一层" class="headerlink" title="http和tcp的区别，分别在哪一层"></a>http和tcp的区别，分别在哪一层</h4><p><strong>TCP协议是传输层协议</strong>，主要解决数据如何在网络中传输，<em><strong>而HTTP是应用层协议</strong></em>**，主要解决如何包装数据，两者本质上没有可比性。</p><p>我们在传输数据时，可以只使用（传输层）TCP&#x2F;IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET 等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP&#x2F;IP做传输层协议将它发到网络上。</p><p><strong>Http协议是建立在TCP协议基础之上的</strong>，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的，所以Http连接是一种短连接，是一种无状态的连接。</p><p>说明：从HTTP&#x2F;1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p><p><strong>Http是无状态的短连接</strong>，直观地说，就是每个请求都是独立的，与前面的请求和后面的请求都是没有直接联系的，因此加入了cookie、session等机制实现有状态的的web。<strong>而TCP是有状态的长连接</strong></p><h4 id="tcp慢启动是怎么实现的"><a href="#tcp慢启动是怎么实现的" class="headerlink" title="tcp慢启动是怎么实现的"></a>tcp慢启动是怎么实现的</h4><p>最初的TCP的实现方式是，在连接建立成功后便会向网络中发送大尺寸的数据包，假如网络出现问题，很多这样的大包会积攒在路由器上，很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此现在的TCP协议规定了，新建立的连接不能够一开始就发送大尺寸的数据包，而只能从一个小尺寸的包开始发送，在发送和数据被对方确认的过程中去计算对方的接收速度，来逐步增加每次发送的数据量（最后到达一个稳定的值，进入高速传输阶段。相应的，慢启动过程中，TCP通道处在低速传输阶段），以避免上述现象的发生。这个策略就是慢启动。</p><p>TCP刚刚开始传输数据时，会<strong>从一个较小的cwnd &#x3D; 1开始，然后按照2的幂逐步增长到sshthresh的过程称为慢启动</strong>，直到<strong>cwnd（拥塞窗口）&gt;（慢启动门限）ssthresh</strong>，则<strong>结束慢启动过程</strong>，<strong>进入到拥塞避免阶段</strong></p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1036177bbd5c4ad6bdbe70a70bde14c4.png" alt="img"></p><h4 id="拥塞避免-1"><a href="#拥塞避免-1" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>当TCP经过慢启动阶段，wnd&gt;ssthresh时，就开始使用拥塞避免算法来进行拥塞控制，这个阶段cwnd是以线性方式增长的，每次收到前面发出去的所有包时，cwnd &#x3D; cwnd + 1（实际是每收到一个ACK, cwnd &#x3D; cwnd + 1&#x2F;cwnd），cwnd线性增长直到检测到拥塞发生。</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7a2514f97e0648cf8e44c127a298ca71.png" alt="img"></p><h4 id="快速重传与超时重传算法"><a href="#快速重传与超时重传算法" class="headerlink" title="快速重传与超时重传算法"></a>快速重传与超时重传算法</h4><p>首先， 我们要区别快速重传与超时重传。</p><p>当接收方发现重复的收到三次或者更多个前一个包的 ACK时，就说明中间丢了一个报文，这时候，发送端就不必等待超时再重传，而是可以直接快速地启动重传———这就是快速重传。</p><p>当接收方直到超时，也没有收到ACK和重复时，发送方TCP发送定时器超时后，也会主动发起重传————这就是超时重传。</p><p>发生超时重传和发生快速重传时，拥塞控制的算法是不一样的，当发生快速重传时，就引入了快速重传的算法。</p><h4 id="http和https有什么区别？"><a href="#http和https有什么区别？" class="headerlink" title="http和https有什么区别？"></a>http和https有什么区别？</h4><p>http与https都是常用的网络通信协议</p><p><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</p><p><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</p><p><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p><p><strong>SEO（搜索引擎优化）</strong>：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。</p><h4 id="说一说https实现加密通信的实现原理？CA证书是怎么获得的？一定安全吗？能有中间人吗？"><a href="#说一说https实现加密通信的实现原理？CA证书是怎么获得的？一定安全吗？能有中间人吗？" class="headerlink" title="说一说https实现加密通信的实现原理？CA证书是怎么获得的？一定安全吗？能有中间人吗？"></a>说一说https实现加密通信的实现原理？CA证书是怎么获得的？一定安全吗？能有中间人吗？</h4><ul><li>https是基于tcp协议的，首先客户端会和服务端发起链接建立</li><li>服务端返回它的证书给客户端，证书中包含了服务端公钥S.pub、颁发机构和有效期等信息，证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</li><li>客户端通过操作系统、浏览器内置的根证书（内部包含CA机构的公钥C.pub）验证证书的合法性</li><li>客户端生成随机的对称加密密钥Z，然后通过服务端的公钥S.pub加密发送给服务端</li><li>服务器通过私钥进行解密，获得客户端浏览器的对称加密密钥</li><li>客户端和服务端之后就通过对称加密密钥Z加密数据来进行http通信</li></ul><p>CA证书由网站向CA机构申请，由CA机构颁发，其中包含证书持有者的公钥、域名。同时通过数字签名来做到防止证书被篡改。</p><p>网站在使用HTTPS前，需要向<strong>CA机构</strong>申领一份<strong>数字证书</strong>，数字证书里含有证书持有者信息、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明“该公钥对应该网站”。而这里又有一个显而易见的问题，“<strong>证书本身的传输过程中，如何防止被篡改”</strong>？即如何证明证书本身的真实性？身份证运用了一些防伪技术，而数字证书怎么防伪呢？解决这个问题我们就接近胜利了！</p><h5 id="如何放防止数字证书被篡改？"><a href="#如何放防止数字证书被篡改？" class="headerlink" title="如何放防止数字证书被篡改？"></a><strong>如何放防止数字证书被篡改？</strong></h5><p>我们把证书原本的内容生成一份“签名”，比对证书内容和签名是否一致就能判别是否被篡改。这就是数字证书的“防伪技术”，这里的“签名”就叫<code>数字签名</code>：</p><h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a><strong>数字签名</strong></h5><p>这部分内容建议看下图并结合后面的文字理解，图中左侧是数字签名的制作过程，右侧是验证过程：</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-7c78935389af46e197e96d9cd91c06dd_1440w-1696303314365-11.webp" alt="img"></p><p>数字签名的生成与验证（<a href="https://cheapsslsecurity.com/blog/digital-signature-vs-digital-certificate-the-difference-explained/%EF%BC%89">https://cheapsslsecurity.com/blog/digital-signature-vs-digital-certificate-the-difference-explained/）</a></p><p>数字签名的制作过程：</p><ol><li>CA机构拥有非对称加密的私钥和公钥。</li><li>CA机构对证书明文数据T进行hash。</li><li>对hash后的值用私钥加密，得到数字签名S。</li></ol><p>明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。<br>那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）</p><p>浏览器验证过程：</p><ol><li>拿到证书，得到明文T，签名S。</li><li>用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。</li><li>用证书里指明的hash算法对明文T进行hash得到T’。</li><li>显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。</li></ol><p>为何么这样可以保证证书可信呢？我们来仔细想一下。</p><h5 id="中间人有可能篡改该证书吗？"><a href="#中间人有可能篡改该证书吗？" class="headerlink" title="中间人有可能篡改该证书吗？"></a><strong>中间人有可能篡改该证书吗？</strong></h5><p>假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。</p><p>既然不可能篡改，那整个证书被掉包呢？</p><h5 id="中间人有可能把证书掉包吗？"><a href="#中间人有可能把证书掉包吗？" class="headerlink" title="中间人有可能把证书掉包吗？"></a><strong>中间人有可能把证书掉包吗？</strong></h5><p>假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，这确实会导致上文“中间人攻击”那里提到的漏洞？</p><p>其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</p><h5 id="为什么制作数字签名时需要hash一次？。"><a href="#为什么制作数字签名时需要hash一次？。" class="headerlink" title="为什么制作数字签名时需要hash一次？。"></a><strong>为什么制作数字签名时需要hash一次？</strong>。</h5><p>最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加解密就快很多。</p><h4 id="HTTP是基于TCP还是UDP？"><a href="#HTTP是基于TCP还是UDP？" class="headerlink" title="HTTP是基于TCP还是UDP？"></a>HTTP是基于TCP还是UDP？</h4><p>HTTP&#x2F;3.0 之前是基于 TCP 协议的，由于TCP的队头阻塞问题， HTTP&#x2F;3.0 将弃用 TCP，改用 <strong>基于 UDP 的 QUIC 协议</strong> 。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/10/03/hello-world/"/>
      <url>/2023/10/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
