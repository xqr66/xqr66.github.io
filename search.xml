<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>优雅实现可配置化限流</title>
      <link href="/2024/08/19/%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%85%8D%E7%BD%AE%E5%8C%96%E9%99%90%E6%B5%81/"/>
      <url>/2024/08/19/%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%85%8D%E7%BD%AE%E5%8C%96%E9%99%90%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>限流器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hellobike.bos.api.util.ratelimit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.ctrip.framework.apollo.model.ConfigChange;</span><br><span class="line"><span class="keyword">import</span> com.ctrip.framework.apollo.model.ConfigChangeEvent;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Maps;</span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.common.utils.Loggers;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.config.ApolloConfig;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.enums.common.ApolloConfigKey;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.common.utils.LogUtil;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.ride.center.common.utils.JsonUtils;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.soa.starter.spring.event.SoaClientStartedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.MapUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.NotNull;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.DependsOn;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@DependsOn(&quot;taskSoaClientEventListener&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskDispatchRateLimiter</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;SoaClientStartedEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, RateLimiter&gt; rateLimiterMap = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApolloConfig apolloConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(<span class="meta">@NotNull</span> SoaClientStartedEvent event)</span> &#123;</span><br><span class="line">        Map&lt;String, Double&gt; limitConfig = apolloConfig.getTaskDispatchRateLimitConfig();</span><br><span class="line">        Loggers.COMMON.info(<span class="string">&quot;限流配置 &#123;&#125;&quot;</span>, JsonUtils.toJson(limitConfig));</span><br><span class="line">        <span class="keyword">if</span> (MapUtils.isEmpty(limitConfig)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        limitConfig.forEach((key, value) -&gt; rateLimiterMap.put(key, RateLimiter.create(value)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(ConfigChangeEvent event)</span> &#123;</span><br><span class="line">        <span class="type">ConfigChange</span> <span class="variable">change</span> <span class="operator">=</span> event.getChange(ApolloConfigKey.TASKDISPATCH_RATE_LIMIT_CONFIG);</span><br><span class="line">        <span class="keyword">if</span> (change == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">newValue</span> <span class="operator">=</span> change.getNewValue();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(newValue)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">newObj</span> <span class="operator">=</span> JSONObject.parseObject(newValue);</span><br><span class="line">        <span class="keyword">if</span> (MapUtils.isEmpty(newObj)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Loggers.COMMON.info(<span class="string">&quot;apollo 换电任务派发 新限流配置 &#123;&#125;&quot;</span>, newObj.toJSONString());</span><br><span class="line">        newObj.forEach((key, value) -&gt; &#123;</span><br><span class="line">            <span class="type">Double</span> <span class="variable">limit</span> <span class="operator">=</span> Double.valueOf(String.valueOf(value));</span><br><span class="line">            Loggers.COMMON.info(<span class="string">&quot;数据源类型：&#123;&#125;，限流：&#123;&#125;&quot;</span>, key, limit);</span><br><span class="line">            rateLimiterMap.put(key, RateLimiter.create(limit));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(String consumerType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ApolloConfig.getApplication().getBooleanProperty(<span class="string">&quot;taskdispatch.rate.limit.switch&quot;</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> rateLimiterMap.get(consumerType);</span><br><span class="line">        <span class="keyword">if</span> (rateLimiter == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rateLimiter.acquire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/image_20240907211646-1725715506540-3.png" alt="image_20240907211646"></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/image_202409072116461.png" alt="image_202409072116461"></p><p>实现这个接口，soaclient启动成功后，其他中间件组件预热初始化，这里读取apoll配置，key为消息名称，value为limit</p><p>实现效果：在soaclient启动后，初始化这个rateLimiterMap，key为msgType，value为限流器。</p><h3 id="限流器实时刷新："><a href="#限流器实时刷新：" class="headerlink" title="限流器实时刷新："></a>限流器实时刷新：</h3><p>实现InitializingBean，重写afterPropertiesSet方法，在bean初始化的时候就加上配置变更监听器，监听apoll配置变化，实时更新rateLimiterMap</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/image_202409072116454.png" alt="image_202409072116454"></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/image_202409072116455.png" alt="image_202409072116455"></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/image_20240907211645-1725715651111-18.png" alt="image_20240907211645"></p><p>每次接收消息&#x2F;执行方法前，先获取</p><p>判断限流开关是否打开，再从Map中获取对应的限流器</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/image-20240907212848311.png" alt="image-20240907212848311"></p><h3 id="使用例子：消息限流："><a href="#使用例子：消息限流：" class="headerlink" title="使用例子：消息限流："></a>使用例子：消息限流：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hellobike.bos.api.listener.task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.carkey.base.model.Proto;</span><br><span class="line"><span class="keyword">import</span> com.carkey.base.util.LogUtils;</span><br><span class="line"><span class="keyword">import</span> com.easybike.bos.user.model.user.MaintUserSM;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.common.consts.Consts;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.common.consts.RedisKey;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.common.utils.ContextUtils;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.common.utils.Loggers;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.common.utils.Protos;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.config.ApolloConfig;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.domain.flame.SwitchExtInfoDTO;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.domain.flame.TaskUpdateRequest;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.enums.EnumDsCode;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.exceptions.ServiceException;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.innerservice.flame.TaskOperateInnerService;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.innerservice.flame.operateImpl.SwitchOperateStr;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.innerservice.flame.operateImpl.TaskOperateCommonFactory;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.innerservice.redis.ApiRedisProxy;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.innerservice.task.domain.TaskSwitchTypeEnum;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.listener.task.dto.SwitchTaskDispatchMsg;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.proxy.BosEhrServiceProxy;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.proxy.TaskCenterDalProxy;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.proxy.flame.FsmInstanceProxy;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.proxy.taskcenterdalproxy.ITaskProxy;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.util.MqConst;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.api.util.ratelimit.TaskDispatchRateLimiter;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.bos.ehr.model.BaseBosUser;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.hms.sdk.Hms;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.hms.sdk.consumer.ConsumeMessage;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.hms.sdk.consumer.MessageListener;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.hms.sdk.consumer.MsgRetryStatus;</span><br><span class="line"><span class="keyword">import</span> com.task.center.dal.iface.flame.instance.DsContext;</span><br><span class="line"><span class="keyword">import</span> com.task.center.dal.model.TaskDO;</span><br><span class="line"><span class="keyword">import</span> com.task.center.dal.model.dto.TaskDetailDto;</span><br><span class="line"><span class="keyword">import</span> com.task.center.dal.model.dto.TaskListDetailDto;</span><br><span class="line"><span class="keyword">import</span> com.task.center.dal.model.enumeration.EnumUserStatus;</span><br><span class="line"><span class="keyword">import</span> com.task.center.dal.model.enumeration.TaskStatusEnum;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.MapUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.ObjectUtils;</span><br><span class="line"><span class="keyword">import</span> com.hellobike.base.redis.core.model.key.Key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 换电侧任务派发消息消费</span></span><br><span class="line"><span class="comment"> * 消费topic的四种类型： 0:任务派发 1:任务状态回退 2:任务添加执行人接口 3:任务扩展信息变更</span></span><br><span class="line"><span class="comment"> * 本次只优化 0:任务派发 1:任务状态回退</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchTaskComsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TaskCenterDalProxy taskCenterDalProxy;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> FsmInstanceProxy fsmInstanceProxy;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SwitchOperateStr switchOperateStr;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ITaskProxy iTaskProxy;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ContextUtils contextUtils;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BosEhrServiceProxy bosEhrServiceProxy;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TaskOperateCommonFactory taskOperateCommonFactory;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TaskDispatchRateLimiter taskDispatchRateLimiter;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApiRedisProxy apiRedisProxy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;consumeThreadMin&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;consumeThreadMax&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="comment">//调整kafka的拉取线程数量</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;consumePollThread&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Hms.subscribe(MqConst.ConsumerGroupConst.TW_SWITCH_TASK_DISPATCH_TOPIC_API_CONSUMER, <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> MsgRetryStatus <span class="title function_">onMessage</span><span class="params">(ConsumeMessage msg)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//空消费开关</span></span><br><span class="line">                    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> ApolloConfig.getApplication().getBooleanProperty(<span class="string">&quot;kafka.switch.task.flag&quot;</span>, Boolean.TRUE);</span><br><span class="line">                    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                        <span class="comment">//不消费消息</span></span><br><span class="line">                        Loggers.COMMON.info(<span class="string">&quot;SwitchTaskComsumer，comsume has been stopped&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> MsgRetryStatus.SUCCEED;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">msgData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(msg.getPayload());</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isBlank(msgData)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> MsgRetryStatus.SUCCEED;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">SwitchTaskDispatchMsg</span> <span class="variable">switchTaskDispatchMsg</span> <span class="operator">=</span> JSON.parseObject(msgData, SwitchTaskDispatchMsg.class);</span><br><span class="line">                    Loggers.COMMON.info(<span class="string">&quot;SwitchTaskComsumer switchTaskDispatchMsg=&#123;&#125;&quot;</span>, switchTaskDispatchMsg);</span><br><span class="line">                    <span class="type">SwitchExtInfoDTO</span> <span class="variable">switchExtInfo</span> <span class="operator">=</span> switchTaskDispatchMsg.getSwitchExtInfo();</span><br><span class="line">                    <span class="keyword">if</span> (ObjectUtils.isEmpty(switchExtInfo)) &#123;</span><br><span class="line">                        Loggers.COMMON.info(<span class="string">&quot;SwitchTaskComsumer, switchExtInfo is null&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> MsgRetryStatus.SUCCEED;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//1、合法性校验</span></span><br><span class="line">                    <span class="keyword">if</span> (ObjectUtils.isEmpty(switchTaskDispatchMsg)) &#123;</span><br><span class="line">                        Loggers.COMMON.info(<span class="string">&quot;SwitchTaskComsumer, msg is null&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> MsgRetryStatus.SUCCEED;</span><br><span class="line">                    &#125;</span><br><span class="line">                    execute(switchTaskDispatchMsg);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Loggers.ERROR.error(<span class="string">&quot;SwitchTaskComsumer error msg:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(msg.getPayload()), e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> MsgRetryStatus.SUCCEED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(SwitchTaskDispatchMsg switchTaskDispatchMsg)</span> &#123;</span><br><span class="line">        <span class="comment">//2、判断消息类型，使用不同的监听方法</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">type</span> <span class="operator">=</span> switchTaskDispatchMsg.getMsgType();</span><br><span class="line">        <span class="type">TaskSwitchTypeEnum</span> <span class="variable">typeEnum</span> <span class="operator">=</span> TaskSwitchTypeEnum.parse(type);</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtils.isEmpty(typeEnum)) &#123;</span><br><span class="line">            Loggers.COMMON.info(<span class="string">&quot;SwitchTaskComsumer, msgType is not support&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LogUtils.COMMON.info(<span class="string">&quot;SwitchTaskDispatchListen, msgType=&#123;&#125;&quot;</span>, typeEnum);</span><br><span class="line">        <span class="keyword">switch</span> (typeEnum) &#123;</span><br><span class="line">            <span class="keyword">case</span> TASK_DISPATCH:</span><br><span class="line">                switchTaskDispatchListen(switchTaskDispatchMsg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TASK_BACK_DISPATCH:</span><br><span class="line">                switchTaskBackDispatchListen(switchTaskDispatchMsg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务派发消息处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> switchTaskDispatchMsg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">switchTaskDispatchListen</span><span class="params">(SwitchTaskDispatchMsg switchTaskDispatchMsg)</span> &#123;</span><br><span class="line">        LogUtils.COMMON.info(<span class="string">&quot;SwitchTaskDispatchListen, this execute has started&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">taskType</span> <span class="operator">=</span> switchTaskDispatchMsg.getMsgType();</span><br><span class="line">        <span class="type">String</span> <span class="variable">typeString</span> <span class="operator">=</span> Integer.toString(taskType);</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtils.isEmpty(taskType)) &#123;</span><br><span class="line">            Loggers.COMMON.info(<span class="string">&quot;SwitchTaskDispatchListen, taskType is null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消费限流</span></span><br><span class="line">        taskDispatchRateLimiter.acquire(typeString);</span><br><span class="line">        <span class="comment">//根据任务id获取任务信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">taskGuid</span> <span class="operator">=</span> switchTaskDispatchMsg.getTaskGuid();</span><br><span class="line">        <span class="comment">//防重复消费</span></span><br><span class="line">        <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> RedisKey.taskSwDispatch(taskGuid);</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">taskLockExist</span> <span class="operator">=</span> apiRedisProxy.exists(key);</span><br><span class="line">        <span class="keyword">if</span> (taskLockExist) &#123;</span><br><span class="line">            <span class="comment">// 如果存在则代表处理过</span></span><br><span class="line">            LogUtils.COMMON.info(<span class="string">&quot;SwitchTaskDispatchListen, This task has been dispatched, key:&#123;&#125;&quot;</span>, taskGuid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加锁，一小时内不可再执行</span></span><br><span class="line">        apiRedisProxy.set(key, taskGuid, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, Consts.ONE_HOUR_SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="type">TaskDO</span> <span class="variable">taskDO</span> <span class="operator">=</span> taskCenterDalProxy.getTaskDOByTaskGuid(taskGuid);</span><br><span class="line">        <span class="keyword">if</span> (taskDO == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!TaskStatusEnum.NOT_DISPATCHER.getType().equals(taskDO.getTaskStatus())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4、更改任务状态</span></span><br><span class="line">        <span class="type">DsContext</span> <span class="variable">dsContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DsContext</span>();</span><br><span class="line">        Map&lt;String, Object&gt; context = switchOperateStr.buildContext(taskGuid);</span><br><span class="line">        dsContext.setEvent(<span class="string">&quot;DISPATCH&quot;</span>);</span><br><span class="line">        dsContext.setDsCode(EnumDsCode.soa.name());</span><br><span class="line">        dsContext.setForwardInstance(<span class="literal">true</span>);</span><br><span class="line">        dsContext.setStartNewInstance(<span class="literal">false</span>);</span><br><span class="line">        dsContext.setTaskCode(taskDO.getTaskCode());</span><br><span class="line">        dsContext.setTaskDO(taskDO);</span><br><span class="line">        dsContext.setContext(context);</span><br><span class="line">        fsmInstanceProxy.forwardInstance(dsContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务状态回退消息处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> switchTaskDispatchMsg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">switchTaskBackDispatchListen</span><span class="params">(SwitchTaskDispatchMsg switchTaskDispatchMsg)</span> &#123;</span><br><span class="line">        LogUtils.COMMON.info(<span class="string">&quot;SwitchTaskBackDispatchListen, this execute has started&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">taskType</span> <span class="operator">=</span> switchTaskDispatchMsg.getMsgType();</span><br><span class="line">        <span class="type">String</span> <span class="variable">typeString</span> <span class="operator">=</span> Integer.toString(taskType);</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtils.isEmpty(taskType)) &#123;</span><br><span class="line">            Loggers.COMMON.info(<span class="string">&quot;SwitchTaskDispatchListen, taskType is null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消费限流</span></span><br><span class="line">        taskDispatchRateLimiter.acquire(typeString);</span><br><span class="line">        <span class="comment">//把单个takGuid转换成数组，实际里面只有一个taskguid</span></span><br><span class="line">        List&lt;String&gt; taskGuidList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">taskGuid</span> <span class="operator">=</span> switchTaskDispatchMsg.getTaskGuid();</span><br><span class="line">        <span class="type">String</span> <span class="variable">cityGuid</span> <span class="operator">=</span> switchTaskDispatchMsg.getCityGuid();</span><br><span class="line">        <span class="keyword">if</span> (taskGuid.isEmpty() || cityGuid.isEmpty()) &#123;</span><br><span class="line">            LogUtils.COMMON.info(<span class="string">&quot;SwitchTaskBackDispatchListen, taskGuid or cityGuid is empty!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防重复消费</span></span><br><span class="line">        <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> RedisKey.taskSwCityBackDispatch(cityGuid, taskGuid);</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">taskBackLockExist</span> <span class="operator">=</span> apiRedisProxy.exists(key);</span><br><span class="line">        <span class="keyword">if</span> (taskBackLockExist) &#123;</span><br><span class="line">            <span class="comment">// 如果存在则代表处理过</span></span><br><span class="line">            LogUtils.COMMON.info(<span class="string">&quot;SwitchTaskBackDispatchListen, this task has been backDispatched, cityNo:&#123;&#125; taskId:&#123;&#125;&quot;</span>, cityGuid, taskGuid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加锁，一小时内不可再执行</span></span><br><span class="line">        apiRedisProxy.set(key, taskGuid, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, Consts.ONE_HOUR_SECONDS);</span><br><span class="line">        taskGuidList.add(taskGuid);</span><br><span class="line">        List&lt;TaskDetailDto&gt; tasks = iTaskProxy.getByTaskGuidsV2(switchTaskDispatchMsg.getCityGuid(), taskGuidList);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(tasks)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;未查询到任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tasks.forEach(task -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">eachTaskGuid</span> <span class="operator">=</span> task.getTaskInfo().getTaskGuid();</span><br><span class="line">            <span class="type">TaskDO</span> <span class="variable">taskDO</span> <span class="operator">=</span> taskCenterDalProxy.getTaskDOByTaskGuid(eachTaskGuid);</span><br><span class="line">            TaskListDetailDto.<span class="type">PersonInfo</span> <span class="variable">personInfo</span> <span class="operator">=</span> task.getPersonInfo();</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(personInfo)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;TaskListDetailDto.PersonSwitch&gt; personSwitches = personInfo.getPersonSwitches();</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(personSwitches)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;MaintUserSM&gt; userSMList = personSwitches.stream().map(item -&gt; &#123;</span><br><span class="line">                <span class="type">MaintUserSM</span> <span class="variable">userSM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MaintUserSM</span>();</span><br><span class="line">                userSM.setGuid(item.getExecutorGuid());</span><br><span class="line">                userSM.setUserName(item.getExecutorName());</span><br><span class="line">                userSM.setUserPhone(item.getExecutorPhone());</span><br><span class="line">                <span class="keyword">return</span> userSM;</span><br><span class="line">            &#125;).collect(Collectors.toList());</span><br><span class="line">            <span class="type">DsContext</span> <span class="variable">updateDsContext</span> <span class="operator">=</span> contextUtils.buildUpdateDsContext(taskDO, userSMList, EnumUserStatus.DOWN.getCode(), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            fsmInstanceProxy.forwardInstance(updateDsContext);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用解析"><a href="#使用解析" class="headerlink" title="使用解析"></a>使用解析</h3><p>空消费开关：开关打开后，接收到消息但是不消费，避免外部大量异常消息对我们服务造成不良影响</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/image_202409072116452.png" alt="image_202409072116452"></h3><p>防止重复消费：每次获取redis key</p><p>消费限流，根据msgType限流</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/image-20240908003004690.png" alt="image-20240908003004690"></p><p>todo：有时间将rateLimiter中令牌桶技术沉淀到文档</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实习排查问题总结</title>
      <link href="/2024/08/19/%E5%AE%9E%E4%B9%A0%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2024/08/19/%E5%AE%9E%E4%B9%A0%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="NPE治理记录"><a href="#NPE治理记录" class="headerlink" title="NPE治理记录"></a><strong>NPE治理记录</strong></h1><h3 id="7-14日Create服务NPE问题排查"><a href="#7-14日Create服务NPE问题排查" class="headerlink" title="7.14日Create服务NPE问题排查"></a>7.14日Create服务NPE问题排查</h3><p>报错直接原因com.easybike.bikebos.taskcreate.kafka.taskmetric.sender.ScheduleNewWorkOrderSender.mergeScheduleWorkOrder(ScheduleNewWorkOrderSender.java:387</p><h4 id="问题复现："><a href="#问题复现：" class="headerlink" title="问题复现："></a>问题复现：</h4><p>看到最近出现NPE是在7.14 - 7.16日</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721113468074-2e6db560-1577-4a66-8641-d443bd202284-1725769913940-1.png" alt="img"></p><p>进入Hlog搜索日志</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721113370918-f6774e24-5aec-4e7a-af22-67923aea9cc6-1725769913940-2.png" alt="img"></p><p>可以看到报错直接原因在com.easybike.bikebos.taskcreate.kafka.taskmetric.sender.ScheduleNewWorkOrderSender.mergeScheduleWorkOrder(ScheduleNewWorkOrderSender.java:387</p><p>根据链路追踪可以看到调用的接口是BikeInfoServiceImpl.requestPhotoFinishTask()方法</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721113888507-e47582f5-1daf-40e6-93bf-43305d71a8f4-1725769913940-3.png" alt="img"></p><p>进入具体代码分析</p><ul><li>可以看到通过TaskJobQuery根据TaskGuid查询子任务的子明细列表</li><li>根据这个列表，获取了列表中bikeNo的列表</li><li>根据这个列表，获取了一个map，其中key为bikeNo， value为TaskSubDetailDo</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721114169397-e97cf1d8-e92c-4a2c-b2de-7c41197bd0b2-1725769913940-4.png" alt="img"></p><p>TaskJobQuery查询的结果如下：</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721114256759-6b90067f-8216-4186-a1d7-ae0b985f7ce0-1725769913940-5.png" alt="img"></p><p>Json格式化后的到的结果如下：注意到共有两条记录，<strong>每条记录有一个subDetails，后续的流程与subDetails有很大关系，注意到第一条记录相比于第二条记录，缺失了scheduleInWorkOrder</strong></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721114330306-e5028365-633b-4fd3-a5ef-fdb9ad621e24-1725769913940-6.png" alt="img"></p><p>进入到方法：</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721114603362-dd19040a-41a7-4deb-bace-03b4ec223784-1725769913940-7.png" alt="img"></p><p>看到这里主要是根据bikeNo获取TaskSubDetailsDo，然后根据TaskSubDetailsDo去获取工单信息</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721114686634-0629e15e-37ff-4374-8231-fcbee9df0456-1725769913940-8.png" alt="img"></p><p>进入该方法，主要功能就是获取TaskSubDetailsDo中的subDetails属性，然后返回其中的scheduleInWorkOrder</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721114845997-aa7395ff-f9ef-42be-9a78-c199da4dba20-1725769913940-9.png" alt="img"></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721115098887-7730f823-a67a-4209-89a4-d464e43e4d43-1725769913940-11.png" alt="img"></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721114962410-89e85e64-eb1e-4dbd-a6cf-533d6e1fb4d4-1725769913940-10.png" alt="img"></p><p>但是第一条记录中缺失了scheduleInWorkOrder，所以为null</p><p>com.easybike.bikebos.taskcreate.kafka.taskmetric.sender.ScheduleNewWorkOrderSender.mergeScheduleWorkOrder(ScheduleNewWorkOrderSender.java:387就出现空指针异常</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721115262132-0a17ef3f-aca6-4424-a413-e3cc72bfeda4-1725769913940-13.png" alt="img"></p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>查询数据库中数据：</p><p>发现该缺失scheduleInWorkOrder的记录在数据库中是完整的，只是查询结果中缺失了，初步预估与网络波动或者数据库缓存有关，导致了查询数据缺失（此预估有误）。</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721197869794-f08a78bd-3bf5-4226-be7d-5426df1eb3e5-1725769913940-12.png" alt="img"></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721198287569-76669774-e539-4af7-ad74-ef58b518478d-1725769913940-14.png" alt="img"></p><p>查看正常调用结果：发现未出现NPE的调用，记录都包含scheduleInWorkOrder。</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721202221368-d802b201-4364-478c-ba9c-f7101f3f8d65-1725769913940-15.png" alt="img"></p><h4 id="原因分析："><a href="#原因分析：" class="headerlink" title="原因分析："></a>原因分析：</h4><p><strong>已确认是一键关锁后异步执行数据落库的数据一致性问题</strong></p><p>排查思路：</p><p>在数据库中查询得到的是完整的数据，但是在日志中调用接口去查询却缺失了scheduleInWorkOrder，并且这个错误是偶发的，让我一度怀疑是不是与Mybatis的缓存机制有关、是不是出现了网络波动、是不是subDetails字段太长了导致被截断？</p><p>但是我坚信计算机是不会犯错的，一定是人为指挥不当导致的错误。最后华哥一语道破了真相：<strong>现在查数据库是完整数据，但是当时调用接口查数据库的时候不一定数据是完整的</strong></p><p>后来了解到该接口是用于完成掉入调出单车后拍照结束任务<img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721220987876-e919c163-9fae-4b9a-b7ec-b506f78d2915-1725769913940-17.png" alt="img"></p><p>但是一辆一辆车的开关锁对于运维人员来说太繁琐，于是之前开发了一键关锁的需求，<strong>可以一键将所有掉入调出单车信息以异步任务的方式落库，在前台显示“已完成”。</strong></p><p>但是本次运维人员一键开关锁的车辆数量较大，<strong>异步落库的时间达到了13.4S，在11:22:04完成落库，而运维人员在调用接口拍照是在11:22:02，所以在调用接口时，数据缺失，造成了空指针</strong></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721221259501-b45e84b4-f32c-4bb0-b468-b6fbadf3fd65-1725769913940-16.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据库该任务的sub_detail</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721221388716-e23c6900-a2fb-4790-838d-2154f85de0f6-1725769913940-18.png" alt="img"></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721221549250-f0408a76-d9f8-44dd-8268-b9dcec1a79fd-1725769913940-19.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一键关锁的链路</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721221487008-669e09a5-07fa-4731-8df1-7266e5d7a4fe-1725769913940-20.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用拍照结束任务的链路</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721222755573-dd5b6318-11f9-4a5c-b08b-3e265866404d-1725769913940-21.jpeg" alt="img"></p><h4 id="预期解决："><a href="#预期解决：" class="headerlink" title="预期解决："></a>预期解决：</h4><p>在使用前加强非空校验，如果scheduleInWorkOrder为Null就走之前else中的逻辑。</p><p>因为与之前的一键关锁相关，目前待定解决</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721134342124-665a9813-8fc0-4c2b-ba3b-3825deb45f35-1725769913940-22.png" alt="img"></p><h4 id="一些思考与感悟"><a href="#一些思考与感悟" class="headerlink" title="一些思考与感悟"></a>一些思考与感悟</h4><ul><li><p>经过此次排查，深刻的意识到理解业务流程，是开发、排查问题的基础，只有了解了整体业务，才能将整个流程串联起来，预测出现问题的原因。</p></li><li><p>同时也让我意识到异步任务虽然能有效提高响应速度、提高用户体验，但是也会带来数据一致性问题，需要关注。</p></li><li><p>最后要以时间的维度看数据，重点关注的是在当时调用接口查询数据，数据是否完整，而不是在排查问题时数据是否完整。</p></li></ul><h1 id="任务地图接口响应慢排查"><a href="#任务地图接口响应慢排查" class="headerlink" title="任务地图接口响应慢排查"></a><strong>任务地图接口响应慢排查</strong></h1><h3 id="1-问题现象"><a href="#1-问题现象" class="headerlink" title="1. 问题现象"></a>1. 问题现象</h3><ul><li><p>地图接口响应速度慢</p></li><li><p>AppBosTaskApiService</p></li><li><p>com.hellobike.bos.api.iface.flame.task.TaskMapIface#getTaskMapWithCluster</p></li></ul><h3 id="2-排查-分析问题"><a href="#2-排查-分析问题" class="headerlink" title="2. 排查&amp;分析问题"></a>2. 排查&amp;分析问题</h3><h4 id="2-1-查看现状"><a href="#2-1-查看现状" class="headerlink" title="2.1. 查看现状"></a>2.1. 查看现状</h4><ul><li><p>近12h，95线看起来总体在300ms以内</p></li><li><p>和前端沟通，300ms以上用户会感觉卡</p></li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1711596773112-5f08144a-1e02-4453-8f0e-bc60f35339df-1725769913940-23.png" alt="img"></p><ul><li>平均耗时</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1711596735089-46912105-0dcc-42cd-9614-d507c20f30c7-1725769913940-24.png" alt="img"></p><ul><li>手动操作地图后发现，当地图缩放（展示数据更多），地图开始越来越卡。特别是地图展示区域将近整个上海的时候</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1711596976735-0d15a729-4093-4aa9-8484-f7e5a950305d-1725769913941-25.png" alt="img"></p><p><strong>现状</strong>：目前来看，这个接口没有那么糟糕，95线基本都在300ms以下，平均耗时也基本在100ms以内。主要是地图展示区域较大的时候，接口会比较卡</p><h4 id="2-2-查询链路"><a href="#2-2-查询链路" class="headerlink" title="2.2. 查询链路"></a>2.2. 查询链路</h4><p><a href="https://set.hellobike.cn/#/m-a/trace/invoke?idType=traceId&traceid=34ea254e377b92db230b9ccddd53f6af&logTime=1711596825000&timeRegion=1m">耗时较长case链路</a></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1711606620075-197b5054-1141-4451-88d4-da48ac6abc31-1725769913941-26.png" alt="img"></p><ul><li>用同样的参数，线上调用了该查询接口几次，测试下是否是偶发。结果发现全部都是很慢，是<strong>必现</strong></li><li>拉出一台线上机器，通过arthas trace命令分析</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">trace</span> <span class="string">-E</span> <span class="string">com.task.center.dal.flame.exchange.es.EsQueryService|io.searchbox.client.http.JestHttpClient</span> <span class="string">flameQueryTaskDetailListByGuids|execute</span> <span class="string">-n</span> <span class="number">5</span> <span class="string">--skipJDKMethod</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1711606870028-f303075b-8fbe-471c-85a7-d6f9d1fa638b-1725769913941-27.png" alt="img"></p><ul><li><p>可以看到跟序列化相关的操作时间都很长，这里有两种可能</p></li><li><p>序列化耗时异常</p></li><li><p>数据量足够大</p></li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1711607110097-78827252-a462-44e8-807a-45a45b1c0035-1725769913941-29.png" alt="img"></p><ul><li>看了下数据量</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1711607575934-3baaf8f9-6864-4911-96a8-1110e97fd394-1725769913941-28.png" alt="img"></p><p>响应包大小<strong>19MB</strong>左右</p><ul><li>从日志里找到了查询语句</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">GET</span> <span class="string">/task_center_task_index*/_search</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="string">&quot;size&quot;</span> <span class="string">:</span> <span class="number">10000</span>,</span><br><span class="line">  <span class="string">&quot;query&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">    <span class="string">&quot;bool&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">      <span class="string">&quot;filter&quot;</span> <span class="string">:</span> [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;term&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">            <span class="string">&quot;cityGuid&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">              <span class="string">&quot;value&quot;</span> <span class="string">:</span> <span class="string">&quot;268baf80921949908e5960d9a11f0f08&quot;</span>,</span><br><span class="line">              <span class="string">&quot;boost&quot;</span> <span class="string">:</span> <span class="number">1.0</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;range&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">            <span class="string">&quot;createDate&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">              <span class="string">&quot;from&quot;</span> <span class="string">:</span> <span class="number">1711555200000</span>,</span><br><span class="line">              <span class="string">&quot;to&quot;</span> <span class="string">:</span> <span class="number">1711596824346</span>,</span><br><span class="line">              <span class="string">&quot;include_lower&quot;</span> <span class="string">:</span> <span class="literal">true</span>,</span><br><span class="line">              <span class="string">&quot;include_upper&quot;</span> <span class="string">:</span> <span class="literal">true</span>,</span><br><span class="line">              <span class="string">&quot;boost&quot;</span> <span class="string">:</span> <span class="number">1.0</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;terms&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">            <span class="string">&quot;defineType&quot;</span> <span class="string">:</span> [</span><br><span class="line">              <span class="string">&quot;2003&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2004&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2005&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2006&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2007&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2008&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2010&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2011&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2012&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2013&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2014&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2015&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2016&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2019&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2020&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2021&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2022&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2023&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2024&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2025&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2026&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2027&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2028&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2029&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2030&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2031&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2036&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2037&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2035&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2038&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2039&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2040&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2046&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2047&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2051&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2052&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2053&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2054&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2055&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2056&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2057&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2101&quot;</span>,</span><br><span class="line">              <span class="string">&quot;2102&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;boost&quot;</span> <span class="string">:</span> <span class="number">1.0</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;geo_distance&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">            <span class="string">&quot;taskLocation&quot;</span> <span class="string">:</span> [</span><br><span class="line">              <span class="number">121.36430081798954</span>,</span><br><span class="line">              <span class="number">31.12307377525507</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;distance&quot;</span> <span class="string">:</span> <span class="number">39000.0</span>,</span><br><span class="line">            <span class="string">&quot;distance_type&quot;</span> <span class="string">:</span> <span class="string">&quot;arc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;validation_method&quot;</span> <span class="string">:</span> <span class="string">&quot;STRICT&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ignore_unmapped&quot;</span> <span class="string">:</span> <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;boost&quot;</span> <span class="string">:</span> <span class="number">1.0</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;terms&quot;</span> <span class="string">:</span> &#123;</span><br><span class="line">            <span class="string">&quot;taskStatus&quot;</span> <span class="string">:</span> [</span><br><span class="line">              <span class="number">10</span>,</span><br><span class="line">              <span class="number">20</span>,</span><br><span class="line">              <span class="number">25</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;boost&quot;</span> <span class="string">:</span> <span class="number">1.0</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;disable_coord&quot;</span> <span class="string">:</span> <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;adjust_pure_negative&quot;</span> <span class="string">:</span> <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;boost&quot;</span> <span class="string">:</span> <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回值如下</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1711607833874-ef44bfc0-0427-4305-aa8c-a60c25c7794b-1725769913941-30.png" alt="img"></p><ul><li><p>这里took代表的是ES搜索的时间，仅仅用时<strong>114ms</strong></p></li><li><p>也就是说1700毫秒当中</p></li><li><p>中间件方法占用769ms，而这其中包含</p></li><li><p>请求ES时间354ms，这其中还包含</p></li><li><p>ES搜索时间114ms</p></li><li><p>数据传输时延200ms</p></li><li><p>序列化response的412ms</p></li><li><p>业务代码中转化部分占用了244ms+741ms</p></li></ul><h3 id="3-结论"><a href="#3-结论" class="headerlink" title="3. 结论"></a>3. 结论</h3><ul><li><p>关于卡顿</p></li><li><p>地图接口，平均耗时、95线均在300ms以内，300毫秒以内用户不会感觉到卡顿</p></li><li><p>但随着展示区域数据的增加，耗时逐渐增加，峰值能够达到2000ms+</p></li><li><p>关于展示数据量较多情况下，底层查询ES接口耗时增加</p></li><li><p><strong>主要是数据量较大，查询存储网络时延增加，应用序列化时长显著增加</strong></p></li><li><p>查询ES返回数据量，采用默认上限10000条。该场景下，返回数据量较多。ES搜索耗时占比6.7%，网络时间耗时占比11.8%，其余均为代码或中间件中序列化耗时占比81.5%</p></li><li><p>另外</p></li><li><p>ES是搜索引擎，特长是搜索而不是存储，在业务设计的时候，业务信息不要过多的存储在ES当中。除非对响应时间有极其严格的要求，其他可以通过ES+DB，ES+Redis+DB，ES+HBase等方式来设计</p></li></ul><h3 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4. 解决方案"></a>4. 解决方案</h3><table><thead><tr><th><strong>解决方向</strong></th><th><strong>具体措施</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>产品优化</td><td>确定一个地图展示数据最大距离</td><td>根据调度距离等因素，推动产品一同确定一个地图最大展示的范围。满足用户需求，提升用户体验。</td></tr><tr><td>技术优化</td><td>底层查询ES数据的时候并发调用</td><td>增加程序执行的并行度来减少耗时</td></tr><tr><td></td><td>查询ES数据的时候，仅返回id等关键信息</td><td>这样可以减少网络时延、序列化时长</td></tr></tbody></table><h1 id="oho-switch-config-CPU峰刺治理"><a href="#oho-switch-config-CPU峰刺治理" class="headerlink" title="oho_switch_config CPU峰刺治理"></a><strong>oho_switch_config CPU峰刺治理</strong></h1><h2 id="一-问题描述"><a href="#一-问题描述" class="headerlink" title="一. 问题描述"></a>一. 问题描述</h2><ul><li>频繁收到DB CPU水位过高告警</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/image-20240908113659694-1725769913941-31.png" alt="image-20240908113659694"></p><h2 id="二-排查定位"><a href="#二-排查定位" class="headerlink" title="二. 排查定位"></a>二. 排查定位</h2><h3 id="2-1-分析监控"><a href="#2-1-分析监控" class="headerlink" title="2.1 分析监控"></a>2.1 分析监控</h3><h4 id="CPU水位情况分析"><a href="#CPU水位情况分析" class="headerlink" title="CPU水位情况分析"></a>CPU水位情况分析</h4><ul><li>总体水位不高，不过有非常多的峰刺</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1681371409321-80f21fb0-e9d4-4bee-8b08-80d2a192a4ea-1725769913941-32.png" alt="img"></p><hr><ul><li><p>整点后推迟一段时间，规律产生峰刺</p></li><li><p>Job、整点推送消息</p></li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1681371631442-bb0ba725-dc88-4bcb-97c5-cd0e593088ea-1725769913941-33.png" alt="img"></p><h4 id="Set监控平台分析"><a href="#Set监控平台分析" class="headerlink" title="Set监控平台分析"></a>Set监控平台分析</h4><ul><li>这个DB涉及三个服务</li></ul><table><thead><tr><th><strong>服务</strong></th><th><strong>监控</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>AppSwitchConfigService</td><td><img src="/./../imgs/%E5%AE%9E%E4%B9%A0%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20240908113923132.png" alt="image-20240908113923132"></td><td></td></tr><tr><td>AppTwNoahPlatformService</td><td><img src="/./../imgs/%E5%AE%9E%E4%B9%A0%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20240908114012100.png" alt="image-20240908114012100"></td><td></td></tr><tr><td>AppSwitchBosWorkCenterService</td><td><img src="/./../imgs/%E5%AE%9E%E4%B9%A0%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20240908114051627.png" alt="image-20240908114051627"></td><td></td></tr></tbody></table><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul><li>可以看到这边<code>AppSwitchBosWorkCenterService</code>调用的量级明显大很多</li><li>这个库主要是用来存储和读取配置，在<code>AppSwitchConfigService</code>和<code>AppTwNoahPlatformService</code>这几个服务都接入了Dpp，调用量不会很大</li><li><code>AppSwitchBosWorkCenterService</code>服务负责和算法交互，处理算法推送的阈值，而且他们的阈值推送的周期基本上就是一小时</li></ul><h4 id="HMS消费者监控分析"><a href="#HMS消费者监控分析" class="headerlink" title="HMS消费者监控分析"></a>HMS消费者监控分析</h4><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/image-20240908114251471-1725769913941-34.png" alt="image-20240908114251471"></p><ul><li>这个时间节点非常匹配，你懂得</li></ul><h3 id="2-2-代码分析"><a href="#2-2-代码分析" class="headerlink" title="2.2 代码分析"></a>2.2 代码分析</h3><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1681372536938-99500276-a0bb-43ca-a0e5-f3ed7e0cf5e6-1725769913941-35.png" alt="img"></p><ul><li>算法推送，批量删除缓存之后，这一批缓存失效，流量直接打到DB</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/image-20240908114344912-1725769913941-37.png" alt="image-20240908114344912"></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1681373046576-1f3a9f99-f780-4096-af38-3b62859c175c-1725769913941-36.png" alt="img"></p><h3 id="2-3-结论"><a href="#2-3-结论" class="headerlink" title="2.3 结论"></a>2.3 结论</h3><ul><li>算法推送阈值消息，更新阈值的时候删除缓存，缓存批量失效，流量打到DB上</li></ul><h2 id="三-问题解决"><a href="#三-问题解决" class="headerlink" title="三. 问题解决"></a>三. 问题解决</h2><table><thead><tr><th><strong>序号</strong></th><th><strong>需要解决的问题</strong></th><th><strong>解决方案</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>1</td><td>算法推送阈值时候，直接删除缓存</td><td>直接将算法阈值更新到Redis</td><td>这边理论上来说存在并发更新缓存的缓存不一致的问题。不过概率比较小，而且评估下来认为是可以接受这种少数情况的。故这里只做简单的更新。不做并发控制</td></tr><tr><td>2</td><td>缓存未设置一定时间内随机过期，导致DB访问峰值较高</td><td>在一定范围内设置过期时间</td><td></td></tr></tbody></table><hr><h1 id="oho-switch-config-CPU较高问题排查续集"><a href="#oho-switch-config-CPU较高问题排查续集" class="headerlink" title="oho_switch_config CPU较高问题排查续集"></a>oho_switch_config CPU较高问题排查续集</h1><hr><h2 id="四-上线后效果"><a href="#四-上线后效果" class="headerlink" title="四. 上线后效果"></a>四. 上线后效果</h2><ul><li>并没有改善，依然有峰刺</li></ul><h2 id="五-跟进排查"><a href="#五-跟进排查" class="headerlink" title="五. 跟进排查"></a>五. 跟进排查</h2><h3 id="5-1-问题分析"><a href="#5-1-问题分析" class="headerlink" title="5.1 问题分析"></a>5.1 问题分析</h3><ul><li><p>首先，CPU上升的曲线是和算法推送阈值强相关的</p></li><li><p>CPU升高和算法阈值推送是肯定有关的</p></li><li><p>但是新的功能上线之后，按道理来说应该拦住了很多读流量</p></li><li><p>按照原先的猜想，CPU升高是因为缓存批量过期导致的读流量较大</p></li><li><p>现在根据监控来看是不匹配的，CPU依然升高，DDL QPS没有明显下降</p></li><li><p>MySQL DBA 范超，开启监控，查看CPU主要消耗</p></li><li><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1690992696473-61c27679-1275-4276-bf1c-b9ad43f88d11-1725769913941-38.png" alt="img"></p></li><li><p>跟阈值更新相关的insert和update语句各占了30+%</p></li><li><p>分析</p></li><li><p>通过和范超沟通，慢SQL确实存在，不过CPU占用依然比较小，对CPU影响比较大的还是算法阈值的插入和更新</p></li><li><p>这样的话，算法阈值推送就是这么多，我们必须进行插入和更新</p></li><li><p>但是这里需要注意一点，并不是DB CPU一直升高，问题是有<strong>峰刺</strong></p></li><li><p>和范超沟通下来有几种解决方案</p></li><li><p>限流，将流量打平</p></li><li><p>其实不稳定因素主要是峰刺，解决峰刺即可</p></li><li><p>升级架构</p></li><li><p>DB升配</p></li><li><p>分库分表</p></li></ul><h3 id="5-2-问题解决"><a href="#5-2-问题解决" class="headerlink" title="5.2 问题解决"></a>5.2 问题解决</h3><ul><li>采用RateLimiter限流，将流量打平</li></ul><h2 id="六-问题总结"><a href="#六-问题总结" class="headerlink" title="六. 问题总结"></a>六. 问题总结</h2><ul><li><p>这个问题的排查和解决其实非常有意思</p></li><li><p>首先，问题的排查并不一定是精准的，一次就能解决的，本次就是个例子，这是“反复，螺旋上升”正常过程</p></li><li><p>一开始排查这个问题，方向其实是<strong>正向</strong>的</p></li><li><p>主要是从代码层面，看看代码有哪些问题，比如</p></li><li><p>缓存采用懒加载</p></li><li><p>缓存过期时间固定，并没有将过期时间打散，可能会导致批量到期</p></li><li><p>但是，换个角度想，问题产生在CPU上升，其实应该根据这个现象，来<strong>反向</strong>定位到问题</p></li><li><p>比如，一开始的时候就去联系DBA排查，看看CPU占用比较高的SQL是什么</p></li><li><p>这样的话，抓住主要矛盾，解决主要矛盾即可解决问题</p></li></ul><h1 id="故障处理总结与思考"><a href="#故障处理总结与思考" class="headerlink" title="故障处理总结与思考"></a><strong>故障处理总结与思考</strong></h1><p>本次发布涉及变更：</p><ul><li>迭代需求：新增紧急任务相关需求</li><li>线上问题优化：算法创建任务通过加锁进行并发控制</li></ul><h2 id="一-故障过程"><a href="#一-故障过程" class="headerlink" title="一. 故障过程"></a>一. 故障过程</h2><h4 id="发布服务（灰度一台）"><a href="#发布服务（灰度一台）" class="headerlink" title="发布服务（灰度一台）"></a>发布服务（灰度一台）</h4><ul><li>soa日志、应用日志都没有报错</li></ul><h4 id="收到Redis告警"><a href="#收到Redis告警" class="headerlink" title="收到Redis告警"></a>收到Redis告警</h4><ul><li>用来存储锁的Redis CPU飙升，已经到了30多，还在持续上涨</li><li>由于本次迭代中涉及到锁，感觉可能和本次变更有关，<strong>先立即拉出SOA&#x2F;HMS</strong>，以防真的是由变更导致故障，并影响<strong>进一步增大</strong></li></ul><h4 id="组内排查"><a href="#组内排查" class="headerlink" title="组内排查"></a>组内排查</h4><ul><li><p>在Grafana上观察Redis相关指标参数，从灰度一台机器后，OPS、CPU逐渐升高，时间点非常匹配，大致可以判定和本次变更发布有关</p></li><li><p>但此时还不确定究竟是本次发布中的哪里的变动导致</p></li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/image-20240908114546483-1725769913941-39.png" alt="image-20240908114546483"></p><ul><li>并且此时观察到CPU并没有下降</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/image-20240908114654470-1725769913941-40.png" alt="image-20240908114654470"></p><ul><li>感觉这台机器有什么东西还是在重复的调用Redis</li></ul><h4 id="终止发布-删除实例"><a href="#终止发布-删除实例" class="headerlink" title="终止发布 &amp; 删除实例"></a>终止发布 &amp; 删除实例</h4><ul><li>终止发布 &amp; 联系SRE删除实例</li><li>Redis CPU立即恢复正常水位</li></ul><h4 id="打印线程栈并分析"><a href="#打印线程栈并分析" class="headerlink" title="打印线程栈并分析"></a>打印线程栈并分析</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack -l 1 &gt; thread.txt </span><br></pre></td></tr></table></figure><ul><li>将<code>thread.txt</code>文件传到本地</li><li>登录<a href="https://fastthread.io/%E7%BD%91%E7%AB%99%EF%BC%8C%E4%B8%8A%E4%BC%A0%60thread.txt%60%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%A6%82%E4%B8%8B%E7%8E%B0%E8%B1%A1%EF%BC%9A">https://fastthread.io/网站，上传`thread.txt`文件进行分析，发现如下现象：</a></li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1660984754210-7a115d0e-219e-48bc-87ca-054853f148ff-1725769913941-41.png" alt="img"></p><ul><li><p>从截图可以看出</p></li><li><p>Blocked，很多线程都处于阻塞状态，由于一直在阻塞状态，导致其他线程也没有办法获取到锁，从而无法得到CPU资源，进行计算</p></li><li><p>点击<code>BLOCKED</code>部分查看详情</p></li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1660984975006-61716017-273d-4275-9ffa-3ca41c8921e3-1725769913941-42.png" alt="img"></p><ul><li><p>查看了很多个线程的线程栈，发现线程栈机会一样都是如上报错</p></li><li><p>可以显然看到<strong>setxxpx****（</strong>如果已经存在也set），这个很可能是和锁续签机制有关了，当锁还没有释放的时候就要继续续签，否则其他线程会获取到锁，这样就没法控制对临界资源的访问了</p></li></ul><p>这边有一点疑问：查看很多个线程的线程栈发现都是阻塞在一个对象上，这个可能要后续再看下公司中间件的源码搞清楚了</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1660985162516-921e41c7-475c-4f5e-bb5e-d79d0e5f3b44-1725769913941-43.png" alt="img"></p><h4 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h4><p><strong>分析</strong></p><ul><li>至此，可以分析出本次Redis CPU飙升的原因大概率和Redis锁中的续签机制有关，与此同时，车基团队在我们发布的前一天，已经提前暴露出这个问题，他们是因为老代码中存在使用Redis锁不规范的地方，没有手动对lock进行release，所以也导致了增量的线程在进行自动续签，导致Redis CPU飙升</li></ul><p><strong>根因</strong></p><ul><li>问题出现在监听关锁消息的地方，由于对于一辆车，可能会重复上报关锁消息，但是我们只需要第一次触发的消息，我们触发任务的判断即可，后面的几次是没有必要再进行处理的。</li><li>所以在这个地方，老代码使用公司中间件的Redis分布式锁，过期时间为3000ms</li><li>老版本中是不论是否有主动释放锁，到<strong>3000ms锁自动过期</strong>，而新版本是在3000ms没到期的时候会对其进行<strong>续签</strong>，那么这里不主动释放就会导致<strong>一直续签</strong>了</li></ul><h2 id="二-总结-思考"><a href="#二-总结-思考" class="headerlink" title="二. 总结&amp;思考"></a>二. 总结&amp;思考</h2><h3 id="2-1-思考"><a href="#2-1-思考" class="headerlink" title="2.1 思考"></a>2.1 思考</h3><p><strong>应急思维</strong></p><ul><li><p>收到告警，发现和本次发布的服务但凡有<strong>一点关联</strong>，立刻拉出<code>SOA/HMS</code>或终止发布进行回滚，在不确定是否和发布有关的情况下，一律做最保险的措施，避免情况进一步恶化</p></li><li><p>这也要求我们，在平时要对一些基本操作要熟悉</p></li><li><p>拉出SOA&#x2F;HMS</p></li><li><p>终止发布&#x2F;回滚服务</p></li><li><p>实例重启&#x2F;删除实例</p></li></ul><p><strong>评估影响，先止血</strong></p><ul><li>首先查看我们的业务大盘、机器情况，对当前问题的影响范围有大致了解，做出大致判断</li><li>重要且紧急、重要不紧急、不重要不紧急</li><li>评估当前告警的部分，会对业务产生什么影响，严重程度如何，进而考虑</li><li>是否要同步业务，对一线进行告知安抚，或是开启其他入口</li><li>是否要问题升级，找到组长或Leader进行协助排查</li><li>是否有补偿措施，比如薪资计算有问题，可以通过事后薪资来补发</li></ul><p><strong>熟练运用工具，定位问题</strong></p><ul><li>查看监控，如：机器水位监控、SOA调用监控、Redis&#x2F;ES&#x2F;DB水位监控等</li><li>通过打印线程栈，分析线程栈，大致定位问题</li><li>如果是JVM相关问题，利用JVM分析工具分析OOM的原因等</li></ul><h3 id="2-2-总结"><a href="#2-2-总结" class="headerlink" title="2.2 总结"></a>2.2 总结</h3><h4 id="故障处理SOA"><a href="#故障处理SOA" class="headerlink" title="故障处理SOA"></a>故障处理SOA</h4><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1660988121523-95e0608b-795a-4430-a24d-00fb080de315-1725769913941-44.jpeg" alt="img"></p><h3 id="TODO："><a href="#TODO：" class="headerlink" title="TODO："></a>TODO：</h3><ul><li>Linux常用指令</li><li>MAT&#x2F;VisualVM</li><li>Arthas</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实习收获</title>
      <link href="/2024/07/20/%E5%AE%9E%E4%B9%A0%E6%94%B6%E8%8E%B7/"/>
      <url>/2024/07/20/%E5%AE%9E%E4%B9%A0%E6%94%B6%E8%8E%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="遇到的问题与收获："><a href="#遇到的问题与收获：" class="headerlink" title="遇到的问题与收获："></a>遇到的问题与收获：</h3><ul><li>在灰度时，尽量不要和老代码耦合在一起，尽量独立抽取成一个方法，这样方便后续灰度出现问题时回切老代码、在灰度没问题时删除老代码</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722044736197-bc0a4651-e744-4f8c-8fdf-9e1404955d8b.png" alt="img"></p><ul><li>方法符合单一职责，可以抽取出公共的方法，尽量避免重复代码</li><li>在发消息时，由于共享平台改成实时处理，需要保证在发消息前已更新好数据库，可以添加延迟时间，避免造成数据覆盖问题</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722044844459-c6803b2b-ca0e-479b-beb3-33053c5448aa.png" alt="img"></p><ul><li>在变更时，需要额外关注各个字段的含义是否发生变化，避免出现取错字段等低级错误</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722045162196-91c1fb62-11c2-41eb-88f3-984e8f28428a.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">老逻辑RewardAmt取taskDo中的TaskAwardPrice字段</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722045204989-03909b95-53b8-4c92-a65c-56c0d09c1478.png" alt="img"></p><p>新逻辑RewardAmt要取record中的Reward字段</p><ul><li>对不同的情况，采用不同的日志级别，方便从日志中观测严重的漏洞</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722045854058-95137228-4a02-45f7-b145-e489bd6cd3e6.png" alt="img"></p><ul><li>在接受消息队列中间件消息时，一定要做幂等处理避免重复消费、数据覆盖等情况</li><li>调用其他平台接口时，一定做好健壮性保障</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722046204887-28bc3e2e-1e78-49f7-b75d-6aae8d71ae7c.png" alt="img"></p><ul><li>在Iface中，请求入参选择用对象来接收，方便在参数上添加限制</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722047228440-1973da46-242f-460e-af0e-1608451becaf.png" alt="img"></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722047243996-5b284643-b2cb-49cc-ab70-72d80f9f2d77.png" alt="img"></p><h3 id="防腐层妙用"><a href="#防腐层妙用" class="headerlink" title="防腐层妙用"></a>防腐层妙用</h3><p>个人认为防腐层可以看做是对远程调用的一种代理，在其中对远程调用进行增强，使用时，我们不直接远程调用，而是面向这种代理关系来调用。</p><p><strong>关键作用：</strong></p><ol><li><strong>隔离变化</strong>：</li></ol><ul><li>远程调用的服务可能会频繁变化，而这些变化可能会对内部系统造成负面影响。防腐层通过隔离这些变化，减少了对内部系统的直接影响。简单来说就是在外部服务变化时，我们只需要变更对应的防腐层就行，如果没有防腐层就需要到全部使用外部服务的地方都做变更。</li></ul><ol><li><strong>模型转换</strong>：</li></ol><ul><li>不同系统之间的数据模型往往不一致。防腐层负责将外部数据模型转换为内部数据模型，确保系统间的数据交互顺畅。</li></ul><ol><li><strong>数据验证和清理</strong>：</li></ol><ul><li>防腐层可以在数据进入内部系统之前进行验证和清理，包括数据判空校验、数据过滤等，确保数据的质量和一致性。</li></ul><ol><li><strong>异常处理：</strong></li></ol><ul><li>防腐层可以在远程调用时对异常进行处理记录，避免远程调用失败造成整个方法都失败。</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/image-20240908123737897.png" alt="image-20240908123737897"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实习常用操作总结</title>
      <link href="/2024/06/10/%E5%AE%9E%E4%B9%A0%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
      <url>/2024/06/10/%E5%AE%9E%E4%B9%A0%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本人在此文档中总结沉淀一些在实习过程中，开发常见的操作</p><h3 id="本地Fat环境Test启动"><a href="#本地Fat环境Test启动" class="headerlink" title="本地Fat环境Test启动"></a>本地Fat环境Test启动</h3><p>⚠️本质上可以看做是连入fat环境的单元测试，适合自测，必须要extends BaseTest</p><ul><li>设置堆大小：在设置中设置堆大小为1500，原本的堆太小会报OOM</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722047433846-4625bdf6-42ae-4e0d-be84-b49a4b04baaa.png" alt="img"></p><ul><li>网络设置：<strong>连上staff网络，并关闭VPN，否则在加载时会出现网络握手失败的问题</strong></li><li><strong>test类继承BaseTest，其中会有启动的参数等，可以直接连接到Fat环境，可以自己mock数据，主要测试代码逻辑问题、最后以debug运行，就可以自测</strong></li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722048218237-acc76ab7-645a-4981-a8ea-5c2071e399d5.png" alt="img"></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722048168525-cf0f5f5a-3de5-4ba4-be00-b01726b345d6.png" alt="img"></p><h3 id="本地起服务"><a href="#本地起服务" class="headerlink" title="本地起服务"></a>本地起服务</h3><p>本地启动服务后你的电脑就相当于fat的一台服务器，可以接收到fat环境的请求，利用白小兔工具进行debug</p><p>在README文件中，拷贝启动参数，最后一行是给你的机器打一个tag，比如现在tag就是rabbit，方便后续指定请求达到你机器上</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1723791713602-dcf13a27-c1e0-497c-97bf-8ebc899b4c58.png" alt="img"></p><p>在启动类，edit configuration</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1723791749524-63d50c92-6d85-45ec-ae2c-807ec52ad03f.png" alt="img"></p><p>找到add VM options，不同版本idea位置可能不同</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1723791824668-fdee3f2a-26f7-46be-a5d8-d512c96a803c.png" alt="img"></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1723791872896-3a3a0e4f-8912-45b7-8978-f2edae4e4a0b.png" alt="img"></p><p>⚠️⚠️⚠️网络配置：在连接staff网络后，不要连接哈奇士VPN，否则可能报错</p><p>此时，可以debug启动服务</p><h3 id="白小兔远程调用："><a href="#白小兔远程调用：" class="headerlink" title="白小兔远程调用："></a>白小兔远程调用：</h3><p>进入白小兔后，选择要调用服务、接口、方法，自己组装参数后可以远程调用接口的方法，并获得返回结果</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1723792234651-fbacfa19-383f-42cf-8395-d06e692dfe4d.png" alt="img"></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1723792267317-2ea6e607-b1a2-4d4f-91f6-f3be1a93e013.png" alt="img"></p><p>我们可以利用本地起服务+白小兔，很方便进行dubug，在其他信息选择有rabbit TAG的机器，也就是我们本地启动的机器，</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1723792380295-531d98e2-22a1-4cff-b130-244e4f2c87c8.png" alt="img"></p><p>然后再发请求，就能本地debug</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1723792514000-6ee8f898-f203-4886-9479-5e75cd32b419.png" alt="img"></p><h3 id="接口yapi、网关配置"><a href="#接口yapi、网关配置" class="headerlink" title="接口yapi、网关配置"></a>接口yapi、网关配置</h3><ul><li>对外提供的接口需要再yapi中配置好请求、响应参数、action等</li></ul><p>可以参考其他人的接口进行配置</p><p><a href="https://yapi.hellobike.cn/project/4554/interface/api/343725">https://yapi.hellobike.cn/project/4554/interface/api/343725</a></p><p><strong>需要关注接口路径，也就是action</strong></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722048679701-1c055e3b-3a63-4a20-9310-3ab4c971a611.png" alt="img"></p><p>接着，去网关平台配置该action调用的接口方法，注意这里有三个网关，分别对应用户、后台、BosApp，按照接口使用者去对应的网关配置</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722048763301-e4281f73-e6d3-41ba-95ea-f14b5e879990.png" alt="img"></p><p>进入对应网关先进入后端服务列表，点击加锁，搜索服务，点击编辑后，添加自己的接口并发布</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722048942074-51ff552b-4f2b-4879-be31-af9ebd3bf1db.png" alt="img"></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722049010061-0a2ae2ac-a7a3-4cec-a5f6-c9cff3e63ef3.png" alt="img"></p><p>接着到用户端接口列表添加接口方法与action之间的映射关系，至此已完成</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722049133552-d4010351-6988-4b93-8a3d-235c9545c355.png" alt="img"></p><h3 id="接口打包Jar提供给其他平台使用"><a href="#接口打包Jar提供给其他平台使用" class="headerlink" title="接口打包Jar提供给其他平台使用"></a>接口打包Jar提供给其他平台使用</h3><p>若其他服务调用我们接口是采用导包的形式引入，则我们需要变更服务的版本号</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722049268018-c9f2973b-e116-413b-8bc3-10645fe46c61.png" alt="img"></p><p>并在atlas上面发布新包,注意分支尽量选择ATLAS&#x2F;FAT_COMMON避免发生包覆盖、冲突</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722049510802-c3930118-954e-4c3c-b0d3-9aa44b034169.png" alt="img"></p><p>可在全局历史中查看包发布情况</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722049642888-9f15960f-5c9d-4c45-b358-07a1765acecf.png" alt="img"></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721890640037-66a83665-8df3-42c1-a0cd-47c2c15b1203.png" alt="img"></p><p>读取配置</p><ol><li>直接使用SpringBoot的@Value注解读取，格式为”${key:default}”, 其中key为你配置的key，default为默认值</li></ol><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1723779806921-5b761fcd-9c7d-4130-bee7-b990a8408a30.png" alt="img"></p><ol><li>在ApolloConfigUtils.java中配置开关和默认值</li></ol><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1711354981244-8816a0cb-4ea3-4d87-815b-c6172e883359.png" alt="img"></p><p>再通过ApolloConfigUtils获取开关的具体值</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1711357329619-8d52819b-5c06-409e-96cd-335da4ce3a70.png" alt="img"></p><h3 id="apoll配置开关"><a href="#apoll配置开关" class="headerlink" title="apoll配置开关"></a>apoll配置开关</h3><p>进入atlas对应服务下配置中心，选择合适环境fat、uat、pre、pro，编辑application配置文件</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721890576283-b76510a6-cc98-4d5c-9d8a-b15253f4aa11.png" alt="img"></p><p>添加配置，可以配置boolean、json等多种类型，</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721890640037-66a83665-8df3-42c1-a0cd-47c2c15b1203.png" alt="img"></p><p>读取配置，直接使用SpringBoot的@Value注解读取，格式为”${key:default}”, 其中key为你配置的key，default为默认值</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1723779806921-5b761fcd-9c7d-4130-bee7-b990a8408a30.png" alt="img"></p><h3 id="诺亚配置灰度规则"><a href="#诺亚配置灰度规则" class="headerlink" title="诺亚配置灰度规则"></a>诺亚配置灰度规则</h3><p>到admin平台场景注册下新增场景</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722050039311-5c52df97-d01a-4c65-9ead-07a465fe8091.png" alt="img"></p><p>接着到场景灰度配置找到刚刚注册的场景，配置灰度城市规则，这里可能需要找坤哥申请一下城市列表权限</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722050119583-49f22431-71a0-46b1-81f5-63c735697512.png" alt="img"></p><h3 id="分库分表下查记录"><a href="#分库分表下查记录" class="headerlink" title="分库分表下查记录"></a>分库分表下查记录</h3><p>由于数据量大，分库分表后我们要查一条记录，需要知道记录在哪个库、哪个表</p><ul><li><strong>推荐方式：直接在智能存储平台逻辑库表查询，不需要查分库分表</strong></li></ul><p><a href="https://hdbs.hellobike.cn/#/workbench?key=bos_task_center_sharding_sharding&sidebar=dbtree">https://hdbs.hellobike.cn/#/workbench?key=bos_task_center_sharding_sharding&amp;sidebar=dbtree</a></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1723794103520-1d3ba6bd-9cc5-48f9-90d5-7e308526e577.png" alt="img"></p><ul><li>老方式：在admin平台查询库、表号</li></ul><p>1使用分库分表工具：<a href="https://fat-admin.hellobike.cn/#/beacon/testZhou">https://fat-admin.hellobike.cn/#/beacon/testZhou</a><br>a输入taskGuid 找到分库分表的位置<br>b数据库编号是7，表编号是23</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1712842169114-4187e5c8-935d-40e5-aa61-806b0b4c3e93.webp" alt="img"></p><p>2在数据库中查询想要的数据</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1712842446202-e9359b3c-a275-470a-8f16-8f783c5dc02d.webp" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Optional使用分析</title>
      <link href="/2024/05/19/Optional%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"/>
      <url>/2024/05/19/Optional%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h1><p>Optional主要用于优雅处理处理一系列的判空、避免三目运算符NPE问题。</p><p>三目运算符NPE问题：</p><p><a href="https://developer.aliyun.com/article/757443">《新版Java开发手册》提到的三目运算符的空指针问题到底是个怎么回事？-阿里云开发者社区</a></p><p>一系列判空伪代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> p.getAddress();</span><br><span class="line">    <span class="keyword">if</span> (address != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Province</span> <span class="variable">province</span> <span class="operator">=</span> sddress.getProvince();</span><br><span class="line">        System.out.println(province.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(); <span class="comment">//如果没找到就抛错</span></span><br></pre></td></tr></table></figure><p>如果使用Optional：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(<span class="keyword">new</span> <span class="title class_">Person</span>)</span><br><span class="line">.map(p -&gt; p.getAddress())</span><br><span class="line">.map(a -&gt; a.getProvince())</span><br><span class="line">.map(p -&gt; p.getName())</span><br><span class="line">.orElseThrow(NoSuchElementException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><p>可以看到，如果用了 Optional，代码里不需要判空的操作，即使 address 、province 为空的话，也不会产生空指针错误，这就是 Optional 带来的好处！</p><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>关于Optional，Java 语言架构师 Brian Goetz 是这么说的：</p><p>Our intention was to provide a limited mechanism for library method return types where there needed to be a clear way to represent “no result”, and using null for such was overwhelmingly likely to cause errors.</p><p>意思就是：Optional 可以给返回结果提供了一个表示无结果的值，而不是返回 null。</p><p>简单理解下，Optional 其实就是一个壳，里面放着原先的值，至于这个值是不是 null 另说，反正拿到的这个壳肯定不是 null。</p><p><img src="/./../../imgs/Optional%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/1723795015942-3df3bf9f-5eb9-4e54-a9d2-f9946d6401c7.png" alt="img"></p><p>我认为 Optional 的好处在于可以简化平日里一系列判断 null 的操作，使得用起来的时候看着不需要判断 null，纵享丝滑，表现出来好像用 Optional 就不需要关心空指针的情况。</p><p>而事实上是 Optional 在替我们负重前行，该有的判断它替我们完成了，而且用了 Optional 最后拿结果的时候还是小心的，盲目 get 一样会抛错。</p><p>在使用的时候，一直有个疑问：</p><ul><li>如果在 <code>p.getAddress()</code> 时拿不到值的话，你说是会继续执行<code>map(a -&gt; a.getProvince())</code> 还是直接跳到 <code>orElseThrow</code>? </li><li>或者反过来如果 <code>map(p -&gt; p.getName())</code> 不为空，你说 <code>orElseThrow</code> 这个方法会不会执行？</li></ul><p>接下来就来看下源码，看看 Optional 的实现机制。</p><h1 id="Optional-源码"><a href="#Optional-源码" class="headerlink" title="Optional 源码"></a>Optional 源码</h1><p>Optional 的代码十分简短且简单，如果去掉注释，我估计就100来行。</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p><img src="/./../../imgs/Optional%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/1723795016155-27ce1696-28e3-4b9c-b8bc-14bd67a72940.png" alt="img"></p><p>符合前面提到的：Optional 就是个壳，里面的 value 才是正主。并且内置了一个 EMPTY 对象，用来替换当 value 为 null 时候的壳。</p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>现在看下上面演示的 map 方法，看看它的内部实现是如何让我们不需要做非空判断的。</p><p><img src="/./../../imgs/Optional%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/1723795016146-15811be1-7b4c-4072-bc23-c93238464eaf.png" alt="img"></p><p>可以看到很简单，没几行代码，我把方法中的两个调用实现都贴上去，这样对着看应该会更清晰：</p><p><img src="/./../../imgs/Optional%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/1723795016237-8a889bba-ae8c-45f1-9904-602d23b81bee.png" alt="img"></p><ul><li>先判断 value 是否为空，如果是空的话说明真正要是值是空的，此时直接返回一个 <code>empty()</code>，直接返回事先创建的空 Optional 。</li><li>如果 value 不为空，那说明值是存在的，因此调用 mapper (就是上面我们写的 p.getAddress 之类的)来操作一波这个 value，并且用 <code>Optional.ofNullable</code> 包了一层，这个方法内部也看到了，如果 value 是空的话，也是返回空 Optional，否则就利用 of 包裹 value 成 Optional 返回。</li></ul><p><strong>因此，不论Optional 里面到底有没有值，map 都能处理！如果你是空，我就返回空 Optional ，如果你有值，就包裹成 Optional 返回，反正不论怎样，调用 map 的返回值都会是一个 Optional，而不是 null，所以执行时不会产生空指针的情况。</strong></p><p>还记得上面的提问吗？结合 map 的源码，现在来回答下上面的问题，看注释：</p><p><img src="/./../../imgs/Optional%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/1723795016175-99da5f17-596c-4d0f-b31d-dde2c073e422.png" alt="img"></p><p>截个 <code>orElseThrow</code> 的实现，就是判断下 value ，如果是 null 就抛错。</p><p><img src="/./../../imgs/Optional%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/1723795016411-40312e9a-24db-4a94-b1e0-f0c96eb063c4.png" alt="img"></p><p>结合源码我们知道了答案：即使 <code>Optional.ofNullable</code> 返回的是空 Optional ，下面的 map 逻辑还是会执行，不会因为中间得到空值而直接跳到<code>orElseThrow</code>执行，这和我们平日知晓的 if else 逻辑不太一样，不为空<code>orElseThrow</code>也一样会执行，就是判断 <code>value!= null</code>然后直接返回 value 的值了。</p><h4 id="orElseGet-VS-orElse"><a href="#orElseGet-VS-orElse" class="headerlink" title="orElseGet VS orElse"></a>orElseGet VS orElse</h4><p>Optional 里有 orElseGet  和 orElse 这两个看起来挺相似的方法，都是处理当值为 null 时的兜底逻辑。在一些文章上看到说用 orElseGet 不要用 orElse ，因为在 Optional 有值时候 orElse 仍然会调用方法，所以后者性能比较差。其实从上面分析我们知道不论 Optional 是否有值，orElse 和 orElseGet  都会被执行，所以是怎么回事呢？</p><p>看下这个代码：</p><p><img src="/./../../imgs/Optional%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/1723795016607-e62bb674-8403-425b-9422-ad867ba7bb88.png" alt="img"></p><p>这样看来 orElse 确实性能会差</p><p>看下源码。</p><p><img src="/./../../imgs/Optional%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/1723795016546-941ddc02-f238-425e-bb31-e3e92e32c708.png" alt="img"></p><p>可以看到两者的入参不同，一个就是普通参数，一个是 Supplier。我们已经得知不论<code>Optional.ofNullable</code> 返回的是否是空 Optional，下面的逻辑还是会执行，所以 orElse 和 orElseGet 这两个方法无论如何都会执行。</p><p>因此 orElse(createYes()) 会被执行，在参数入栈之前，执行了 createYes 方法得到结果，然后入栈，而 orElseGet 的参数是 Supplier，所以直接入栈，然后在调用 other.get 的时候，createYes 方法才会被触发执行，这就是两者的区别之处。</p><p>所以才会造成上面表现出的性能问题，也不是有些文章说的 Optional 有值 orElse 也会被执行而 orElseGet 不会执行这样不准确的说法。</p><h4 id="of-VS-ofNullable"><a href="#of-VS-ofNullable" class="headerlink" title="of VS ofNullable"></a>of VS ofNullable</h4><p><img src="/./../../imgs/Optional%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/1723795016593-ea666b16-96c3-4e04-8425-79730008ff9c.png" alt="img"></p><h4 id="isPresent-VS-ifPresent-Consumer-consumer"><a href="#isPresent-VS-ifPresent-Consumer-consumer" class="headerlink" title="isPresent() VS ifPresent(Consumer&lt;? super T&gt; consumer)"></a>isPresent() VS ifPresent(Consumer&lt;? super T&gt; consumer)</h4><p><img src="/./../../imgs/Optional%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/1723795016667-f3b5f96f-51ae-43fd-9a2b-826a513d0512.png" alt="img"></p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>这个方法要小心，如果没做好判断，直接调用，当是空 Optional 时会抛错的。</p><p><img src="/./../../imgs/Optional%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/1723795016758-03896d9f-468e-466b-88b5-e98a0415a0a5.png" alt="img"></p><p>参考：<a href="https://blog.csdn.net/qq_37840993/article/details/116120837">JAVA 中的Optional类理解、学习与使用_java的optional类-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>优雅迁移老接口</title>
      <link href="/2024/05/19/%E4%BC%98%E9%9B%85%E8%BF%81%E7%A7%BB%E8%80%81%E6%8E%A5%E5%8F%A3/"/>
      <url>/2024/05/19/%E4%BC%98%E9%9B%85%E8%BF%81%E7%A7%BB%E8%80%81%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="API服务车基接口迁移"><a href="#API服务车基接口迁移" class="headerlink" title="API服务车基接口迁移"></a>API服务车基接口迁移</h1><p>此处为语雀内容卡片，点击链接查看：<a href="https://hellobike.yuque.com/qnwdg4/ppgvq0/vgkfa4g5xgrhig76">https://hellobike.yuque.com/qnwdg4/ppgvq0/vgkfa4g5xgrhig76</a></p><h3 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a>基本流程：</h3><p>用两个开关来控制数据比对和新接口切换</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1721975978979-8e61417c-7573-43c0-929c-91031648cdc3.jpeg" alt="1721975978979-8e61417c-7573-43c0-929c-91031648cdc3"></p><h3 id="开关设置"><a href="#开关设置" class="headerlink" title="开关设置"></a>开关设置</h3><p>开关采用的是Json格式，其中包含两个集合，分别是要进行数据比对的接口、要进行接口切换的接口</p><p>相比于直接使用两个Boolean类型的开关，使用Json的优势：</p><ul><li>仅需要一个配置，集中管理开关情况</li><li>对各个方法都可以单独的进行数据比对、接口迁移的开关，只需要在Josn的对应集合中添加&#x2F;删除接口名</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722672491456-a14501b4-cf5a-4710-94c5-9e3c82bf62f2.png" alt="img"></p><p>将读取到的Json转化为对象，其中包含两个Set，方便判断是否存在xxx接口</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1722672785285-dcd898a1-7838-49e3-a128-6a0e9288def7.png" alt="img"></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/image-20240908124059153.png" alt="image-20240908124059153"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>配置中心与本地缓存了解</title>
      <link href="/2024/05/19/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%92%8C%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/"/>
      <url>/2024/05/19/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%92%8C%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="了解apoll配置平台、"><a href="#了解apoll配置平台、" class="headerlink" title="了解apoll配置平台、"></a>了解apoll配置平台、</h1><ul><li><p>apoll是什么：携程开源的维服务配置管理中心。</p></li><li><p>使用场景：微服务通常一个服务会部署多台机器，当需要更改配置时，需要对每一台机器进行配置修改和发布，因此需要集中化管理配置，能够动态修改配置。</p></li><li><p>特点：</p></li><li><p>热发布</p></li><li><p>配置数据存储在数据库</p></li><li><p>服务端和客户端之间维持长连接，服务端主动推送配置的变更，客户端每隔一段时间会主动拉取服务端的配置作为兜底策略防止服务端推送失败</p></li><li><p>使用本地缓存，若配置未发生变化不需要重新拉取配置</p></li><li><p>版本发布管理</p></li><li><p>支持回滚操作</p></li><li><p>灰度发布</p></li><li><p>指发布后先在部分机器进行验证</p></li><li><p>与springcloud config配置中心对比：</p></li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1719756714410-e47f9b06-bf0d-4633-92de-c023016d11df.png" alt="img"></p><ul><li>整体架构：采用Eureka作为服务注册发现中心，使用数据库存储配置，可对配置进行分布式读写</li></ul><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1719757379090-1f8fa726-ac34-4a28-a5c0-1be441fa3f82.png" alt="img"></p><h1 id="DPP本地缓存："><a href="#DPP本地缓存：" class="headerlink" title="DPP本地缓存："></a>DPP本地缓存：</h1><p>通过本次SDK的更新，我理解了从诺亚配置新建 到 BOS端使用配置的全流程，在看这块代码时，我理解了之前的dpp推送原理，即本地缓存，将那些读多写少的数据，批量推送到OSS，再下载到本地缓冲中，避免每次都查数据库，在更新更新数据库时，会通过注解感知这个数据操作，并触发推送逻辑，实时更新本地缓存，但是直接写SQL操作数据库时，需要手动推dpp才能更新，可能会造成短期的数据不一致。</p><p><strong>推送系统流程图：</strong></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1724900293369-81825248-6481-4bb6-96c0-6371ab76116f.png" alt="img"></p><p><strong>时序图：</strong></p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1724900698487-ac64d809-0fe1-459c-8d16-76cc9e22c2d0.png" alt="img"></p><p>数据流：</p><p><img src="/./../../imgs/%E6%A8%A1%E6%9D%BF%20-%20%E5%89%AF%E6%9C%AC/1724901645216-4769686a-c565-40f8-803d-3d5ec6b94b0b-1725770731094-5.png" alt="1724901645216-4769686a-c565-40f8-803d-3d5ec6b94b0b"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2024/04/19/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/04/19/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="基本数据类型与权限"><a href="#基本数据类型与权限" class="headerlink" title="基本数据类型与权限"></a>基本数据类型与权限</h3><h4 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a><strong>基本类型和包装类型的区别</strong></h4><h5 id="1-基本类型有初始值，而包装类型的默认值是null"><a href="#1-基本类型有初始值，而包装类型的默认值是null" class="headerlink" title="1.基本类型有初始值，而包装类型的默认值是null"></a>1.基本类型有初始值，而包装类型的默认值是null</h5><h5 id="2-包装类型可以为-null，而基本类型不可以"><a href="#2-包装类型可以为-null，而基本类型不可以" class="headerlink" title="2.包装类型可以为 null，而基本类型不可以"></a>2.包装类型可以为 null，而基本类型不可以</h5><p>数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有<a href="https://so.csdn.net/so/search?q=NPE&spm=1001.2101.3001.7020">NPE</a>（NullPointerException）风险。</p><h5 id="3-存储位置有所区别：基本类型是成员变量就存储在堆内存里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用"><a href="#3-存储位置有所区别：基本类型是成员变量就存储在堆内存里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用" class="headerlink" title="3.存储位置有所区别：基本类型是成员变量就存储在堆内存里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用"></a>3.存储位置有所区别：基本类型是成员变量就存储在<a href="https://so.csdn.net/so/search?q=%E5%A0%86%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">堆内存</a>里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用</h5><h5 id="4-包装类型可用于泛型，而基本类型不可以"><a href="#4-包装类型可用于泛型，而基本类型不可以" class="headerlink" title="4.包装类型可用于泛型，而基本类型不可以"></a>4.包装类型可用于泛型，而基本类型不可以</h5><p>如果我们这么写<br>List<int> a &#x3D; new ArrayList&lt;&gt;();<br>编译器会报错：Type argument cannot be of primitive type(类型参数不能为基本类型)<br>这是为什么呢？因为泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类。</p><h5 id="5-在使用“-”进行判断的时候的不同"><a href="#5-在使用“-”进行判断的时候的不同" class="headerlink" title="5.在使用“&#x3D;&#x3D;”进行判断的时候的不同"></a>5.在使用“&#x3D;&#x3D;”进行判断的时候的不同</h5><p>基本数据类型会直接比较值是否相同，而包装数据类型用“&#x3D;&#x3D;”判断比较的是地址值（在-128 – 127之间会共用内部类的cache），真正判断是否相等需要用equals()。</p><p><strong>6.自动装箱和自动拆箱</strong><br>把基本类型转换成包装类型的过程叫做装箱（boxing）。反之，把包装类型转换成基本类型的过程叫做拆箱（unboxing）。</p><p>1）基本类型和包装类型进行 &#x3D;&#x3D; 比较，包装类型会自动拆箱，直接和基本类型比较值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">System.out.println(a == b);</span><br></pre></td></tr></table></figure><p>上述代码的结果为 true。</p><p>2）当需要进行自动装箱时，如果数字在 -128 至 127 之间，会直接使用缓存中的对象，而不是重新创建一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">199</span>;  </span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> A;  </span><br></pre></td></tr></table></figure><p>执行第一句代码的时候，系统为我们执行了：<br>Integer A &#x3D; Integer.valueOf(199);<br>执行第二句代码的时候，系统为我们执行了：<br>int a &#x3D; A.intValue();</p><h4 id="java的访问权限有哪些"><a href="#java的访问权限有哪些" class="headerlink" title="java的访问权限有哪些"></a>java的访问权限有哪些</h4><h5 id="类的成员变量和方法访问权限"><a href="#类的成员变量和方法访问权限" class="headerlink" title="类的成员变量和方法访问权限"></a>类的成员变量和方法访问权限</h5><table><thead><tr><th>修饰符</th><th>类内部</th><th>同包（package）</th><th>子类</th><th>任何地方</th></tr></thead><tbody><tr><td>public</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>protected</td><td>Yes</td><td>Yes</td><td>Yes</td><td></td></tr><tr><td>缺省</td><td>Yes</td><td>Yes</td><td></td><td></td></tr><tr><td>private</td><td>Yes</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th align="left">权限修饰符</th><th align="left">类</th><th align="left">变量&#x2F;方法</th></tr></thead><tbody><tr><td align="left">public</td><td align="left">包内外的类都可以访问</td><td align="left">包内外的类都可以访问</td></tr><tr><td align="left">protected</td><td align="left">类不可以声明为protected</td><td align="left">本包内的类和子类可以访问</td></tr><tr><td align="left">不写</td><td align="left">本包中的类可以访问</td><td align="left">本包中的类可以访问</td></tr><tr><td align="left">private</td><td align="left">类不可以声明为private</td><td align="left">只允许本类访问</td></tr></tbody></table><h5 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h5><p>类的访问权限仅有<strong>public</strong>和<strong>default</strong>， 如果一个类声明的时候用了<strong>public</strong>，则该类的类名必须与文件名一致，包括大小写，如果不匹配，会有编译错误</p><h4 id="Java的基本类型存储位置"><a href="#Java的基本类型存储位置" class="headerlink" title="Java的基本类型存储位置"></a><strong>Java的基本类型存储位置</strong></h4><ul><li><p><strong>第一种</strong>: 在方法中声明的变量，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因</p><p>（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中</p><p>（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。</p></li><li><p><strong>第二种</strong> 在类中声明的变量是类的成员变量(全局变量),放在堆中</p><ol><li>声明的是基本类型的变量,其变量名及其值放在堆内存中</li><li>声明的是引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中。但与对象中的普通成员变量（局部变量）不同的是，它们的生命周期是在对象销毁时才结束的</li></ol></li><li><p><strong>第三种</strong> 静态变量：</p><p>​静态变量随着类的加载而存在，是存储在方法区（Method Area）中的，而不是存储在栈或堆上，所以它的生命周期与程序的生命周期一样长。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjcxMjE2,size_16,color_FFFFFF,t_70.png" alt="img"></p></li></ul><h4 id="包装类的缓存"><a href="#包装类的缓存" class="headerlink" title="包装类的缓存"></a>包装类的缓存</h4><p>1、前提：发生自动装箱的过程（基本类型–&gt;包装类型）<br>创建一个包装类对象有两种方法：<br>（1）构造器方法（就是new出来）；<br>（2）自动装箱（就是编译器自动调用包装类的valueOf方法）；</p><h5 id="两种方法的区别："><a href="#两种方法的区别：" class="headerlink" title="两种方法的区别："></a>两种方法的区别：</h5><p>构造器方法：不论值的大小，返回的将都会是一个新对象；<br>自动装箱会先经过判断，再决定返回的是一个新对象还是常量池中已存在的对象。</p><p>2、机制：当通过自动装箱机制创建包装类对象时，首先会判断数值是否在缓存范围内，如果满足条件，则会从  该包装类中的静态内部类xxCache包装类（例如IntegerCache类）类型数组（例如static final Integer cache[]）（放在方法区的常量池）中寻找指定数值，并返回缓存的对象，否则创建一个新的对象返回。</p><p>3、原理：<br>（1）当包装类加载时，该包装类中的静态内部类xxCache会初始化一个静态包装类类型数组，最小值（固定值）为-128,而最大值（默认值）为127【可修改】，是所有线程共享的。</p><h5 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h5><p>在缓存值范围内的对象可以直接在常量池中取出，不用创建新的对象；<br>当需要频繁的使用同一对象的时候，如果有缓存，则可以避免重复创建同一对象，节省空间开销和时间消耗，提升了性能。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111615708.png" alt="image-20231003111615708"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h4><ol><li>重写必须依赖于继承(父子关系) 将父类的的方法给完善。而重载不需要依赖继承关系，在自己的类中就可以实现。</li><li>重写的方法名和参数列表必须和父类相同，如果父类没有这个方法，那么就不算重写。重载是在自身类中创建多个方法名相同但是参数类型或者个数不同的方法。</li><li>重写的参数不能修改，而重载的参数必须修改。</li></ol><h4 id="object中的hashcode-方法是做什么用的"><a href="#object中的hashcode-方法是做什么用的" class="headerlink" title="object中的hashcode()方法是做什么用的"></a>object中的hashcode()方法是做什么用的</h4><p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p><p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><h5 id="那为什么不只提供-hashCode-方法呢？"><a href="#那为什么不只提供-hashCode-方法呢？" class="headerlink" title="那为什么不只提供 hashCode() 方法呢？"></a><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></h5><p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p><h5 id="那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？"><a href="#那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？" class="headerlink" title="那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？"></a><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></h5><p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><h4 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h4><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p>再map集合中，如果只重写equals方法，那么两个相同对象hashcode可能不同，会存在多个key相同的情况。</p><h4 id="object类中的常用方法的用处："><a href="#object类中的常用方法的用处：" class="headerlink" title="object类中的常用方法的用处："></a>object类中的常用方法的用处：</h4><p>1、 getClass()：获取类的class对象。<br>2、 hashCode():获取对象的hashCode值<br>3、 equals():比较对象是否相等，先比较存储地址再比较对象，子类可重写以自定义。<br>4、 clone()：浅拷贝一个新的对象。<br>5、 toString():如果没有重写，应用对象将打印的是地址值。<br>6、 notify():随机选择一个在该对象上调用wait方法的线程，解除其阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>7、 notifyall():解除所有那些在该对象上调用wait方法的线程的阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>8、 wait():导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在同步方法中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>9、 finalize()：对象回收时调用</p><h4 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h4><ol><li><p>final修饰符（关键字）。被<strong>final修饰的类</strong>，就意味着<strong>不能再派生出新的子类</strong>，不能作为父类而被子类继承。因此一个类不能既被abstract声明，又被final声明。将<strong>变量或方法声明为final</strong>，可以保证他们在<strong>使用的过程中不被修改</strong>。被声明为final的变量必须在声明时<strong>给出变量的初始值</strong>，而在以后的引用中只能读取。被final声明的方法也同样只能使用，即不能方法重写。</p></li><li><p>finally是在<strong>异常处理时提供finally块来执行任何清除操作</strong>。不管有没有异常被抛出、捕获，finally块都会被执行。try块中的内容是在无异常时执行到结束。catch块中的内容，是在try块内容发生catch所声明的异常时，跳转到catch块中执行。<strong>finally块则是无论异常是否发生，都会执行finally块的内容，所以在代码逻辑中有需要无论发生什么都必须执行的代码，就可以放在finally块中</strong>。</p></li><li><p>finalize是方法名。java技术允许使用finalize（）方法<strong>在垃圾收集器将对象从内存中清除出去之前做必要的清理工作</strong>。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在object类中定义的，因此所有的类都继承了它。子类覆盖finalize（）方法以整理系统资源或者被执行其他清理工作。<strong>finalize（）方法是在垃圾收集器删除对象之前对这个对象调用的。</strong></p></li></ol><h4 id="Return与finally的使用顺序"><a href="#Return与finally的使用顺序" class="headerlink" title="Return与finally的使用顺序"></a>Return与finally的使用顺序</h4><p><strong>如果程序是从try代码块或者catch代码块中返回时，finally中的代码总会执行。而且finally语句在return语句执行之后return返回之前执行的。可以使用编译器的Debug功能查看详细过程。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally模块被执行&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">//结果 finally模块被执行 1</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>/<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally模块被执行&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//结果： finally模块被执行 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>/<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally模块被执行&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">//结果 finally模块被执行 0；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally模块被执行&quot;</span>);</span><br><span class="line">          result = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//结果 finally模块被执行 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>*<strong>如果try和catch的return是一个变量时且函数的是从其中一个返回时，后面finally中语句即使有对返回的变量进行赋值的操作时，也不会影响返回的值，因为返回值已经被保存到局部变量表中，赋值操作无法修改到返回值。*</strong></p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String为什么不可变"><a href="#String为什么不可变" class="headerlink" title="String为什么不可变"></a>String为什么不可变</h4><ul><li>将 class 自身声明为 final，这样别人就不能通过扩展来绕过限制了。</li><li>将所有成员变量定义为 private 和 final（使得byte[]引用不可变），并且没有实现 setter 方法来修改byte[]（使得byte[]值不可变）。</li><li>通过构造对象时，成员变量使用深拷贝来初始化，而不是直接赋值，这是一种防御措施，因为该输入对象被其他变量引用，你无法确定输入对象不被其他人修改。</li></ul><p>可以通过反射修改String的值，相当于使用set方法修改byte[];</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString3</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">strObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;反射执行前字符串：&quot;</span> + strObj);</span><br><span class="line">    System.out.println(<span class="string">&quot;反射执行前的hash值：&quot;</span> + strObj.hashCode());</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> strObj.getClass().getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">char</span>[] value = (<span class="type">char</span>[]) field.get(strObj);</span><br><span class="line">    value[<span class="number">2</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;反射执行后字符串：&quot;</span> + strObj);</span><br><span class="line">    System.out.println(<span class="string">&quot;反射执行后的hash值：&quot;</span> + strObj.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1的内存地址：<span class="number">1922154895</span></span><br><span class="line">执行+=后str1的内存地址：<span class="number">883049899</span></span><br><span class="line">拼接之后str1的值：helloworld</span><br><span class="line">str3的值：<span class="number">123</span></span><br><span class="line">str4的值：<span class="number">123456</span></span><br><span class="line">str5的值：ABC</span><br><span class="line">str6的值：BBC</span><br></pre></td></tr></table></figure><h4 id="String-类设计成不可变的原因及好处？"><a href="#String-类设计成不可变的原因及好处？" class="headerlink" title="String 类设计成不可变的原因及好处？"></a><strong>String 类设计成不可变的原因及好处？</strong></h4><p>其实好处就是原因，String 设计成不可变，主要是从性能和安全两方面考虑。</p><h5 id="1、常量池的需要"><a href="#1、常量池的需要" class="headerlink" title="1、常量池的需要"></a><strong>1、常量池的需要</strong></h5><p>这个方面很好理解，Java 中的字符串常量池的存在就是为了性能优化。</p><p>字符串常量池（String pool）是 Java 堆内存中一个特殊的存储区域，当创建一个 String 对象时，假如此字符串已经存在于常量池中，则不会创建新的对象，而是直接引用已经存在的对象。这样做能够减少 JVM 的内存开销，提高效率。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span> s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="title class_">String</span> s2 = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><p>比如引用 s1和 s2 都是指向常量池的同一个对象 “abc”，如果 String 是可变类，引用 s1 对 String 对象的修改，会直接导致引用 s2 获取错误的值。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/43vmfn3rmu.png" alt="img"></p><p>所以，如果字符串是可变的，那么常量池就没有存在的意义了。</p><h5 id="2、hashcode-缓存的需要"><a href="#2、hashcode-缓存的需要" class="headerlink" title="2、hashcode 缓存的需要"></a><strong>2、hashcode 缓存的需要</strong></h5><p>String有一个属性用来缓存hash值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p>因为字符串不可变，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就使得字符串很适合作为 HashMap 中的 key，效率大大提高。</p><h5 id="3、多线程安全"><a href="#3、多线程安全" class="headerlink" title="3、多线程安全"></a><strong>3、多线程安全</strong></h5><p>多线程中，可变对象的值很可能被其他线程改变，造成不可预期的结果。而不可变的 String 可以自由在多个线程之间共享，不需要同步处理。</p><h4 id="String-、StringBuffer和StringBuilder的区别"><a href="#String-、StringBuffer和StringBuilder的区别" class="headerlink" title="String 、StringBuffer和StringBuilder的区别"></a>String 、StringBuffer和StringBuilder的区别</h4><h5 id="1-可变性"><a href="#1-可变性" class="headerlink" title="1.可变性"></a>1.可变性</h5><p>​String 内部的 value 值是 final 修饰的，所以它是不可变类。所以每次修改 String 的值，都会产生一个新的对象。<br>​StringBuffer 和 StringBuilder 是可变类，字符串的变更不会产生新的对象。</p><h5 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="2.线程安全性"></a>2.线程安全性</h5><p>​String 是不可变类，所以它是线程安全的。<br>​StringBuffer 是线程安全的，因为它每个操作方法都加了 synchronized 同步关键字。<br>​StringBuilder 不是线程安全的。所以在多线程环境下对字符串进行操作，应该使用 StringBuffer，否则使用StringBuilder</p><h5 id="3-性能方面。"><a href="#3-性能方面。" class="headerlink" title="3.性能方面。"></a>3.性能方面。</h5><p>​String 的性能是最低的，因为不可变意味着在做字符串拼接和修改的时候，需要重新创建新的对象以及分配内存。<br>​其次是 StringBuffer 要比 String 性能高，因为它的可变性使得字符串可以直接被修改<br>​最后是 StringBuilder，它比 StringBuffer 的性能高，因为 StringBuffer 加了同步锁。</p><h5 id="4-存储方面。"><a href="#4-存储方面。" class="headerlink" title="4.存储方面。"></a>4.存储方面。</h5><p>​String 存储在字符串常量池里面<br>​StringBuffer 和 StringBuilder 存储在堆内存空间。</p><h4 id="StringBuffer、StringBuilder的扩容原理"><a href="#StringBuffer、StringBuilder的扩容原理" class="headerlink" title="StringBuffer、StringBuilder的扩容原理"></a>StringBuffer、StringBuilder的扩容原理</h4><p>扩容原理：</p><p><code>StringBuffer</code>的底层数组结构用的是<code>char</code>类型的数组如果没有指定大小，默认大小为16，指定了大小，默认大小为（16 + 指定大小）。</p><p>所以，当我们使用<code>StringBuffer</code>对象的<code>append(...)</code>方法追加数据时，</p><ul><li>如果数组长度可以容纳追加的数据，就直接追加到数组</li><li>如果char类型数组的长度无法容纳我们追加的数据，<code>StringBuffer</code>就会进行扩容。</li><li>扩容时会用到<code>Arrays</code>类中的<code>copyOf(...)</code>方法，每次扩容的容量大小是原来的容量的2倍（通过无符号左移）加2。</li></ul><h4 id="String-str-“abc”-和String-str-new-String-“abc”-的区别"><a href="#String-str-“abc”-和String-str-new-String-“abc”-的区别" class="headerlink" title="String str &#x3D; “abc” 和String str &#x3D; new String(“abc”)的区别"></a><strong>String str &#x3D; “abc” 和String str &#x3D; new String(“abc”)的区别</strong></h4><p><code>String str =&quot;abc&quot;</code>的原理，采用字面值的方式创建时，<code>JVM</code>会先去字符串常量池中去查找是否存在”abc”这个对象，如果不存在就创建这个字符串，并把地址返回给<code>str</code>。如果存在则直接把”abc”这个字符串的地址返回给<code>str</code>。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/16e1f7c1f13d9561tplv-t2oaga2asx-jj-mark3024000q75-1696302993864-1.webp" alt="img"></p><p><code>String str = new String(&quot;abc&quot;)</code>采用<code>new</code>关键字的方式创建，能被看成”abc”和new String()，<code>JVM</code>也会去字符串常量池中查找有没有这个字符串，如果没有的话，就先在字符串常量池里创建”abc”这个字符串，然后再复制一份放在堆里并把地址返回给<code>str</code>。如果字符串常量池里存在该字符串，那么就直接复制一份放在堆里并把地址返回给<code>str</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = original.value;</span><br><span class="line">        <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">    &#125;<span class="comment">//浅拷贝</span></span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/16e1f8c6aa324edetplv-t2oaga2asx-jj-mark3024000q75-1696303002110-3.webp" alt="img"></p><h4 id="（String的）equals-的底层代码是什么"><a href="#（String的）equals-的底层代码是什么" class="headerlink" title="（String的）equals 的底层代码是什么?"></a>（String的）equals 的底层代码是什么?</h4><ol><li>先使用&#x3D;&#x3D; 进行地址值的判断  </li><li>判断equals()中的值是否为字符串  instanceof()方法</li><li>判断字符串的长度是否相同  </li><li>循环遍历进行判断两个字符串是否相同</li></ol><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="集合顶层是什么，各个接口实现类有哪些"><a href="#集合顶层是什么，各个接口实现类有哪些" class="headerlink" title="集合顶层是什么，各个接口实现类有哪些"></a>集合顶层是什么，各个接口实现类有哪些</h4><p><strong>Java 集合框架架构图如下图所示</strong>：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1711439392899-248.png" alt="图片"></p><p><code>List</code> 接口实现类：</p><ul><li><code>ArrayList</code>: 底层基于可调节大小的数组实现。</li><li><code>LinkedList</code>: 底层基于双向链表实现，链表实现类。</li><li><code>Vector</code>: 和<code>ArrayList</code>类似，但线程安全。</li><li><code>Stack</code>: 继承自 <code>Vector</code>，栈实现类。</li></ul><p><code>Set</code> 接口实现类：</p><ul><li><code>HashSet</code>: 底层基于哈希表实现，没有排序保证。</li><li><code>LinkedHashSet</code>: 底层基于哈希表和链表实现，元素的插入和取出顺序满足 FIFO</li><li><code>TreeSet</code>: 底层基于红黑树实现，元素是有序的，排序的方式有自然排序和定制排序。</li></ul><p><code>Map</code> 接口实现类：</p><ul><li><code>HashMap</code>: 仅用于存储键值对，JDK1.8 之前 <code>HashMap</code> 底层基于数组和链表实现，JDK1.8 之前基于数组和红黑树。</li><li><code>LinkedHashMap</code>: 继承自 <code>HashMap</code>，并在 <code>HashMap</code> 基础上维护一条双向链表，支持遍历时会按照插入顺序有序进行迭代，支持按照元素访问顺序排序，迭代效率比<code>HashMap</code>更高。</li><li><code>TreeMap</code>: 相比于 <code>HashMap</code> 来说，<code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</li><li><code>Hashtable</code>: 与 <code>HashMap</code> 类似，但线程安全。</li></ul><p><code>Queue</code> 接口实现类：</p><ul><li><code>LinkedList</code>: 同时实现了 <code>List</code> 和 <code>Queue</code> 接口。</li><li><code>PriorityQueue</code>：元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</li><li><code>ArrayDeque</code> ：底层基于可变长的数组和双指针实现，允许我们在队列的两端进行元素的插入和移除操作。</li></ul><h4 id="数组和链表的不同"><a href="#数组和链表的不同" class="headerlink" title="数组和链表的不同"></a>数组和链表的不同</h4><table><thead><tr><th></th><th>数组</th><th>链表</th></tr></thead><tbody><tr><td>逻辑结构</td><td>（1）数组在内存中连续； (2)使用数组之前，必须事先固定数组长度，不支持动态改变数组大小；(3) 数组元素增加时，有可能会数组越界；(4) 数组元素减少时，会造成内存浪费；（5）数组增删时需要移动其它元素</td><td>（1）链表采用动态内存分配的方式，在内存中不连续 (2)支持动态增加或者删除元素</td></tr><tr><td>访问效率</td><td>数组在内存中顺序存储，可通过下标访问，访问效率高</td><td>链表访问效率低，如果想要访问某个元素，需要从头遍历</td></tr><tr><td>越界问题</td><td>数组的大小是固定的，所以存在访问越界的风险</td><td>只要可以申请得到链表空间，链表就无越界风险</td></tr><tr><td>使用场景</td><td>存储的大小变化不大，且可以事先确定大小，主要是进行查找，很少插入和删除时</td><td>长度变化较大时，事先无法估量数据规模，当线性表要求频繁插入和删除时</td></tr></tbody></table><h4 id="说说ArrayList"><a href="#说说ArrayList" class="headerlink" title="说说ArrayList"></a>说说ArrayList</h4><p>ArrayList 是一个数组结构的存储容器，所以ArrayList是支持随机存取的，默认情况下，数组的长度是 10.也可以在构建 ArrayList 对象的时候自己指定初始长度。随着在程序里面不断的往 ArrayList 中添加数据，当添加的数据达到 10 个的时候，ArrayList 就没有多余容量可以存储后续的数据。这个时候 ArrayList 会自动触发扩容。扩容的具体流程很简单：</p><ol><li>首先，创建一个新的数组，这个新数组的长度是原来数组长度的 1.5 倍。</li><li>然后使用 Arrays.copyOf 方法把老数组里面的数据拷贝到新的数组里面。<br>扩容完成后再把当前要添加的元素加入到新的数组里面，从而完成动态扩容的过程。</li></ol><h4 id="常见的树"><a href="#常见的树" class="headerlink" title="常见的树"></a>常见的树</h4><p><a href="https://zhuanlan.zhihu.com/p/531299726#%E5%89%8D%E8%A8%80">为什么红黑树的效率比较高 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/361961175">红黑树 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/91960960">一文带你彻底读懂红黑树（附详细图解） - 知乎 (zhihu.com)</a></p><h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><strong>平衡二叉树</strong></h5><p>特点：<strong>任意节点的左子树和右子树高度差不能超过1</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-db8cdc6ff692f73cb4984ff80e45ef34_720w.webp" alt="img"></p><h5 id="非平衡二叉树"><a href="#非平衡二叉树" class="headerlink" title="非平衡二叉树"></a><strong>非平衡二叉树</strong></h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-07b3c6b4c4d2d524555fb739bf599981_720w.webp" alt="img"></p><p>高度差已经大于1 了。平衡树解决的问题就是 能够最大限度的增加访问的每个节点的的平均性。保证每个节点被访问的次数平衡。</p><h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a><strong>完全二叉树</strong></h5><p>除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-db8cdc6ff692f73cb4984ff80e45ef34_720w.webp" alt="img"></p><p>堆排序 结构其实就是一个完全二叉树的结构，倒序和正序就是用的 大根堆 小根堆的原理。</p><h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a><strong>满二叉树</strong></h5><p>每个节点是叶节点或者度为2.</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-c24507d5ab42fa1a9de508aea129bacc_720w.webp" alt="img"></p><h5 id="二叉搜索树（Binary-Search-Tree）"><a href="#二叉搜索树（Binary-Search-Tree）" class="headerlink" title="二叉搜索树（Binary Search Tree）"></a><strong>二叉搜索树（Binary Search Tree）</strong></h5><p>特点是每个根节点大于左子树上的任意一个节点，小于等于右子树上的任意一个节点。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-bc1985e7abdd4871d0d0709f02a64725_720w.webp" alt="img"></p><p>可以利用二叉搜索树的大小关系，有点类似于二分查找。二叉搜索树查询的时间复杂度为O(logn)，因为每次查找都能将范围缩小一半。</p><p><strong>二叉搜索树的不足：</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-b43c0ec9893114064c891d5b3b2ee383_720w.webp" alt="img"></p><p>极端的二叉搜索树：如果二叉搜索树每个节点都只有左节点或者都只有右节点，那么这颗树就会降级为链表结构，使得时间复杂度为O(n),所以引出了平衡排序树(AVL树).</p><h5 id="平衡二叉搜索树（AVL树）"><a href="#平衡二叉搜索树（AVL树）" class="headerlink" title="平衡二叉搜索树（AVL树）"></a>平衡二叉搜索树（AVL树）</h5><p><strong>特点</strong></p><ul><li>任意节点的左右子树的高度差都小于等于1</li><li>常见的平衡树包括B树（MySQL中的索引），AVL树等</li></ul><p><strong>平衡二叉搜索树能同时满足平衡树和二叉搜索树的特点：</strong></p><ul><li>优点：AVL树可以有效减少二叉树的深度，从而提升查询的效率。</li><li>缺点：AVL树为了达到平衡（任意节点的左右子树的高度差都小于等于1，这属于<strong>绝对平衡</strong>，维持起来并不容易），需要付出额外代价。在插入和删除操作时，AVL树都需要进行再平衡。</li></ul><p>所以AVL树还有待改进——红黑树。</p><table><thead><tr><th>平衡二叉树类型</th><th>平衡度</th><th>调整频率</th><th>适用场景</th></tr></thead><tbody><tr><td>AVL树</td><td>高</td><td>高</td><td>查询多，增&#x2F;删少</td></tr><tr><td>红黑树</td><td>低</td><td>低</td><td>增&#x2F;删频繁</td></tr></tbody></table><hr><h5 id="红黑树（R-B树）"><a href="#红黑树（R-B树）" class="headerlink" title="红黑树（R-B树）"></a>红黑树（R-B树）</h5><p>红黑树是一种特化的AVL树，查询与AVL树基本相同，在插入和删除时通过特定操作保持二叉搜索树的<strong>相对平衡</strong>（红黑树与AVL树不同，AVL是绝对平衡）， 因为这种相对平衡的条件，红黑树在插入和删除时，对于树的调整的频率低于AVL树，对于树的旋转的次数也比AVL树少，从而获得较高的性能。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-d5a84583be75cd748b2a979e27a911ec_720w.webp" alt="img"></p><p><strong>由图可以看出红黑树不是严格的AVL树，只是黑色平衡</strong></p><p><strong>红黑树的特点</strong>：</p><ol><li><strong>首先必须满足二叉搜索树</strong></li><li><strong>节点非黑即红</strong></li><li><strong>根节点是黑色的，叶子节点是黑色的（都是空节点，为了简单起见，红黑树一般会省略叶子结点）</strong></li><li><strong>相邻父子节点不能同为红色，每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。</strong>）</li><li><strong>从一个节点到该节点的叶子结点的所有路径上包含的黑节点数量相等（这是平衡关键）</strong></li></ol><p><strong>红黑树特点总结成一句口诀：黑根黑叶红不邻，通祖等高只数黑</strong></p><p><strong>红黑树相关定理</strong></p><ol><li>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</li></ol><p>要满足从根节点到叶节点每条路径的黑色节点数量一致。最短路径：全是黑色 最长路径：黑红相间</p><p>对于给定的黑色高度为n的红黑树，从根结点到叶结点的简单路径的最短长度为n-1，最大长度为2(n-1)，从这一点我们可以看出红黑树是 大致平衡的。(当然比平衡二叉树要差一些，AVL的平衡因子最多为1)</p><ol start="2"><li>红黑树的树高(h)不大于两倍的红黑树的黑深度(bd)，即h&lt;&#x3D;2bd</li></ol><p>根据定理1，我们不难说明这一点。bd是红黑树的最短路径长度。而可能的最长路径长度(树高的最大值)就是红黑相间的路径，等于2bd。因此h&lt;&#x3D;2bd。</p><ol start="3"><li>一棵拥有n个内部结点(不包括叶子结点)的红黑树的树高h&lt;&#x3D;2log(n+1)</li></ol><p>下面我们首先证明一颗有n个内部结点的红黑树满足n&gt;&#x3D;2^bd-1。这可以用数学归纳法证明，施归纳于树高h。当h&#x3D;0时，这相当于是一个叶结点，黑高度bd为0，而内部结点数量n为0，此时0&gt;&#x3D;2^0-1成立。假设树高h&lt;&#x3D;t时，n&gt;&#x3D;2^bd-1成立，我们记一颗树高 为t+1的红黑树的根结点的左子树的内部结点数量为nl，右子树的内部结点数量为nr，记这两颗子树的黑高度为bd’（注意这两颗子树的黑高度必然一 样），显然这两颗子树的树高&lt;&#x3D;t，于是有nl&gt;&#x3D;2^bd’-1以及nr&gt;&#x3D;2^bd’-1，将这两个不等式相加有nl+nr&gt;&#x3D;2^(bd’+1)-2，将该不等式左右加1，得到n&gt;&#x3D;2^(bd’+1)-1，很显然bd’+1&gt;&#x3D;bd，于是前面的不等式可以 变为n&gt;&#x3D;2^bd-1，这样就证明了一颗有n个内部结点的红黑树满足n&gt;&#x3D;2^bd-1。</p><p>在根据定理2，h&lt;&#x3D;2bd。即n&gt;&#x3D;2^(h&#x2F;2)-1，那么h&lt;&#x3D;2log(n+1)</p><p>从这里我们能够看出，红黑树的查找长度最多不超过2log(n+1)，因此其查找时间复杂度也是O(log N)级别的。</p><p><strong>红黑树的复杂度分析</strong></p><ul><li><p>一棵含有n个节点（内部节点，不包含空的叶子节点）的红黑树的高度至多为2log(n+1)</p></li><li><p>查找时间复杂度为O(logn),红黑树上的查找操作与普通二叉查找树上的查找操作相同</p></li><li><p>插入时间复杂度为O(1)+O(logn)</p></li><li><p>删除时间复杂度为O(1)+O(logn)</p></li></ul><p><strong>AVL vs 红黑树</strong></p><ul><li>插入：AVL和红黑树都是最多两次旋转实现复衡，旋转的量级是O(1)，恢复红黑树的属性需要O(log n)的颜色变更</li><li>删除：AVL旋转的量级是O(logn)，红黑树最多旋转3次实现复衡只要O(1)</li><li>红黑树插入和删除效率更高，AVL的查找效率更高.</li><li>红黑树成本较低，AVL成本较高</li></ul><p><strong>两者没有谁好谁坏，关键看使用场景</strong></p><p><strong>红黑树的实际应用</strong></p><ul><li><strong>Java中的HashMap、TreeMap、TreeSet等</strong></li></ul><p><strong>红黑树的基本操作</strong></p><p><strong>查找节点（二叉搜索树一样的查找）</strong></p><ol><li>选择根节点作为当前节点</li><li>按照二叉搜索树特点进行循环查找（若值与当前节点值相等，则返回该节点；若值小于当前节点，左节点作为当前节点；否则，右节点作为当前节点）</li><li>未找到，为null</li></ol><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-f90edcb09cc58e310e2047ba8d6af772_720w.webp" alt="img"></p><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>[B+ 树搜索时间复杂度到底是什么：mlogmN &#x2F; logN？ - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/402951">https://zhuanlan.zhihu.com/p/402951</a></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231023104558443.png" alt="image-20231023104558443"></p><p>第一种，按照B+树数据结构来算，要访问节点数 * 节点内的搜索时间复杂度，其中节点内搜索时间有线性查找、二分查找两种</p><p>第二种：</p><p>说一个结论：非叶子节点的大小 &#x3D; 页大小。下面是证明</p><blockquote><p>B+ 树在搜索过程中，需要从磁盘IO来读取节点的数据。我们知道磁盘IO一次读取的数据大小为一页。</p><ul><li>非叶子节点的大小 &gt; 页大小：那么意味着搜索过程中，为了获取一个完整节点来查找数据，我们需要多次IO来获取这个节点，这显然非常消耗时间。所以非叶子节点的大小不能超过一页。</li><li>非叶子节点的体积非常小：这就意味着B+树的分叉就少，B+树的总节点数会变多、深度变大。B+树利用指针构成的树形结构，意味着每个节点在磁盘上是不连续的，B+树的深度变大了，意味着搜索时访问的节点数量变多，IO次数也变多了。</li><li>因此，非叶子节点过大、过小，都会导致IO次数增加。所以最合适的非叶子节点大小 &#x3D; 页大小。</li></ul></blockquote><p>因为</p><p>1 B+树的节点，即非叶子节点大小 &#x3D; 页大小</p><p>2 读取一页需要一次IO</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231023105000623.png" alt="image-20231023105000623"></p><h4 id="有哪些线程安全的容器？"><a href="#有哪些线程安全的容器？" class="headerlink" title="有哪些线程安全的容器？"></a>有哪些线程安全的容器？</h4><h5 id="不可变类："><a href="#不可变类：" class="headerlink" title="不可变类："></a>不可变类：</h5><ul><li>String：String的各个substring、replace、reverse 等方法都是重新new一个String对象，不会改变源对象，而且用final修饰，不会有子类覆盖String的方法，不会出现线程安全问题</li><li>Integer 类似String</li><li>Random 类似String</li></ul><h5 id="遗留的线程安全集合"><a href="#遗留的线程安全集合" class="headerlink" title="遗留的线程安全集合"></a>遗留的线程安全集合</h5><ul><li>StringBuﬀer 对方法加上了synchronized锁，保证线程安全，但是效率比StringBuilder低一些</li><li>Vector 每个方法都加上了synchronized 关键字，串行化执行，效率低下。而且多线程下组合调用这些方法还是会出现线程不安全。</li><li>Hashtable： 每个方法都加上了synchronized 关键字，串行化执行，效率低下。而且多线程下组合调用这些方法还是会出现线程不安全。</li></ul><h5 id="经过修饰的线程安全的集合"><a href="#经过修饰的线程安全的集合" class="headerlink" title="经过修饰的线程安全的集合"></a>经过修饰的线程安全的集合</h5><ul><li>synchronizedList 、synchronizedMap 、 synchronizedSet等等， 把不安全的list、map、set等作为构造的参数， 其方法使用synchronized(mutex) {map.get();} 使用的还是原本集合中的方法，但是通过synchronized和信号量来实现同步</li></ul><h5 id="java-util-concurrent-包下的类"><a href="#java-util-concurrent-包下的类" class="headerlink" title="java.util.concurrent 包下的类"></a>java.util.concurrent 包下的类</h5><ul><li><p>concurrentHashMap。</p></li><li><p>BlockingQueue的实现类:阻塞队列（<code>BlockingQueue</code>）被广泛使用在“生产者-消费者”问题中，其原因是 <code>BlockingQueue</code> 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p></li><li><p>copyOnWriteArrayList: <code>CopyOnWriteArrayList</code> 中的读取操作是完全无需加锁的。更加厉害的是，写入操作也不会阻塞读取操作，只有写写才会互斥。这样一来，读操作的性能就可以大幅度提升。</p></li></ul><p>线程安全的类不一定能保证线程安全，只能保证单个方法执行是线程安全的，但是多个方法的组合还是会出现不安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">concurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.get(str);</span><br><span class="line"><span class="comment">//在此处时间片结束，线程不安全</span></span><br><span class="line">map.put(str,count == <span class="number">0</span> : <span class="number">1</span> ? count + <span class="number">1</span>);;</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="CopyOnWriteArrayList详情"><a href="#CopyOnWriteArrayList详情" class="headerlink" title="CopyOnWriteArrayList详情"></a>CopyOnWriteArrayList详情</h4><p><code>CopyOnWriteArrayList</code> 线程安全的核心在于其采用了 <strong>写时复制（Copy-On-Write）</strong> 的策略，<strong>采用读写分离的思想</strong></p><p>当需要修改（ <code>add</code>，<code>set</code>、<code>remove</code> 等操作） <code>CopyOnWriteArrayList</code> 的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将原容器的引用指向新的容器，这样就可以保证写操作不会影响读操作了。</p><ul><li>在修改数组时(add、remove、set),需要先获取锁，实现多线程写同步</li><li>读的时候不需要加锁，如果读的时候多个线程正在修改数据，读操作还是会读到旧的数据，因为在读的那一刻就已经确定了读的对象是旧对象。</li></ul><p><strong>适用于读多写少的并发场景</strong>：如白名单、黑名单、商品类目的访问和变更等</p><p><strong>缺点</strong></p><p><strong>内存占用问题</strong>。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p><p>　　针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如<a href="http://ifeve.com/concurrenthashmap/">ConcurrentHashMap</a>。</p><p>　　<strong>数据一致性问题</strong>。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p><h4 id="线程不安全的集合"><a href="#线程不安全的集合" class="headerlink" title="线程不安全的集合"></a>线程不安全的集合</h4><ul><li>HashMap</li><li>HashSet</li><li>ArrayList:put方法中，elementData[size++] &#x3D; e，不是一个原子操作</li><li>LinkedList:add方法可能出现指针指向错误节点</li></ul><h4 id="List、Map、Set能不能存NULL？"><a href="#List、Map、Set能不能存NULL？" class="headerlink" title="List、Map、Set能不能存NULL？"></a>List、Map、Set能不能存NULL？</h4><h5 id="List-——-允许为null"><a href="#List-——-允许为null" class="headerlink" title="List —— 允许为null"></a><strong>List —— 允许为null</strong></h5><ul><li>ArrayList底层是数组，可以添加null</li><li>LinkedList底层是双向链表，可以node.value &#x3D; null</li><li>Vector底层是数组，可以存储NULL</li></ul><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h5><ul><li>HashMap只允许有一个key为null的节点，因为Map的key相同，后面节点会替换相同key的节点，可以有多个value为null的节点，当key为null，计算出的hash值为0，放在第一个桶中。可以有多个value为null的节点，这是因为 HashMap 的设计是给单线程使用的，所以如果查询到了 null 值，我们可以通过 hashMap.containsKey(key) 的方法来区分这个 null 值到底是存入的 null？还是压根不存在的 null？这样二义性问题就得到了解决，所以 HashMap 不怕二义性问题。</li><li>TreeMap会调用compareTo方法，当对象为null，会报空指针</li><li>HashTable底层为散列表，需要对value进行判空，会调用key.hashCode()来计算桶的位置，key和value都不能为空。</li></ul><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h5><ul><li>HashSet底层是HashMap，可以有一个key为NULL的元素。</li><li>LinkedHashSet底层也是HashMap，允许一个key为NULL</li><li>TreeSet底层是TreeMap，底层是红黑树，需要对节点的value进行比对排序，不能有key为null的元素</li></ul><h4 id="ConcurrentHashMap为什么key和value都不能存入null？"><a href="#ConcurrentHashMap为什么key和value都不能存入null？" class="headerlink" title="ConcurrentHashMap为什么key和value都不能存入null？"></a>ConcurrentHashMap为什么key和value都不能存入null？</h4><p>从代码层面来看：ConcurrentHashMap在put方法的起始位置就判断Key和Value是否为空，如果是就抛出空指针异常。</p><p><code>ConcurrentHashMap</code> 的 key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，表示没有对象或没有引用。（如果你用 null 作为键，那么你就无法区分这个键是否存在于 <code>ConcurrentHashMap</code> 中，还是根本没有这个键。）同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储<code>ConcurrentHashMap</code> 中的，还是因为找不到对应的键而返回的。</p><p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p><ul><li>值没有在集合中 ；</li><li>值本身就是 null。</li></ul><p>这也就是二义性的由来。</p><p>多线程环境下，存在一个线程操作该 <code>ConcurrentHashMap</code> 时，其他的线程将该 <code>ConcurrentHashMap</code> 修改的情况，所以无法通过 <code>containsKey(key)</code> 来判断否存在这个键值对，也就没办法解决二义性问题了。</p><p>与此形成对比的是，<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入 null 作为参数，就会返回 hash 值为 0 的位置的值。HashMap 的设计是给单线程使用的，所以如果取到 null（空） 值，我们可以通过HashMap 的 containsKey(key)方 法来区分这个 null（空） 值到底是插入值是 null（空），还是本就没有才返回的 null（空） 值。单线程环境下，不存在一个线程操作该 HashMap 时，其他的线程将该 <code>HashMap</code> 修改的情况，所以可以通过 <code>contains(key)</code>来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。</p><p>也就是说，多线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。</p><p>如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>举个例子，现在有线程 T1 调用了 ConcurrentHashMap 的 containsKey(key) 方法，<br>我们期望返回的结果是 false，也就是说，T1 并没有往 ConcurrentHashMap 中 put null（空）值。<br>但是，恰恰出了个意外，在线程 T1 还没有得到返回结果之前，线程 T2 又调用了<br>ConcurrentHashMap 的 put() 方法，插入了一个 Key，并且存入的 Value 是 null（空） 值。那么，线程 T1 最终得到的返回结果就变成 true 了。</p><h4 id="Map的遍历方式"><a href="#Map的遍历方式" class="headerlink" title="Map的遍历方式"></a>Map的遍历方式</h4><p>1）在 for 循环中使用 entries 实现 Map 的遍历（最常见和最常用的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;Java入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;C语言入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapKey</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapValue</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        System.out.println(mapKey + <span class="string">&quot;：&quot;</span> + mapValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）使用 for-each 循环遍历 key 或者 values，一般适用于只需要 Map 中的 key 或者 value 时使用。性能上比 entrySet 较好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Java入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;C语言入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line"><span class="comment">// 打印键集合</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印值集合</span></span><br><span class="line"><span class="keyword">for</span> (String value : map.values()) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）使用迭代器（Iterator）遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Java入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;C语言入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;    </span><br><span class="line">    Entry&lt;String, String&gt; entry = entries.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;:&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）通过键找值遍历，这种方式的效率比较低，因为本身从键取值是耗时的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hash怎么扩容有了解吗？"><a href="#hash怎么扩容有了解吗？" class="headerlink" title="hash怎么扩容有了解吗？"></a>hash怎么扩容有了解吗？</h4><ul><li>HashMap的底层是采用数组来存储数据，当 HashMap 中元素个数超过（大于）临界值时会自动触发扩容，这个临界值有一个计算公式。</li><li>threashold&#x3D;loadFactor*capacity。loadFactor 的默认值是 0.75，capacity 的默认值是 16。当元素个数超过临界值就会触发Hash扩容（resize函数），默认扩容的大小是原来数组长度的 2 倍，HashMap 的最大容量是Integer.MAX_VALUE，也就是 2 的 31 次方-1。</li><li>然后会进行数据迁移，会伴随着一次重新 hash 分配（reHash),是非常耗时的，并且会遍历 hash 表中所有的元素，HasMap让容量为2的幂次方，就是方便数据迁移，元素的位置是  元素的hash&amp;（n - 1），此时n是全为1的二进制数，那么元素根据hash值的的位置要么不变，要么加上原来的长度, 底层的行为都是给 table 赋值一个两倍长度的新数组。</li></ul><h4 id="为什么扩容因子是-0-75？"><a href="#为什么扩容因子是-0-75？" class="headerlink" title="为什么扩容因子是 0.75？"></a>为什么扩容因子是 0.75？</h4><p>扩容因子表示 Hash 表中元素的填充程度，扩容因子的值越大，那么触发扩容的元素个数更多，<br>虽然空间利用率比较高，但是 hash 冲突的概率会增加。<br>扩容因子的值越小，触发扩容的元素个数就越少，也意味着 hash 冲突的概率减少，<br>但是对内存空间的浪费就比较多，而且还会增加扩容的频率。<br>因此，扩容因子的值的设置，本质上就是在 冲突的概率 以及 空间利用率之间的平衡。<br>0.75 这个值的来源，和统计学里面的泊松分布有关。</p><p>当扩容因子在 0.75 的时候，链表长度达到 8 的可能性几乎为 0，也就是比较好的达到了空间成本和时间成本的平衡。</p><h4 id="HashMap的Hash值如何计算"><a href="#HashMap的Hash值如何计算" class="headerlink" title="HashMap的Hash值如何计算"></a>HashMap的Hash值如何计算</h4><p> <strong>h &#x3D; (key.hashCode ()) ^ (key.hashCode()&gt;&gt;16)</strong>,让hashCode的高16位和低16位进行异或，这样可以让hash值得散列度更高，尽可能区减少hash冲突的情况，从而去提升数据查找性能。</p><h4 id="HashMap为什么一定大小要是2的幂次方？"><a href="#HashMap为什么一定大小要是2的幂次方？" class="headerlink" title="HashMap为什么一定大小要是2的幂次方？"></a>HashMap为什么一定大小要是2的幂次方？</h4><p>HashMap为了提高存取效率，减少hash冲突，就是要尽量把数据分配均匀，使得每个链表长度大致相同，就可以通过hash值 % 数组长度 来实现。<br>但直接取模运算的效率不如位运算&amp;，当容量为2的n次方时，hash &amp; (capacity - 1) &#x3D;&#x3D; hash % capacity，通过 hash &amp; (capacity - 1) 来替代取模运算，而前提就是容量必须为2的n次方。</p><h4 id="HashMap怎么解决hash冲突的"><a href="#HashMap怎么解决hash冲突的" class="headerlink" title="HashMap怎么解决hash冲突的"></a>HashMap怎么解决hash冲突的</h4><p>hash 冲突问题 : 也就是两个不同 hash 值的 key，最终&amp;运算会落到同一个数组下标。所以 HashMap 引入了链式寻址法来解决 hash 冲突问题， 对于存在冲突的key，HashMap 把这些 key 组成一个单向链表。然后采用尾插法把这个 key 保存到链表的尾部。另外，为了避免链表过长的问题，当链表长度大于 8 并且数组长度大于等于 64 的时候，HashMap 会把链表转化为红黑树,从而减少链表数据查询的时间复杂度问题，提升查询性能</p><p>解决 hash 冲突问题的方法有很多，比如</p><ul><li>再 hash 法，就是如果某个 hash 函数产生了冲突，再用另外一个 hash 进行计算，</li><li>开放寻址法，就是直接从冲突的数组位置往下寻找一个空的数组下标进行数据存储，(这个在 ThreadLocal 里面有使用到)。</li><li>建立公共溢出区，也就是把存在冲突的 key 统一放在一个公共溢出区里面。</li></ul><h4 id="为什么HashMap将链表转化为红黑树的阈值是8？"><a href="#为什么HashMap将链表转化为红黑树的阈值是8？" class="headerlink" title="为什么HashMap将链表转化为红黑树的阈值是8？"></a>为什么HashMap将链表转化为红黑树的阈值是8？</h4><p>这是因为在实践中，当链表中的元素数量达到8时，使用红黑树进行查找的效率会超过链表。具体来说，当链表中的元素数量为8时，平均查找长度为8&#x2F;2&#x3D;4。而红黑树的平均查找长度为log(8)，大约是3。因此，将链表转换为红黑树可以提高查找效率。</p><p>然而，红黑树并不是在所有情况下都比链表更优。当红黑树中的元素数量较少时，树结构的维护成本会变得相对较高。这是因为每次插入或删除元素，都可能需要调整树的平衡。因此，当红黑树中的元素数量减少到一定程度时，HashMap会将其转换回链表。在JDK 1.8的实现中，这个阈值是6。</p><p>为何选择6作为红黑树转换回链表的阈值呢？这是因为在实践中，当红黑树中的元素数量小于等于6时，使用链表进行查找的效率会超过红黑树。具体来说，当红黑树中的元素数量为6时，平均查找长度为log(6)，大约是2.58。而链表的平均查找长度为6&#x2F;2&#x3D;3。因此，将红黑树转换回链表可以提高效率。 同时，选择6相比于7和8能避免频繁发生链表和红黑树的转换，造成大量性能消耗</p><h4 id="HashMap在多线程情况下会产生哪些问题？会产生死锁吗？"><a href="#HashMap在多线程情况下会产生哪些问题？会产生死锁吗？" class="headerlink" title="HashMap在多线程情况下会产生哪些问题？会产生死锁吗？"></a>HashMap在多线程情况下会产生哪些问题？会产生死锁吗？</h4><ul><li>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</li><li>为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题。并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</li></ul><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><ul><li><p>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。</p><p>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。</p><p>随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</p></li><li><p>还有一种情况是这两个线程同时 <code>put</code> 操作导致 <code>size</code> 的值不正确，进而导致数据覆盖的问题：</p><ol><li>线程 1 执行 <code>if(++size &gt; threshold)</code> 判断时，假设获得 <code>size</code> 的值为 10，由于时间片耗尽挂起。</li><li>线程 2 也执行 <code>if(++size &gt; threshold)</code> 判断，获得 <code>size</code> 的值也为 10，并将元素插入到该桶位中，并将 <code>size</code> 的值更新为 11。</li><li>随后，线程 1 获得时间片，它也将元素放入桶位中，并将 size 的值更新为 11。</li><li>线程 1、2 都执行了一次 <code>put</code> 操作，但是 <code>size</code> 的值只增加了 1，也就导致实际上只有一个元素被添加到了 <code>HashMap</code> 中。</li></ol></li></ul><h4 id="说一说HashMap-get元素的完整流程"><a href="#说一说HashMap-get元素的完整流程" class="headerlink" title="说一说HashMap get元素的完整流程"></a>说一说HashMap get元素的完整流程</h4><p>先计算key的hashcode值，然后计算key的hash值，通过（n - 1） &amp; hash 找到对应的桶的位置。</p><ul><li><p>如果位置上没有结点，直接返回null。</p></li><li><p>有结点，判断头结点的hash值是否等于key的hash值</p><ul><li><p>hash值相等，继续用 “&#x3D;&#x3D;” 和equals（）判断key是否相等，相等就返回</p></li><li><p>hash值不相等，遍历整个链表或者红黑树结点，还是判断hash值和key是否相等</p></li><li><p>头结点hash值 &lt; 0, 说明map正在扩容，需要到新的table中用一个 find() 方法去查找</p></li></ul></li></ul><h4 id="说一说HashMap-put元素的完整流程"><a href="#说一说HashMap-put元素的完整流程" class="headerlink" title="说一说HashMap put元素的完整流程"></a>说一说HashMap put元素的完整流程</h4><ol><li>根据key的hashcode 获得hash值（hashcode ^ (hashcode  &gt;&gt;&gt; 16)),也就是高十六位与低十六位进行异或运算</li><li>通过hash &amp; (n - 1) 找到对应桶的位置</li><li>如果桶为空，就直接put</li><li>如果桶不为空就遍历桶中所有元素，通过比较hashcode –&gt; “&#x3D;&#x3D;”判断 –&gt;equals 判断是否已存在，存在就更新value值， 不存在，就插入，size++     </li><li>判断是否需要转化为红黑树，是否需要扩容</li></ol><h4 id="ConcurrentHashMap为什么能保证线程安全？"><a href="#ConcurrentHashMap为什么能保证线程安全？" class="headerlink" title="ConcurrentHashMap为什么能保证线程安全？"></a>ConcurrentHashMap为什么能保证线程安全？</h4><p>添加元素时首先会判断容器是否为空，</p><ul><li><p>如果为空则使用 volatile 加 CAS 来初始化，防止多个线程同时初始化，造成并发问题，</p></li><li><p>如果容器不为空，则根据存储的元素计算该位置是否为空。</p><ul><li><p>如果根据存储的元素计算结果桶为空，则利用 CAS 设置该节点，避免并发冲突；</p></li><li><p>如果根据存储的元素计算桶为空不为空，则使用 synchronized 锁住这个桶链表的头结点，然后，遍历桶中的数据，根据hash值与key，更新或新增节点到桶中，</p></li><li><p>如果桶中头结点的hash值为 MOVED（-1），就说明map正在进行扩容，此时会锁住这个桶中的链表来帮助扩容，避免扩容的并发问题，等待扩容完成再put入新的table</p></li><li><p>最后再判断是否需要转为红黑树。这样就能保证并发访问时的线程安全了。</p></li></ul></li></ul><p>设置多个累加单元来计算size()的值，防止并发下计数错误。</p><ul><li>当线程竞争不激烈时，直接采用 CAS 对baseCount操作实现元素个数的原子递增。</li><li>如果线程竞争激烈，使用一个数组来维护元素个数，如果要增加总的元素个数，则直接从数组中随机选择一个，再通过 CAS 实现原子递增，之后遍历数组中所有的值与baseCount累加。它的核心思想是引入了数组来实现对并发更新的负载。</li></ul><p>总结： ConcurrentHashMap 通过<strong>对数组头结点加锁</strong>和<strong>加CAS的初始化</strong>来保证线程安全的。</p><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p><strong>特点</strong></p><ul><li>PriorityQueue 的底层是堆，堆的底层是数组</li><li>PriorityQueue中放置的元素必须要能够比较大小 （只有实现了 Comparable 和 Comparator 接口的类才能比较大小），不能插入无法比较大小的对象，否则会抛出 ClassCastException 异常</li><li>不能插入 null 对象，否则会抛出 NullPointerException 异常</li><li>没有容量限制，可以插入任意多个元素，其内部可以自动扩容</li><li>插入和删除元素的时间复杂度均为 O(log2N)</li><li>PriorityQueue底层使用了堆数据结构</li></ul><p>插入&#x2F;删除&#x2F;获取优先级最高的元素</p><table><thead><tr><th align="left">函数名</th><th>功能介绍</th></tr></thead><tbody><tr><td align="left">boolean offer(E e)&#x2F;add()</td><td>插入元素 e，插入成功返回 true，如果 e 对象为空，抛出 NullPointerException 异常，时间复杂度为 O(log2N) ，注意：空间不够时会自动扩容</td></tr><tr><td align="left">E peek()&#x2F;element()</td><td>获取优先级最高的元素，如果优先级队列为空，返回 null</td></tr><tr><td align="left">E poll()&#x2F;remove()</td><td>移除优先级最高的元素并返回，如果优先级队列为空，返回 null</td></tr><tr><td align="left">int size()</td><td>获取有效元素的个数</td></tr><tr><td align="left">void clean()</td><td>清空</td></tr><tr><td align="left">boolean isEmpty()</td><td>检测优先级队列是否为空，空返回 true</td></tr></tbody></table><h4 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h4><p>前提知识：二叉树的顺序存储<br>使用数组存储二叉树的方式，就是将二叉树按照层序遍历放入数组<br>一般只适合完全二叉树，因为非完全二叉树会有空间的浪费<br>这种方式的主要用法就是堆的表示</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知双亲(parent)的下标</span><br><span class="line">左孩子(left)下标 = 2 * parent + 1;</span><br><span class="line">右孩子(right)下标 = 2 * parent + 2;</span><br><span class="line">已知孩子（不区分左右）(child)下标</span><br><span class="line">双亲(parent)下标 = (child - 1) / 2;</span><br></pre></td></tr></table></figure><p><strong>1、概念</strong><br>概括：堆就是一颗顺序存储的完全二叉树，底层是一个数组</p><p>堆逻辑上是一颗完全二叉树</p><p>堆物理上是保存在数组中</p><p>堆满足任意结点的值都大于其子树中结点的值，也就是所有根节点 &gt; 其左右孩子结点，叫做大堆，或者大根堆、最大堆</p><p>反之则是小堆，或者小根堆、最小堆</p><p>堆的基本作用是快速找到集合中的最值</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70-1710494617676-3.png" alt="img"></p><p><strong>2、性质</strong></p><ul><li>堆中某个节点的值总是不大于或不小于其父结点的值</li><li>堆总是一颗完全二叉树</li></ul><p><strong>3、向下调整</strong></p><p>找左右孩子最大值，然后和父亲结点进行交换</p><p><strong>4、建堆</strong></p><p>这里我们从倒数的第一个非叶子节点的子树开始调整，一直调整到根节点的树，就可以调整成堆。</p><p>具体做法就是，从最后一个非叶子结点子树开始，比较左右孩子结点，较大的孩子结点和父亲结点比较，比父亲结点大的话就进行交换，直到这棵子树已经成了一个堆<br>    <img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70-1710494806954-6.jpeg" alt="img"></p><p><strong>插入一个元素</strong></p><ul><li><strong>过程（以大堆为例）：</strong></li></ul><ol><li>首先按尾插方式放入数组（空间不够时需要扩容）</li><li>比较其和其双亲的值的大小，如果双亲的值大，则满足堆的性质，插入结束</li><li>否则，交换其和双亲位置的值，重新进行 2、3 步骤（2、3就是向上调整的过程）</li><li>直到根结点</li></ol><ul><li><p><strong>图示</strong><br><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70-1710494847608-9.jpeg" alt="在这里插入图片描述"><br>是一个向上调整的过程</p><p><strong>删除一个元素</strong></p><p>为了防止破坏堆的结构，删除时并不是直接将堆顶元素删除，而是</p><ol><li>用数组的最后一个元素替换堆顶元素 ，usedSize–</li><li>然后从堆顶<strong>0号位置</strong>下标的元素开始，通过<strong>向下调整</strong>方式重新调整成堆<br><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70-1710494869532-12.jpeg" alt="在这里插入图片描述"></li></ol></li></ul><p>​</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h4><p>面向过程：把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。</p><p>面向对象：将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p><p>好处：</p><p><strong>易扩展</strong>：由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，增加或修改业务时，只需要改变小部分代码，使得系统更灵活、更容易扩展，而且成本较低。</p><p><strong>代码复用率高</strong>：可重用现有的已被测试过的类使系统满足业务需求并具有较高的质量。</p><p><strong>效率高</strong>：根据设计的需要对现实世界的事物进行抽象，产生类。使用这样的方法解决问题，接近于日常生活和自然的思考方式，势必提高软件开发的效率和质量。</p><h4 id="Java-基础有哪些核心模块"><a href="#Java-基础有哪些核心模块" class="headerlink" title="Java 基础有哪些核心模块"></a>Java 基础有哪些核心模块</h4><p>这里简单对我觉得 Java 基础比较核心的模块做一下总结：</p><ul><li><strong>异常</strong>：定义了 Java 运行中可能出现的异常，提供了异常处理手段。</li><li><strong>泛型</strong>：使用泛型参数，可以增强代码的可读性以及稳定性。</li><li><strong>反射</strong>：赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</li><li><strong>注解</strong>：可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</li><li><strong>集合</strong>：Java 集合，也叫作容器，可以用于保存数据，主要分为 List, Set, Queue, Map 四大类，这四类分别由不同的用途。</li><li><strong>IO 流</strong>：用于处理输入和输出，比如文件读写。</li><li><strong>多线程</strong>：除了 <code>Thread</code> 类和 <code>Runnable</code> 接口这些基础外，最重要的就是 JUC 了，这个包中包含并发编程中很常用的实用工具类，包括线程池、异步 IO、各种锁等等。</li></ul><h4 id="Java三大特性"><a href="#Java三大特性" class="headerlink" title="Java三大特性"></a>Java三大特性</h4><p><strong>封装</strong></p><blockquote><p>封装指的是属性和方法私有化，根据需要提供setter和getter方法来访问属性。即隐藏具体属性和实现细节，仅对外开放接口，控制程序中属性的访问级别。</p><p>封装目的：增强安全性和简化编程，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员与方法。</p></blockquote><p><strong>继承</strong></p><blockquote><p>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，使用extends关键字实现继承；子类中可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。</p><p>• 继承的出现减少了代码冗余，提高了代码的复用性。<br>• 继承的出现，更有利于功能的扩展。<br>• 继承的出现让类与类之间产生了的关系，为多态的使用提供了前提。</p></blockquote><p><strong>多态</strong></p><blockquote><p>多态就是在声明时使用父类，在实现或调用时使用具体的子类；即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态。</p><p>在 Java 中的体现：父类的引用指向子类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure><p><strong>多态的条件：</strong></p><p><strong>继承</strong>: 在多态中必须存在有继承关系的子类和父类。</p><p><strong>方法重写</strong>: 子类对父类中某些方法进行重新定义,在调用这些方法时就会调用子类的方法。</p><p><strong>向上转型</strong>: 在多态中需要将子类的引用赋给父类对象,只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p></blockquote><blockquote><p>好处：父类变量引用的子类对象不同，执行的方法就不同，实现动态绑定。代码编写更灵活、功能更强大，可维护性和扩展性更好了。<br>弊端：一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法（父类中没有的属性和方法）。</p></blockquote><h4 id="抽象类接口什么不同"><a href="#抽象类接口什么不同" class="headerlink" title="抽象类接口什么不同"></a>抽象类接口什么不同</h4><p><strong>抽象类</strong>：在Java中被abstract关键字修饰的类称为抽象类，被abstract关键字修饰的方法称为抽象方法，抽象方法只有方法的声明，没有方法体。抽象类的特点：</p><p>a、抽象类不能被实例化只能被继承；</p><p>b、包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法，抽象类中可以包含普通方法；</p><p>c、抽象类中的抽象方法的修饰符只能为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），默认为public；</p><p>d、一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类；</p><p>e、抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。</p><p>*<strong>接口*：</strong>Java中接口使用interface关键字修饰，特点为:</p><p>a、接口可以包含变量、方法；变量被隐式指定为public static final，方法被隐式指定为public abstract（JDK1.8之前）；</p><p>b、接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题；</p><p>c、一个类可以实现多个接口；</p><h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a><strong>相同点</strong></h5><p>（1）都不能被实例化 （2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。</p><h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a><strong>不同点</strong></h5><p>（1）接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现（普通方法），方法可在抽象类中实现。</p><p>（2）实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</p><p>（3）接口强调特定功能的实现，而抽象类强调所属关系。</p><h4 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h4><p>深拷贝和浅拷贝是只针对引用数据类型的</p><p><strong>引用拷贝</strong>: 引用拷贝就是直接赋值，只在栈中创建一个新的引用，拷贝引用的地址，所以指向的是堆中同一个对象。</p><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），这个对象有着原始对象属性值的一份精确拷贝。如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。深拷贝会递归拷贝对象所有层级的对象属性和数组元素。深拷贝相比于浅拷贝速度较慢并且花销较大。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111716166.png" alt="image-20231003111716166"></p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111721557.png" alt="image-20231003111721557" style="zoom:150%;" /><h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><p>序列化核心目的是为了解决网络通信之间的对象传输问题。<br>也就是说，如何把当前 JVM 进程里面的一个对象，跨网络传输到另外一个 JVM进程里面。<br>序列化：把内存里面的<strong>对象转化为字节流</strong>，以便用来<strong>实现存储或者传输</strong>。<br>反序列化：根据从<strong>文件或者网络上获取到的对象的字节流</strong>，根据字节流里面保存的<strong>对象描述信息和状态</strong>，重新构建一个新的对象。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111810871.png" alt="image-20231003111810871"></p><p>其次呢，序列化的前提是保证通信双方对于对象的可识别性，所以很多时候，我们会把对象先转化为通用的解析格式，比如 json、xml 等。然后再把他们转化为字节流进行网络传输，从而实现跨平台和跨语言的可识别性。</p><h4 id="Java反射有了解吗？举几个Java反射的应用案例"><a href="#Java反射有了解吗？举几个Java反射的应用案例" class="headerlink" title="Java反射有了解吗？举几个Java反射的应用案例"></a>Java反射有了解吗？举几个Java反射的应用案例</h4><p>反射是java语言的一个特性，<strong>反射功能通常用于检查或修改Java虚拟机运行中（runtime）的应用程序的行为</strong>,它允程序在运行时（注意不是编译的时候），获取任意一个类的成员变量、成员方法和属性,调用任意一个对象的方法和属性,，这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p><ul><li>获取任意类的名称、package信息、所有属性、方法、注解、类型、类加载器等</li><li>获取任意对象的属性，并且能改变对象的属性</li><li>调用任意对象的方法</li><li>判断任意一个对象所属的类</li><li>实例化任意一个类的对象</li><li>通过反射我们可以实现动态装配，降低代码的耦合度,动态代理等。</li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>可以增加程序的灵活性，在运行过程中可以动态对类进行修改和操作</li><li>提高代码复用率，比如动态代理</li><li>可以在运行时轻松获取任意一个类的方法、属性、并且还能通过反射进行动态调用</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>使用反射后，可读性较差</li><li>反射可以绕过一些限制访问的属性和方法，可能会导致一些安全性问题</li><li>反射会涉及动态类型的解析，所以JVM无法对这些代码进行优化，导致性能要比非反射调用更低</li></ul><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>AOP动态代理的场景中，使用动态生成的代理类来提升代码复用性。</li><li>IOC：组件扫描后，用反射来实例化bean对象等</li></ul><h5 id="反射的原理"><a href="#反射的原理" class="headerlink" title="反射的原理"></a>反射的原理</h5><p>通常，java在编译之后，会将Java代码生成为class源文件，JVM启动时，将会载入所有的源文件，并将类信息存放到方法区中；将所有对象实例存放在Java堆中，同时也会保存指向类型信息的指针。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rad5bGx6YGT5aOr,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>以下分两种情况来分析，直接使用类和使用反射的区别，以此理解反射的实现原理。</p><p><strong>直接使用类</strong><br>正常流程下，我们要创建一个类的实例，是一定确定这个类的类型信息的，我们知道这个类的名字、方法、属性等等。我们可以很容易的创建实例，也可以通过实例很容易的获取属性、调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br></pre></td></tr></table></figure><p><strong>使用反射</strong><br>在一个方法中，如果我们不知道在实际运行（runtime）时，它将要处理的对象是谁，它的类型信息是怎么样的，那我们如何访问这个对象或为这个对象创建一个新的实例呢？</p><p>与直接使用类相反，我们需要<strong>先获取到对象在方法区的类型信息</strong>（通过实例对象的getClass方法、全限定类名等限定条件），获取到类型信息后，我们就知道这个类的构造器、属性、方法、注解、子类、父类等等信息了，这个时候，<strong>我们就可以通过这些类型信息来回调处理对象，来完成自己想要的操作了。</strong></p><p><strong>反射在运行时，通过读取方法区中的字节码，来动态的找到其反射的类以及类的方法和属性等（实际上就是在运行时，根据全类型名、对象的getClass()等，在方法区找对应的类）</strong>，用这些类型信息完成对该类实例的操作，其实就是直接使用类的一个逆向使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">void</span> <span class="title function_">reflectMethod</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理这个无法明确类型的实例对象</span></span><br><span class="line">        <span class="comment">// 获取类型信息</span></span><br><span class="line">        Class&lt;?&gt; aClass = obj.getClass();</span><br><span class="line">        Field[] fields = aClass.getFields();</span><br><span class="line">        Method[] methods = aClass.getMethods();</span><br><span class="line">        Annotation[] annotations = aClass.getAnnotations();</span><br><span class="line">        Constructor&lt;?&gt;[] constructors = aClass.getConstructors();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = aClass.getInterfaces();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 操作属性或方法</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> fields[<span class="number">0</span>];</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> field.get(obj); <span class="comment">// 获取obj的属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在实际开发过程会遇到很多这种情况，譬如常用到的Bean属性工具类org.springframework.beans.BeanUtils.copyProperties(Object source, Object target)，在复制对象属性前，它是并不知道source、target这两个对象有什么属性的，那么这个工具类是如何完成属性复制呢？这里其实就用到了反射功能。可以简单了解下流程：</p><ul><li><p>获取target的类型</p></li><li><p>获取target类中属性、getter和setter方法</p></li><li><p>遍历target中的属性，查询source中是否有属性名相同且支持getter和setter的属性</p></li><li><p>通过source.getter.invoke方法读取值</p></li><li><p>最后通过target.setter.invoke(source.getter.invoke) 设置刚刚从source读取的值</p></li><li><p>循环遍历target所有属性后，就完成了整个属性的复制</p></li><li><p>这里只是一个简单的反射运用，感兴趣的可以看看源码</p></li></ul></blockquote><p><strong>总结</strong></p><ul><li><p>直接使用是在运行前就明确类型信息，然后在运行时根据这个类来操作对象；</p></li><li><p>而反射是运行时先拿到对象，根据对象得到方法区中的类型信息后，<strong>再根据属性、方法来操作该对象。</strong></p></li></ul><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p><strong>什么是代理模式</strong></p><p>定义：为其他对象提供一种代理以控制对这个对象的访问。</p><p>如果<strong>根据字节码的创建时机</strong>来分类，可以分为静态代理和动态代理：</p><ul><li>所谓<strong>静态</strong>也就是在<strong>程序运行前</strong>就已经存在代理类的<strong>字节码文件</strong>，代理类和真实主题角色的关系在运行前就确定了。</li><li>而动态代理的源码是在程序运行期间由<strong>JVM</strong>根据<strong>反射</strong>等机制<strong>动态的生成</strong>，所以在运行前并不存在代理类的字节码文件</li></ul><p><strong>静态代理</strong></p><p>我们先通过实例来学习静态代理，然后理解静态代理的缺点，再来学习本文的主角：动态代理</p><p>编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span>;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;查询 selectById&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新 update&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将通过静态代理对 UserServiceImpl 进行功能增强，在调用<code>select</code>和<code>update</code>之前记录一些日志。写一个代理类 UserServiceProxy，代理类需要实现 UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceProxy</span><span class="params">(UserService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        target.select();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        target.update();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;     <span class="comment">// 在执行方法之前执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log start time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;      <span class="comment">// 在执行方法之后执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log end time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userServiceImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceProxy</span>(userServiceImpl);</span><br><span class="line"></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br></pre></td></tr></table></figure><p>通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。</p><p>静态代理的缺点<br>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。</p><p>1、 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</p><ul><li>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致<strong>代理类过于庞大</strong>,方法过多</li><li>新建多个代理类，每个目标对象对应一个代理类，但是这样会<strong>产生过多的代理类</strong></li></ul><p>2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，<strong>不易维护。</strong></p><p><strong>动态代理就是让代理类动态的生成，最常见的就是使用反射实现</strong>，使用反射（依据被代理类、被代理类的所有接口、被代理类的ClassLoader）来加载代理类</p><p>&#x2F;&#x2F;动态代理：使⽤JDK提供的api（InvocationHandler、Proxy实现），此种⽅式实现，要求被代理类必须实现接⼝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayServiceJDKInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"><span class="comment">//⽬标对象即就是被代理对象</span></span><br><span class="line"><span class="keyword">private</span> Object target;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PayServiceJDKInvocationHandler</span><span class="params">( Object target)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//proxy代理对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"> <span class="comment">//1.安全检查</span></span><br><span class="line"> System.out.println(<span class="string">&quot;安全检查&quot;</span>);</span><br><span class="line"> <span class="comment">//2.记录⽇志</span></span><br><span class="line"> System.out.println(<span class="string">&quot;记录⽇志&quot;</span>);</span><br><span class="line"><span class="comment">//3.时间统计开始</span></span><br><span class="line">System.out.println(<span class="string">&quot;记录开始时间&quot;</span>);</span><br><span class="line"><span class="comment">//通过反射调⽤被代理类的⽅法</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"><span class="comment">//4.时间统计结束</span></span><br><span class="line">System.out.println(<span class="string">&quot;记录结束时间&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">PayService target= <span class="keyword">new</span> <span class="title class_">AliPayService</span>();</span><br><span class="line"><span class="comment">//⽅法调⽤处理器</span></span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PayServiceJDKInvocationHandler</span>(target);</span><br><span class="line"><span class="comment">//创建⼀个代理类：通过被代理类、被代理实现的接⼝、⽅法调⽤处理器来创建</span></span><br><span class="line"><span class="type">PayService</span> <span class="variable">proxy</span> <span class="operator">=</span> (PayService) Proxy.newProxyInstance(</span><br><span class="line">target.getClass().getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;PayService.class&#125;,handler);</span><br><span class="line">proxy.pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK动态代理</strong></p><p>从 UserServiceProxy 的代码中我们可以发现：</p><ul><li>UserServiceProxy 继承了 Proxy 类，并且实现了被代理的所有接口，以及equals、hashCode、toString等方法</li><li>由于 UserServiceProxy 继承了 Proxy 类，所以每个代理类都会关联一个 InvocationHandler 方法调用处理器</li><li>类和所有方法都被 <code>public final</code> 修饰，所以代理类只可被使用，不可以再被继承</li><li>每个方法都有一个 Method 对象来描述，Method 对象在static静态代码块中创建，以 <code>m + 数字</code> 的格式命名</li><li>调用方法的时候通过 <code>super.h.invoke(this, m1, args)</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 xxxHandler 对象，它继承 InvocationHandler 类，负责实际的调用处理逻辑</li></ul><p>而 LogHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，<strong>然后通过反射让被代理的对象 target 执行方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    before();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);       <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">    after();</span><br><span class="line">    <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以车站卖票的例子来看</strong></p><pre><code>1. 通过代理对象调用sell()方法2. 根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法3. 代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法，传入调用的方法以及参数4. invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法</code></pre><p>JDK动态代理执行方法调用的过程简图如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-776369e13e295f3c8e33489251bd4927_1440w.webp" alt="img"></p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="Error与Exception的区别"><a href="#Error与Exception的区别" class="headerlink" title="Error与Exception的区别"></a>Error与Exception的区别</h4><p>(1)Error类和Exception类都是继承Throwable类<br>(2)Error（错误）<strong>是系统中的错误</strong>，程序员是不能改变的和处理的，是在<strong>程序编译时出现的错误</strong>，只能通过修改程序才能修正。一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。<br>(3)Exception（异常）表示程序可以处理的异常，<strong>可以捕获且可能恢复</strong>。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。<br><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY5ODU2MQ==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><h4 id="异常顶层是什么，有哪些接口实现类"><a href="#异常顶层是什么，有哪些接口实现类" class="headerlink" title="异常顶层是什么，有哪些接口实现类"></a>异常顶层是什么，有哪些接口实现类</h4><p><strong>Java 异常类层次结构图概览</strong>：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640.png" alt="图片"></p><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong><code>Exception</code></strong>: 程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。</li><li>分为 Checked Exception 非运行时异常（编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义unchecked异常。通俗的话说，就是在写代码时出现红线，需要try catch或者throws时出现的异常。</li><li>Unchecked Exception(运行时异常)，都是RuntimeException类及其子类异常，就是我们在开发中测试功能时程序终止，控制台出现的异常，比如：<br>NullPointerException(空指针异常)<br>IndexOutOfBoundsException(下标越界异常)<br>ClassCastException(类转换异常)<br>ArrayStoreException(数据存储异常，操作数组时类型不一致)<br>IO操作的BufferOverflowException异常</li><li><strong><code>Error</code></strong>: <code>Error</code> 属于程序无法处理的错误 ，不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h4 id="全局异常处理器如何实现？"><a href="#全局异常处理器如何实现？" class="headerlink" title="全局异常处理器如何实现？"></a>全局异常处理器如何实现？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用ControllerAdvice注解标识该类为异常处理类</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常处理，指定该方法处理的异常类型为Exception</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="comment">//将返回的Result转化为Json格式，在controller中已经包含此注解</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">error</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.build(<span class="literal">null</span> , <span class="number">201</span>,<span class="string">&quot;出现了异常&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常处理，指定该方法处理的异常类型为GuiguException</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = GuiguException.class)</span><span class="comment">// 处理自定义异常</span></span><br><span class="line">    <span class="comment">//将返回的Result转化为Json格式，在controller中已经包含此注解</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">error</span><span class="params">(GuiguException exception)</span> &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.build(<span class="literal">null</span> , exception.getResultCodeEnum()) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么情况下会报ClassNotFound的异常？"><a href="#什么情况下会报ClassNotFound的异常？" class="headerlink" title="什么情况下会报ClassNotFound的异常？"></a>什么情况下会报ClassNotFound的异常？</h4><p>当应用程序运行的过程中尝试使用类加载器去加载Class文件的时候，如果没有在classpath中查找到指定的类，就会抛出ClassNotFoundException。一般情况下，当我们使用Class.forName()或者ClassLoader.loadClass以及使用ClassLoader.findSystemClass()在运行时加载类的时候，如果类没有被找到，那么就会导致JVM抛出ClassNotFoundException。</p><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><h4 id="字符流与字节流"><a href="#字符流与字节流" class="headerlink" title="字符流与字节流"></a>字符流与字节流</h4><p><strong>流</strong><br>流是一个抽象的概念，可以看作是一连串的数据，在程序中所有的数据都是以流的方式进行传输或保存的，程序需要数据的时候要使用输入流读取数据，而当程序需要将一些数据保存起来的时候，就要使用输出流完成。程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。</p><p>Java中的流是对字节序列的抽象，我们可以想象有一个水管，只不过现在流动在水管中的不再是水，而是字节序列。和水流一样，Java中的流也具有一个“流动的方向”，通常可以从中读入一个字节序列的对象被称为输入流；能够向其写入一个字节序列的对象被称为输出流。</p><blockquote><p>知识补充1：<br>计算机能存储的唯一东西就是 bytes,为了在计算机中存储东西,我们首先得将其编码(encode),例如将其转化为 bytes。<br>比如：要想保存音乐(以字节形式保存),我们首先得用 MP3, WAV 等将其编码；要想保存图片,我们首先得用 PNG, JPEG 等将其编码；要想保存文本,我们首先得用 ASCII, UTF-8 等将其编码.<br>知识补充2:<br>Unicode 是字符集,不是字符编码。Unicode 把全世界的字符都搜集并且编号了,但是没有规定具体的编码规则。编码规则有 UTF-8、GBK等。</p></blockquote><p><strong>字节流</strong><br>Java中的字节流处理的最基本单位为单个字节，它通常用来处理二进制数据。Java中最基本的两个字节流类是InputStream和OutputStream，它们分别代表了最基本的输入字节流和输出字节流。InputStream是所有字节输入流的祖先，而OutputStream是所有字节输出流的祖先，它们都是抽象类。</p><p><strong>字节流在默认情况下是不支持缓存的，字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，这意味着每调用一次read方法都会请求操作系统来读取一个字节，这往往会伴随着一次磁盘IO</strong>，因此效率会比较低。要使用内存缓冲区以提高读取的效率，我们应该使用BufferedInputStream。</p><p>需注意，使用BufferedOutputStream输出数据时如果没有关闭流，数据也是不会输出到文件当中的，即并不是所有字节流都不用到缓冲区，输入缓冲字节流BufferedInputStream和输出缓冲字节流BufferedOutputStream还是要用到缓冲区的。</p><p><strong>字符流</strong></p><p><strong>为什么要有字符流？</strong></p><p>Java中字符是采用Unicode标准，Unicode 编码中，一个英文为一个字节，一个中文为两个字节。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-bc6b06e4cf29ecb425f56eb3e72d6e40_1440w.webp" alt="img"></p><p>而在UTF-8编码中，一个中文字符是3个字节。例如下面图中，“云深不知处”5个中文对应的是15个字节：-28-70-111-26-73-79-28-72-115-25-97-91-27-92-124</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-d10f2fb7a759d08a233fb04dd7ca7b95_1440w.webp" alt="img"></p><p>那么问题来了，如果使用字节流处理中文，如果一次读写一个字符对应的字节数就不会有问题，一旦将一个字符对应的字节分裂开来，就会出现乱码了。为了更方便地处理中文这些字符，Java就推出了字符流。</p><p>Java中的字符流处理的最基本的单元是Unicode码元（大小2字节），它通常<strong>用来处理文本数据</strong>，例如字符、字符数组或字符串。Java中的String类型默认就把字符以Unicode规则编码而后存储在内存中。存储在磁盘上的数据通常有着各种各样的编码方式，不同的编码方式最终输出的字节内容是不同的，所以，字节流的读取和写入都要<strong>设置相应的编码方式。</strong></p><p>由于<strong>字符流在输出前</strong>实际上是要完成<strong>Unicode码元序列</strong>到相应编码方式的<strong>字节序列的转换</strong>，所以它会使用<strong>内存缓冲区</strong>来存放转换后得到的<strong>字节序列</strong>，等待都转换完毕再一同写入磁盘文件中。</p><p>所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列。</p><p>字符流与字节流的区别：</p><ul><li><p>字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元（通常为两个字节）。<br>字节流默认不使用缓冲区；字符流使用缓冲区(用于保存由字符转化为的字节)。</p></li><li><p>字节流在操作的时候本身是不会用到缓冲区的，是与文件本身直接操作的，所以字节流在操作文件时，即使不关闭资源，文件也能输出；字符流在操作的时候是使用到缓冲区的。如果字符流不调用close或flush方法，则不会输出任何内容。</p></li><li><p>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</p></li><li><p>字节流按字节读数据,而字节不需要编码、解码,只有字节与字符之间转换时才需要编码、解码！</p></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="单例模式（重要）"><a href="#单例模式（重要）" class="headerlink" title="单例模式（重要）"></a>单例模式（重要）</h4><p><strong>何为单例模式</strong><br>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。<br><strong>实现思路</strong><br>如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将 类的构造器的访问权限设置为 private ，这样，就不能用 new 操作符在类的外部产生类的对<br>象了，但在类内部仍可以产生该类的对象。</p><p>因为在类的外部开始还无法得到类的对象， 只能调用该类的某个静态方法 以返回类内部创建的对象，</p><p>静态方法只能访问类中的静态成员变量，所以，指向类内部产生的 该类对象的变量也必须定义成静态的 。</p><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 私有化构造器，防止使用构造器new对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 内部提供一个当前类的实例</span></span><br><span class="line">    <span class="comment">// 4. 此实例也必须静态化，才能让静态方法返回该实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 3. 提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="懒汉式-多线程环境下多个线程同时初始化对象会出现线程安全问题，需要加上类锁"><a href="#懒汉式-多线程环境下多个线程同时初始化对象会出现线程安全问题，需要加上类锁" class="headerlink" title="懒汉式(多线程环境下多个线程同时初始化对象会出现线程安全问题，需要加上类锁)"></a>懒汉式(多线程环境下多个线程同时初始化对象会出现线程安全问题，需要加上类锁)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyOne</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyOne instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyOne</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方式 1 ：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazyOne <span class="title function_">getInstance1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式 2 ：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title function_">getInstance2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazyOne.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式 3 ：存在线程安全问题，当线程1获得锁，new instance并不是一个原子操作</span></span><br><span class="line"><span class="comment">//线程2判断instance不为空可能返回未初始化完成的instance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title function_">getInstance2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyOne.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">                    <span class="comment">//分配空间</span></span><br><span class="line">                    <span class="comment">//初始化</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要解决双重检查锁模式带来空指针异常的问题，只需要使用 `volatile` 关键字, `volatile` 关键字可以保证可见性和有序性。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过静态内部类实现懒汉式单例模式，不需要加锁，较为推荐</strong></p><p>静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder</p><p>并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p><h5 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h5><p>使用<strong>序列化与反序列化</strong>可以生成多个实例对象，会破坏单例设计模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//往文件中写对象</span></span><br><span class="line">        <span class="comment">//writeObject2File();</span></span><br><span class="line">        <span class="comment">//从文件中读取对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断两个反序列化后的对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title function_">readObjectFromFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建对象输入流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//第一个读取Singleton对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeObject2File</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="comment">//创建对象输出流</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//将instance对象写出到文件中</span></span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决</strong>：在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面是为了解决序列化反序列化破解单例模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：反射能够调用private的构造方法，破坏单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的字节码对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Singleton.class;</span><br><span class="line">        <span class="comment">//获取Singleton类的私有无参构造方法对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//取消访问检查</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Singleton类的对象s1</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line">        <span class="comment">//创建Singleton类的对象s2</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断通过反射创建的两个Singleton对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决</strong>：在构造器中添加判断逻辑，如果instance不为空，就抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           反射破解单例模式需要添加的代码</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>饿汉式</strong>：</p><ul><li><strong>特点</strong>： 立即加载 ，即在使用类的时候已经将对象创建完毕。</li><li><strong>优点</strong>：实现起来 简单 ；没有多线程安全问题。</li><li><strong>缺点</strong>：当类被加载的时候，会初始化 static 的实例，静态变量被创建并分配内存空间，从这以后，这个 static 的实例便一直占着这块内存，直到类被卸载时，静态变量被摧毁，并释放所占有的内存。因此在某些特定条件下会 耗费内存 。</li></ul><p><strong>懒汉式</strong>：</p><ul><li><strong>特点</strong>： 延迟加载 ，即在调用静态方法时实例才被创建。</li><li><strong>优点</strong>：实现起来比较简单；当类被加载的时候，static 的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会节约内存 。</li><li><strong>缺点</strong>：在多线程环境中，这种实现方法是完全错误的， 线程不安全 ，需要加锁保证单例的唯一性。</li></ul><p><strong>单例模式的优点及应用场景</strong><br>由于单例模式只生成一个实例，减少了 系统性能开销 ，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时，直接产生一个单例对象，然后永久驻留内存的方式来解决。</p><h4 id="Strategy策略模式"><a href="#Strategy策略模式" class="headerlink" title="Strategy策略模式"></a><strong>Strategy策略模式</strong></h4><p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们之间可以相互替换，策略模式可以在不影响客户端的情况下发生变化。 策略模式是处理算法不同变体的一种成熟模式，策略模式通过接口或抽象类封装算法的标识，即在接口中定义一个抽象方法，实现该接口的类将实现接口中的抽象方法。策略模式把针对一个算法标识的一系列具体算法分别封装在不同的类中，使得各个类给出的具体算法可以相互替换。</p><p>策略模式的结构：</p><ul><li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li></ul><p>【例】促销活动</p><p>一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p>代码如下：</p><p>定义百货公司所有促销活动的共同接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为春节准备的促销活动A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买一送一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为中秋准备的促销活动B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满200元减50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为圣诞准备的促销活动C</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalesMan</span> &#123;                        </span><br><span class="line">    <span class="comment">//持有抽象策略角色的引用                              </span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;                 </span><br><span class="line">                                               </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SalesMan</span><span class="params">(Strategy strategy)</span> &#123;       </span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;              </span><br><span class="line">    &#125;                                          </span><br><span class="line">                                               </span><br><span class="line">    <span class="comment">//向客户展示促销活动                                </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">salesManShow</span><span class="params">()</span>&#123;                </span><br><span class="line">        strategy.show();                       </span><br><span class="line">    &#125;                                          </span><br><span class="line">&#125;                                              </span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p><strong>1，优点：</strong></p><ul><li><p>策略类之间可以自由切换</p><p>由于策略类都实现同一个接口，所以使它们之间可以自由切换。</p></li><li><p>易于扩展</p><p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“</p></li><li><p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想。</p></li></ul><p><strong>2，缺点：</strong></p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li></ul><p><strong>使用场景</strong></p><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li></ul><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><strong>工厂模式</strong></h4><p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。现在在以一个具体的例子来简单简化下工厂模式。假如我现在去餐馆吃饭，餐馆有回锅肉，有鱼，有烤鸭可供我选择，然后我点餐餐馆为我做出具体的菜。</p><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>首先我们来创建一个餐馆的接口,因为这里只要有做菜就行，所以写一个cook的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Resaurant</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来写三个实现类，分别是做回锅肉的，做鱼的，做烤鸭的，用这三个实现类去实现餐馆的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> <span class="keyword">implements</span> <span class="title class_">Resaurant</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来一份烤鸭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">implements</span> <span class="title class_">Resaurant</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来一份红烧鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Meet</span> <span class="keyword">implements</span> <span class="title class_">Resaurant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来一份回锅肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在餐馆已经具备了做回锅肉，做鱼，做烤鸭的功能，但是客人来了并不知道餐馆有这些菜，这时候就需要我们来给餐馆做一个菜单，客人来了就可以根据菜单点餐；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wait</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MEAN_MEET</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MEAN_FISH</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MEAN_DUCK</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Resaurant <span class="title function_">getMean</span><span class="params">(<span class="type">int</span> meantype)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (meantype)&#123;</span><br><span class="line">            <span class="keyword">case</span> MEAN_MEET :</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Meet</span>();</span><br><span class="line">            <span class="keyword">case</span> MEAN_FISH :</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">            <span class="keyword">case</span> MEAN_DUCK :</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>菜单也有了，现在客人来了可以点餐了，假如客人根据菜单点了一份烤鸭，那餐馆就可以直接给客人制作一份美味的烤鸭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//简单工厂模式</span></span><br><span class="line">        <span class="type">Resaurant</span> <span class="variable">resaurant</span> <span class="operator">=</span> Wait.getMean(Wait.MEAN_DUCK);</span><br><span class="line">        resaurant.cook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看执行结果</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-fdb9586dea3ad2f16c5e3ba1289117c1_1440w.webp" alt="img"></p><h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>工厂模式除了简单工厂模式还有工厂方法模式和抽象工厂模式，下面我再已餐馆这个例子给大家扩展一下工厂方法模式。工厂方法模式就是把简单工厂中具体的工厂类，划分成两层：抽象工厂层+具体的工厂子类层。</p><p>首先我们来创建一个抽象工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CookFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Resaurant <span class="title function_">createRestaurant</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建两个具体需要的产品实现类去继承上面这个抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DuckFactory</span> <span class="keyword">extends</span> <span class="title class_">CookFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Resaurant <span class="title function_">createRestaurant</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FishFactory</span> <span class="keyword">extends</span> <span class="title class_">CookFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Resaurant <span class="title function_">createRestaurant</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>烤鸭和鱼都做好了，开始享用吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cook</span> &#123;</span><br><span class="line">    <span class="comment">//工厂方法模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Resaurant</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DuckFactory</span>().createRestaurant();</span><br><span class="line">        duck.cook();</span><br><span class="line">        <span class="type">Resaurant</span> <span class="variable">fish</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FishFactory</span>().createRestaurant();</span><br><span class="line">        fish.cook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下执行结果</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-6f3165566e6db1dc7ac0a40aabd93d9e_1440w.webp" alt="img"></p><p><strong>优点和缺点</strong></p><p>优点：</p><ul><li><strong>一个调用者想创建一个对象，只要知道其名称就可以了。</strong></li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li><li>屏蔽产品的具体实现，调用者只关心产品的接口。</li></ul><p>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p><strong>概述</strong>：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p><p><strong>结构</strong>：原型模式包含如下角色：</p><ul><li>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ul><p>接口类图如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png"></p><p><strong>用原型模式生成“三好学生”奖状</strong></p><p>同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。</p><p>类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F1.png" style="zoom:80%;" /><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奖状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试访问类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        c1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制奖状</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> c1.clone();</span><br><span class="line">        <span class="comment">//将奖状的名字修改李四</span></span><br><span class="line">        c2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>对象的创建非常复杂，可以使用原型模式快捷的创建对象。</li><li>性能和安全要求比较高。</li></ul><h5 id="扩展（深克隆）"><a href="#扩展（深克隆）" class="headerlink" title="扩展（深克隆）"></a>扩展（深克隆）</h5><p>将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奖状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStu</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stu = stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(stu.getName() + <span class="string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line">        c1.setStu(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制奖状</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> c1.clone();</span><br><span class="line">        <span class="comment">//获取c2奖状所属学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> c2.getStu();</span><br><span class="line">        stu1.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断stu对象和stu1对象是否是同一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F2.png" style="zoom:80%;" /><p><font color="red">说明：</font></p><p>​stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，</p><p>可以重写clone方法实现。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// constructors, getters and setters</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) <span class="built_in">super</span>.clone();</span><br><span class="line">        user.setAddress(<span class="built_in">this</span>.address.clone());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用序列化实现深拷贝</p><p>Java提供了序列化的能力，我们可以先将源对象进行序列化，再反序列化生成拷贝对象。但是，使用序列化的前提是拷贝的类（包括其成员变量）需要实现Serializable接口。Apache Commons Lang包对Java序列化进行了封装，我们可以直接使用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String country;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// constructors, getters and setters</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// constructors, getters and setters</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serializableCopy</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;杭州&quot;</span>, <span class="string">&quot;中国&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;大山&quot;</span>, address);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 使用Apache Commons Lang序列化进行深拷贝</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">copyUser</span> <span class="operator">=</span> (User) SerializationUtils.clone(user);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 修改源对象的值</span></span><br><span class="line">    user.getAddress().setCity(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 检查两个对象的值不同</span></span><br><span class="line">    assertNotSame(user.getAddress().getCity(), copyUser.getAddress().getCity());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="序列化为JSON"><a href="#序列化为JSON" class="headerlink" title="序列化为JSON"></a>序列化为JSON</h5><p>Gson可以将对象序列化成JSON，也可以将JSON反序列化成对象，所以我们可以用它进行深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gsonCopy</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;杭州&quot;</span>, <span class="string">&quot;中国&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;大山&quot;</span>, address);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 使用Gson序列化进行深拷贝</span></span><br><span class="line">    <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    <span class="type">User</span> <span class="variable">copyUser</span> <span class="operator">=</span> gson.fromJson(gson.toJson(user), User.class);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 修改源对象的值</span></span><br><span class="line">    user.getAddress().setCity(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 检查两个对象的值不同</span></span><br><span class="line">    assertNotSame(user.getAddress().getCity(), copyUser.getAddress().getCity());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p><strong>定义：</strong></p><p>​运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p><p>【例】俄罗斯方块</p><p>下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.jpeg" style="zoom:60%;" /><p><strong>先来看类图：</strong></p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p><strong>代码如下：</strong></p><p>俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getShape</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方块形状：&quot;</span> + <span class="built_in">this</span>.getShape() + <span class="string">&quot; 颜色：&quot;</span> + color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;L&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, AbstractBox&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BoxFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, AbstractBox&gt;();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">iBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">lBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">oBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OBox</span>();</span><br><span class="line">        map.put(<span class="string">&quot;I&quot;</span>, iBox);</span><br><span class="line">        map.put(<span class="string">&quot;L&quot;</span>, lBox);</span><br><span class="line">        map.put(<span class="string">&quot;O&quot;</span>, oBox);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BoxFactory <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BoxFactory</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BoxFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AbstractBox <span class="title function_">getBox</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优缺点和使用场景"><a href="#优缺点和使用场景" class="headerlink" title="优缺点和使用场景"></a>优缺点和使用场景</h5><p><strong>优点</strong></p><ul><li>极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</li></ul><p><strong>使用场景：</strong></p><ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li></ul><h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p><strong>定义：</strong></p><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p><p>【例】炒菜</p><p>炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">cookProcess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//第一步：倒油</span></span><br><span class="line">        <span class="built_in">this</span>.pourOil();</span><br><span class="line">        <span class="comment">//第二步：热油</span></span><br><span class="line">        <span class="built_in">this</span>.heatOil();</span><br><span class="line">        <span class="comment">//第三步：倒蔬菜</span></span><br><span class="line">        <span class="built_in">this</span>.pourVegetable();</span><br><span class="line">        <span class="comment">//第四步：倒调味料</span></span><br><span class="line">        <span class="built_in">this</span>.pourSauce();</span><br><span class="line">        <span class="comment">//第五步：翻炒</span></span><br><span class="line">        <span class="built_in">this</span>.fry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;倒油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：热油是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heatOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;热油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：倒调味料是不一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五步：翻炒是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;炒啊炒啊炒到熟啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_BaoCai</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是包菜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是辣椒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_CaiXin</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是菜心&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是蒜蓉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//炒手撕包菜</span></span><br><span class="line">        <span class="type">ConcreteClass_BaoCai</span> <span class="variable">baoCai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass_BaoCai</span>();</span><br><span class="line">        baoCai.cookProcess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//炒蒜蓉菜心</span></span><br><span class="line">        <span class="type">ConcreteClass_CaiXin</span> <span class="variable">caiXin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass_CaiXin</span>();</span><br><span class="line">        caiXin.cookProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：为防止恶意操作，一般模板方法都加上 final 关键词。</p></blockquote><p><strong>优点：</strong></p><ul><li><p>提高代码复用性</p><p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p></li><li><p>实现了反向控制</p><p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。</p></li></ul><p><strong>缺点：</strong></p><ul><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li></ul><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><p><strong>定义：</strong></p><p>​指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p><p><strong>例子</strong></p><p>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。</p><p>使用继承的方式存在的问题：</p><ul><li><p>扩展性不好</p><p>如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。</p></li><li><p>产生过多的子类</p></li></ul><p>我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.png" style="zoom:75%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快餐接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> price;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">(<span class="type">float</span> price, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">float</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDesc</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span>;  <span class="comment">//获取价格</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒饭</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRice</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedRice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">10</span>, <span class="string">&quot;炒饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedNoodles</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedNoodles</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">12</span>, <span class="string">&quot;炒面&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配料类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Garnish</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FastFood fastFood;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FastFood <span class="title function_">getFastFood</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFastFood</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Garnish</span><span class="params">(FastFood fastFood, <span class="type">float</span> price, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(price,desc);</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鸡蛋配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Egg</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Egg</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(fastFood,<span class="number">1</span>,<span class="string">&quot;鸡蛋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//培根配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bacon</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bacon</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(fastFood,<span class="number">2</span>,<span class="string">&quot;培根&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//点一份炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">&quot; &quot;</span> + food.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加鸡蛋的炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line"></span><br><span class="line">        food1 = <span class="keyword">new</span> <span class="title class_">Egg</span>(food1);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food1.getDesc() + <span class="string">&quot; &quot;</span> + food1.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加培根的炒面</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedNoodles</span>();</span><br><span class="line">        food2 = <span class="keyword">new</span> <span class="title class_">Bacon</span>(food2);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food2.getDesc() + <span class="string">&quot; &quot;</span> + food2.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>好处：</strong></p><ul><li><p>装饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</p></li><li><p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p></li></ul><p><strong>使用场景</strong></p><ul><li><p>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</p><p>不能采用继承的情况主要有两类：</p><ul><li>第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；</li><li>第二类是因为类定义不能继承（如final类）</li></ul></li><li><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p></li><li><p>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</p></li></ul><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p><strong>定义</strong>：又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p>【例】现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。</p><p>类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请假条</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//请假天数</span></span><br><span class="line">    <span class="keyword">private</span> String content;<span class="comment">//请假内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeaveRequest</span><span class="params">(String name, <span class="type">int</span> num, String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理者抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_ONE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_THREE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_SEVEN</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该领导处理的请假天数区间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//领导上面还有领导</span></span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围 上不封顶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart, <span class="type">int</span> numEnd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">        <span class="built_in">this</span>.numEnd = numEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置上级领导</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(Handler nextHandler)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交请假条</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(LeaveRequest leave)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">this</span>.numStart)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果请假天数达到该领导者的处理要求</span></span><br><span class="line">        <span class="keyword">if</span>(leave.getNum() &gt;= <span class="built_in">this</span>.numStart)&#123;</span><br><span class="line">            <span class="built_in">this</span>.handleLeave(leave);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果还有上级 并且请假天数超过了当前领导的处理范围</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> != <span class="built_in">this</span>.nextHandler &amp;&amp; leave.getNum() &gt; numEnd)&#123;</span><br><span class="line">                <span class="built_in">this</span>.nextHandler.submit(leave);<span class="comment">//继续提交</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;流程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各级领导处理请假条方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小组长</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupLeader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//小组长处理1-3天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_ONE, Handler.NUM_THREE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小组长审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//部门经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理3-7天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_THREE, Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;部门经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GeneralManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理7天以上的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//请假条来一张</span></span><br><span class="line">        <span class="type">LeaveRequest</span> <span class="variable">leave</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="string">&quot;小花&quot;</span>,<span class="number">5</span>,<span class="string">&quot;身体不适&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//各位领导</span></span><br><span class="line">        <span class="type">GroupLeader</span> <span class="variable">groupLeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>();</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        <span class="type">GeneralManager</span> <span class="variable">generalManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralManager</span>();</span><br><span class="line"></span><br><span class="line">        groupLeader.setNextHandler(manager);<span class="comment">//小组长的领导是部门经理</span></span><br><span class="line">        manager.setNextHandler(generalManager);<span class="comment">//部门经理的领导是总经理</span></span><br><span class="line">        <span class="comment">//之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交申请</span></span><br><span class="line">        groupLeader.submit(leave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p><strong>优点：</strong></p><ul><li><p>降低了对象之间的耦合度</p><p>该模式降低了请求发送者和接收者的耦合度。</p></li><li><p>增强了系统的可扩展性</p><p>可以根据需要增加新的请求处理类，满足开闭原则。</p></li><li><p>增强了给对象指派职责的灵活性</p><p>当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。</p></li><li><p>责任链简化了对象之间的连接</p><p>一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</p></li><li><p>责任分担</p><p>每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</p></li></ul><p><strong>缺点：</strong></p><ul><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li></ul><p>使用案例：Filter的链式调用</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p><strong>定义：</strong></p><p>又被称为发布-订阅（Publish&#x2F;Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><p><strong>结构</strong></p><ul><li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li><li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li><li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li><li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li></ul><p>【例】微信公众号</p><p>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。</p><p>类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p>代码如下：</p><p>定义抽象观察者类，里面定义一个更新的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体观察者类，微信用户是观察者，里面实现了更新的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeixinUser</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 微信用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeixinUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象主题类，提供了attach、detach、notify三个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//增加订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通知订阅者更新消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//储存订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; weixinUserlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserlist.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserlist.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : weixinUserlist) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SubscriptionSubject mSubscriptionSubject=<span class="keyword">new</span> <span class="title class_">SubscriptionSubject</span>();</span><br><span class="line">        <span class="comment">//创建微信用户</span></span><br><span class="line">        WeixinUser user1=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;孙悟空&quot;</span>);</span><br><span class="line">        WeixinUser user2=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;猪悟能&quot;</span>);</span><br><span class="line">        WeixinUser user3=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;沙悟净&quot;</span>);</span><br><span class="line">        <span class="comment">//订阅公众号</span></span><br><span class="line">        mSubscriptionSubject.attach(user1);</span><br><span class="line">        mSubscriptionSubject.attach(user2);</span><br><span class="line">        mSubscriptionSubject.attach(user3);</span><br><span class="line">        <span class="comment">//公众号更新发出消息给订阅的微信用户</span></span><br><span class="line">        mSubscriptionSubject.notify(<span class="string">&quot;传智黑马的专栏更新了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p><strong>优点：</strong></p><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】</li></ul><p><strong>缺点：</strong></p><ul><li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时</li><li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</li></ul><p><strong>使用场景</strong></p><ul><li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。</li></ul><h3 id="JDK新特性"><a href="#JDK新特性" class="headerlink" title="JDK新特性"></a>JDK新特性</h3><h5 id="JDK1-8的新特性"><a href="#JDK1-8的新特性" class="headerlink" title="JDK1.8的新特性:"></a><strong>JDK1.8的新特性:</strong></h5><ol><li><p>stream流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;gkh&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="comment">//返回符合条件的stream</span></span><br><span class="line">    Stream&lt;String&gt; stringStream = strings.stream().filter(s -&gt; <span class="string">&quot;abc&quot;</span>.equals(s));</span><br><span class="line">    <span class="comment">//计算流符合条件的流的数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringStream.count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//forEach遍历-&gt;打印元素</span></span><br><span class="line">    strings.stream().forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>2、Lambda 表达式<br>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、函数式接口</p><p>Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p><p>4、方法与构造函数引用</p><p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">converter = something::startsWith;</span><br><span class="line"><span class="type">String</span> <span class="variable">converted</span> <span class="operator">=</span> converter.convert(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">System.out.println(converted);</span><br></pre></td></tr></table></figure><ol start="5"><li>日期 Date-timeAPI</li></ol><ul><li>增强了时区处理</li><li>增强各种格式化、和时间计算</li></ul><h5 id="JDK9新特性"><a href="#JDK9新特性" class="headerlink" title="JDK9新特性"></a>JDK9新特性</h5><ol><li><p>JShell，为 Java 提供了类似于 Python 的实时命令行交互工具。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111847441.png" alt="image-20231003111847441"></p></li><li><p>String 改为用byte[]存储。</p></li></ol><h5 id="jdk10新特性"><a href="#jdk10新特性" class="headerlink" title="jdk10新特性"></a>jdk10新特性</h5><p><strong>局部变量类型推断(var)</strong>***</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">id</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">codefx</span> <span class="operator">=</span>newURL(<span class="string">&quot;https://mp.weixin.qq.com/&quot;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span>newArrayList&lt;&gt;();</span><br><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span>List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h5 id="JDK11新特性"><a href="#JDK11新特性" class="headerlink" title="JDK11新特性"></a>JDK11新特性</h5><h5 id="String增强"><a href="#String增强" class="headerlink" title="String增强"></a>String增强</h5><p>增加了一系列的字符串处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断字符串是否为空</span></span><br><span class="line"><span class="string">&quot; &quot;</span>.isBlank();<span class="comment">//true</span></span><br><span class="line"><span class="comment">//去除字符串首尾空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.strip();<span class="comment">// &quot;Java&quot;</span></span><br><span class="line"><span class="comment">//去除字符串首部空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.stripLeading();   <span class="comment">// &quot;Java &quot;</span></span><br><span class="line"><span class="comment">//去除字符串尾部空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.stripTrailing();  <span class="comment">// &quot; Java&quot;</span></span><br><span class="line"><span class="comment">//重复字符串多少次</span></span><br><span class="line"><span class="string">&quot;Java&quot;</span>.repeat(<span class="number">3</span>);             <span class="comment">// &quot;JavaJavaJava&quot;</span></span><br><span class="line"><span class="comment">//返回由行终止符分隔的字符串集合。</span></span><br><span class="line"><span class="string">&quot;A\nB\nC&quot;</span>.lines().count();    <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;A\nB\nC&quot;</span>.lines().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2024/04/19/MySQL/"/>
      <url>/2024/04/19/MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL："><a href="#MySQL：" class="headerlink" title="MySQL："></a>MySQL：</h2><h3 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h3><h4 id="执行一条-SQL-查询语句，期间发生了什么？"><a href="#执行一条-SQL-查询语句，期间发生了什么？" class="headerlink" title="执行一条 SQL 查询语句，期间发生了什么？"></a>执行一条 SQL 查询语句，期间发生了什么？</h4><ul><li><p>连接器：建立连接，管理连接、校验用户身份；</p></li><li><p>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</p></li><li><p>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</p></li><li><p>执行 SQL：执行 SQL 共有三个阶段：</p><ul><li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul><p><img src="/./../../imgs/MySQL/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p></li></ul><h4 id="为什么禁止使用select"><a href="#为什么禁止使用select" class="headerlink" title="为什么禁止使用select *"></a>为什么禁止使用select *</h4><ul><li>增加查询分析器解析成本。</li><li>增减字段容易与 resultMap 配置不一致。</li><li>无用字段增加网络 消耗，尤其是 text 类型的字段。</li></ul><h4 id="SQL语句执行顺序"><a href="#SQL语句执行顺序" class="headerlink" title="SQL语句执行顺序"></a>SQL语句执行顺序</h4><ol><li><p>from 子句组装来自不同数据源的数据；</p></li><li><p>where 子句基于指定的条件对记录行进行筛选；  </p></li><li><p>group by 子句将数据划分为多个分组；  </p></li><li><p>使用聚集函数进行计算； </p></li><li><p>使用 having 子句筛选分组；</p></li><li><p>计算所有的表达式后，select；  </p></li><li><p>使用 order by 对结果集进行排序。</p></li><li><p>limit限制查询数量、查询偏移量</p><p><img src="/./../../imgs/MySQL/image-20231003111856990.png" alt="image-20231003111856990"></p></li></ol><h4 id="Mysql表字段限制"><a href="#Mysql表字段限制" class="headerlink" title="Mysql表字段限制"></a>Mysql表字段限制</h4><p>（1）innodb引擎对于列的硬性要求是不能超过1017列，MyISAM引擎能达到4096的限制</p><p>（2）一个表最多可以包含64个 二级索引,两种引擎都有这个限制。</p><p>（3）索引键前缀长度限制为767个字节 ，<strong>当某一列中的数据非常多的话，在数据页中只会存储该列的前767个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做行溢出，存储超出767字节的那些页面也被称为溢出页。</strong>主键是聚集索引，也是其他二级索引的基础，所以每个主键要在一个数据页存储，不能分布在其他的溢出页，不能像其他大字段一样溢出数据页</p><p>（4）MySQL本身对所有列的组合大小强加了65535的行大小限制，这个更多对应单个列的字段长度不能大于65535字节</p><p><img src="/./../../imgs/MySQL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xKRlBIUA==,size_16,color_FFFFFF,t_70.png" alt="img"></p><h4 id="行溢出后怎么处理"><a href="#行溢出后怎么处理" class="headerlink" title="行溢出后怎么处理"></a>行溢出后怎么处理</h4><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</p><p>Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p><p><img src="/./../../imgs/MySQL/%E8%A1%8C%E6%BA%A2%E5%87%BA.png" alt="img"></p><p>Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。</p><h4 id="varchar-n-中-n-最大取值为多少？"><a href="#varchar-n-中-n-最大取值为多少？" class="headerlink" title="varchar(n) 中 n 最大取值为多少？"></a>varchar(n) 中 n 最大取值为多少？</h4><p>行数据保存格式</p><p>变长字段列表存储各个变长字段的长度 null值列表用一个bit表示该行某一列位null</p><p><img src="/./../../imgs/MySQL/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A81.png" alt="img"></p><p><img src="/./../../imgs/MySQL/COMPACT.drawio.png" alt="img"></p><p><strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节</strong>。</p><p>varchar(n) 字段类型的 n 代表的是最多存储的字符数量，不是字节大小。</p><p>要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。</p><p>我们存储字段类型为 varchar(n) 的数据时，其实分成了三个部分来存储：</p><ul><li>真实数据</li><li>真实数据占用的字节数</li><li>NULL 标识，如果不允许为NULL，这部分不需要</li></ul><p><strong>因为我们这个案例是只有 1 个变长字段，所以「变长字段长度列表」&#x3D; 1 个「变长字段长度」占用的字节数，也就是 2 字节</strong>。</p><p>因为我们在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。所以，<strong>在数据库表只有一个 varchar(n) 字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 &#x3D; 65535 - 2 - 1 &#x3D; 65532</strong>。</p><p><strong>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;&#x3D; 65535</strong>。</p><h4 id="Insert-into和replace-into有什么区别"><a href="#Insert-into和replace-into有什么区别" class="headerlink" title="Insert into和replace into有什么区别"></a>Insert into和replace into有什么区别</h4><p>inset into是不允许添加主键重复列的,而replace可以,且影响行数是2,</p><p>replace into用于不知道操作为更新还是新增的时候,使用时,先尝试直接向库中插入数据,遇到主键或唯一索引而引发的重复键错误时,删除掉冲突行并再次尝试插入,这个过程是MySQL自行处理的,并不会存在用户感知之类的</p><h4 id="union和union-all的区别"><a href="#union和union-all的区别" class="headerlink" title="union和union all的区别"></a>union和union all的区别</h4><p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</p><p>union：对两个结果集进行并集操作，不包括重复行，相当于distinct，同时进行默认规则的排序；</p><p>union all：对两个结果集进行并集操作，包括重复行，不进行排序；</p><p>union因为要进行重复值扫描，所以在结果集庞大的情况下，效率极低，因此建议使用union all。</p><p>若结果集去重是强需求，则在应用程序代码上进行去重，因为数据库资源要比应用服务器资源更加珍贵。</p><h4 id="MySQL根据某一个或者多个字段查找重复数据的sql语句（MySQL如何避免查询重复字段）"><a href="#MySQL根据某一个或者多个字段查找重复数据的sql语句（MySQL如何避免查询重复字段）" class="headerlink" title="MySQL根据某一个或者多个字段查找重复数据的sql语句（MySQL如何避免查询重复字段）"></a>MySQL根据某一个或者多个字段查找重复数据的sql语句（MySQL如何避免查询重复字段）</h4><p><strong>1.表中有id和name 两个字段，查询出name重复的所有数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> xi a <span class="keyword">where</span> (a.username) <span class="keyword">in</span> (<span class="keyword">select</span> username  <span class="keyword">from</span> xi <span class="keyword">group</span> <span class="keyword">by</span> username <span class="keyword">having</span> <span class="built_in">count</span> (<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>2、查询出所有数据进行分组之后，查询重复的name字段和重复次数，先列下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span> (username) <span class="keyword">as</span> <span class="string">&#x27;重复次数&#x27;</span>,username <span class="keyword">from</span> xi <span class="keyword">group</span> <span class="keyword">by</span> username <span class="keyword">having</span> <span class="built_in">count</span> (<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> username <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>3、以下为查看别人的 结果，现列下：查询及删除重复记录的方法大全</p><p>1、查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> people <span class="keyword">where</span> peopleId <span class="keyword">in</span> (<span class="keyword">select</span> peopleId <span class="keyword">from</span> people <span class="keyword">group</span> <span class="keyword">by</span> peopleId <span class="keyword">having</span> <span class="built_in">count</span> (peopleId) <span class="operator">&gt;</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>2、删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断，只留有rowid最小的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> people <span class="keyword">where</span> rowid  <span class="keyword">not</span> <span class="keyword">in</span> ( <span class="keyword">select</span> <span class="built_in">min</span>(rowid)  <span class="keyword">from</span> people  <span class="keyword">group</span> <span class="keyword">by</span> peopleId )</span><br></pre></td></tr></table></figure><p>3、删除两个字段重复的数据，只保留一条</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> group_member</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> b.id</span><br><span class="line">  <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(id) <span class="keyword">AS</span> id</span><br><span class="line">    <span class="keyword">FROM</span> group_member</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> group_id, member_id</span><br><span class="line">  ) <span class="keyword">AS</span> b</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>4、查找表中多余的重复记录（多个字段）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> vitae a <span class="keyword">where</span> rowid  <span class="keyword">in</span> ( <span class="keyword">select</span> rowid  <span class="keyword">from</span> vitae  <span class="keyword">group</span> <span class="keyword">by</span> peopleId,seq  <span class="keyword">having</span> <span class="built_in">count</span> (<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>5、查找表中多余的重复记录（多个字段），不包含id最小的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  group_member</span><br><span class="line"><span class="keyword">where</span> id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(g.id) </span><br><span class="line">    <span class="keyword">from</span> group_member g</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> group_id, member_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>6、查询排名前十的数据，包含并列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">s1.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student s1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student s2 <span class="keyword">ON</span> s1.t_id <span class="operator">=</span> s2.t_id </span><br><span class="line"><span class="keyword">AND</span> s1.score <span class="operator">&lt;</span> s2.score </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">s1.id</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="built_in">COUNT</span>( s2.id ) <span class="operator">&lt;</span> <span class="number">10</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">s1.t_id,</span><br><span class="line">s1.score <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h4 id="使用自增id还是UUID来当主键"><a href="#使用自增id还是UUID来当主键" class="headerlink" title="使用自增id还是UUID来当主键"></a>使用自增id还是UUID来当主键</h4><p>应该使用UUID。</p><p>B+树使用双向链表来保存数据，所以使用自增id能够直接加到尾部，不需要页分裂，效率很高，且占用的空间小。但是如果一些敏感信息设置成自增就很容易被推理，暴露机密。</p><p>同时当单表的数据量上来之后我们就需要进行水平分表操作（将一张数据表的数据分成多张表），如果这时我们还是按照之前的自增形式来做主键 id，就有可能会出现 id 重复的问题。</p><p>如果使用UUID，生成的ID不仅是表独立的，而且是库独立的。对以后的数据操作很有好处，可以说一劳永逸。我们可以使用 UUID 来作为不重复的主键 id，但是 UUID 是无序的字符串，所以主键索引就会失效，而且占用空间大。</p><ul><li>全局唯一性：不能出现重复的 id</li><li>递增性：MySQL 的 InnoDB 使用的是聚簇索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，因此在主键的选择上我们还是应该尽可能地使用有序的主键来保证写入性能，我们保证下一个 id 一定大于上一个 id，以此来满足事务版本号、IM 增量消息或者排序的特殊需求</li><li>安全性：如果 id 是连续的，那么我们在知道一些基本规则的情况下就能很轻松地推测出下一份数据，这在一些机密性较高的业务场景是很危险的。所以我们有时会希望 id 是无规则的，最好还能包含有时间戳，这样就能够在开发中快速了解这个分布式 id 的生成时间</li><li>高性能高可用性：确保在任何时候都能正确地生成 id，并且在高并发的环境下也能表现良好</li></ul><p>UUID：我们可以使用 UUID 来作为不重复的主键 id，但是 UUID 是无序的字符串，所以主键索引就会失效</p><p>优点：简单、方便、性能好、出现数据拆分、合并存储的时候，能达到全局的唯一性<br>缺点：占用空间大，无序性、存储的是字符串、查询效率低、传输数据量大</p><p>雪花算法：雪花算法是 Twitter 推出的针对分布式环境下的 id 生成算法，其结果是一个 Long 型的 64bit id。具体实现上使用 41bit 作为毫秒数，10bit 作为机器的 id（5bit 是数据中心，5bit 是机器 id），12bit 作为毫秒内的流水号（这意味着每个节点在每毫秒内可以产生 4096 个 id），最后还有一个符号位永远是 0</p><p>优点：不依赖数据库、完全在内存中生成 id、高性能高可用、容量大、每秒可生成数百万个 id、id 递增、后续插入数据库的索引时性能较高<br>缺点：严重依赖系统时钟，如果某台机器的系统时钟发生回拨，就有可能会造成 id 冲突甚至 id 乱序</p><h4 id="MySQL三大范式"><a href="#MySQL三大范式" class="headerlink" title="MySQL三大范式"></a>MySQL三大范式</h4><ul><li><h5 id="第一范式（1-NF）：字段不可再拆分。"><a href="#第一范式（1-NF）：字段不可再拆分。" class="headerlink" title="第一范式（1 NF）：字段不可再拆分。"></a>第一范式（1 NF）：字段不可再拆分。</h5><p><img src="/./../../imgs/MySQL/image-20231003112028615.png" alt="image-20231003112028615"></p></li><li><h5 id="第二范式（2-NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。"><a href="#第二范式（2-NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。" class="headerlink" title="第二范式（2 NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。"></a>第二范式（2 NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。</h5></li></ul><p>​即一张表只能描述一件事情，学生表中就不要存储成绩，可以专门设计一张成绩表存储学生ID和每一科的成绩。否则造成整张表的数据冗余且更新插入等不方便</p><ol><li>造成整表的数据冗余。</li></ol><p>如，学生表，可能我就只有2个学生，每个学生都有许多的信息，比如，年龄、性别、身高、住址……如果与课程信息放到同一张表中，可能每个学生有3门课程，那数据总条数就会变成6条了。但是通过拆分，学生表我们只需要存储 2 条学生信息，课程表只需要存储 3 条课程信息，成绩表就只需保留学号、课程名称和成绩字段。</p><ol start="2"><li>更新数据不方便。</li></ol><p>假设，课程的学分发生了变更，那我们就需要把整表关于该课程的学分都要更新一次，但如果我们拆分出课程表，那我们就只需要把课程表中的课程信息更新就行。</p><ol start="3"><li>插入数据不方便或产生异常。</li></ol><p>① 假设主键是学号或课程名称，我们新增了某个课程，需要把数据插入到表中，这时，可能只有部分人有选修这门课程，那我们插入数据的时候还要规定给哪些人插入对应的课程信息，同时可能由于成绩还没有，我们需要对成绩置空，后续有成绩后还得重新更新一遍。</p><p>② 假设主键是学号和课程名称的联合主键。同样也是新增了某课程，但是暂时没有人选修这门课，缺少了学号主键字段数据，会导致课程信息无法插入。</p><ul><li><h5 id="第三范式（3-NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段-A-可以获取-某非主键字段-B。"><a href="#第三范式（3-NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段-A-可以获取-某非主键字段-B。" class="headerlink" title="第三范式（3 NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。"></a>第三范式（3 NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。</h5></li></ul><p>如果产生这样情况其实就可以把两者重新建表。如员工表既出现了员工所在的部门id，又出现了部门名称和工作地点，就可以把后面三个单独拆成一张表</p><h4 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h4><table><thead><tr><th>存储引擎</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>InnoDB</td><td>①支持事务②行级锁，提高并发性能③支持外键</td><td>各方面都比较优秀，适合绝大部分的场景</td></tr><tr><td>MyISAM</td><td>①不支持事务②不支持外键③只支持表锁不支持行锁④访问速度快</td><td>适合读操作和插入操作比较频繁的数据，而且对事务和并发要求不高，比如系统配置表等静态表</td></tr><tr><td>Memory</td><td>①存储在内存②hash索引</td><td>通常用于临时表以及缓存</td></tr></tbody></table><h4 id="怎么保证redis和DB的数据一致性"><a href="#怎么保证redis和DB的数据一致性" class="headerlink" title="怎么保证redis和DB的数据一致性"></a>怎么保证redis和DB的数据一致性</h4><h5 id="采用延时双删"><a href="#采用延时双删" class="headerlink" title="采用延时双删"></a>采用延时双删</h5><p><strong>其核心思想是在更新数据库后，先删除缓存中的数据，然后在一段时间后再次删除缓存。这样，即使在这段时间内有新的读请求导致缓存被重建，由于缓存中的数据已经被删除，所以新的读请求会重新从数据库中读取最新数据，从而保证缓存与数据库的一致性。</strong></p><p>这种方案，在并发写的时候，不会出问题。因为都是先更新数据库再删除缓存，不会出现不一致的情况。</p><p>但是在并发读写的时候，还是有可能出现数据不一致。</p><ol><li>读请求查询缓存没数据，然后查询数据库</li><li>写请求更新数据库，删除缓存</li><li>读请求回写缓存</li></ol><p>执行结果是，缓存中是旧数据，而数据库里是新数据，导致数据不一致。</p><p>其实这种情况出现的概率很低，写缓存比写数据库快出几个量级，读写缓存都是内存操作，速度非常快。</p><p>遇到了这种极端场景，我们也需要做一下兜底方案，缓存都要设置过期时间，或者当更新数据后休眠一段时间通过定时任务（可通过整合定时任务框架、创建线程池，从中拿出一个线程休眠一段时间再启动）再删除一次缓存。这种方案属于数据的弱一致性和最终一致性，而不是强一致性。</p><h5 id="异步更新缓存-基于订阅binlog的同步机制"><a href="#异步更新缓存-基于订阅binlog的同步机制" class="headerlink" title="异步更新缓存(基于订阅binlog的同步机制)"></a>异步更新缓存(基于订阅binlog的同步机制)</h5><p>采用缓存淘汰策略，先更新数据库，再删除对应redis缓存后更新缓存。</p><p><img src="/./../../imgs/MySQL/image-20231012113429919.png" alt="image-20231012113429919"></p><p>通过 Canal（消息推送工具也可以用kafka、rabbitMQ等来实现可靠性消息通信更新Redis。） 组件，（伪装成从节点）监控 Mysql 中 binlog（记录MySQL中新的写入、更新、删除等操作） 的日志，把更新后的数据同步到 Redis 里面，canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。</p><p><img src="/./../../imgs/MySQL/image-20231012113453556.png" alt="image-20231012113453556"></p><p>因为这里是基于最终一致性来实现的，如果业务场景不能接受数据的短期不一致性，那就不能使用这个方案来做。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务的四大特性（ACID）："><a href="#事务的四大特性（ACID）：" class="headerlink" title="事务的四大特性（ACID）："></a>事务的四大特性（ACID）：</h4><ul><li>原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性：事务完成时，必须使得所有的数据保持一致状态</li><li>隔离性：数据库系统提供的隔离机制，保证事务不受外部并发操作的影响，在独立的环境下运行。</li><li>持久性：事务一单提交或回滚，会对数据库产生永久的改变</li></ul><table><thead><tr><th>特性</th><th>由什么机制来保证</th></tr></thead><tbody><tr><td>原子性、一致性、持久性</td><td>redo log、 undo log</td></tr><tr><td>隔离性</td><td>MVCC多版本控制、数据库的锁</td></tr></tbody></table><h4 id="并发事务问题："><a href="#并发事务问题：" class="headerlink" title="并发事务问题："></a>并发事务问题：</h4><ol><li><p>脏读：一个事务读到了另一个事务还没有提交的数据。<img src="/./../../imgs/MySQL/image-20231003111916626.png" alt="image-20231003111916626"></p></li><li><p>不可重复读：一个事务先后读取同一条记录，但是两次读取的<strong>数据不同</strong>，强调数据不同</p></li></ol><p><img src="/./../../imgs/MySQL/image-20231003111926058.png" alt="image-20231003111926058"></p><ol start="3"><li>幻读：前后读取的记录数量不一致，强调说的是存不存在的问题：原来不存在的,现在存在了,则是幻读。<img src="/./../../imgs/MySQL/image-20231003111932452.png" alt="image-20231003111932452"></li></ol><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p><img src="/./../../imgs/MySQL/image-20231003111936844.png" alt="image-20231003111936844"></p><h4 id="undo-log（原子性-一致性）"><a href="#undo-log（原子性-一致性）" class="headerlink" title="undo log（原子性 一致性）"></a>undo log（原子性 一致性）</h4><ul><li>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性、一致性) 和MVCC(多版本并发控制) 。</li><li>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undolog中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</li><li>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</li></ul><h4 id="redo-log（持久性、-一致性）"><a href="#redo-log（持久性、-一致性）" class="headerlink" title="redo log（持久性、 一致性）"></a>redo log（持久性、 一致性）</h4><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo logfile）,前者是在内存中，后者在磁盘中。<strong>当事务提交之后</strong>会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p><img src="/./../../imgs/MySQL/image-20231003112038852.png" alt="image-20231003112038852"></p><p>有了redolog之后，<strong>当对缓冲区的数据进行增删改之后</strong>，会首先将操作的数据页的变化，记录在redolog buffer中。<strong>在事务提交时</strong>，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样<strong>就保证了事务的持久性</strong>。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="哪些情况适合创建索引"><a href="#哪些情况适合创建索引" class="headerlink" title="哪些情况适合创建索引"></a>哪些情况适合创建索引</h4><ul><li><strong>字段的数值有唯一性的限制</strong></li></ul><p>具有唯一索引的字段，即使是组合字段，也必须建成唯一索引。唯一索引对 insert 的速度损耗可以忽略，但是提高的查找速度是明显的。</p><ul><li><strong>频繁作为 *<em>where*</em> 查询条件的字段</strong></li><li><strong>经常GROUP BY 或 ORDER BY的列</strong></li><li><strong>UPDATE、DELETE 的 WHERE 条件列</strong></li><li><strong>DISTINCT 字段需要创建索引</strong>,排序后去重自然也更快了！</li></ul><h4 id="哪些情况不适合创建索引"><a href="#哪些情况不适合创建索引" class="headerlink" title="哪些情况不适合创建索引"></a>哪些情况不适合创建索引</h4><ul><li><strong>在 WHERE 中使用不到的字段，不要设置索引</strong></li></ul><p>同理，如GROUP BY 或 ORDER BY 条件里用不到的字段，也不要设置索引。原因也很简单，不需要快速定位，设置索引也没有用！</p><ul><li><strong>数据量小的表最好不要使用索引</strong></li></ul><p>在数据量很小的时候，原本查询时间已经很短了，不必要再添加索引。索引的回表等操作可能会使耗费时间更多！</p><ul><li><p><strong>有大量重复数据的列上不要建立索引</strong>, 比如sex、status，否则查找效率也很低</p></li><li><p><strong>避免对经常需要更新的表创建过多的索引</strong>，在对数据进行修改时，索引也会需要调整更新，造成很大负担</p></li></ul><h4 id="B-Tree-与-B-Tree相比"><a href="#B-Tree-与-B-Tree相比" class="headerlink" title="B+Tree 与 B-Tree相比"></a>B+Tree 与 B-Tree相比</h4><ul><li>所有的数据都会出现在叶子节点。</li><li>叶子节点形成一个双向循环链表。</li><li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。<img src="/./../../imgs/MySQL/image-20231003111941842.png" alt="image-20231003111941842"></li></ul><h4 id="为什么InnoDB存储引擎选择使用B-tree索引结构"><a href="#为什么InnoDB存储引擎选择使用B-tree索引结构" class="headerlink" title="为什么InnoDB存储引擎选择使用B+tree索引结构?"></a>为什么InnoDB存储引擎选择使用B+tree索引结构?</h4><ol><li>相对于二叉树，层级更少，搜索效率高；</li><li>对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；B+树叶子节点有链表，支持排序和范围查询。</li><li>相对Hash索引，Hash索引会发生Hash冲突，B+tree支持范围匹配及排序操作；</li><li>数据都在叶子节点，搜索效率稳定，且叶子节点形成双向循环链表，便于范围查找和排序</li></ol><p><strong>与shipList相比：****B+树</strong>是多叉树结构，每个结点都是一个16k的数据页，能存放较多索引信息，所以非叶子节点度数很大，三层<strong>左右就可以存储<code>2kw</code>左右的数据。也就是说查询一次数据，如果这些数据页都在磁盘里，那么最多需要查询</strong>三次磁盘IO**。</p><p><strong>跳表</strong>是链表结构，查询都要能达到<strong>二分查找</strong>的效果，相当于一颗二叉搜索树，保存相同量的数据，层数远比B+树高，需要更多的磁盘IO，查询效率更慢。</p><p>而针对<strong>写操作</strong>，B+树会出现页分裂，跳表则独立插入，没有旋转和维持平衡的开销，因此<strong>跳表的写入性能会比B+树要好。</strong></p><p>缺点:B+树用页来保存数据，会产生内存碎片。</p><h4 id="聚集索引-二级索引"><a href="#聚集索引-二级索引" class="headerlink" title="聚集索引&amp;二级索引"></a>聚集索引&amp;二级索引</h4><p><img src="/./../../imgs/MySQL/image-20231003111945629.png" alt="image-20231003111945629"></p><p>聚集索引选取规则:</p><ul><li><p>​如果存在主键，主键索引就是聚集索引。</p></li><li><p>​如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p></li><li><p>​如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p><p><img src="/./../../imgs/MySQL/image-20231003111949312.png" alt="image-20231003111949312"></p></li><li><p>聚集索引的叶子节点下挂的是这一行的数据 。</p></li><li><p>二级索引的叶子节点下挂的是该字段值对应的主键值。</p></li></ul><h4 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h4><p><font color = gold>聚簇索引和非聚簇索引不是聚集索引与二级索引，而是两种数据存储方式。</font></p><p>聚簇索引存储（InnoDB）：<font color = gold>行数据和主键B+树存储在一起</font>，辅助键B+树只存储辅助键和主键，主键和非主键B+树几乎是两种类型的树。</p><p>非聚簇索引存储（MySAM）：<font color = gold>表数据存储在独立的地方</font>&gt;,主键B+树在叶子节点存储指向真正数据行的<strong>地址指针</strong>，而非主键。</p><p>InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id &#x3D; 14″这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。</p><p>MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个<strong>地址指向真正的表数据</strong>，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索<strong>无需访问主键的索引树</strong>。</p><p>假想一个表如下图存储了4行数据。其中Id作为主索引，Name作为辅助索引。图示清晰的显示了聚簇索引和非聚簇索引的差异。</p><p><a href="https://kyle.ai/blog/wp-content/uploads/2018/03/9.png"><img src="/./../../imgs/MySQL/9.png" alt="9"></a> <a href="https://kyle.ai/blog/wp-content/uploads/2018/03/10.png"><img src="/./../../../../../../%2525E4%2525B8%2525AA%2525E4%2525BA%2525BA%2525E5%25258D%25259A%2525E5%2525AE%2525A2/hexo/blog/source/imgs/Java%2525E7%25259F%2525A5%2525E8%2525AF%252586%2525E7%252582%2525B9%2525E6%252580%2525BB%2525E7%2525BB%252593/10.png" alt="10"></a></p><h5 id="聚簇索引的优势"><a href="#聚簇索引的优势" class="headerlink" title="聚簇索引的优势"></a>聚簇索引的优势</h5><p>看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，聚簇索引的优势在哪？</p><ol><li><p>行数据和叶子节点存储在一起，这样主键和行数据是一起载入内存，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。</p></li><li><p>辅助索引使用主键作为”指针” 而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB<strong>在移动行时无须更新辅助索引中的这个”指针”</strong>。也就是说行的位置（会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。</p></li></ol><h4 id="为什么非主键索引存放的是主键ID而不是数据行的地址？"><a href="#为什么非主键索引存放的是主键ID而不是数据行的地址？" class="headerlink" title="为什么非主键索引存放的是主键ID而不是数据行的地址？"></a>为什么非主键索引存放的是主键ID而不是数据行的地址？</h4><p><strong>保持一致性：</strong><br>当数据库表进行DML操作时，可能会出现“页分裂”、’’非叶子节点分裂’’情况，同一行记录的页地址会发生改变，因非主键索引保存的是主键的值，无需同步更改，降低二级索引的维护开销。</p><h4 id="为什么存放主键id而不是行数据？"><a href="#为什么存放主键id而不是行数据？" class="headerlink" title="为什么存放主键id而不是行数据？"></a>为什么存放主键id而不是行数据？</h4><p><strong>节省存储空间：</strong><br>Innodb数据本身就已经汇聚到主键索引所在的B+树上了， 如果普通索引还继续再保存一份数据，就会导致有多少索引就要存多少份数据，造成数据冗余。</p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>存储一些比较长的字符串时，如果建立索引会使得索引变得很大，查询时大量的磁盘IO降低查询效率，此时可以提取字符串的一部分前缀来建立索引，这样可以大大节约索引空间，提高索引效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 截取某个字段的前 n 个字符建立索引</span></span><br><span class="line"><span class="keyword">create</span> index index_name <span class="keyword">on</span> table_name(column_name(n));</span><br></pre></td></tr></table></figure><p>具体截取的字符串的长度是 选择性最高的最小的n，选择性即是不重复的索引值和数据表的记录总数的比值</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p> 覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。索引的b+树的叶子节点中保存了我们需要查询的数据，此时无需进行回表查询。</p><h4 id="联合索引在b-树中怎么存储"><a href="#联合索引在b-树中怎么存储" class="headerlink" title="联合索引在b+树中怎么存储"></a>联合索引在b+树中怎么存储</h4><p>联合索引是对多个列（字段）建立的索引(需要满足最左前缀法则)</p><p><font color = gold><strong>前一个条件</strong>相等的情况下 <strong>当前条件</strong>才会是<strong>有序的</strong>，当<strong>前一个条件</strong>不同 那么无法保证<strong>当前条件</strong>为有序的 所以索引失效</font>,也就是说,只有<strong>记录左边的字段都是相等的时,记录的当前字段才会是有序的,才能使用当前字段索引</strong></p><p>联合索引和其他索引的区别就是在非叶子节点存储的是联合索引上全部字段，按照最左前缀法则排序，叶子节点会存储联合索引全部字段和主键id</p><p><img src="/./../../imgs/MySQL/v2-e6c3ce6effabafb1a96e08cffbeb104b_r.jpg" alt="img"></p><h4 id="索引下推？"><a href="#索引下推？" class="headerlink" title="索引下推？"></a><strong>索引下推？</strong></h4><p><a href="https://juejin.cn/post/7005794550862053412">五分钟搞懂MySQL索引下推 - 掘金 (juejin.cn)</a></p><p><a href="https://blog.csdn.net/wang_luwei/article/details/120274064">Mysql性能优化之什么是索引下推？_索引吓退-CSDN博客</a></p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li><p>索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，是针对非聚集索引得优化（聚集索引没有回表查询这一说法）用于减少存储引擎回表查询的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</p></li><li><p>在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</p></li><li><p>在使用ICP的情况下，如果<font color = gold><strong>存在某些被索引的列</strong>是<strong>判断条件</strong>时，MySQL服务器将<strong>这一部分判断条件</strong>传递给<strong>存储引擎</strong>，然后由存储引擎通过<strong>判断索引是否符合</strong>MySQL服务器传递的<strong>条件</strong>，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器</font>。</p></li></ul><h5 id="优化的原理"><a href="#优化的原理" class="headerlink" title="优化的原理"></a>优化的原理</h5><p>我们先简单了解一下MySQL大概的架构：</p><p><img src="/./../../imgs/MySQL/52288fa925f84cef937bb0b46d27c60atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="MySQL大概架构"></p><p>MySQL服务层负责SQL语法解析、生成执行计划等，并调用存储引擎层去执行数据的存储和检索。</p><p><font color = gold><code>索引下推</code>的<strong>下推</strong>其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理，推的是在查数据走联合索引时，将5.6版本之前 （联合）索引中容忽略的字段给添加上，让（联合）索引中的全部字段都用上。</font></p><p>我们来具体看一下，在没有使用ICP的情况下，MySQL的查询：</p><ul><li>存储引擎读取索引记录；</li><li>根据索引中的主键值，定位并读取完整的行记录；</li><li>存储引擎把记录交给<code>Server</code>层去检测该记录是否满足<code>WHERE</code>条件。</li></ul><p>使用ICP的情况下，查询过程：</p><ul><li>存储引擎读取索引记录（不是完整的行记录）；</li><li>判断<code>WHERE</code>条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；</li><li>条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；</li><li>存储引擎把记录交给<code>Server</code>层，<code>Server</code>层检测该记录是否满足<code>WHERE</code>条件的其余部分。</li></ul><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>使用一张用户表<code>tuser</code>，表里创建联合索引（name, age）。</p><p><img src="/./../../imgs/MySQL/1b49ff7a5bff433688d7640d1ca64fb4tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="用户表"></p><p>如果现在有一个需求：检索出表中<code>名字第一个字是张，而且年龄是10岁的所有用户</code>。那么，SQL语句是这么写的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>假如你了解索引最左匹配原则，那么就知道这个语句在搜索索引树的时候，只能用 <code>%张</code>，<font color = gold>会忽略age这个字段</font>，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为1，4，然后拿着取到的id值一次次的回表查询，因此这个过程需要回表两次。</p><p><strong>（忽略的原因是：<font color = gold>组合索引满足最左匹配，但是遇到非等值判断时匹配停止</font>。name like ‘陈%’ 不是等值匹配，所以 age &#x3D; 20 这里就用不上 (name,age) 组合索引了。如果没有索引下推，组合索引只能用到 name，age 的判定就需要回表才能做了。5.6版本之后有了索引下推，age &#x3D; 20 可以直接在组合索引里判定。）</strong></p><p><img src="/./../../imgs/MySQL/a2db6afbc11546fbb4205b2faa64400ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="B+树联合索引"></p><p><strong>没有使用ICP</strong></p><p>存储引擎根据通过联合索引找到<code>name like &#39;张%&#39;</code> 的主键id（1、4），逐一进行回表扫描，去聚簇索引找到完整的行记录，server层再对数据根据<code>age=10进行筛选</code>。</p><p>我们看一下示意图：</p><p><img src="/./../../imgs/MySQL/c97ed6c5e395416181cb57591151fb09tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="未使用ICP"></p><p>可以看到需要回表两次，把我们联合索引的另一个字段<code>age</code>浪费了。</p><p><strong>使用ICP</strong></p><p>存储引擎根据（name，age）联合索引，找到<code>name like &#39;张%&#39;</code>，由于<strong>联合索引中包含<code>age</code>列</strong>，InnoDB并没有忽略索引中age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要回表一次。，所以存储引擎直接再联合索引里按照<code>age=10</code>过滤。按照过滤后的数据再一一进行回表扫描。</p><p>我们看一下示意图：</p><p><img src="/./../../imgs/MySQL/8edc3c9af2e5403da79f77e50adaecd3tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="使用ICP的示意图"></p><p>可以看到只回表了一次。</p><p>除此之外我们还可以看一下执行计划，看到<code>Extra</code>一列里<code> Using index condition</code>，这就是用到了索引下推。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>复制代码<span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tuser <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> na_index      <span class="operator">|</span> na_index <span class="operator">|</span> <span class="number">102</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">25.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure><h5 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h5><ul><li>只能用于<code>range</code>（范围查询）、 <code>ref</code>、 <code>eq_ref</code>、<code>ref_or_null</code>访问方法；</li><li>只能用于<code>InnoDB</code>和 <code>MyISAM</code>存储引擎及其分区表；</li><li>对<code>InnoDB</code>存储引擎来说，索引下推只适用于二级索引（也叫辅助索引）;</li></ul><blockquote><p>索引下推的目的是为了减少回表次数，也就是要减少IO操作。对于<code>InnoDB</code>的<strong>聚簇索引</strong>来说，数据和索引是在一起的，不存在回表这一说。</p></blockquote><ul><li>引用了子查询的条件不能下推；</li><li>引用了存储函数的条件不能下推，因为存储引擎无法调用存储函数。</li></ul><h4 id="为什么范围查找Mysql没有用索引下推优化？"><a href="#为什么范围查找Mysql没有用索引下推优化？" class="headerlink" title="为什么范围查找Mysql没有用索引下推优化？"></a><strong>为什么范围查找Mysql没有用索引下推优化？</strong></h4><p>估计应该是Mysql认为范围查找过滤的结果集过大，like KK% 在绝大多数情况来看，过滤后的结果集比较小，所以这里Mysql选择给 like KK% 用了索引下推优化</p><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><p><a href="https://cloud.tencent.com/developer/article/1992920">15个必知的Mysql索引失效场景，别再踩坑了-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><ol><li><p><strong>在索引列上进行使用内置函数、运算操作（如，+、-、*、&#x2F;）， 索引将失效</strong> ，MySQL 查询优化器无法直接利用索引来定位满足条件的记录，执行全表扫描或使用其他索引进行查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="built_in">SUBSTRING</span>(name, <span class="number">1</span>, <span class="number">5</span>) <span class="operator">=</span> <span class="string">&#x27;Smith&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">-</span> <span class="number">1</span> <span class="operator">&gt;</span> <span class="number">20</span>; </span><br></pre></td></tr></table></figure></li><li><p><strong>发生隐式的类型转换</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> 软件工程 <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>比如字符串不加引号，比如将char转换为int，尽管我们为条件列创建了索引，但由于查询条件中的隐式类型转换，MySQL 将<code>&#39;1&#39;</code>视为一个字符串，而不是整数。这会导致索引无法生效，数据库将会执行全表扫描来搜索匹配的行。</p></li><li><p><strong>头部模糊查询</strong>（尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效） </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%软件%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>因为 % 通配符表示匹配任意数量的字符，导致数据库无法使用索引进行快速查找，而需要执行全表扫描来搜索匹配的行</p></li><li><p><strong>OR连接条件</strong>  OR连接多个条件时，如果一个条件不能使用索引，就需要全表扫描，导致索引失效。这是因为 OR 运算符要求数据库同时检索满足两个条件的数据，而无法利用单一列的索引进行快速查找。我们将查询拆分为两个独立的查询，并分别使用适当的索引，以提高查询性能，可以考虑用union 或者 union all将结果连接起来来替代or</p></li><li><p><strong>联合索引（多列索引）不满足最左前缀法则</strong>。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p></li><li><p>**联合索引中，出现范围查询(&gt;,&lt;)**，范围查询右侧的列索引失效,因为**前一个条件**相等的情况下 **当前条件**才会是**有序的**。<br>当**前一个条件**不同 那么无法保证**当前条件**为有序的 所以索引失效。当范围查询使用&gt;&#x3D; 或 &lt;&#x3D; 时，分为两种， “&#x3D;”走联合索引，不会使右侧的列索引失效， “&lt;” 或者“&gt;”会使索引失效</p></li><li><p><strong>当查询条件使用了is null 或者 is not null</strong>，由于null值不能使用索引，索引也会失效。</p></li><li><p><strong>索引字段上使用 !&#x3D; 或者 &lt;&gt;</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">!=</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure><p>MySQL 的 B-Tree 索引存储的是有序的键值，它只能高效地利用索引来定位特定键值或键值范围的数据。</p><p>但是，使用 !&#x3D; 操作符相当于一个不等条件，无法构建有效的键值范围，因此 MySQL 通常会选择不使用索引，而执行全表扫描来获取结果。</p><p>可以使用等于操作符 &#x3D; 和 NOT 运算符来取代 !&#x3D;，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure><p>或者使用等价的条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="keyword">NOT</span> (age <span class="operator">=</span> <span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>这样可以有效利用索引，提高查询性能。</p></li><li><p><strong>使用not in 或not exists</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_items <span class="keyword">WHERE</span> order_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_id <span class="keyword">FROM</span> orders);</span><br></pre></td></tr></table></figure><p>在这个查询中，子查询 (SELECT order_id FROM orders) 会返回所有的订单ID。如果 orders 表中的订单ID较多，子查询的结果集会很大，导致 MySQL 在执行主查询时需要扫描大量数据，无法高效地利用索引。这可能导致索引失效，性能下降。</p><p>使用 NOT EXISTS：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_items oi <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> orders o <span class="keyword">WHERE</span> o.order_id <span class="operator">=</span> oi.order_id);</span><br></pre></td></tr></table></figure><p>这个查询会查询 order_items 表中的订单项，并使用子查询 (SELECT 1 FROM orders o WHERE o.order_id &#x3D; oi.order_id) 来判断是否存在对应的订单。尽管 NOT EXISTS 子查询只需要找到第一个匹配的结果，就可以确定不存在匹配的结果，但是如果子查询中的条件复杂或执行计划不佳，也可能导致索引失效或影响查询性能。</p><p>为了避免这种情况，可以考虑使用其他方式，比如使用 LEFT JOIN 结合 IS NULL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> oi.<span class="operator">*</span> <span class="keyword">FROM</span> order_items oi <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders o <span class="keyword">ON</span> o.order_id <span class="operator">=</span> oi.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p>这种方式可以利用 LEFT JOIN 并检查 orders 表中的订单ID是否为 NULL，来确定哪些订单项没有对应的订单。这样就能更有效地利用索引，提高查询性能。</p></li><li><p><strong>order by 排序顺序与索引的顺序不匹配</strong>：</p><p>索引是按照升序（ASC）排列的，而我们尝试以降序（DESC）进行排序。虽然数据库可以通过排序结果的逆向扫描来实现降序排序，但这可能会导致索引失效，因为索引无法直接按照所需的顺序匹配。</p></li><li><p>MySQL优化器<strong>评估不走索引比走索引还快</strong>，索引也失效。</p></li></ol><h4 id="如何去合理地创建表的索引"><a href="#如何去合理地创建表的索引" class="headerlink" title="如何去合理地创建表的索引"></a>如何去合理地创建表的索引</h4><ul><li><strong>针对于查询比较频繁建立索引：</strong>常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li><li><strong>尽量选择区分度高的列作为索引</strong>，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li><strong>建立前缀索引</strong>：字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li><strong>建立联合索引</strong>：对进程需要同时查询多个列的语句，建立联合索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li><strong>要控制索引的数量</strong>：索引越多，每次插入删除数据都需要找到多棵B+树进行操作，维护索引结构的代价也就越大，会影响增删改的效率</li><li><strong>定期维护索引</strong>：定期维护索引可以清理无用的索引，以保证数据库的正常运行</li></ul><h4 id="B-树的查询时间复杂度："><a href="#B-树的查询时间复杂度：" class="headerlink" title="B+树的查询时间复杂度："></a>B+树的查询时间复杂度：</h4><p>B+树的搜索过程中的IO次数 &#x3D; 搜索过程中访问节点的数量 &#x3D; B+树的深度 &#x3D; logmN，其中m为B+树一个节点的度数</p><h4 id="通过索引查询数据，会经历几次磁盘IO"><a href="#通过索引查询数据，会经历几次磁盘IO" class="headerlink" title="通过索引查询数据，会经历几次磁盘IO"></a>通过索引查询数据，会经历几次磁盘IO</h4><p>B+树一般高度为3层（3层可以存放约2000W行数据）</p><ul><li><p>如果查询建立了聚集索引，或者能够使用覆盖索引，就不需要回表，也就是需要B+树的层高次，</p></li><li><p>否则要查两次索引，也就是两倍层高次</p></li></ul><p><strong>B+树数据的存储能有多少呢?</strong></p><ol><li>对于非叶子节点，如果key使用的是bigint，则为8字节，指针在mysql中为6字节，一共是14字节，则16k能存放 16 * 1024 &#x2F; 14 &#x3D; 1170 个索引指针。</li><li>对于叶子节点，如果一行数据大小为1k，那么一页就能存16条数据；</li></ol><p><strong>于是可以算出</strong></p><p>高度为2的B+树(18720 条数据)</p><ul><li>根节点存储索引指针节点，那么它有1170个叶子节点存储数据，每个叶子节点可以存储16条数据，一共 1170 x 16 &#x3D; 18720 条数据。</li></ul><p>而对于高度为3的B+树(21902400 条数据)</p><ul><li>就可以存放 1170 x 1170 x 16 &#x3D; 21902400 条数据（两千多万条数据），也就是对于两千多万条的数据，</li></ul><h4 id="为什么Mysql页设置为16KB"><a href="#为什么Mysql页设置为16KB" class="headerlink" title="为什么Mysql页设置为16KB"></a>为什么Mysql页设置为16KB</h4><p>mysql的数据是放在页里面的,一次数据I&#x2F;O至少加载一页数据.这样是为了减少I&#x2F;O资源浪费</p><p> mysql设置16K的大小，数据就可以存<strong>2千多万</strong>就已经足够了吧，既能保证一次磁盘IO不要Load太多的数据 又能保证一次load的性能，即便表的数据在几千万的数量也能保证树的高度在一个可控的范围。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="MySQL锁概述"><a href="#MySQL锁概述" class="headerlink" title="MySQL锁概述"></a>MySQL锁概述</h4><p>锁是计算机协调多个进程或线程并发访问某一资源的机制，在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源，所以数据库也需要使用不同的锁来保证数据并发访问的一致性、有效性，锁冲突也是影响数据库并发访问性能的一个重要因素，所以锁对于数据库是很重要的。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ul><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据</li></ul><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p><strong>锁定数据库中的所有表</strong></p><p>特点：</p><ul><li>加锁后整个数据库实例处于只读状态，</li><li>后续的DML语句，DDL语句，事务提交语句均被阻塞。</li><li>如果在主库上备份，整个数据库处于只读状态，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li></ul><p>应用场景：</p><ul><li>全库的逻辑备份，从而获取一致性视图。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加全局锁</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"><span class="comment">-- 备份文件</span></span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p <span class="number">1234</span> itcast <span class="operator">&gt;</span> itcast.sql</span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p><strong>每次操作锁住整张表</strong>。表级锁主要有三类：<strong>表锁、元数据锁、意向锁</strong>。</p><h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5><p>表锁分为两类，表共享读锁(read lock)和表共享写锁(write lock)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加锁</span></span><br><span class="line">lock <span class="keyword">table</span> table_name read<span class="operator">/</span>write</span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">unlock tables <span class="operator">/</span> 客户端断开连接</span><br></pre></td></tr></table></figure><p><strong>读锁</strong></p><p>客户端A对表a加上读锁，则A和其他客户端均不能执行DDL和DML语句，均可以执行DQL语句，直到客户端A释放读锁。</p><p><img src="/./../../imgs/MySQL/%E8%AF%BB%E9%94%81.png" alt="读锁"></p><p><strong>写锁</strong></p><p>客户端A对表a加上写锁，则A可以执行DDL&#x2F;DML&#x2F;DQL语句，其他客户端均不可以执行DDL&#x2F;DML&#x2F;DQL语句，直到客户端A释放锁。</p><p><img src="/./../../imgs/MySQL/%E5%86%99%E9%94%81.png" alt="写锁"></p><h5 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a>元数据锁（MDL）</h5><p>MDL加锁过程由系统自动控制，不需要显式使用</p><p>在表中有活动事务时，不可以对元数据进行写入操作，元数据简单来说就是一张表的表结构，简单来说就是防止DML语句和DDL语句的冲突，有事务时不能修改表结构，保证读写的正确性。</p><table><thead><tr><th>对表的操作</th><th>加的MDL锁</th></tr></thead><tbody><tr><td>DML和DQL语句(增删改查)</td><td>MDL读锁（共享）</td></tr><tr><td>DDL语句(修改表结构)</td><td>MDL写锁(排他)</td></tr></tbody></table><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p><strong>意向锁是为了防止行锁与表锁发生冲突</strong>，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p><ul><li>当一个事务修改某一行数据时有可能会对表加上行锁，此时如果有另一个事务试图对表加上表锁，就有可能发生锁冲突，表锁需要检查每行数据是否加锁。</li><li>为了防止这种情况，第一个事务在加行锁之前会对整张表加上意向锁，记录行锁信息，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。</li></ul><p>意向锁分为意向共享锁和意向排他锁。意向锁之间不会互斥。</p><p>意向共享锁（IS）：由语句select…lock in share mode添加。与表锁读锁兼容，与表锁写锁互斥。</p><p>意向排他锁（IX）：由insert，update，delect，select…for update添加。与表锁的写锁和读锁都互斥。</p><p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><p><strong>每次操作锁住对应的行数据</strong>。只存在于InnoDB存储引擎之中。行级锁是针对主键索引加锁。行级锁主要分为三类，行锁（Record Lock），间隙锁（Gap Lock），Next-Key Lock。</p><h5 id="行锁-Record-Lock"><a href="#行锁-Record-Lock" class="headerlink" title="行锁 - Record Lock"></a>行锁 - Record Lock</h5><p>锁定单个记录，防止其他事务对此进行update和delete，在读提交和可重复读的隔离级别下均支持。行锁分为两类，<strong>共享锁</strong>和<strong>排他锁</strong>，共享锁之间兼容，排他锁与共享锁和排他锁均不兼容。基本语句的行锁加锁情况如下：</p><p><img src="/./../../imgs/MySQL/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8A%A0%E9%94%81%E6%83%85%E5%86%B5.png" alt="基本语句的行锁加锁情况"></p><p>特点</p><ul><li>使用update或delete针对唯一索引已存在的记录进行等值匹配时，表锁会优化为行锁，只锁目标记录。</li><li>如果不用索引检索数据，语句不走索引，那么InnoDB会对所有的记录加锁，此时行锁升级为表锁。</li></ul><h5 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁 - Gap Lock"></a>间隙锁 - Gap Lock</h5><p>间隙锁 是 <strong>Innodb 在 RR(可重复读) 隔离级别</strong> 下为了解决<code>幻读问题</code>时引入的锁机制。<strong>间隙锁是innodb中行锁的一种</strong>。</p><p>锁定索引之间的间隙，确保索引之间的间隙不变，防止其他事务对这个间隙的insert的操作。</p><p>请务必牢记：<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据</strong>。</p><p>举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,…,100,101，下面的SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empid <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure><p>当我们用条件检索数据，并请求共享或排他锁时，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p><p>这个时候如果你插入empid等于102的数据的，如果那边事物还没有提交，那你就会处于等待状态，无法插入数据。</p><p>间隙锁在innoDB中的唯一作用就是在一定的“间隙”内防止其他事务的插入操作，以此防止幻读的发生：</p><ul><li>使用update或delete针对<strong>唯一索引</strong>上不存在的记录进行等值匹配时，InnoDB会对数据加上间隙锁，左开右闭。此时会阻塞这个间隙中的insert语句。</li><li>间隙锁之间兼容，同一个间隙可以重复加锁</li><li>普通索引（非唯一索引）上的等值查询向右遍历到第一个不满足要求的记录时，next-key退化为间隙锁，锁住 查询的值所在的区间</li></ul><h5 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h5><ul><li>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</li></ul><p><strong>临键锁</strong>只与<strong>非唯一索引列</strong>有关，在<strong>唯一索引列（包括主键列）上不存在临键锁。</strong>当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。</p><p>当查询的索引含有唯一属性（唯一索引，主键索引）时，Innodb存储引擎会对next-key lock进行优化，将其降为record lock,即仅锁住索引本身，而不是范围，因为是唯一索引，不会插入重复的数据，不会造成幻读。</p><h5 id="何时使用行锁，何时产生间隙锁"><a href="#何时使用行锁，何时产生间隙锁" class="headerlink" title="何时使用行锁，何时产生间隙锁"></a>何时使用行锁，何时产生间隙锁</h5><ol><li>只使用<strong>唯一索引查询</strong>，并且<strong>只锁定一条记录</strong>时，innoDB会<strong>使用行锁</strong>，因为是唯一索引，不能插入已经重复的数据，造成幻读。</li><li>只使用<strong>唯一索引查询</strong>，但是检索条件是<strong>范围检索</strong>，或者是<strong>唯一检索然而检索结果不存在</strong>（试图锁住不存在的数据）时，会产生 <strong>Next-Key Lock</strong>。</li><li>使用<strong>普通索引检索</strong>时，不管是何种查询，<strong>只要加锁</strong>，都会<strong>产生间隙锁</strong>。</li><li>同时使用<strong>唯一索引</strong>和<strong>普通索引</strong>时，由于数据行是<strong>优先根据普通索引排序</strong>，再根据唯一索引排序，所以<strong>也会产生间隙锁</strong>。</li></ol><h4 id="mysql：死锁是什么？-实习中你有遇到死锁的情况吗"><a href="#mysql：死锁是什么？-实习中你有遇到死锁的情况吗" class="headerlink" title="mysql：死锁是什么？ 实习中你有遇到死锁的情况吗"></a>mysql：死锁是什么？ 实习中你有遇到死锁的情况吗</h4><p><strong>1、产生原因：</strong></p><p>所谓死锁：是指两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用，它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。</p><ul><li>死锁的关键在于：两个(或以上)的线程加锁的顺序不一致。</li><li>那么对应的解决死锁问题的关键就是：让不同的线程加锁有次序</li></ul><p><strong>2、产生示例：</strong></p><p>案例一</p><p>需求：将投资的钱拆成几份随机分配给借款人。</p><p>起初业务程序思路是这样的：</p><p>投资人投资后，将金额随机分为几份，然后随机从借款人表里面选几个，然后通过一条条select for update 去更新借款人表里面的余额等。</p><p>例如两个用户同时投资，A用户金额随机分为2份，分给借款人1，2</p><p>B用户金额随机分为2份，分给借款人2，1</p><p>由于加锁的顺序不一样，死锁当然很快就出现了。</p><p>对于这个问题的改进很简单，直接把所有分配到的借款人直接一次锁住就行了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> xxx <span class="keyword">where</span> id <span class="keyword">in</span> (xx,xx,xx) <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><h4 id="乐观锁与悲观锁，在MySQL中怎么实现"><a href="#乐观锁与悲观锁，在MySQL中怎么实现" class="headerlink" title="乐观锁与悲观锁，在MySQL中怎么实现"></a>乐观锁与悲观锁，在MySQL中怎么实现</h4><p>悲观锁，比较消极的一种锁处理方式。直接在操作数据时，抢占锁。其他的事务在进行时就会等待，直到占有锁的事务释放锁为止。</p><p>​    这种处理方式能保证数据的最大一致性，但是容易导致锁超时、并发程度低等问题。 首先我们开启事务一，并且对id&#x3D;1的数据进行update操作，此时我们不提交事务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql root@127.0.0.1:demo&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.002s</span><br><span class="line">mysql root@127.0.0.1:demo&gt; update `user` <span class="built_in">set</span> name = <span class="string">&#x27;张三111111&#x27;</span><span class="built_in">where</span> <span class="built_in">id</span> = 1;</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line">Time: 0.004s</span><br></pre></td></tr></table></figure><p>​    接着我们开启事务二，对id&#x3D;1的数据进行update操作，查看此时会发生什么情况？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql root@127.0.0.1:demo&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.002s</span><br><span class="line">mysql root@127.0.0.1:demo&gt; update `user` <span class="built_in">set</span> sex = 1 <span class="built_in">where</span> <span class="built_in">id</span> = 1;</span><br></pre></td></tr></table></figure><p>​    我们执行完update语句之后，就处于等待状态，SQL语句也不会马上被执行，这是因为事务一没有commit，也就没有释放id&#x3D;1的数据对应的写锁。</p><p>乐观锁认为数据一般情况下不会造成冲突，只有当数据去执行修改情况时，才会针对数据冲突做处理。这里是如何发现冲突了呢？常规的方式，都是在数据行上加一个版本号或者时间戳等字段。(本文使用version作为版本号方式，使用时间戳方式同理)</p><p>​    <strong>乐观锁的实现原理：</strong></p><ul><li>一个事务在读取数据时，将对应的版本号字段读取出来，假设此时的版本号是1。    </li><li>另外一个事务也是执行同样的读取操作。当事务一提交时，对版本号执行+1，此时该数据行的版本号就是2。    </li><li>第二个事务执行修改操作时，针对业务数据做条件，并默认增加一个版本号作为where条件。此时修改语句中的版本号字段是不满足where条件，该事务执行失败。通过这种方式来达到锁的功能。</li></ul><h4 id="MySQL如何解决幻读"><a href="#MySQL如何解决幻读" class="headerlink" title="MySQL如何解决幻读"></a>MySQL如何解决幻读</h4><p><strong>快照读</strong></p><p>快照读，读取的是<strong>快照数据</strong>，不加锁的普通 SELECT 都属于快照读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure><p>通过mvcc机制来解决幻读</p><p><strong>当前读</strong></p><p>当前读就是读的是<strong>最新数据</strong>，而不是历史的数据，加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> <span class="keyword">values</span> ...</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ...</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> ...</span><br></pre></td></tr></table></figure><p>在当前读的条件下，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li><li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止，使用间隙锁锁住区间。</li></ul><p><em>间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会</em><br><em>阻止另一个事务在同一间隙上采用间隙锁。</em></p><p><a href="https://juejin.cn/post/7056583607929798692">MySQL 如何解决幻读（MVCC 原理分析） - 掘金 (juejin.cn)</a></p><h4 id="MVCC机制"><a href="#MVCC机制" class="headerlink" title="MVCC机制"></a>MVCC机制</h4><p>详见<a href="https://juejin.cn/post/7016165148020703246#heading-24">看一遍就理解：MVCC原理详解 - 掘金 (juejin.cn)</a></p><p>InnoDB还会自动的给我们每一条数据添加三个隐藏字段及其含义分别是</p><p><img src="/./../../imgs/MySQL/image-20231003112043284.png" alt="image-20231003112043284"></p><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><p>当某个事务执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，<br>并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/./../../imgs/MySQL/image-20231003112046405.png" alt="image-20231003112046405"></p><p>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致<strong>该记录的undolog生成一条记录版本链表</strong>，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><p>ReadView（读视图）是<strong>快照读 SQL执行时MVCC提取数据的依据</strong>，记录并维护系统当前活跃的事务（未提交的）id。</p><p><strong>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</strong></p><p><strong>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView</strong></p><p>ReadView中包含了四个核心字段：</p><p><img src="/./../../imgs/MySQL/image-20231003112049869.png" alt="image-20231003112049869"></p><p>readview中规定版本链数据的访问规则：<br>trx_id 代表当前undolog版本链对应事务ID。</p><p><img src="/./../../imgs/MySQL/image-20231003112052634.png" alt="image-20231003112052634"></p><h4 id="MySQL-事务的可重复读和读已提交，Read-View-时机"><a href="#MySQL-事务的可重复读和读已提交，Read-View-时机" class="headerlink" title="MySQL 事务的可重复读和读已提交，Read View 时机"></a>MySQL 事务的可重复读和读已提交，Read View 时机</h4><ul><li>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li><li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li></ul><h4 id="MVCC完全解决了幻读吗？"><a href="#MVCC完全解决了幻读吗？" class="headerlink" title="MVCC完全解决了幻读吗？"></a>MVCC完全解决了幻读吗？</h4><p>整个发生幻读的时序图如下：</p><p><img src="/./../../imgs/MySQL/%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png" alt="img"></p><p>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id &#x3D; 5 的记录并提交。接着，事务 A 对 id &#x3D; 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</p><p>因为这种特殊现象的存在，所以我们认为 <strong>MySQL Innodb 中的 MVCC 并不能完全避免幻读现象</strong></p><h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><h4 id="SQL优化（常规）"><a href="#SQL优化（常规）" class="headerlink" title="SQL优化（常规）"></a>SQL优化（常规）</h4><h5 id="插入数据优化"><a href="#插入数据优化" class="headerlink" title="插入数据优化"></a>插入数据优化</h5><ol><li><p>批量插入数据 <code>Insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;); </code></p></li><li><p>手动控制事务 ，避免频繁开启、提交事务</p><p><code>start transaction; insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;); insert into tb_test values(4,&#39;Tom&#39;),(5,&#39;Cat&#39;),(6,&#39;Jerry&#39;); insert into tb_test values(7,&#39;Tom&#39;),(8,&#39;Cat&#39;),(9,&#39;Jerry&#39;); commit;</code></p></li><li><p>主键顺序插入，性能要高于乱序插入，乱序插入会出现页分裂会降低效率。</p></li><li><p>一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，可以使用MySQL数据库提供的load指令进行插入</p><p><code>-- 客户端连接服务端时，加上参数 -–local-infile</code><br><code>mysql –-local-infile -u root -p</code><br><code>-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</code><br><code>set global local_infile = 1;</code><br><code>-- 执行load指令将准备好的数据，加载到表结构中</code><br><code>load data local infile &#39;/root/sql1.log&#39; into table tb_user fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39; ;</code></p></li></ol><h5 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h5><ul><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改</li></ul><h5 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h5><ul><li>在分组操作时，可以通过索引来提高效率。</li><li>分组操作时，索引的使用也是满足最左前缀法则的。</li></ul><h5 id="表连接优化"><a href="#表连接优化" class="headerlink" title="表连接优化"></a>表连接优化</h5><ul><li>经常在连接的列上,也是外键上创建索引,可以加快连接的速度；</li><li>合理选择驱动表，小表驱动大表。减少创建连接的次数，因为小表连接一次可以在大表中查询多次。</li><li>合理添加过滤条件可以显著减少扫描次数。</li></ul><p>left join的情况下，对右表加索引，左表是驱动表，左连接就是左边都要查出来，所以左边还是all，但是右边是ref了。</p><h5 id="子查询怎么优化"><a href="#子查询怎么优化" class="headerlink" title="子查询怎么优化"></a>子查询怎么优化</h5><p>把子查询转化为表连接，并在右表的连接字段（外键）建立索引实现优化</p><h5 id="limit优化-深度分页怎么优化？"><a href="#limit优化-深度分页怎么优化？" class="headerlink" title="(limit优化)深度分页怎么优化？"></a>(limit优化)深度分页怎么优化？</h5><p><strong>为什么深度分页比较慢？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,balance <span class="keyword">from</span> account <span class="keyword">where</span> update_time<span class="operator">&gt;</span> <span class="string">&#x27;2020-09-19&#x27;</span> limit <span class="number">100000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这条sql的执行流程:</p><ul><li>先从update_time的索引树中找到100010条满足条件的记录，返回主键id给server，server再从主键树中回表查询100010行记录，然后扔掉前面100000行</li></ul><p>由于扫描了100000行无用的记录，还要回表100010次，所以效率很低。</p><ol><li><strong>子查询优化</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,balance <span class="keyword">FROM</span> account <span class="keyword">where</span> id <span class="operator">&gt;=</span> (<span class="keyword">select</span> a.id <span class="keyword">from</span> account a <span class="keyword">where</span> a.update_time <span class="operator">&gt;=</span> <span class="string">&#x27;2020-09-19&#x27;</span> limit <span class="number">100000</span>, <span class="number">1</span>) LIMIT <span class="number">10</span></span><br></pre></td></tr></table></figure><p>一种优化思路是减少回表次数，即子查询优化。即从二级索引树中取出来记录的第一条的主键ID，这个过程是不用回表的，因为2级树的叶子节点中有ID，取到第一个记录的ID，再回到主键树从这个ID开始取十个数，大大减少了回表次数，从而提高了查询效率。</p><ol start="2"><li><strong>延迟关联</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  acct1.id,acct1.name,acct1.balance <span class="keyword">FROM</span> account acct1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> a.id <span class="keyword">FROM</span> account a <span class="keyword">WHERE</span> a.update_time <span class="operator">&gt;=</span> <span class="string">&#x27;2020-09-19&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a.update_time LIMIT <span class="number">100000</span>, <span class="number">10</span>) <span class="keyword">AS</span>  acct2 <span class="keyword">on</span> acct1.id<span class="operator">=</span> acct2.id;</span><br></pre></td></tr></table></figure><p>这个思路也是和子查询优化差不多，同样是先找好ID再回表，区别是从二级索引树中先找出对应的n条数据再两表联查。</p><ol start="3"><li><strong>游标标记法</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span>  birth_date <span class="operator">&gt;</span><span class="string">&#x27;1955-01-01&#x27;</span> <span class="keyword">and</span> emp_no <span class="operator">&gt;</span> <span class="number">229225</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> emp_no limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>记录上一次查询到的主键ID，下一次直接从主键树中该ID往后查询。缺点是在查询过程中数据库数据变化可能导致查询的数据不准，并且要求字段自增，并且每次查询要知道上一次查询结果中的最大Id，所以不能跳页查看，只能前后翻页。</p><h5 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h5><table><thead><tr><th>count(数字)</th><th>InoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，<strong>放一个数字“1”进去，直接按行进行累加</strong>。</th></tr></thead><tbody><tr><td>count(*)</td><td>InnoDB引擎<strong>并不会把全部字段取出来</strong>，而是专门做了优化，不取值，服务层直接按行进行累加。</td></tr><tr><td>count(字段)</td><td>没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，<strong>服务层判断是否为null.不为null，计数累加</strong>。有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</td></tr></tbody></table><p>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(※)，所以尽量使用 count(*※)。</p><h5 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h5><p>尽量给要Update的字段加索引，将表锁降为行锁，缓解锁冲突阻塞。</p><h5 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h5><p><a href="https://mp.weixin.qq.com/s/BLsd1b57-hlILzFvf9Gf0A">https://mp.weixin.qq.com/s/BLsd1b57-hlILzFvf9Gf0A</a></p><p>order by原理：</p><p>查找1000个杭州人，按照名字排序</p><p><img src="/./../../imgs/MySQL/20190505204141450.png" alt="img"></p><h6 id="全字段索引"><a href="#全字段索引" class="headerlink" title="全字段索引"></a>全字段索引</h6><p>我们需要在city上添加一个索引。 我们在执行explain命令来看看这个语句的执行情况。</p><p><img src="/./../../imgs/MySQL/2019050520441242.png" alt="在这里插入图片描述"></p><p>Extra这个字段中的”Using filesort“ 表示的就是需要排序，MySql会给每个线程分配分配一块内存用于排序，称为sort_buffer。</p><p><img src="/./../../imgs/MySQL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyOTYxNjU=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>从图中可以看到，满足city&#x3D;‘杭州’条件的行，是从ID_X到ID_(X+N)的这些记录。<br>通常情况下，这个语句执行流程如下所示：</p><ol><li>初始化sort_buffer, 确定放入name、city、age这三个字段;</li><li>从索引city找到第一个满足city&#x3D;“杭州” 条件的主键id，也就是图中的ID_X;</li><li>到主建索引取出整行数据（回表查询），取name、city、age 三个 字段的值，存入sort_buffer中;</li><li>从索引city取下一个记录的主键id ;</li><li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y;</li><li>对sort_buffer 中的数据<strong>按照字段name做快速排序</strong>;</li><li>按照排序结果取前1000行返回给客户端;</li></ol><p><img src="/./../../imgs/MySQL/640-1713193636636-6.webp" alt="图片"></p><p><img src="/./../../imgs/MySQL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyOTYxNjU=,size_16,color_FFFFFF,t_70-1711682366199-8.png" alt="在这里插入图片描述"></p><p>按照字段 username 做快速排序这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和 sort_buffer 的大小，由参数 <code>sort_buffer_size</code> 决定。</p><p>如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则就需要利用<strong>磁盘临时文件</strong>来辅助排序。</p><p>解释下这里使用磁盘临时文件来进行辅助排序的含义，外部排序常用的排序算法是<strong>多路归并排序算法</strong>，具体步骤如下：</p><ul><li>到主键 id 索引树上查找到对应的整行数据后，取 city、username、age 三个字段的值，存入 sort_buffer 中，能存多少是多少，当 sort_buffer 快要满时，就对 sort_buffer 中的<strong>数据进行排序</strong>，排完后，把数据<strong>临时放到磁盘的一个小文件</strong>中，然后<strong>清空 sort_buffer</strong>（这样的话，一个很大的数据，就会被分成若干个临时磁盘文件）</li><li>继续回到主键 id 索引树取数据，重复上一步，直到取出所有满足条件的数据</li><li>最后，<strong>归并已经有序的若干个临时磁盘文件</strong>，形成一个完整的有序大文件</li></ul><p>可以看出，整个排序过程，我们要查询的 city、username、age 全都参与了，所以，暂且把这个排序过程，称为<strong>全字段排序</strong></p><p><strong>routId 排序</strong><br>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。但这个算法有一个问题，如果查询返回的数据字段多，那么内存中放的数据就要分成多个临时文件，排序的性能就会很差。</p><p>修改参数 max_length_for_sort_data,是MySql中专门控制用于排序的行数据的长度的一个参数，它的意思是，如果单行的长度超过这个值 ，MySQL就认为单行太大，要换一个算法。</p><p><img src="/./../../imgs/MySQL/2019050521265030.png" alt="在这里插入图片描述"></p><p>city,name,age这三个字段的定义总长度是36，我把max_length_for_sort_data设置为16，那么放入sort_buffer的字段只有要排序的列(即 name 字段 是order by 后面的关键字)和主键id。<br>但这时，排序的结果就因为少了city和age字段的值 ，不能直接返回了，整个执行的流程就变成 如下所示的样子:</p><ol><li><p>初始化sort_buffer，确定放入两个字段，即name和id;</p></li><li><p>从索引city找到第一个满足city&#x3D;’上海’条件的主键,也就是图中的ID_X;</p></li><li><p>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中;</p></li><li><p>从索引city取下一个记录的主键id;</p></li><li><p>重复3、4步骤，直到找到不city!&#x3D;‘杭州’;</p></li><li><p>对sort_buffer中的数据按照name进行排序;</p></li><li><p>遍历排序结果，取前1000行，并按照id的值回到原表中的city、name和age三个字段返回给客户端。</p></li></ol><p><img src="/./../../imgs/MySQL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyOTYxNjU=,size_16,color_FFFFFF,t_70-1711682407937-13.png" alt="在这里插入图片描述"></p><h6 id="对排序进行优化"><a href="#对排序进行优化" class="headerlink" title="对排序进行优化"></a>对排序进行优化</h6><p>很显然，如果不排序就能得到正确的结果，那对系统的消耗会小很多，语句的执行时间也会变得更短。</p><p>从上面分析的执行过程我们可以看到，MySQL 之所以需要 sort_buffer，并且在 sort_buffer 上做排序操作，其原因是原来的数据都是无序的。</p><p>回顾下我们的需求：查询出 city 是 “杭州” 的所有 username，并且按照 username 进行排序，返回前 1000 个人的姓名、年龄。</p><p>那，<strong>如果能够保证从 city 这个索引上取出来的数据行，已经天然就是按照 username 进行递增排序的话，不就不用再排序了吗</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> index_city(city,name);</span><br></pre></td></tr></table></figure><p>这样数据的索引就有按照name进行排序。 这样整个排序过程就变成了下面这样。</p><ul><li><p>从索引(city,name)找到第一个满足city&#x3D;”杭州”条件的主键id;</p></li><li><p><font color = "gold">到主键id索引查找整行数据(回表查询),取name、city、age三个字段的值，作为结果集的一部分直接返回,因为索引中name就已经是有序的了，不需要在内存中继续排序。</font></p></li><li><p>从联合索引取出一个记录主键 id；</p></li><li><p>重复2、3步。</p><p><img src="/./../../imgs/MySQL/640.webp" alt="图片"></p></li></ul><p><img src="/./../../imgs/MySQL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyOTYxNjU=,size_16,color_FFFFFF,t_70-1711682434446-16.png" alt="在这里插入图片描述"></p><p>在使用explain 来分析这个sql</p><p><img src="/./../../imgs/MySQL/20190506211600249.png" alt="在这里插入图片描述"></p><p>可以看到extra字段中没有Using filesort了，也就是不需要排序了。<br>由于覆盖索引的原则，我们可以再进行优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> index_city(city,name,age);</span><br></pre></td></tr></table></figure><p>1）从联合索引 (city, username, age) 树上找到第一个满足 city&#x3D;’杭州’ 条件的记录，把这条记录作为结果集的一部分直接返回；</p><p>2）从联合索引 (city, username, age) 树上取下一个记录，同样将这条记录作为结果集的一部分直接返回</p><p>3）重复执行步骤 2，直到查到第 1000 条记录，或者是不满足 city&#x3D;’南京’ 条件时循环结束</p><p>如下图所示：</p><p><img src="/./../../imgs/MySQL/640-1713193542850-3.webp" alt="图片"></p><p>在使用explain 对sql进行分析</p><p><img src="/./../../imgs/MySQL/20190506211915927.png" alt="在这里插入图片描述"></p><p>发现使用Using index，表示的就是使用了覆盖索引，性能上会快很多。</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li><li>尽量使用覆盖索引，避免fileSort。</li><li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）。</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。</li></ul><ol><li>order by 的基本原理其实就是 MySQL 会给每个线程分配一块内存也就是 sort_buffer 用于排序，sort_buffer 中存储的是 select 涉及到的所有的字段，可以称为全字段排序吧。排序这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和 sort_buffer 的大小，由参数 <code>sort_buffer_size</code> 决定。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，就需要利用磁盘临时文件来辅助排序,临时文件存放的是每一次sort后的有序的部分结果,需要将各个磁盘临时文件归并排序来构成完整的结果集。</li><li>这里其实可以优化下，<strong>只存放排序相关的字段</strong>(包括查询字段和主键id,其中主键id用于回表查询)，而不是 select 涉及的所有字段，这样 sort_buffer 中存放的东西就多一点，就尽可能避免使用磁盘进行外部排序，或者说使得划分的磁盘文件相对变少，减少磁盘访问。这种排序称为 rowid 排序。如果表中单行的长度超过 <code>max_length_for_sort_data</code> 定义的值，那 MySQL 就认为单行太大（那么数据量肯定就越大，sort_buffer 可能不够用），由全字段排序改为 rowid 排序, 再排序结束后再根据id会表查询。</li></ol><p>以上是我们说的关于 order by 的两个参数优化，还可以根据索引进行一些优化</p><ol><li>以 <code>select a, b, c from table where a = xxxx order by b</code> 为例，我们为查询条件 a 和排序条件 b 建立联合索引，联合索引就是 a 是从小到大绝对有序的，如果 a 相同，再按 b 从小到大排序，这样就不需要排序了，直接避免了排序这个操作。</li><li>还可以进一步优化，由于联合索引 (a, b) 中没有 c 的值，所以从联合索引树上获取符合条件的对应主键 id 后，还需要回表查询取出 a b c 的值，这个回表查询的过程可以通过建立 (a,b,c) 覆盖索引来避免。</li></ol><h4 id="SQL优化（技巧）"><a href="#SQL优化（技巧）" class="headerlink" title="SQL优化（技巧）"></a>SQL优化（技巧）</h4><h5 id="使用update更新一个大表，怎么优化"><a href="#使用update更新一个大表，怎么优化" class="headerlink" title="使用update更新一个大表，怎么优化"></a>使用update更新一个大表，怎么优化</h5><ol><li>批量更新，而不是一条一条更新</li><li>在分组、排序之前就过滤，过滤优先于一切</li><li>同时过滤、排序条件的列尽量走索引，过滤走索引才能使用行锁，否则会升级为表锁</li><li>尽量走主键索引，联合索引避免回表查询</li><li>分区表：如果可能的话，考虑将大表分成更小的分区表。这样可以将更新操作限制在特定分区内，减少锁定冲突的机会。</li></ol><h5 id="SQL优化，使用索引的时候怎么优化"><a href="#SQL优化，使用索引的时候怎么优化" class="headerlink" title="SQL优化，使用索引的时候怎么优化"></a>SQL优化，使用索引的时候怎么优化</h5><ol><li><p>避免索引失效：</p><ul><li><p>模糊查询 %放在右边<br>原理：模糊查询的时候尽量在字段后面使用模糊查询最左原则</p></li><li><p>避免使用or</p></li><li><p>在where条件中，等式左侧不要进行表带式、函数操作。</p></li><li><p>查询条件不要用 &lt;&gt; 或者 !&#x3D;</p></li><li><p>使用联合索引要符合最左匹配原则</p></li><li><p>避免出现select *</p></li></ul></li><li><p>优先过滤，尽量避免分组后再过滤</p></li><li><p>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p></li><li><p>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p></li></ol><h4 id="慢sql怎么看-怎么解决"><a href="#慢sql怎么看-怎么解决" class="headerlink" title="慢sql怎么看 怎么解决"></a>慢sql怎么看 怎么解决</h4><h5 id="慢查询日志："><a href="#慢查询日志：" class="headerlink" title="慢查询日志："></a>慢查询日志：</h5><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。如果要开启慢查询日志，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 开启MySQL慢日志查询开关`</span><br><span class="line">slow_query_log<span class="operator">=</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line">#设置慢日志的时间为<span class="number">2</span>秒，<span class="keyword">SQL</span>语句执行时间超过<span class="number">2</span>秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#重启mysql服务</span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>检查慢查询日志 ：在慢查询日志中，只会记录执行时间超多我们预设时间（2s）的SQL，执行较快的SQL是不会记录的。</p><p>那这样，通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化</p><h5 id="profile详情"><a href="#profile详情" class="headerlink" title="profile详情"></a>profile详情</h5><p>可以查看执行时间较长的sql，并且了解时间耗费在哪个步骤</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询数据库是否支持profile</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@have_profiling</span>;</span><br><span class="line"><span class="comment">-- 开启profile的开关</span></span><br><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 查看每一条sql的执行情况</span></span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"><span class="comment">-- 查询指定query_id在sql的各个阶段的耗时</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure><p><strong>用explain分析sql</strong></p><p>[explain有哪些字段，分别有什么含义_explain字段含义-CSDN博客](<a href="https://blog.csdn.net/weixin_50998273/article/details/111938295#:~:text=explain%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89">https://blog.csdn.net/weixin_50998273/article/details/111938295#:~:text=explain有哪些字段，分别有什么含义</a> 1 1. id SQL查询中的序列号。 id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行。 2 2.,查询真正使用到的索引。 … 8 8. key_len 查询用到的索引长度（字节数）。 … 更多项目)</p><p>explain命令可以查看select语句的执行计划，包括表连接顺序以及索引使用情况等等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select_sql;</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/MySQL/explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png" alt="sql的执行计划"></p><ul><li><p>id：指代sql语句中的执行顺序。多表查询中，id相同，执行顺序从上到下，id不同，id值越大越先执行</p></li><li><p>select_type:表示查询类型，常见取值有SIMPLE(简单表，即单表查询)，PRIMARY(子查询中的外层查询)等</p></li><li><p>type：表示查询的连接类型，由好到差依次是<strong>null &gt; system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</strong>。</p><ul><li>system,访问系统表</li><li>const，使用<strong>唯一索引</strong>或者<strong>主键索引</strong>，单表中<strong>最多有一条匹配行</strong>。select * from student where id &#x3D; 1;</li><li>eq_ref ,主键或者唯一索引被连接使用，最多只会返回一个值，常出现在多表查询中。从一个表中查出另一个表的主键然后在另一个表中进行查询。</li><li>ref，使用<strong>普通索引</strong>或者<strong>唯一性索引的部分前缀</strong>，有可能会<strong>返回多条值</strong></li><li>range，使用索引选择行，仅检索给定范围内的行，范围查询。</li><li>index，扫描<strong>全表索引</strong>，比all要快一些</li><li>all，<strong>全表扫描</strong>，效果最差</li></ul></li><li><p>possible_key：查询语句可能用到的索引</p></li><li><p>key：实际使用的索引，如果为NULL则说明没有使用索引</p></li><li><p>key_len：索引使用的字节数，这个值越短越好</p></li><li><p>row：MySQL认为可能扫描的行数，是一个估计值，这个值越小越好</p></li><li><p>filtered：表示返回结果的行数占读取行数的百分比，filtered值越大越好</p></li></ul><p>解决：</p><ol><li>SQL语句优化，尽量精简，去除非必要语句</li><li>索引优化，让所有SQL都能够走索引</li><li>如果是表的瓶颈问题，则分表，单表数据量维持在2000W（理论上）以内</li><li>如果是单库瓶颈问题，则分库，读写分离</li><li>如果是物理机器性能问题，则分多个数据库节点</li></ol><p>第 1 个原因：没有索引或者 导致索引失效。<br>第 2 个原因：单表数据量数据过多，导致查询瓶颈<br>第 3 个原因：网络原因或者机器负载过高。<br>第 4 个原因：热点数据导致单点负载不均衡。</p><p>第 1 种情况：索引失效或者没有没有索引的情况<br>首先，可以打开 MySQL 的慢查询日志，收集一段时间的慢查询日志内容，然后找出耗时最长的 SQL 语句，对这些 SQL 语句进行分析。<br>比如可以利用执行计划 explain 去查看 SQL 是否有命中索引。如果发现慢查询的 SQL 没有命中索引，可以尝试去优化这些 SQL 语句，保证 SQL 走索引执行。如果 SQL 结构没有办法优化的话，可以考虑在表上再添加对应的索引。我们在优化 SQL 或者是添加索引的时候，都需要符合最左匹配原则。</p><p>第 2 种情况：单表数据量数据过多，导致查询瓶颈的情况。即使 SQL 语句走了索引，表现性能也不会特别好。这个时候我们需要考虑对表进行切分。表切分规则一般分为两种，一种是水平切分，一种是垂直切分。水平切分的意思是把一张数据行数达到千万级别的大表，按照业务主键切分为多张小表，这些小表可能达到 100 张甚至 1000 张。</p><p><img src="/./../../imgs/MySQL/image-20240318112030315.png" alt="image-20240318112030315"></p><p>那垂直切分的意思是，将一张单表中的多个列，按照业务逻辑把关联性比较大的列放到同一张表中去。</p><p><img src="/./../../imgs/MySQL/image-20240318112110577.png" alt="image-20240318112110577"></p><p>除了这种分表之外，我们还可以分库，</p><p><img src="/./../../imgs/MySQL/image-20240318112121184.png" alt="image-20240318112121184"></p><p>比如我们已经拆分完 1000 表，然后，把后缀为 0-100 的表放到同一个数据库实例中，然后，100-200 的表放到另一个数据库实例中，依此类推把 1000 表存放到 10 个数据库实例中。这样的话，我们就可以根据业务主键把请求路由到不同数据库实例，从而让每一个数据库实例承担的流量比较小，达到提高数据库性能的目的。</p><p>第 3 种情况：网络原因或者机器负载过高的情况，我们可以进行读写分离.</p><p><img src="/./../../imgs/MySQL/image-20240318112139782.png" alt="image-20240318112139782"></p><p>比如 MySQL 支持一主多从的分布式部署，我们可以将主库只用来处理写数据的操作，而多个从库只用来处理读操作。在流量比较大的场景中，可以增加从库来提高数据库的负载能力，从而提升数据的总体性能。</p><p>第 4 种情况：热点数据导致单点负载不均衡的情况。</p><p><img src="/./../../imgs/MySQL/image-20240318112149545.png" alt="image-20240318112149545"></p><p>这种情况下，除了对数据库本身的调整以外，还可以增加缓存。将查询比较频繁的热点数据预存到缓存当<br>中，比如 Redis、MongoDB、ES 等，以此来缓解数据的压力，从而提高数据库的响应速度。</p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><h4 id="binlog刷盘策略"><a href="#binlog刷盘策略" class="headerlink" title="binlog刷盘策略"></a>binlog刷盘策略</h4><p>mysql只有在事务提交的时候才会记录binlog日志，此时日志还在内存中，那binlog是什么时候被刷到磁盘中的呢？<br>mysql通过sync_binlog控制刷盘，取值范围0~N</p><ul><li>0：不强制要求刷盘，由系统自行判断什么时候将binlog写入磁盘；</li><li>1：每次提交事务就将binlog写入磁盘；</li><li>n：每提交n个事务将binlog写入磁盘；</li></ul><p>显然，sync_binlog为1是最安全的，每次提交事务就将binlog写入磁盘，数据一致性最好。但实际情况中，往往为了提高数据库的性能，会将sync_binlog适当设大，来减少磁盘IO次数，用数据一致性换性能。<br>在对数据库一致性要求不高或数据没那么重要的业务场景，完全可以把sync_binlog设置在100~1000范围内的某个值，以此来提高数据库的性能。而在对数据一致性要求高的业务场景或特别重要的数据，比如订单则建议将sync_binlog的值设置为1，这样可以保证哪怕数据库挂了也不会丢失数据。<br>sync_binlog的默认值是0，这时由系统会自行判断将binlog写入磁盘的时机。数据库可能会在空闲的时候综合考虑缓存的binlog日志大小来决定是否要将binlog写入磁盘。</p><h5 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h5><blockquote><p>由于每一个binlog与事务相关，随事务的提交而提交，所以每一个事务都有一个binlog cache，如果存储内容超过了这个参数，就要暂存到磁盘，待事务提交后一次性写入文件系统的 page cache，而sync_binlog&#x3D;n这个参数表示文件系统积累多少个事务的binlog后一次性刷盘到磁盘，安全性和一致性要求比较高的场景这个值设置为1，磁盘IO压力比较大的情况下可以增大。</p></blockquote><h4 id="binlog组提交"><a href="#binlog组提交" class="headerlink" title="binlog组提交"></a>binlog组提交</h4><p>MySQL引入binlog来实现主从实例之间的数据同步，提高数据库系统的可用性，但同时也增加了事务整体的资源消耗，需要额外的磁盘空间和IO处理能力。尤其是为了保证本地事务的持久性，必须将binlog刷盘控制参数sync_binlog设置为1，设想如果每一次事务提交，都强制进行一次刷盘操作，数据库整体的性能会受到极大的影响。<br>MySQL引入组提交的目的是为了在高并发下合并多个线程的刷盘操作，降低日志刷盘次数，提高数据库的整体性能</p><h4 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog 归档日志"></a>binlog 归档日志</h4><p>binlog是Server层的日志，binlog的主要作用是归档，即可以把数据库恢复到之前一段时间内的任意一天的状态。</p><p>binlog会记录MySQL执行的SQL原始语句，具体流程就是，当MySQL执行一条update语句时，流程如下：</p><ol><li>更新缓存中的对应行，如果缓存中不存在则从数据库中读入内存然后更新。</li><li>将数据页变化写入redo log，此时处于prepare的状态。</li><li>事务提交前，将执行的sql语句写入binlog</li><li>提交事务，redo log处于commit状态</li></ol><p>sync_binlog&#x3D;1时，每次事务的binlog都会持久化到磁盘，建议设置为1.</p><h5 id="binlog-实现-数据库恢复的原理"><a href="#binlog-实现-数据库恢复的原理" class="headerlink" title="binlog 实现 数据库恢复的原理"></a>binlog 实现 数据库恢复的原理</h5><p>数据库一般隔一段时间比如三天或者五天或者七天会做整库备份，而binlog则会保留一段时间的所有sql语句的逻辑操作。所以进行整库备份的流程：</p><ol><li>找到上一次的全量备份的文件，将这个备份恢复到数据库，同时记录备份时间a</li><li>如果想要恢复到时间点b的状态，则将binlog中a和b之间的逻辑操作全部取出来依次执行</li></ol><h5 id="binlog和redo-log的区别"><a href="#binlog和redo-log的区别" class="headerlink" title="binlog和redo log的区别"></a>binlog和redo log的区别</h5><p>binlog用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。binlog是mysql的逻辑日志，并且由Server层进行记录，使用任何存储引擎的mysql数据库都会记录binlog日志。</p><table><thead><tr><th>binlog</th><th>① Server层 ② 逻辑日志，记录原始逻辑 （命令）③ 循环写，空间固定④主从复制，数据恢复</th></tr></thead><tbody><tr><td>redo log</td><td>①引擎层，InnoDB独有 ②物理日志，记录数据页变化 ③追加写，不会覆盖④故障恢复</td></tr></tbody></table><h4 id="讲一讲mysql主从部署"><a href="#讲一讲mysql主从部署" class="headerlink" title="讲一讲mysql主从部署"></a>讲一讲mysql主从部署</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p><p>MySQL 复制的优点主要包含以下三个方面：</p><ul><li>主库出现问题，可以快速切换到从库提供服务。</li><li>实现读写分离，降低主库的访问压力。</li><li>可以在从库中执行备份，以避免备份期间影响主库服务。</li></ul><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>MySQL主从复制的核心就是 二进制日志，具体的过程如下：</p><p><img src="/./../../imgs/MySQL/image-20231003112012277.png" alt="image-20231003112012277"></p><p>从上图来看，复制分成三步：</p><ol><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li><li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ol><h5 id="主从复制的问题？"><a href="#主从复制的问题？" class="headerlink" title="主从复制的问题？"></a>主从复制的问题？</h5><ol><li>同步延迟：由于主从复制是异步执行的，从服务器需要等待主服务器将数据操作记录到二进制日志（BinLog）并传输到从服务器后才能执行。这可能导致从服务器的数据与主服务器存在一定的时间差，从而引起同步延迟。而且从服务器上只有一个 SQL Thread，当主服务器有大量写操作时，复制延时也可能会增大。</li><li>数据一致性：在主从复制过程中，如果主服务器发生故障或网络中断，从服务器可能会丢失部分尚未复制的数据。</li></ol><ul><li><strong>半同步复制</strong>—解决数据丢失的问题</li><li><strong>并行复制</strong>—-解决从库复制延迟的问题</li></ul><p>半同步复制（5.5集成到mysql，以插件的形式存在，需要单独安装）</p><ul><li>该模式下 MySQL 主节点在发送完 BinLog 后不会立刻提交数据，而是至少等待一个从服务器写完 RelayLog 并返回 ACK 消息后，才提交事务</li><li>确保事务提交后binlog至少传输到一个从库</li><li>不保证从库应用完成这个事务的binlog</li><li>性能有一定的降低</li></ul><p><img src="/./../../imgs/MySQL/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2jmn5LlhavkuZ0=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><p><strong>并行复制</strong></p><p>单线程的 SQL Thread Relay 操作在 Master 的 TPS 比较高的情况下，会出现严重的性能瓶颈，进而导致主从同步延迟。</p><p>MySQL 为了解决这个问题，将 SQL Thread 演化成了多个 Worker 的形式，在 Slave 端并行应用 Relay Log 中的事务，从而提升 Relay Log 的应用速度，降低复制延迟</p><p><img src="/./../../imgs/MySQL/curr-relay.webp" alt="relay worker"></p><ul><li>并行是指从库多线程并行应用binlog，同一个库数据更改还是串行的</li></ul><h5 id="搭建主从环境："><a href="#搭建主从环境：" class="headerlink" title="搭建主从环境："></a>搭建主从环境：</h5><p>配置主库，修改配置文件 &#x2F;etc&#x2F;my.cnf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 232-1，默认为1</span><br><span class="line">server-id=1</span><br><span class="line">#是否只读,1 代表只读, 0 代表读写</span><br><span class="line">read-only=0</span><br></pre></td></tr></table></figure><p>重启MySQL服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld </span><br></pre></td></tr></table></figure><p>登录mysql，创建远程连接的账号，并授予主从复制权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#创建itcast用户，并设置密码，该用户可在任意主机连接该MySQL服务</span><br><span class="line">CREATE USER &#x27;itcast&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;Root@123456&#x27;</span><br><span class="line">;</span><br><span class="line">#为 &#x27;itcast&#x27;@&#x27;%&#x27; 用户分配主从复制权限</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;itcast&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>通过指令，查看二进制日志坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status ;</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/MySQL/image-20231003112018880.png" alt="image-20231003112018880"></p><p>字段含义说明：<br>file : 从哪个日志文件开始推送日志文件<br>position ： 从哪个位置开始推送日志<br>binlog_ignore_db : 指定不需要同步的数据库</p><h5 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h5><p>修改配置文件 &#x2F;etc&#x2F;my.cnf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，和主库不一样即可</span><br><span class="line">server-id=2</span><br><span class="line">#是否只读,1 代表只读, 0 代表读写</span><br><span class="line">read-only=1</span><br></pre></td></tr></table></figure><p>重新启动MySQL服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>登录mysql，设置主库配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CHANGE REPLICATION SOURCE TO SOURCE_HOST=&#x27;192.168.200.200&#x27;, SOURCE_USER=&#x27;itcast&#x27;,</span><br><span class="line">SOURCE_PASSWORD=&#x27;Root@123456&#x27;, SOURCE_LOG_FILE=&#x27;binlog.000004&#x27;,</span><br><span class="line">SOURCE_LOG_POS=663;</span><br><span class="line">或者</span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.200.200&#x27;, MASTER_USER=&#x27;itcast&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;Root@123456&#x27;, MASTER_LOG_FILE=&#x27;binlog.000004&#x27;,</span><br><span class="line">MASTER_LOG_POS=663;</span><br></pre></td></tr></table></figure><p>开启同步操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start replica ; #8.0.22之后</span><br><span class="line">start slave ; #8.0.22之前</span><br></pre></td></tr></table></figure><p>查看主从同步状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show replica status ; #8.0.22之后</span><br><span class="line">show slave status ; #8.0.22之前</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/MySQL/image-20231003112023725.png" alt="image-20231003112023725"></p><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><p>分库分表的原因：</p><ul><li>当某一个数据库被访问得特别频繁时，有可能会占用绝大部分的服务器磁盘IO和网络IO，影响同一台服务器上的其他数据，此时可以将数据库进行拆分，将一台服务器上的数据库拆分到多台服务器上。</li><li>当表的数据量特别大或者表中的字段很多时，可以将字段进行拆分或者分散到多张表中，提高查询效率以及更新效率。</li></ul><h5 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h5><p>垂直拆分</p><p>垂直分库：以表为依据，将不同业务的表拆分到不同的数据库中。</p><p><img src="/./../../imgs/MySQL/image-20240318140611487.png" alt="image-20240318140611487"></p><ul><li>每个库的表结构都不一样。</li><li>每个库的数据也不一样。</li><li>所有库的并集是全量数据。</li></ul><p>垂直分表：以字段为依据，将一张表中的字段进行分类拆分到不同的表中。不同表可以通过外键进行关联</p><p><img src="/./../../imgs/MySQL/image-20240318140637932.png" alt="image-20240318140637932"></p><ul><li>每个表的结构都不一样。</li><li>每个表的数据也不一样，一般通过一列（主键&#x2F;外键）关联。</li><li>所有表的并集是全量数据。</li></ul><p>水平拆分</p><ul><li>水平分库，将数据库中的表复制到多个服务器数据库中，每个数据库中的表结构都是一样的，各自存储一部分的数据。</li></ul><p><img src="/./../../imgs/MySQL/image-20240318141105540.png" alt="image-20240318141105540"></p><ul><li>每个库的表结构都一样。</li><li>每个库的数据都不一样。</li><li>所有库的并集是全量数据。</li></ul><ul><li>水平分表：将一张表拆分成多个结构相同的表，每个表中保存一部分数据。</li></ul><p><img src="/./../../imgs/MySQL/image-20240318141154799.png" alt="image-20240318141154799"></p><ul><li>每个表的表结构都一样。</li><li>每个表的数据都不一样。</li><li>所有表的并集是全量数据</li></ul><h5 id="分片规则"><a href="#分片规则" class="headerlink" title="分片规则"></a>分片规则</h5><p>范围分片：根据指定的字段及其配置的范围与数据节点的对应情况， 来决定该数据属于哪一个分片。</p><p><img src="/./../../imgs/MySQL/image-20240318144804381.png" alt="image-20240318144804381"></p><p>取模分片：指定的字段值与节点数量进行求模运算，根据运算结果， 来决定该数据属于哪一个分片</p><p><img src="/./../../imgs/MySQL/image-20240318144846254.png" alt="image-20240318144846254"></p><p>哈希切片：对数据库的某个字段进行来求哈希，再除以分片总数后取模，取模后相同的数据为一个分片，这样将数据分成多个分片的方法叫做哈希分片，我们大多数在数据没有时效性的情况下使用哈希分片，就是数据不管是什么时候产生的，系统都需要处理或者查询；复制table_index &#x3D; hash(order_id) % tables_num</p><ul><li>优点：负载均衡，每个表的数据分布相对均匀。</li><li>缺点：不利于二次扩容。</li></ul><p><img src="/./../../imgs/MySQL/image-20240318145159998.png" alt="image-20240318145159998"></p><p>时间切片：按照时间的范围将数据分布到不同的分片上，比如我们可以将交易数据按照与进行切片，或者按照季度进行切片，由交易数据的多少来决定按照什么样的时间周期来进行切片</p><p>这种切片方式适合明显时间特点的数据，常见的就是订单历史查询</p><p><img src="/./../../imgs/MySQL/image-20240318145310059.png" alt="image-20240318145310059"></p><ul><li><p>一致性hash：计算指定字段的hash值，然后根据hash值不同将数据存储在对应节点。而一致性的意思是即使以后增加节点，原来的数据依然会划分到原来的节点，不会因为节点的增加而发生改变，有效的解决了分布式数据的拓容问题。</p><p><img src="/./../../imgs/MySQL/image-20240318145000616.png" alt="image-20240318145000616"></p></li><li><p>枚举分片：枚举指定字段的值来决定数据会被分配到哪个节点。适用于按照省份，状态，性别等进行分片的场景</p><p><img src="/./../../imgs/MySQL/image-20240318145038787.png" alt="image-20240318145038787"></p></li><li><p>应用指定：根据数据的某个字段的一部分（必须是数字）来直接决定数据存储在哪个节点。如01_xx,02_xx,03_xx</p><p><img src="/./../../imgs/MySQL/image-20240318145106020.png" alt="image-20240318145106020"></p></li></ul><h4 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h4><h5 id="普通-hash-算法的缺陷："><a href="#普通-hash-算法的缺陷：" class="headerlink" title="普通 hash 算法的缺陷："></a>普通 hash 算法的缺陷：</h5><p><strong>hash（key）% N</strong></p><p>​        如果增加或者删除服务器节点，那么n的数量就会改变，所有缓存的位置都要发生改变，也就是说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据。</p><ul><li><p>一致性哈希算法将整个哈希值空间按照顺时针方向组织成一个虚拟的圆环，称为 Hash 环；</p></li><li><p>接着将各个服务器使用 Hash 函数进行哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，从而确定每台机器在哈希环上的位置</p></li><li><p>最后使用算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针寻找，第一台遇到的服务器就是其应该定位到的服务器</p></li></ul><p>哈希环的组织：</p><p>​    我们将 2^32 想象成一个圆，像钟表一样，钟表的圆可以理解成由60个点组成的圆，而此处我们把这个圆想象成由2^32个点组成的圆，示意图如下：</p><p><img src="/./../../imgs/MySQL/1dabc6d21275466885e876058dd81d7a.png" alt="img"></p><p>​    圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第一个点代表2^32-1，我们把这个由 2^32 个点组成的圆环称为hash环。</p><p>（2）步骤二：确定服务器在哈希环的位置：</p><p>哈希算法：hash（服务器的IP） % 2^32</p><p>​    上述公式的计算结果一定是 0 到 2^32-1 之间的整数，那么上图中的 hash 环上必定有一个点与这个整数对应，所以我们可以使用这个整数代表服务器，也就是服务器就可以映射到这个环上，假设我们有 ABC 三台服务器，那么它们在哈希环上的示意图如下：</p><p><img src="/./../../imgs/MySQL/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_14,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p> （3）步骤三：将数据映射到哈希环上：</p><p>​    我们还是使用图片的名称作为 key，所以我们使用下面算法将图片映射在哈希环上：hash（图片名称） % 2^32，假设我们有4张图片，映射后的示意图如下，其中橘黄色的点表示图片：</p><p><img src="/./../../imgs/MySQL/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>​    那么，怎么算出上图中的图片应该被缓存到哪一台服务上面呢？我们只要从图片的位置开始，沿顺时针方向遇到的第一个服务器就是图片存放的服务器了。最终，1号、2号图片将会被缓存到服务器A上，3号图片将会被缓存到服务器B上，4号图片将会被缓存到服务器C上。</p><p>一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，只有部分缓存会失效，不至于将所有压力都在同一时间集中到后端服务器上，具有较好的容错性和可扩展性。</p><p>​    假设服务器B出现了故障，需要将服务器B移除，那么移除前后的示意图如下图所示：</p><p><img src="/./../../imgs/MySQL/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>hash 环的倾斜与虚拟节点：<br>        一致性哈希算法在服务节点太少的情况下，容易因为节点分部不均匀而造成数据倾斜问题，也就是被缓存的对象大部分集中缓存在某一台服务器上，从而出现数据分布不均匀的情况，这种情况就称为 hash 环的倾斜。如下图所示：</p><p><img src="/./../../imgs/MySQL/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_20,color_FFFFFF,t_70,g_se,x_16-1712633028188-13.png" alt="img"></p><p>​     hash 环的倾斜在极端情况下，仍然有可能引起系统的崩溃，为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对<strong>每一个服务节点计算多个哈希</strong>，每个<strong>计算结果位置都放置一个此服务节点，称为虚拟节点</strong>，一个实际物理节点可以对应多个虚拟节点，虚拟节点越多，hash环上的<strong>节点就越多</strong>，缓存被均匀分布的概率就越大，hash环倾斜所带来的影响就越小，同时数据定位算法不变，只是多了一步<strong>虚拟节点到实际节点的映射</strong>。<strong>具体做法可以在服务器ip或主机名的后面增加编号来实现</strong>，加入虚拟节点以后的hash环如下：</p><p><img src="/./../../imgs/MySQL/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_15,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><ul><li><strong>节点数量多了后，节点在哈希环上的分布就相对均匀了</strong>。这时候，如果有访问请求寻址到「A-01」这个虚拟节点，接着再通过「A-01」虚拟节点找到真实节点 A，这样请求就能访问到真实节点 A 了。</li><li>虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。<strong>当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高</strong>。</li><li>有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如对权重更高的节点增加更多的虚拟机节点即可。</li></ul><h4 id="假设有一个用户表，你用ID做的分片键，那么有一个类似于name这样的字段如何查询？"><a href="#假设有一个用户表，你用ID做的分片键，那么有一个类似于name这样的字段如何查询？" class="headerlink" title="假设有一个用户表，你用ID做的分片键，那么有一个类似于name这样的字段如何查询？"></a>假设有一个用户表，你用ID做的分片键，那么有一个类似于name这样的字段如何查询？</h4><p>这里提供几种常见的思路：</p><h5 id="全局索引"><a href="#全局索引" class="headerlink" title="全局索引"></a>全局索引</h5><p>全局索引是一个跨所有分片的索引，它包含了非分片键字段和对应的分片键信息。查询时，先通过全局索引找到相关的分片键，然后在相应的分片中查询详细数据。</p><p>适用场景：适用于查询频率高、数据量大的非分片键字段。</p><p>优点：查询效率高，可以快速定位到数据所在的分片。</p><p>缺点：全局索引维护成本较高，需要定期更新以保持与分片数据的一致性。</p><h5 id="2-数据冗余"><a href="#2-数据冗余" class="headerlink" title="2. 数据冗余"></a>2. 数据冗余</h5><p>在每个分片中存储部分非分片键字段的数据。这样，即使不直接查询分片键，也可以在分片内快速找到相关数据。</p><p>适用场景：适用于查询性能要求极高，且可以接受一定数据冗余的场景。</p><p>优点：查询性能高，无需跨分片查询。</p><p>缺点：数据冗余增加了存储成本和维护复杂性。</p><h5 id="3-应用层处理"><a href="#3-应用层处理" class="headerlink" title="3. 应用层处理"></a>3. 应用层处理</h5><p>在应用层实现复杂的查询逻辑，将多个分片中的查询结果汇总后进行处理。</p><p>适用场景：适用于查询频率不高，或者可以接受一定延迟的场景。</p><p>优点：灵活性高，可以根据业务需求定制查询逻辑。</p><p>缺点：查询性能可能受到网络延迟和分片数量的影响。</p><h5 id="4-使用Elasticsearch（ES）"><a href="#4-使用Elasticsearch（ES）" class="headerlink" title="4. 使用Elasticsearch（ES）"></a>4. 使用Elasticsearch（ES）</h5><p>将非分片键字段的数据同步到Elasticsearch中，利用Elasticsearch强大的搜索和查询能力进行查询。</p><p>适用场景：适用于非结构化数据、全文搜索、复杂查询等场景。</p><p>优点：支持复杂的查询操作，如全文搜索、模糊匹配等；查询性能高，支持分布式部署。</p><p>缺点：需要维护Elasticsearch集群，增加了系统的复杂性；数据同步可能引入一定的延迟。</p><h5 id="5-数据库中间件"><a href="#5-数据库中间件" class="headerlink" title="5. 数据库中间件"></a>5. 数据库中间件</h5><p>使用数据库中间件（如ShardingSphere、MyCAT等）来管理分库分表，中间件可以自动处理非分片键字段的查询，将请求路由到正确的分片。</p><p>适用场景：适用于希望减少应用层复杂性的场景。</p><p>优点：简化了应用层的查询逻辑，减少了开发和维护的工作量。</p><p>缺点：需要配置和维护数据库中间件。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/10/03/hello-world/"/>
      <url>/2023/10/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
