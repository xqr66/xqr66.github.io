<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/04/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/04/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/04/19/%E5%B8%B8%E7%94%A8%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2024/04/19/%E5%B8%B8%E7%94%A8%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/04/19/redis/"/>
      <url>/2024/04/19/redis/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/04/19/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
      <url>/2024/04/19/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java知识点总结</title>
      <link href="/2024/04/19/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2024/04/19/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>复制到指定路径 .&#x2F;..&#x2F;imgs&#x2F;${filename}</p><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="基本数据类型与权限"><a href="#基本数据类型与权限" class="headerlink" title="基本数据类型与权限"></a>基本数据类型与权限</h3><h4 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a><strong>基本类型和包装类型的区别</strong></h4><h5 id="1-基本类型有初始值，而包装类型的默认值是null"><a href="#1-基本类型有初始值，而包装类型的默认值是null" class="headerlink" title="1.基本类型有初始值，而包装类型的默认值是null"></a>1.基本类型有初始值，而包装类型的默认值是null</h5><h5 id="2-包装类型可以为-null，而基本类型不可以"><a href="#2-包装类型可以为-null，而基本类型不可以" class="headerlink" title="2.包装类型可以为 null，而基本类型不可以"></a>2.包装类型可以为 null，而基本类型不可以</h5><p>数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有<a href="https://so.csdn.net/so/search?q=NPE&spm=1001.2101.3001.7020">NPE</a>（NullPointerException）风险。</p><h5 id="3-存储位置有所区别：基本类型是成员变量就存储在堆内存里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用"><a href="#3-存储位置有所区别：基本类型是成员变量就存储在堆内存里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用" class="headerlink" title="3.存储位置有所区别：基本类型是成员变量就存储在堆内存里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用"></a>3.存储位置有所区别：基本类型是成员变量就存储在<a href="https://so.csdn.net/so/search?q=%E5%A0%86%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">堆内存</a>里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用</h5><h5 id="4-包装类型可用于泛型，而基本类型不可以"><a href="#4-包装类型可用于泛型，而基本类型不可以" class="headerlink" title="4.包装类型可用于泛型，而基本类型不可以"></a>4.包装类型可用于泛型，而基本类型不可以</h5><p>如果我们这么写<br>List<int> a &#x3D; new ArrayList&lt;&gt;();<br>编译器会报错：Type argument cannot be of primitive type(类型参数不能为基本类型)<br>这是为什么呢？因为泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类。</p><h5 id="5-在使用“-”进行判断的时候的不同"><a href="#5-在使用“-”进行判断的时候的不同" class="headerlink" title="5.在使用“&#x3D;&#x3D;”进行判断的时候的不同"></a>5.在使用“&#x3D;&#x3D;”进行判断的时候的不同</h5><p>基本数据类型会直接比较值是否相同，而包装数据类型用“&#x3D;&#x3D;”判断比较的是地址值（在-128 – 127之间会共用内部类的cache），真正判断是否相等需要用equals()。</p><p><strong>6.自动装箱和自动拆箱</strong><br>把基本类型转换成包装类型的过程叫做装箱（boxing）。反之，把包装类型转换成基本类型的过程叫做拆箱（unboxing）。</p><p>1）基本类型和包装类型进行 &#x3D;&#x3D; 比较，包装类型会自动拆箱，直接和基本类型比较值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">System.out.println(a == b);</span><br></pre></td></tr></table></figure><p>上述代码的结果为 true。</p><p>2）当需要进行自动装箱时，如果数字在 -128 至 127 之间，会直接使用缓存中的对象，而不是重新创建一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">199</span>;  </span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> A;  </span><br></pre></td></tr></table></figure><p>执行第一句代码的时候，系统为我们执行了：<br>Integer A &#x3D; Integer.valueOf(199);<br>执行第二句代码的时候，系统为我们执行了：<br>int a &#x3D; A.intValue();</p><h4 id="java的访问权限有哪些"><a href="#java的访问权限有哪些" class="headerlink" title="java的访问权限有哪些"></a>java的访问权限有哪些</h4><h5 id="类的成员变量和方法访问权限"><a href="#类的成员变量和方法访问权限" class="headerlink" title="类的成员变量和方法访问权限"></a>类的成员变量和方法访问权限</h5><table><thead><tr><th>修饰符</th><th>类内部</th><th>同包（package）</th><th>子类</th><th>任何地方</th></tr></thead><tbody><tr><td>public</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>protected</td><td>Yes</td><td>Yes</td><td>Yes</td><td></td></tr><tr><td>缺省</td><td>Yes</td><td>Yes</td><td></td><td></td></tr><tr><td>private</td><td>Yes</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th align="left">权限修饰符</th><th align="left">类</th><th align="left">变量&#x2F;方法</th></tr></thead><tbody><tr><td align="left">public</td><td align="left">包内外的类都可以访问</td><td align="left">包内外的类都可以访问</td></tr><tr><td align="left">protected</td><td align="left">类不可以声明为protected</td><td align="left">本包内的类和子类可以访问</td></tr><tr><td align="left">不写</td><td align="left">本包中的类可以访问</td><td align="left">本包中的类可以访问</td></tr><tr><td align="left">private</td><td align="left">类不可以声明为private</td><td align="left">只允许本类访问</td></tr></tbody></table><h5 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h5><p>类的访问权限仅有<strong>public</strong>和<strong>default</strong>， 如果一个类声明的时候用了<strong>public</strong>，则该类的类名必须与文件名一致，包括大小写，如果不匹配，会有编译错误</p><h4 id="Java的基本类型存储位置"><a href="#Java的基本类型存储位置" class="headerlink" title="Java的基本类型存储位置"></a><strong>Java的基本类型存储位置</strong></h4><ul><li><p><strong>第一种</strong>: 在方法中声明的变量，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因</p><p>（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中</p><p>（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。</p></li><li><p><strong>第二种</strong> 在类中声明的变量是类的成员变量(全局变量),放在堆中</p><ol><li>声明的是基本类型的变量,其变量名及其值放在堆内存中</li><li>声明的是引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中。但与对象中的普通成员变量（局部变量）不同的是，它们的生命周期是在对象销毁时才结束的</li></ol></li><li><p><strong>第三种</strong> 静态变量：</p><p>​静态变量随着类的加载而存在，是存储在方法区（Method Area）中的，而不是存储在栈或堆上，所以它的生命周期与程序的生命周期一样长。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjcxMjE2,size_16,color_FFFFFF,t_70.png" alt="img"></p></li></ul><h4 id="包装类的缓存"><a href="#包装类的缓存" class="headerlink" title="包装类的缓存"></a>包装类的缓存</h4><p>1、前提：发生自动装箱的过程（基本类型–&gt;包装类型）<br>创建一个包装类对象有两种方法：<br>（1）构造器方法（就是new出来）；<br>（2）自动装箱（就是编译器自动调用包装类的valueOf方法）；</p><h5 id="两种方法的区别："><a href="#两种方法的区别：" class="headerlink" title="两种方法的区别："></a>两种方法的区别：</h5><p>构造器方法：不论值的大小，返回的将都会是一个新对象；<br>自动装箱会先经过判断，再决定返回的是一个新对象还是常量池中已存在的对象。</p><p>2、机制：当通过自动装箱机制创建包装类对象时，首先会判断数值是否在缓存范围内，如果满足条件，则会从  该包装类中的静态内部类xxCache包装类（例如IntegerCache类）类型数组（例如static final Integer cache[]）（放在方法区的常量池）中寻找指定数值，并返回缓存的对象，否则创建一个新的对象返回。</p><p>3、原理：<br>（1）当包装类加载时，该包装类中的静态内部类xxCache会初始化一个静态包装类类型数组，最小值（固定值）为-128,而最大值（默认值）为127【可修改】，是所有线程共享的。</p><h5 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h5><p>在缓存值范围内的对象可以直接在常量池中取出，不用创建新的对象；<br>当需要频繁的使用同一对象的时候，如果有缓存，则可以避免重复创建同一对象，节省空间开销和时间消耗，提升了性能。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111615708.png" alt="image-20231003111615708"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h4><ol><li>重写必须依赖于继承(父子关系) 将父类的的方法给完善。而重载不需要依赖继承关系，在自己的类中就可以实现。</li><li>重写的方法名和参数列表必须和父类相同，如果父类没有这个方法，那么就不算重写。重载是在自身类中创建多个方法名相同但是参数类型或者个数不同的方法。</li><li>重写的参数不能修改，而重载的参数必须修改。</li></ol><h4 id="object中的hashcode-方法是做什么用的"><a href="#object中的hashcode-方法是做什么用的" class="headerlink" title="object中的hashcode()方法是做什么用的"></a>object中的hashcode()方法是做什么用的</h4><p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p><p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><h5 id="那为什么不只提供-hashCode-方法呢？"><a href="#那为什么不只提供-hashCode-方法呢？" class="headerlink" title="那为什么不只提供 hashCode() 方法呢？"></a><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></h5><p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p><h5 id="那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？"><a href="#那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？" class="headerlink" title="那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？"></a><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></h5><p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><h4 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h4><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p>再map集合中，如果只重写equals方法，那么两个相同对象hashcode可能不同，会存在多个key相同的情况。</p><h4 id="object类中的常用方法的用处："><a href="#object类中的常用方法的用处：" class="headerlink" title="object类中的常用方法的用处："></a>object类中的常用方法的用处：</h4><p>1、 getClass()：获取类的class对象。<br>2、 hashCode():获取对象的hashCode值<br>3、 equals():比较对象是否相等，先比较存储地址再比较对象，子类可重写以自定义。<br>4、 clone()：浅拷贝一个新的对象。<br>5、 toString():如果没有重写，应用对象将打印的是地址值。<br>6、 notify():随机选择一个在该对象上调用wait方法的线程，解除其阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>7、 notifyall():解除所有那些在该对象上调用wait方法的线程的阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>8、 wait():导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在同步方法中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>9、 finalize()：对象回收时调用</p><h4 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h4><ol><li><p>final修饰符（关键字）。被<strong>final修饰的类</strong>，就意味着<strong>不能再派生出新的子类</strong>，不能作为父类而被子类继承。因此一个类不能既被abstract声明，又被final声明。将<strong>变量或方法声明为final</strong>，可以保证他们在<strong>使用的过程中不被修改</strong>。被声明为final的变量必须在声明时<strong>给出变量的初始值</strong>，而在以后的引用中只能读取。被final声明的方法也同样只能使用，即不能方法重写。</p></li><li><p>finally是在<strong>异常处理时提供finally块来执行任何清除操作</strong>。不管有没有异常被抛出、捕获，finally块都会被执行。try块中的内容是在无异常时执行到结束。catch块中的内容，是在try块内容发生catch所声明的异常时，跳转到catch块中执行。<strong>finally块则是无论异常是否发生，都会执行finally块的内容，所以在代码逻辑中有需要无论发生什么都必须执行的代码，就可以放在finally块中</strong>。</p></li><li><p>finalize是方法名。java技术允许使用finalize（）方法<strong>在垃圾收集器将对象从内存中清除出去之前做必要的清理工作</strong>。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在object类中定义的，因此所有的类都继承了它。子类覆盖finalize（）方法以整理系统资源或者被执行其他清理工作。<strong>finalize（）方法是在垃圾收集器删除对象之前对这个对象调用的。</strong></p></li></ol><h4 id="Return与finally的使用顺序"><a href="#Return与finally的使用顺序" class="headerlink" title="Return与finally的使用顺序"></a>Return与finally的使用顺序</h4><p><strong>如果程序是从try代码块或者catch代码块中返回时，finally中的代码总会执行。而且finally语句在return语句执行之后return返回之前执行的。可以使用编译器的Debug功能查看详细过程。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally模块被执行&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">//结果 finally模块被执行 1</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>/<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally模块被执行&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//结果： finally模块被执行 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>/<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally模块被执行&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">//结果 finally模块被执行 0；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally模块被执行&quot;</span>);</span><br><span class="line">          result = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//结果 finally模块被执行 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>*<strong>如果try和catch的return是一个变量时且函数的是从其中一个返回时，后面finally中语句即使有对返回的变量进行赋值的操作时，也不会影响返回的值，因为返回值已经被保存到局部变量表中，赋值操作无法修改到返回值。*</strong></p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String为什么不可变"><a href="#String为什么不可变" class="headerlink" title="String为什么不可变"></a>String为什么不可变</h4><ul><li>将 class 自身声明为 final，这样别人就不能通过扩展来绕过限制了。</li><li>将所有成员变量定义为 private 和 final（使得byte[]引用不可变），并且没有实现 setter 方法来修改byte[]（使得byte[]值不可变）。</li><li>通过构造对象时，成员变量使用深拷贝来初始化，而不是直接赋值，这是一种防御措施，因为该输入对象被其他变量引用，你无法确定输入对象不被其他人修改。</li></ul><p>可以通过反射修改String的值，相当于使用set方法修改byte[];</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString3</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">strObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;反射执行前字符串：&quot;</span> + strObj);</span><br><span class="line">    System.out.println(<span class="string">&quot;反射执行前的hash值：&quot;</span> + strObj.hashCode());</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> strObj.getClass().getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">char</span>[] value = (<span class="type">char</span>[]) field.get(strObj);</span><br><span class="line">    value[<span class="number">2</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;反射执行后字符串：&quot;</span> + strObj);</span><br><span class="line">    System.out.println(<span class="string">&quot;反射执行后的hash值：&quot;</span> + strObj.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1的内存地址：<span class="number">1922154895</span></span><br><span class="line">执行+=后str1的内存地址：<span class="number">883049899</span></span><br><span class="line">拼接之后str1的值：helloworld</span><br><span class="line">str3的值：<span class="number">123</span></span><br><span class="line">str4的值：<span class="number">123456</span></span><br><span class="line">str5的值：ABC</span><br><span class="line">str6的值：BBC</span><br></pre></td></tr></table></figure><h4 id="String-类设计成不可变的原因及好处？"><a href="#String-类设计成不可变的原因及好处？" class="headerlink" title="String 类设计成不可变的原因及好处？"></a><strong>String 类设计成不可变的原因及好处？</strong></h4><p>其实好处就是原因，String 设计成不可变，主要是从性能和安全两方面考虑。</p><h5 id="1、常量池的需要"><a href="#1、常量池的需要" class="headerlink" title="1、常量池的需要"></a><strong>1、常量池的需要</strong></h5><p>这个方面很好理解，Java 中的字符串常量池的存在就是为了性能优化。</p><p>字符串常量池（String pool）是 Java 堆内存中一个特殊的存储区域，当创建一个 String 对象时，假如此字符串已经存在于常量池中，则不会创建新的对象，而是直接引用已经存在的对象。这样做能够减少 JVM 的内存开销，提高效率。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span> s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="title class_">String</span> s2 = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><p>比如引用 s1和 s2 都是指向常量池的同一个对象 “abc”，如果 String 是可变类，引用 s1 对 String 对象的修改，会直接导致引用 s2 获取错误的值。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/43vmfn3rmu.png" alt="img"></p><p>所以，如果字符串是可变的，那么常量池就没有存在的意义了。</p><h5 id="2、hashcode-缓存的需要"><a href="#2、hashcode-缓存的需要" class="headerlink" title="2、hashcode 缓存的需要"></a><strong>2、hashcode 缓存的需要</strong></h5><p>String有一个属性用来缓存hash值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p>因为字符串不可变，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就使得字符串很适合作为 HashMap 中的 key，效率大大提高。</p><h5 id="3、多线程安全"><a href="#3、多线程安全" class="headerlink" title="3、多线程安全"></a><strong>3、多线程安全</strong></h5><p>多线程中，可变对象的值很可能被其他线程改变，造成不可预期的结果。而不可变的 String 可以自由在多个线程之间共享，不需要同步处理。</p><h4 id="String-、StringBuffer和StringBuilder的区别"><a href="#String-、StringBuffer和StringBuilder的区别" class="headerlink" title="String 、StringBuffer和StringBuilder的区别"></a>String 、StringBuffer和StringBuilder的区别</h4><h5 id="1-可变性"><a href="#1-可变性" class="headerlink" title="1.可变性"></a>1.可变性</h5><p>​String 内部的 value 值是 final 修饰的，所以它是不可变类。所以每次修改 String 的值，都会产生一个新的对象。<br>​StringBuffer 和 StringBuilder 是可变类，字符串的变更不会产生新的对象。</p><h5 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="2.线程安全性"></a>2.线程安全性</h5><p>​String 是不可变类，所以它是线程安全的。<br>​StringBuffer 是线程安全的，因为它每个操作方法都加了 synchronized 同步关键字。<br>​StringBuilder 不是线程安全的。所以在多线程环境下对字符串进行操作，应该使用 StringBuffer，否则使用StringBuilder</p><h5 id="3-性能方面。"><a href="#3-性能方面。" class="headerlink" title="3.性能方面。"></a>3.性能方面。</h5><p>​String 的性能是最低的，因为不可变意味着在做字符串拼接和修改的时候，需要重新创建新的对象以及分配内存。<br>​其次是 StringBuffer 要比 String 性能高，因为它的可变性使得字符串可以直接被修改<br>​最后是 StringBuilder，它比 StringBuffer 的性能高，因为 StringBuffer 加了同步锁。</p><h5 id="4-存储方面。"><a href="#4-存储方面。" class="headerlink" title="4.存储方面。"></a>4.存储方面。</h5><p>​String 存储在字符串常量池里面<br>​StringBuffer 和 StringBuilder 存储在堆内存空间。</p><h4 id="StringBuffer、StringBuilder的扩容原理"><a href="#StringBuffer、StringBuilder的扩容原理" class="headerlink" title="StringBuffer、StringBuilder的扩容原理"></a>StringBuffer、StringBuilder的扩容原理</h4><p>扩容原理：</p><p><code>StringBuffer</code>的底层数组结构用的是<code>char</code>类型的数组如果没有指定大小，默认大小为16，指定了大小，默认大小为（16 + 指定大小）。</p><p>所以，当我们使用<code>StringBuffer</code>对象的<code>append(...)</code>方法追加数据时，</p><ul><li>如果数组长度可以容纳追加的数据，就直接追加到数组</li><li>如果char类型数组的长度无法容纳我们追加的数据，<code>StringBuffer</code>就会进行扩容。</li><li>扩容时会用到<code>Arrays</code>类中的<code>copyOf(...)</code>方法，每次扩容的容量大小是原来的容量的2倍（通过无符号左移）加2。</li></ul><h4 id="String-str-“abc”-和String-str-new-String-“abc”-的区别"><a href="#String-str-“abc”-和String-str-new-String-“abc”-的区别" class="headerlink" title="String str &#x3D; “abc” 和String str &#x3D; new String(“abc”)的区别"></a><strong>String str &#x3D; “abc” 和String str &#x3D; new String(“abc”)的区别</strong></h4><p><code>String str =&quot;abc&quot;</code>的原理，采用字面值的方式创建时，<code>JVM</code>会先去字符串常量池中去查找是否存在”abc”这个对象，如果不存在就创建这个字符串，并把地址返回给<code>str</code>。如果存在则直接把”abc”这个字符串的地址返回给<code>str</code>。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/16e1f7c1f13d9561tplv-t2oaga2asx-jj-mark3024000q75-1696302993864-1.webp" alt="img"></p><p><code>String str = new String(&quot;abc&quot;)</code>采用<code>new</code>关键字的方式创建，能被看成”abc”和new String()，<code>JVM</code>也会去字符串常量池中查找有没有这个字符串，如果没有的话，就先在字符串常量池里创建”abc”这个字符串，然后再复制一份放在堆里并把地址返回给<code>str</code>。如果字符串常量池里存在该字符串，那么就直接复制一份放在堆里并把地址返回给<code>str</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = original.value;</span><br><span class="line">        <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">    &#125;<span class="comment">//浅拷贝</span></span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/16e1f8c6aa324edetplv-t2oaga2asx-jj-mark3024000q75-1696303002110-3.webp" alt="img"></p><h4 id="（String的）equals-的底层代码是什么"><a href="#（String的）equals-的底层代码是什么" class="headerlink" title="（String的）equals 的底层代码是什么?"></a>（String的）equals 的底层代码是什么?</h4><ol><li>先使用&#x3D;&#x3D; 进行地址值的判断  </li><li>判断equals()中的值是否为字符串  instanceof()方法</li><li>判断字符串的长度是否相同  </li><li>循环遍历进行判断两个字符串是否相同</li></ol><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="集合顶层是什么，各个接口实现类有哪些"><a href="#集合顶层是什么，各个接口实现类有哪些" class="headerlink" title="集合顶层是什么，各个接口实现类有哪些"></a>集合顶层是什么，各个接口实现类有哪些</h4><p><strong>Java 集合框架架构图如下图所示</strong>：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1711439392899-248.png" alt="图片"></p><p><code>List</code> 接口实现类：</p><ul><li><code>ArrayList</code>: 底层基于可调节大小的数组实现。</li><li><code>LinkedList</code>: 底层基于双向链表实现，链表实现类。</li><li><code>Vector</code>: 和<code>ArrayList</code>类似，但线程安全。</li><li><code>Stack</code>: 继承自 <code>Vector</code>，栈实现类。</li></ul><p><code>Set</code> 接口实现类：</p><ul><li><code>HashSet</code>: 底层基于哈希表实现，没有排序保证。</li><li><code>LinkedHashSet</code>: 底层基于哈希表和链表实现，元素的插入和取出顺序满足 FIFO</li><li><code>TreeSet</code>: 底层基于红黑树实现，元素是有序的，排序的方式有自然排序和定制排序。</li></ul><p><code>Map</code> 接口实现类：</p><ul><li><code>HashMap</code>: 仅用于存储键值对，JDK1.8 之前 <code>HashMap</code> 底层基于数组和链表实现，JDK1.8 之前基于数组和红黑树。</li><li><code>LinkedHashMap</code>: 继承自 <code>HashMap</code>，并在 <code>HashMap</code> 基础上维护一条双向链表，支持遍历时会按照插入顺序有序进行迭代，支持按照元素访问顺序排序，迭代效率比<code>HashMap</code>更高。</li><li><code>TreeMap</code>: 相比于 <code>HashMap</code> 来说，<code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</li><li><code>Hashtable</code>: 与 <code>HashMap</code> 类似，但线程安全。</li></ul><p><code>Queue</code> 接口实现类：</p><ul><li><code>LinkedList</code>: 同时实现了 <code>List</code> 和 <code>Queue</code> 接口。</li><li><code>PriorityQueue</code>：元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</li><li><code>ArrayDeque</code> ：底层基于可变长的数组和双指针实现，允许我们在队列的两端进行元素的插入和移除操作。</li></ul><h4 id="数组和链表的不同"><a href="#数组和链表的不同" class="headerlink" title="数组和链表的不同"></a>数组和链表的不同</h4><table><thead><tr><th></th><th>数组</th><th>链表</th></tr></thead><tbody><tr><td>逻辑结构</td><td>（1）数组在内存中连续； (2)使用数组之前，必须事先固定数组长度，不支持动态改变数组大小；(3) 数组元素增加时，有可能会数组越界；(4) 数组元素减少时，会造成内存浪费；（5）数组增删时需要移动其它元素</td><td>（1）链表采用动态内存分配的方式，在内存中不连续 (2)支持动态增加或者删除元素</td></tr><tr><td>访问效率</td><td>数组在内存中顺序存储，可通过下标访问，访问效率高</td><td>链表访问效率低，如果想要访问某个元素，需要从头遍历</td></tr><tr><td>越界问题</td><td>数组的大小是固定的，所以存在访问越界的风险</td><td>只要可以申请得到链表空间，链表就无越界风险</td></tr><tr><td>使用场景</td><td>存储的大小变化不大，且可以事先确定大小，主要是进行查找，很少插入和删除时</td><td>长度变化较大时，事先无法估量数据规模，当线性表要求频繁插入和删除时</td></tr></tbody></table><h4 id="说说ArrayList"><a href="#说说ArrayList" class="headerlink" title="说说ArrayList"></a>说说ArrayList</h4><p>ArrayList 是一个数组结构的存储容器，所以ArrayList是支持随机存取的，默认情况下，数组的长度是 10.也可以在构建 ArrayList 对象的时候自己指定初始长度。随着在程序里面不断的往 ArrayList 中添加数据，当添加的数据达到 10 个的时候，ArrayList 就没有多余容量可以存储后续的数据。这个时候 ArrayList 会自动触发扩容。扩容的具体流程很简单：</p><ol><li>首先，创建一个新的数组，这个新数组的长度是原来数组长度的 1.5 倍。</li><li>然后使用 Arrays.copyOf 方法把老数组里面的数据拷贝到新的数组里面。<br>扩容完成后再把当前要添加的元素加入到新的数组里面，从而完成动态扩容的过程。</li></ol><h4 id="常见的树"><a href="#常见的树" class="headerlink" title="常见的树"></a>常见的树</h4><p><a href="https://zhuanlan.zhihu.com/p/531299726#%E5%89%8D%E8%A8%80">为什么红黑树的效率比较高 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/361961175">红黑树 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/91960960">一文带你彻底读懂红黑树（附详细图解） - 知乎 (zhihu.com)</a></p><h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><strong>平衡二叉树</strong></h5><p>特点：<strong>任意节点的左子树和右子树高度差不能超过1</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-db8cdc6ff692f73cb4984ff80e45ef34_720w.webp" alt="img"></p><h5 id="非平衡二叉树"><a href="#非平衡二叉树" class="headerlink" title="非平衡二叉树"></a><strong>非平衡二叉树</strong></h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-07b3c6b4c4d2d524555fb739bf599981_720w.webp" alt="img"></p><p>高度差已经大于1 了。平衡树解决的问题就是 能够最大限度的增加访问的每个节点的的平均性。保证每个节点被访问的次数平衡。</p><h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a><strong>完全二叉树</strong></h5><p>除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-db8cdc6ff692f73cb4984ff80e45ef34_720w.webp" alt="img"></p><p>堆排序 结构其实就是一个完全二叉树的结构，倒序和正序就是用的 大根堆 小根堆的原理。</p><h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a><strong>满二叉树</strong></h5><p>每个节点是叶节点或者度为2.</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-c24507d5ab42fa1a9de508aea129bacc_720w.webp" alt="img"></p><h5 id="二叉搜索树（Binary-Search-Tree）"><a href="#二叉搜索树（Binary-Search-Tree）" class="headerlink" title="二叉搜索树（Binary Search Tree）"></a><strong>二叉搜索树（Binary Search Tree）</strong></h5><p>特点是每个根节点大于左子树上的任意一个节点，小于等于右子树上的任意一个节点。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-bc1985e7abdd4871d0d0709f02a64725_720w.webp" alt="img"></p><p>可以利用二叉搜索树的大小关系，有点类似于二分查找。二叉搜索树查询的时间复杂度为O(logn)，因为每次查找都能将范围缩小一半。</p><p><strong>二叉搜索树的不足：</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-b43c0ec9893114064c891d5b3b2ee383_720w.webp" alt="img"></p><p>极端的二叉搜索树：如果二叉搜索树每个节点都只有左节点或者都只有右节点，那么这颗树就会降级为链表结构，使得时间复杂度为O(n),所以引出了平衡排序树(AVL树).</p><h5 id="平衡二叉搜索树（AVL树）"><a href="#平衡二叉搜索树（AVL树）" class="headerlink" title="平衡二叉搜索树（AVL树）"></a>平衡二叉搜索树（AVL树）</h5><p><strong>特点</strong></p><ul><li>任意节点的左右子树的高度差都小于等于1</li><li>常见的平衡树包括B树（MySQL中的索引），AVL树等</li></ul><p><strong>平衡二叉搜索树能同时满足平衡树和二叉搜索树的特点：</strong></p><ul><li>优点：AVL树可以有效减少二叉树的深度，从而提升查询的效率。</li><li>缺点：AVL树为了达到平衡（任意节点的左右子树的高度差都小于等于1，这属于<strong>绝对平衡</strong>，维持起来并不容易），需要付出额外代价。在插入和删除操作时，AVL树都需要进行再平衡。</li></ul><p>所以AVL树还有待改进——红黑树。</p><table><thead><tr><th>平衡二叉树类型</th><th>平衡度</th><th>调整频率</th><th>适用场景</th></tr></thead><tbody><tr><td>AVL树</td><td>高</td><td>高</td><td>查询多，增&#x2F;删少</td></tr><tr><td>红黑树</td><td>低</td><td>低</td><td>增&#x2F;删频繁</td></tr></tbody></table><hr><h5 id="红黑树（R-B树）"><a href="#红黑树（R-B树）" class="headerlink" title="红黑树（R-B树）"></a>红黑树（R-B树）</h5><p>红黑树是一种特化的AVL树，查询与AVL树基本相同，在插入和删除时通过特定操作保持二叉搜索树的<strong>相对平衡</strong>（红黑树与AVL树不同，AVL是绝对平衡）， 因为这种相对平衡的条件，红黑树在插入和删除时，对于树的调整的频率低于AVL树，对于树的旋转的次数也比AVL树少，从而获得较高的性能。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-d5a84583be75cd748b2a979e27a911ec_720w.webp" alt="img"></p><p><strong>由图可以看出红黑树不是严格的AVL树，只是黑色平衡</strong></p><p><strong>红黑树的特点</strong>：</p><ol><li><strong>首先必须满足二叉搜索树</strong></li><li><strong>节点非黑即红</strong></li><li><strong>根节点是黑色的，叶子节点是黑色的（都是空节点，为了简单起见，红黑树一般会省略叶子结点）</strong></li><li><strong>相邻父子节点不能同为红色，每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。</strong>）</li><li><strong>从一个节点到该节点的叶子结点的所有路径上包含的黑节点数量相等（这是平衡关键）</strong></li></ol><p><strong>红黑树特点总结成一句口诀：黑根黑叶红不邻，通祖等高只数黑</strong></p><p><strong>红黑树相关定理</strong></p><ol><li>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</li></ol><p>要满足从根节点到叶节点每条路径的黑色节点数量一致。最短路径：全是黑色 最长路径：黑红相间</p><p>对于给定的黑色高度为n的红黑树，从根结点到叶结点的简单路径的最短长度为n-1，最大长度为2(n-1)，从这一点我们可以看出红黑树是 大致平衡的。(当然比平衡二叉树要差一些，AVL的平衡因子最多为1)</p><ol start="2"><li>红黑树的树高(h)不大于两倍的红黑树的黑深度(bd)，即h&lt;&#x3D;2bd</li></ol><p>根据定理1，我们不难说明这一点。bd是红黑树的最短路径长度。而可能的最长路径长度(树高的最大值)就是红黑相间的路径，等于2bd。因此h&lt;&#x3D;2bd。</p><ol start="3"><li>一棵拥有n个内部结点(不包括叶子结点)的红黑树的树高h&lt;&#x3D;2log(n+1)</li></ol><p>下面我们首先证明一颗有n个内部结点的红黑树满足n&gt;&#x3D;2^bd-1。这可以用数学归纳法证明，施归纳于树高h。当h&#x3D;0时，这相当于是一个叶结点，黑高度bd为0，而内部结点数量n为0，此时0&gt;&#x3D;2^0-1成立。假设树高h&lt;&#x3D;t时，n&gt;&#x3D;2^bd-1成立，我们记一颗树高 为t+1的红黑树的根结点的左子树的内部结点数量为nl，右子树的内部结点数量为nr，记这两颗子树的黑高度为bd’（注意这两颗子树的黑高度必然一 样），显然这两颗子树的树高&lt;&#x3D;t，于是有nl&gt;&#x3D;2^bd’-1以及nr&gt;&#x3D;2^bd’-1，将这两个不等式相加有nl+nr&gt;&#x3D;2^(bd’+1)-2，将该不等式左右加1，得到n&gt;&#x3D;2^(bd’+1)-1，很显然bd’+1&gt;&#x3D;bd，于是前面的不等式可以 变为n&gt;&#x3D;2^bd-1，这样就证明了一颗有n个内部结点的红黑树满足n&gt;&#x3D;2^bd-1。</p><p>在根据定理2，h&lt;&#x3D;2bd。即n&gt;&#x3D;2^(h&#x2F;2)-1，那么h&lt;&#x3D;2log(n+1)</p><p>从这里我们能够看出，红黑树的查找长度最多不超过2log(n+1)，因此其查找时间复杂度也是O(log N)级别的。</p><p><strong>红黑树的复杂度分析</strong></p><ul><li><p>一棵含有n个节点（内部节点，不包含空的叶子节点）的红黑树的高度至多为2log(n+1)</p></li><li><p>查找时间复杂度为O(logn),红黑树上的查找操作与普通二叉查找树上的查找操作相同</p></li><li><p>插入时间复杂度为O(1)+O(logn)</p></li><li><p>删除时间复杂度为O(1)+O(logn)</p></li></ul><p><strong>AVL vs 红黑树</strong></p><ul><li>插入：AVL和红黑树都是最多两次旋转实现复衡，旋转的量级是O(1)，恢复红黑树的属性需要O(log n)的颜色变更</li><li>删除：AVL旋转的量级是O(logn)，红黑树最多旋转3次实现复衡只要O(1)</li><li>红黑树插入和删除效率更高，AVL的查找效率更高.</li><li>红黑树成本较低，AVL成本较高</li></ul><p><strong>两者没有谁好谁坏，关键看使用场景</strong></p><p><strong>红黑树的实际应用</strong></p><ul><li><strong>Java中的HashMap、TreeMap、TreeSet等</strong></li></ul><p><strong>红黑树的基本操作</strong></p><p><strong>查找节点（二叉搜索树一样的查找）</strong></p><ol><li>选择根节点作为当前节点</li><li>按照二叉搜索树特点进行循环查找（若值与当前节点值相等，则返回该节点；若值小于当前节点，左节点作为当前节点；否则，右节点作为当前节点）</li><li>未找到，为null</li></ol><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-f90edcb09cc58e310e2047ba8d6af772_720w.webp" alt="img"></p><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>[B+ 树搜索时间复杂度到底是什么：mlogmN &#x2F; logN？ - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/402951">https://zhuanlan.zhihu.com/p/402951</a></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231023104558443.png" alt="image-20231023104558443"></p><p>第一种，按照B+树数据结构来算，要访问节点数 * 节点内的搜索时间复杂度，其中节点内搜索时间有线性查找、二分查找两种</p><p>第二种：</p><p>说一个结论：非叶子节点的大小 &#x3D; 页大小。下面是证明</p><blockquote><p>B+ 树在搜索过程中，需要从磁盘IO来读取节点的数据。我们知道磁盘IO一次读取的数据大小为一页。</p><ul><li>非叶子节点的大小 &gt; 页大小：那么意味着搜索过程中，为了获取一个完整节点来查找数据，我们需要多次IO来获取这个节点，这显然非常消耗时间。所以非叶子节点的大小不能超过一页。</li><li>非叶子节点的体积非常小：这就意味着B+树的分叉就少，B+树的总节点数会变多、深度变大。B+树利用指针构成的树形结构，意味着每个节点在磁盘上是不连续的，B+树的深度变大了，意味着搜索时访问的节点数量变多，IO次数也变多了。</li><li>因此，非叶子节点过大、过小，都会导致IO次数增加。所以最合适的非叶子节点大小 &#x3D; 页大小。</li></ul></blockquote><p>因为</p><p>1 B+树的节点，即非叶子节点大小 &#x3D; 页大小</p><p>2 读取一页需要一次IO</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231023105000623.png" alt="image-20231023105000623"></p><h4 id="有哪些线程安全的容器？"><a href="#有哪些线程安全的容器？" class="headerlink" title="有哪些线程安全的容器？"></a>有哪些线程安全的容器？</h4><h5 id="不可变类："><a href="#不可变类：" class="headerlink" title="不可变类："></a>不可变类：</h5><ul><li>String：String的各个substring、replace、reverse 等方法都是重新new一个String对象，不会改变源对象，而且用final修饰，不会有子类覆盖String的方法，不会出现线程安全问题</li><li>Integer 类似String</li><li>Random 类似String</li></ul><h5 id="遗留的线程安全集合"><a href="#遗留的线程安全集合" class="headerlink" title="遗留的线程安全集合"></a>遗留的线程安全集合</h5><ul><li>StringBuﬀer 对方法加上了synchronized锁，保证线程安全，但是效率比StringBuilder低一些</li><li>Vector 每个方法都加上了synchronized 关键字，串行化执行，效率低下。而且多线程下组合调用这些方法还是会出现线程不安全。</li><li>Hashtable： 每个方法都加上了synchronized 关键字，串行化执行，效率低下。而且多线程下组合调用这些方法还是会出现线程不安全。</li></ul><h5 id="经过修饰的线程安全的集合"><a href="#经过修饰的线程安全的集合" class="headerlink" title="经过修饰的线程安全的集合"></a>经过修饰的线程安全的集合</h5><ul><li>synchronizedList 、synchronizedMap 、 synchronizedSet等等， 把不安全的list、map、set等作为构造的参数， 其方法使用synchronized(mutex) {map.get();} 使用的还是原本集合中的方法，但是通过synchronized和信号量来实现同步</li></ul><h5 id="java-util-concurrent-包下的类"><a href="#java-util-concurrent-包下的类" class="headerlink" title="java.util.concurrent 包下的类"></a>java.util.concurrent 包下的类</h5><ul><li><p>concurrentHashMap。</p></li><li><p>BlockingQueue的实现类:阻塞队列（<code>BlockingQueue</code>）被广泛使用在“生产者-消费者”问题中，其原因是 <code>BlockingQueue</code> 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p></li><li><p>copyOnWriteArrayList: <code>CopyOnWriteArrayList</code> 中的读取操作是完全无需加锁的。更加厉害的是，写入操作也不会阻塞读取操作，只有写写才会互斥。这样一来，读操作的性能就可以大幅度提升。</p></li></ul><p>线程安全的类不一定能保证线程安全，只能保证单个方法执行是线程安全的，但是多个方法的组合还是会出现不安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">concurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.get(str);</span><br><span class="line"><span class="comment">//在此处时间片结束，线程不安全</span></span><br><span class="line">map.put(str,count == <span class="number">0</span> : <span class="number">1</span> ? count + <span class="number">1</span>);;</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="CopyOnWriteArrayList详情"><a href="#CopyOnWriteArrayList详情" class="headerlink" title="CopyOnWriteArrayList详情"></a>CopyOnWriteArrayList详情</h4><p><code>CopyOnWriteArrayList</code> 线程安全的核心在于其采用了 <strong>写时复制（Copy-On-Write）</strong> 的策略，<strong>采用读写分离的思想</strong></p><p>当需要修改（ <code>add</code>，<code>set</code>、<code>remove</code> 等操作） <code>CopyOnWriteArrayList</code> 的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将原容器的引用指向新的容器，这样就可以保证写操作不会影响读操作了。</p><ul><li>在修改数组时(add、remove、set),需要先获取锁，实现多线程写同步</li><li>读的时候不需要加锁，如果读的时候多个线程正在修改数据，读操作还是会读到旧的数据，因为在读的那一刻就已经确定了读的对象是旧对象。</li></ul><p><strong>适用于读多写少的并发场景</strong>：如白名单、黑名单、商品类目的访问和变更等</p><p><strong>缺点</strong></p><p><strong>内存占用问题</strong>。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p><p>　　针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如<a href="http://ifeve.com/concurrenthashmap/">ConcurrentHashMap</a>。</p><p>　　<strong>数据一致性问题</strong>。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p><h4 id="线程不安全的集合"><a href="#线程不安全的集合" class="headerlink" title="线程不安全的集合"></a>线程不安全的集合</h4><ul><li>HashMap</li><li>HashSet</li><li>ArrayList:put方法中，elementData[size++] &#x3D; e，不是一个原子操作</li><li>LinkedList:add方法可能出现指针指向错误节点</li></ul><h4 id="List、Map、Set能不能存NULL？"><a href="#List、Map、Set能不能存NULL？" class="headerlink" title="List、Map、Set能不能存NULL？"></a>List、Map、Set能不能存NULL？</h4><h5 id="List-——-允许为null"><a href="#List-——-允许为null" class="headerlink" title="List —— 允许为null"></a><strong>List —— 允许为null</strong></h5><ul><li>ArrayList底层是数组，可以添加null</li><li>LinkedList底层是双向链表，可以node.value &#x3D; null</li><li>Vector底层是数组，可以存储NULL</li></ul><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h5><ul><li>HashMap只允许有一个key为null的节点，因为Map的key相同，后面节点会替换相同key的节点，可以有多个value为null的节点，当key为null，计算出的hash值为0，放在第一个桶中。可以有多个value为null的节点，这是因为 HashMap 的设计是给单线程使用的，所以如果查询到了 null 值，我们可以通过 hashMap.containsKey(key) 的方法来区分这个 null 值到底是存入的 null？还是压根不存在的 null？这样二义性问题就得到了解决，所以 HashMap 不怕二义性问题。</li><li>TreeMap会调用compareTo方法，当对象为null，会报空指针</li><li>HashTable底层为散列表，需要对value进行判空，会调用key.hashCode()来计算桶的位置，key和value都不能为空。</li></ul><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h5><ul><li>HashSet底层是HashMap，可以有一个key为NULL的元素。</li><li>LinkedHashSet底层也是HashMap，允许一个key为NULL</li><li>TreeSet底层是TreeMap，底层是红黑树，需要对节点的value进行比对排序，不能有key为null的元素</li></ul><h4 id="ConcurrentHashMap为什么key和value都不能存入null？"><a href="#ConcurrentHashMap为什么key和value都不能存入null？" class="headerlink" title="ConcurrentHashMap为什么key和value都不能存入null？"></a>ConcurrentHashMap为什么key和value都不能存入null？</h4><p>从代码层面来看：ConcurrentHashMap在put方法的起始位置就判断Key和Value是否为空，如果是就抛出空指针异常。</p><p><code>ConcurrentHashMap</code> 的 key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，表示没有对象或没有引用。（如果你用 null 作为键，那么你就无法区分这个键是否存在于 <code>ConcurrentHashMap</code> 中，还是根本没有这个键。）同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储<code>ConcurrentHashMap</code> 中的，还是因为找不到对应的键而返回的。</p><p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p><ul><li>值没有在集合中 ；</li><li>值本身就是 null。</li></ul><p>这也就是二义性的由来。</p><p>多线程环境下，存在一个线程操作该 <code>ConcurrentHashMap</code> 时，其他的线程将该 <code>ConcurrentHashMap</code> 修改的情况，所以无法通过 <code>containsKey(key)</code> 来判断否存在这个键值对，也就没办法解决二义性问题了。</p><p>与此形成对比的是，<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入 null 作为参数，就会返回 hash 值为 0 的位置的值。HashMap 的设计是给单线程使用的，所以如果取到 null（空） 值，我们可以通过HashMap 的 containsKey(key)方 法来区分这个 null（空） 值到底是插入值是 null（空），还是本就没有才返回的 null（空） 值。单线程环境下，不存在一个线程操作该 HashMap 时，其他的线程将该 <code>HashMap</code> 修改的情况，所以可以通过 <code>contains(key)</code>来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。</p><p>也就是说，多线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。</p><p>如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>举个例子，现在有线程 T1 调用了 ConcurrentHashMap 的 containsKey(key) 方法，<br>我们期望返回的结果是 false，也就是说，T1 并没有往 ConcurrentHashMap 中 put null（空）值。<br>但是，恰恰出了个意外，在线程 T1 还没有得到返回结果之前，线程 T2 又调用了<br>ConcurrentHashMap 的 put() 方法，插入了一个 Key，并且存入的 Value 是 null（空） 值。那么，线程 T1 最终得到的返回结果就变成 true 了。</p><h4 id="Map的遍历方式"><a href="#Map的遍历方式" class="headerlink" title="Map的遍历方式"></a>Map的遍历方式</h4><p>1）在 for 循环中使用 entries 实现 Map 的遍历（最常见和最常用的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;Java入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;C语言入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapKey</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapValue</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        System.out.println(mapKey + <span class="string">&quot;：&quot;</span> + mapValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）使用 for-each 循环遍历 key 或者 values，一般适用于只需要 Map 中的 key 或者 value 时使用。性能上比 entrySet 较好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Java入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;C语言入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line"><span class="comment">// 打印键集合</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印值集合</span></span><br><span class="line"><span class="keyword">for</span> (String value : map.values()) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）使用迭代器（Iterator）遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Java入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;C语言入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;    </span><br><span class="line">    Entry&lt;String, String&gt; entry = entries.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;:&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）通过键找值遍历，这种方式的效率比较低，因为本身从键取值是耗时的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hash怎么扩容有了解吗？"><a href="#hash怎么扩容有了解吗？" class="headerlink" title="hash怎么扩容有了解吗？"></a>hash怎么扩容有了解吗？</h4><ul><li>HashMap的底层是采用数组来存储数据，当 HashMap 中元素个数超过（大于）临界值时会自动触发扩容，这个临界值有一个计算公式。</li><li>threashold&#x3D;loadFactor*capacity。loadFactor 的默认值是 0.75，capacity 的默认值是 16。当元素个数超过临界值就会触发Hash扩容（resize函数），默认扩容的大小是原来数组长度的 2 倍，HashMap 的最大容量是Integer.MAX_VALUE，也就是 2 的 31 次方-1。</li><li>然后会进行数据迁移，会伴随着一次重新 hash 分配（reHash),是非常耗时的，并且会遍历 hash 表中所有的元素，HasMap让容量为2的幂次方，就是方便数据迁移，元素的位置是  元素的hash&amp;（n - 1），此时n是全为1的二进制数，那么元素根据hash值的的位置要么不变，要么加上原来的长度, 底层的行为都是给 table 赋值一个两倍长度的新数组。</li></ul><h4 id="为什么扩容因子是-0-75？"><a href="#为什么扩容因子是-0-75？" class="headerlink" title="为什么扩容因子是 0.75？"></a>为什么扩容因子是 0.75？</h4><p>扩容因子表示 Hash 表中元素的填充程度，扩容因子的值越大，那么触发扩容的元素个数更多，<br>虽然空间利用率比较高，但是 hash 冲突的概率会增加。<br>扩容因子的值越小，触发扩容的元素个数就越少，也意味着 hash 冲突的概率减少，<br>但是对内存空间的浪费就比较多，而且还会增加扩容的频率。<br>因此，扩容因子的值的设置，本质上就是在 冲突的概率 以及 空间利用率之间的平衡。<br>0.75 这个值的来源，和统计学里面的泊松分布有关。</p><p>当扩容因子在 0.75 的时候，链表长度达到 8 的可能性几乎为 0，也就是比较好的达到了空间成本和时间成本的平衡。</p><h4 id="HashMap的Hash值如何计算"><a href="#HashMap的Hash值如何计算" class="headerlink" title="HashMap的Hash值如何计算"></a>HashMap的Hash值如何计算</h4><p> <strong>h &#x3D; (key.hashCode ()) ^ (key.hashCode()&gt;&gt;16)</strong>,让hashCode的高16位和低16位进行异或，这样可以让hash值得散列度更高，尽可能区减少hash冲突的情况，从而去提升数据查找性能。</p><h4 id="HashMap为什么一定大小要是2的幂次方？"><a href="#HashMap为什么一定大小要是2的幂次方？" class="headerlink" title="HashMap为什么一定大小要是2的幂次方？"></a>HashMap为什么一定大小要是2的幂次方？</h4><p>HashMap为了提高存取效率，减少hash冲突，就是要尽量把数据分配均匀，使得每个链表长度大致相同，就可以通过hash值 % 数组长度 来实现。<br>但直接取模运算的效率不如位运算&amp;，当容量为2的n次方时，hash &amp; (capacity - 1) &#x3D;&#x3D; hash % capacity，通过 hash &amp; (capacity - 1) 来替代取模运算，而前提就是容量必须为2的n次方。</p><h4 id="HashMap怎么解决hash冲突的"><a href="#HashMap怎么解决hash冲突的" class="headerlink" title="HashMap怎么解决hash冲突的"></a>HashMap怎么解决hash冲突的</h4><p>hash 冲突问题 : 也就是两个不同 hash 值的 key，最终&amp;运算会落到同一个数组下标。所以 HashMap 引入了链式寻址法来解决 hash 冲突问题， 对于存在冲突的key，HashMap 把这些 key 组成一个单向链表。然后采用尾插法把这个 key 保存到链表的尾部。另外，为了避免链表过长的问题，当链表长度大于 8 并且数组长度大于等于 64 的时候，HashMap 会把链表转化为红黑树,从而减少链表数据查询的时间复杂度问题，提升查询性能</p><p>解决 hash 冲突问题的方法有很多，比如</p><ul><li>再 hash 法，就是如果某个 hash 函数产生了冲突，再用另外一个 hash 进行计算，</li><li>开放寻址法，就是直接从冲突的数组位置往下寻找一个空的数组下标进行数据存储，(这个在 ThreadLocal 里面有使用到)。</li><li>建立公共溢出区，也就是把存在冲突的 key 统一放在一个公共溢出区里面。</li></ul><h4 id="为什么HashMap将链表转化为红黑树的阈值是8？"><a href="#为什么HashMap将链表转化为红黑树的阈值是8？" class="headerlink" title="为什么HashMap将链表转化为红黑树的阈值是8？"></a>为什么HashMap将链表转化为红黑树的阈值是8？</h4><p>这是因为在实践中，当链表中的元素数量达到8时，使用红黑树进行查找的效率会超过链表。具体来说，当链表中的元素数量为8时，平均查找长度为8&#x2F;2&#x3D;4。而红黑树的平均查找长度为log(8)，大约是3。因此，将链表转换为红黑树可以提高查找效率。</p><p>然而，红黑树并不是在所有情况下都比链表更优。当红黑树中的元素数量较少时，树结构的维护成本会变得相对较高。这是因为每次插入或删除元素，都可能需要调整树的平衡。因此，当红黑树中的元素数量减少到一定程度时，HashMap会将其转换回链表。在JDK 1.8的实现中，这个阈值是6。</p><p>为何选择6作为红黑树转换回链表的阈值呢？这是因为在实践中，当红黑树中的元素数量小于等于6时，使用链表进行查找的效率会超过红黑树。具体来说，当红黑树中的元素数量为6时，平均查找长度为log(6)，大约是2.58。而链表的平均查找长度为6&#x2F;2&#x3D;3。因此，将红黑树转换回链表可以提高效率。 同时，选择6相比于7和8能避免频繁发生链表和红黑树的转换，造成大量性能消耗</p><h4 id="HashMap在多线程情况下会产生哪些问题？会产生死锁吗？"><a href="#HashMap在多线程情况下会产生哪些问题？会产生死锁吗？" class="headerlink" title="HashMap在多线程情况下会产生哪些问题？会产生死锁吗？"></a>HashMap在多线程情况下会产生哪些问题？会产生死锁吗？</h4><ul><li>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</li><li>为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题。并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</li></ul><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><ul><li><p>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。</p><p>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。</p><p>随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</p></li><li><p>还有一种情况是这两个线程同时 <code>put</code> 操作导致 <code>size</code> 的值不正确，进而导致数据覆盖的问题：</p><ol><li>线程 1 执行 <code>if(++size &gt; threshold)</code> 判断时，假设获得 <code>size</code> 的值为 10，由于时间片耗尽挂起。</li><li>线程 2 也执行 <code>if(++size &gt; threshold)</code> 判断，获得 <code>size</code> 的值也为 10，并将元素插入到该桶位中，并将 <code>size</code> 的值更新为 11。</li><li>随后，线程 1 获得时间片，它也将元素放入桶位中，并将 size 的值更新为 11。</li><li>线程 1、2 都执行了一次 <code>put</code> 操作，但是 <code>size</code> 的值只增加了 1，也就导致实际上只有一个元素被添加到了 <code>HashMap</code> 中。</li></ol></li></ul><h4 id="说一说HashMap-get元素的完整流程"><a href="#说一说HashMap-get元素的完整流程" class="headerlink" title="说一说HashMap get元素的完整流程"></a>说一说HashMap get元素的完整流程</h4><p>先计算key的hashcode值，然后计算key的hash值，通过（n - 1） &amp; hash 找到对应的桶的位置。</p><ul><li><p>如果位置上没有结点，直接返回null。</p></li><li><p>有结点，判断头结点的hash值是否等于key的hash值</p><ul><li><p>hash值相等，继续用 “&#x3D;&#x3D;” 和equals（）判断key是否相等，相等就返回</p></li><li><p>hash值不相等，遍历整个链表或者红黑树结点，还是判断hash值和key是否相等</p></li><li><p>头结点hash值 &lt; 0, 说明map正在扩容，需要到新的table中用一个 find() 方法去查找</p></li></ul></li></ul><h4 id="说一说HashMap-put元素的完整流程"><a href="#说一说HashMap-put元素的完整流程" class="headerlink" title="说一说HashMap put元素的完整流程"></a>说一说HashMap put元素的完整流程</h4><ol><li>根据key的hashcode 获得hash值（hashcode ^ (hashcode  &gt;&gt;&gt; 16)),也就是高十六位与低十六位进行异或运算</li><li>通过hash &amp; (n - 1) 找到对应桶的位置</li><li>如果桶为空，就直接put</li><li>如果桶不为空就遍历桶中所有元素，通过比较hashcode –&gt; “&#x3D;&#x3D;”判断 –&gt;equals 判断是否已存在，存在就更新value值， 不存在，就插入，size++     </li><li>判断是否需要转化为红黑树，是否需要扩容</li></ol><h4 id="ConcurrentHashMap为什么能保证线程安全？"><a href="#ConcurrentHashMap为什么能保证线程安全？" class="headerlink" title="ConcurrentHashMap为什么能保证线程安全？"></a>ConcurrentHashMap为什么能保证线程安全？</h4><p>添加元素时首先会判断容器是否为空，</p><ul><li><p>如果为空则使用 volatile 加 CAS 来初始化，防止多个线程同时初始化，造成并发问题，</p></li><li><p>如果容器不为空，则根据存储的元素计算该位置是否为空。</p><ul><li><p>如果根据存储的元素计算结果桶为空，则利用 CAS 设置该节点，避免并发冲突；</p></li><li><p>如果根据存储的元素计算桶为空不为空，则使用 synchronized 锁住这个桶链表的头结点，然后，遍历桶中的数据，根据hash值与key，更新或新增节点到桶中，</p></li><li><p>如果桶中头结点的hash值为 MOVED（-1），就说明map正在进行扩容，此时会锁住这个桶中的链表来帮助扩容，避免扩容的并发问题，等待扩容完成再put入新的table</p></li><li><p>最后再判断是否需要转为红黑树。这样就能保证并发访问时的线程安全了。</p></li></ul></li></ul><p>设置多个累加单元来计算size()的值，防止并发下计数错误。</p><ul><li>当线程竞争不激烈时，直接采用 CAS 对baseCount操作实现元素个数的原子递增。</li><li>如果线程竞争激烈，使用一个数组来维护元素个数，如果要增加总的元素个数，则直接从数组中随机选择一个，再通过 CAS 实现原子递增，之后遍历数组中所有的值与baseCount累加。它的核心思想是引入了数组来实现对并发更新的负载。</li></ul><p>总结： ConcurrentHashMap 通过<strong>对数组头结点加锁</strong>和<strong>加CAS的初始化</strong>来保证线程安全的。</p><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p><strong>特点</strong></p><ul><li>PriorityQueue 的底层是堆，堆的底层是数组</li><li>PriorityQueue中放置的元素必须要能够比较大小 （只有实现了 Comparable 和 Comparator 接口的类才能比较大小），不能插入无法比较大小的对象，否则会抛出 ClassCastException 异常</li><li>不能插入 null 对象，否则会抛出 NullPointerException 异常</li><li>没有容量限制，可以插入任意多个元素，其内部可以自动扩容</li><li>插入和删除元素的时间复杂度均为 O(log2N)</li><li>PriorityQueue底层使用了堆数据结构</li></ul><p>插入&#x2F;删除&#x2F;获取优先级最高的元素</p><table><thead><tr><th align="left">函数名</th><th>功能介绍</th></tr></thead><tbody><tr><td align="left">boolean offer(E e)&#x2F;add()</td><td>插入元素 e，插入成功返回 true，如果 e 对象为空，抛出 NullPointerException 异常，时间复杂度为 O(log2N) ，注意：空间不够时会自动扩容</td></tr><tr><td align="left">E peek()&#x2F;element()</td><td>获取优先级最高的元素，如果优先级队列为空，返回 null</td></tr><tr><td align="left">E poll()&#x2F;remove()</td><td>移除优先级最高的元素并返回，如果优先级队列为空，返回 null</td></tr><tr><td align="left">int size()</td><td>获取有效元素的个数</td></tr><tr><td align="left">void clean()</td><td>清空</td></tr><tr><td align="left">boolean isEmpty()</td><td>检测优先级队列是否为空，空返回 true</td></tr></tbody></table><h4 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h4><p>前提知识：二叉树的顺序存储<br>使用数组存储二叉树的方式，就是将二叉树按照层序遍历放入数组<br>一般只适合完全二叉树，因为非完全二叉树会有空间的浪费<br>这种方式的主要用法就是堆的表示</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知双亲(parent)的下标</span><br><span class="line">左孩子(left)下标 = 2 * parent + 1;</span><br><span class="line">右孩子(right)下标 = 2 * parent + 2;</span><br><span class="line">已知孩子（不区分左右）(child)下标</span><br><span class="line">双亲(parent)下标 = (child - 1) / 2;</span><br></pre></td></tr></table></figure><p><strong>1、概念</strong><br>概括：堆就是一颗顺序存储的完全二叉树，底层是一个数组</p><p>堆逻辑上是一颗完全二叉树</p><p>堆物理上是保存在数组中</p><p>堆满足任意结点的值都大于其子树中结点的值，也就是所有根节点 &gt; 其左右孩子结点，叫做大堆，或者大根堆、最大堆</p><p>反之则是小堆，或者小根堆、最小堆</p><p>堆的基本作用是快速找到集合中的最值</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70-1710494617676-3.png" alt="img"></p><p><strong>2、性质</strong></p><ul><li>堆中某个节点的值总是不大于或不小于其父结点的值</li><li>堆总是一颗完全二叉树</li></ul><p><strong>3、向下调整</strong></p><p>找左右孩子最大值，然后和父亲结点进行交换</p><p><strong>4、建堆</strong></p><p>这里我们从倒数的第一个非叶子节点的子树开始调整，一直调整到根节点的树，就可以调整成堆。</p><p>具体做法就是，从最后一个非叶子结点子树开始，比较左右孩子结点，较大的孩子结点和父亲结点比较，比父亲结点大的话就进行交换，直到这棵子树已经成了一个堆<br>    <img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70-1710494806954-6.jpeg" alt="img"></p><p><strong>插入一个元素</strong></p><ul><li><strong>过程（以大堆为例）：</strong></li></ul><ol><li>首先按尾插方式放入数组（空间不够时需要扩容）</li><li>比较其和其双亲的值的大小，如果双亲的值大，则满足堆的性质，插入结束</li><li>否则，交换其和双亲位置的值，重新进行 2、3 步骤（2、3就是向上调整的过程）</li><li>直到根结点</li></ol><ul><li><p><strong>图示</strong><br><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70-1710494847608-9.jpeg" alt="在这里插入图片描述"><br>是一个向上调整的过程</p><p><strong>删除一个元素</strong></p><p>为了防止破坏堆的结构，删除时并不是直接将堆顶元素删除，而是</p><ol><li>用数组的最后一个元素替换堆顶元素 ，usedSize–</li><li>然后从堆顶<strong>0号位置</strong>下标的元素开始，通过<strong>向下调整</strong>方式重新调整成堆<br><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70-1710494869532-12.jpeg" alt="在这里插入图片描述"></li></ol></li></ul><p>​</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h4><p>面向过程：把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。</p><p>面向对象：将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p><p>好处：</p><p><strong>易扩展</strong>：由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，增加或修改业务时，只需要改变小部分代码，使得系统更灵活、更容易扩展，而且成本较低。</p><p><strong>代码复用率高</strong>：可重用现有的已被测试过的类使系统满足业务需求并具有较高的质量。</p><p><strong>效率高</strong>：根据设计的需要对现实世界的事物进行抽象，产生类。使用这样的方法解决问题，接近于日常生活和自然的思考方式，势必提高软件开发的效率和质量。</p><h4 id="Java-基础有哪些核心模块"><a href="#Java-基础有哪些核心模块" class="headerlink" title="Java 基础有哪些核心模块"></a>Java 基础有哪些核心模块</h4><p>这里简单对我觉得 Java 基础比较核心的模块做一下总结：</p><ul><li><strong>异常</strong>：定义了 Java 运行中可能出现的异常，提供了异常处理手段。</li><li><strong>泛型</strong>：使用泛型参数，可以增强代码的可读性以及稳定性。</li><li><strong>反射</strong>：赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</li><li><strong>注解</strong>：可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</li><li><strong>集合</strong>：Java 集合，也叫作容器，可以用于保存数据，主要分为 List, Set, Queue, Map 四大类，这四类分别由不同的用途。</li><li><strong>IO 流</strong>：用于处理输入和输出，比如文件读写。</li><li><strong>多线程</strong>：除了 <code>Thread</code> 类和 <code>Runnable</code> 接口这些基础外，最重要的就是 JUC 了，这个包中包含并发编程中很常用的实用工具类，包括线程池、异步 IO、各种锁等等。</li></ul><h4 id="Java三大特性"><a href="#Java三大特性" class="headerlink" title="Java三大特性"></a>Java三大特性</h4><p><strong>封装</strong></p><blockquote><p>封装指的是属性和方法私有化，根据需要提供setter和getter方法来访问属性。即隐藏具体属性和实现细节，仅对外开放接口，控制程序中属性的访问级别。</p><p>封装目的：增强安全性和简化编程，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员与方法。</p></blockquote><p><strong>继承</strong></p><blockquote><p>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，使用extends关键字实现继承；子类中可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。</p><p>• 继承的出现减少了代码冗余，提高了代码的复用性。<br>• 继承的出现，更有利于功能的扩展。<br>• 继承的出现让类与类之间产生了的关系，为多态的使用提供了前提。</p></blockquote><p><strong>多态</strong></p><blockquote><p>多态就是在声明时使用父类，在实现或调用时使用具体的子类；即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态。</p><p>在 Java 中的体现：父类的引用指向子类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure><p><strong>多态的条件：</strong></p><p><strong>继承</strong>: 在多态中必须存在有继承关系的子类和父类。</p><p><strong>方法重写</strong>: 子类对父类中某些方法进行重新定义,在调用这些方法时就会调用子类的方法。</p><p><strong>向上转型</strong>: 在多态中需要将子类的引用赋给父类对象,只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p></blockquote><blockquote><p>好处：父类变量引用的子类对象不同，执行的方法就不同，实现动态绑定。代码编写更灵活、功能更强大，可维护性和扩展性更好了。<br>弊端：一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法（父类中没有的属性和方法）。</p></blockquote><h4 id="抽象类接口什么不同"><a href="#抽象类接口什么不同" class="headerlink" title="抽象类接口什么不同"></a>抽象类接口什么不同</h4><p><strong>抽象类</strong>：在Java中被abstract关键字修饰的类称为抽象类，被abstract关键字修饰的方法称为抽象方法，抽象方法只有方法的声明，没有方法体。抽象类的特点：</p><p>a、抽象类不能被实例化只能被继承；</p><p>b、包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法，抽象类中可以包含普通方法；</p><p>c、抽象类中的抽象方法的修饰符只能为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），默认为public；</p><p>d、一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类；</p><p>e、抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。</p><p>*<strong>接口*：</strong>Java中接口使用interface关键字修饰，特点为:</p><p>a、接口可以包含变量、方法；变量被隐式指定为public static final，方法被隐式指定为public abstract（JDK1.8之前）；</p><p>b、接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题；</p><p>c、一个类可以实现多个接口；</p><h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a><strong>相同点</strong></h5><p>（1）都不能被实例化 （2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。</p><h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a><strong>不同点</strong></h5><p>（1）接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现（普通方法），方法可在抽象类中实现。</p><p>（2）实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</p><p>（3）接口强调特定功能的实现，而抽象类强调所属关系。</p><h4 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h4><p>深拷贝和浅拷贝是只针对引用数据类型的</p><p><strong>引用拷贝</strong>: 引用拷贝就是直接赋值，只在栈中创建一个新的引用，拷贝引用的地址，所以指向的是堆中同一个对象。</p><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），这个对象有着原始对象属性值的一份精确拷贝。如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。深拷贝会递归拷贝对象所有层级的对象属性和数组元素。深拷贝相比于浅拷贝速度较慢并且花销较大。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111716166.png" alt="image-20231003111716166"></p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111721557.png" alt="image-20231003111721557" style="zoom:150%;" /><h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><p>序列化核心目的是为了解决网络通信之间的对象传输问题。<br>也就是说，如何把当前 JVM 进程里面的一个对象，跨网络传输到另外一个 JVM进程里面。<br>序列化：把内存里面的<strong>对象转化为字节流</strong>，以便用来<strong>实现存储或者传输</strong>。<br>反序列化：根据从<strong>文件或者网络上获取到的对象的字节流</strong>，根据字节流里面保存的<strong>对象描述信息和状态</strong>，重新构建一个新的对象。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111810871.png" alt="image-20231003111810871"></p><p>其次呢，序列化的前提是保证通信双方对于对象的可识别性，所以很多时候，我们会把对象先转化为通用的解析格式，比如 json、xml 等。然后再把他们转化为字节流进行网络传输，从而实现跨平台和跨语言的可识别性。</p><h4 id="Java反射有了解吗？举几个Java反射的应用案例"><a href="#Java反射有了解吗？举几个Java反射的应用案例" class="headerlink" title="Java反射有了解吗？举几个Java反射的应用案例"></a>Java反射有了解吗？举几个Java反射的应用案例</h4><p>反射是java语言的一个特性，<strong>反射功能通常用于检查或修改Java虚拟机运行中（runtime）的应用程序的行为</strong>,它允程序在运行时（注意不是编译的时候），获取任意一个类的成员变量、成员方法和属性,调用任意一个对象的方法和属性,，这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p><ul><li>获取任意类的名称、package信息、所有属性、方法、注解、类型、类加载器等</li><li>获取任意对象的属性，并且能改变对象的属性</li><li>调用任意对象的方法</li><li>判断任意一个对象所属的类</li><li>实例化任意一个类的对象</li><li>通过反射我们可以实现动态装配，降低代码的耦合度,动态代理等。</li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>可以增加程序的灵活性，在运行过程中可以动态对类进行修改和操作</li><li>提高代码复用率，比如动态代理</li><li>可以在运行时轻松获取任意一个类的方法、属性、并且还能通过反射进行动态调用</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>使用反射后，可读性较差</li><li>反射可以绕过一些限制访问的属性和方法，可能会导致一些安全性问题</li><li>反射会涉及动态类型的解析，所以JVM无法对这些代码进行优化，导致性能要比非反射调用更低</li></ul><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>AOP动态代理的场景中，使用动态生成的代理类来提升代码复用性。</li><li>IOC：组件扫描后，用反射来实例化bean对象等</li></ul><h5 id="反射的原理"><a href="#反射的原理" class="headerlink" title="反射的原理"></a>反射的原理</h5><p>通常，java在编译之后，会将Java代码生成为class源文件，JVM启动时，将会载入所有的源文件，并将类信息存放到方法区中；将所有对象实例存放在Java堆中，同时也会保存指向类型信息的指针。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rad5bGx6YGT5aOr,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>以下分两种情况来分析，直接使用类和使用反射的区别，以此理解反射的实现原理。</p><p><strong>直接使用类</strong><br>正常流程下，我们要创建一个类的实例，是一定确定这个类的类型信息的，我们知道这个类的名字、方法、属性等等。我们可以很容易的创建实例，也可以通过实例很容易的获取属性、调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br></pre></td></tr></table></figure><p><strong>使用反射</strong><br>在一个方法中，如果我们不知道在实际运行（runtime）时，它将要处理的对象是谁，它的类型信息是怎么样的，那我们如何访问这个对象或为这个对象创建一个新的实例呢？</p><p>与直接使用类相反，我们需要<strong>先获取到对象在方法区的类型信息</strong>（通过实例对象的getClass方法、全限定类名等限定条件），获取到类型信息后，我们就知道这个类的构造器、属性、方法、注解、子类、父类等等信息了，这个时候，<strong>我们就可以通过这些类型信息来回调处理对象，来完成自己想要的操作了。</strong></p><p><strong>反射在运行时，通过读取方法区中的字节码，来动态的找到其反射的类以及类的方法和属性等（实际上就是在运行时，根据全类型名、对象的getClass()等，在方法区找对应的类）</strong>，用这些类型信息完成对该类实例的操作，其实就是直接使用类的一个逆向使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">void</span> <span class="title function_">reflectMethod</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理这个无法明确类型的实例对象</span></span><br><span class="line">        <span class="comment">// 获取类型信息</span></span><br><span class="line">        Class&lt;?&gt; aClass = obj.getClass();</span><br><span class="line">        Field[] fields = aClass.getFields();</span><br><span class="line">        Method[] methods = aClass.getMethods();</span><br><span class="line">        Annotation[] annotations = aClass.getAnnotations();</span><br><span class="line">        Constructor&lt;?&gt;[] constructors = aClass.getConstructors();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = aClass.getInterfaces();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 操作属性或方法</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> fields[<span class="number">0</span>];</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> field.get(obj); <span class="comment">// 获取obj的属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在实际开发过程会遇到很多这种情况，譬如常用到的Bean属性工具类org.springframework.beans.BeanUtils.copyProperties(Object source, Object target)，在复制对象属性前，它是并不知道source、target这两个对象有什么属性的，那么这个工具类是如何完成属性复制呢？这里其实就用到了反射功能。可以简单了解下流程：</p><ul><li><p>获取target的类型</p></li><li><p>获取target类中属性、getter和setter方法</p></li><li><p>遍历target中的属性，查询source中是否有属性名相同且支持getter和setter的属性</p></li><li><p>通过source.getter.invoke方法读取值</p></li><li><p>最后通过target.setter.invoke(source.getter.invoke) 设置刚刚从source读取的值</p></li><li><p>循环遍历target所有属性后，就完成了整个属性的复制</p></li><li><p>这里只是一个简单的反射运用，感兴趣的可以看看源码</p></li></ul></blockquote><p><strong>总结</strong></p><ul><li><p>直接使用是在运行前就明确类型信息，然后在运行时根据这个类来操作对象；</p></li><li><p>而反射是运行时先拿到对象，根据对象得到方法区中的类型信息后，<strong>再根据属性、方法来操作该对象。</strong></p></li></ul><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p><strong>什么是代理模式</strong></p><p>定义：为其他对象提供一种代理以控制对这个对象的访问。</p><p>如果<strong>根据字节码的创建时机</strong>来分类，可以分为静态代理和动态代理：</p><ul><li>所谓<strong>静态</strong>也就是在<strong>程序运行前</strong>就已经存在代理类的<strong>字节码文件</strong>，代理类和真实主题角色的关系在运行前就确定了。</li><li>而动态代理的源码是在程序运行期间由<strong>JVM</strong>根据<strong>反射</strong>等机制<strong>动态的生成</strong>，所以在运行前并不存在代理类的字节码文件</li></ul><p><strong>静态代理</strong></p><p>我们先通过实例来学习静态代理，然后理解静态代理的缺点，再来学习本文的主角：动态代理</p><p>编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span>;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;查询 selectById&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新 update&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将通过静态代理对 UserServiceImpl 进行功能增强，在调用<code>select</code>和<code>update</code>之前记录一些日志。写一个代理类 UserServiceProxy，代理类需要实现 UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceProxy</span><span class="params">(UserService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        target.select();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        target.update();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;     <span class="comment">// 在执行方法之前执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log start time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;      <span class="comment">// 在执行方法之后执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log end time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userServiceImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceProxy</span>(userServiceImpl);</span><br><span class="line"></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br></pre></td></tr></table></figure><p>通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。</p><p>静态代理的缺点<br>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。</p><p>1、 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</p><ul><li>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致<strong>代理类过于庞大</strong>,方法过多</li><li>新建多个代理类，每个目标对象对应一个代理类，但是这样会<strong>产生过多的代理类</strong></li></ul><p>2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，<strong>不易维护。</strong></p><p><strong>动态代理就是让代理类动态的生成，最常见的就是使用反射实现</strong>，使用反射（依据被代理类、被代理类的所有接口、被代理类的ClassLoader）来加载代理类</p><p>&#x2F;&#x2F;动态代理：使⽤JDK提供的api（InvocationHandler、Proxy实现），此种⽅式实现，要求被代理类必须实现接⼝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayServiceJDKInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"><span class="comment">//⽬标对象即就是被代理对象</span></span><br><span class="line"><span class="keyword">private</span> Object target;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PayServiceJDKInvocationHandler</span><span class="params">( Object target)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//proxy代理对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"> <span class="comment">//1.安全检查</span></span><br><span class="line"> System.out.println(<span class="string">&quot;安全检查&quot;</span>);</span><br><span class="line"> <span class="comment">//2.记录⽇志</span></span><br><span class="line"> System.out.println(<span class="string">&quot;记录⽇志&quot;</span>);</span><br><span class="line"><span class="comment">//3.时间统计开始</span></span><br><span class="line">System.out.println(<span class="string">&quot;记录开始时间&quot;</span>);</span><br><span class="line"><span class="comment">//通过反射调⽤被代理类的⽅法</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"><span class="comment">//4.时间统计结束</span></span><br><span class="line">System.out.println(<span class="string">&quot;记录结束时间&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">PayService target= <span class="keyword">new</span> <span class="title class_">AliPayService</span>();</span><br><span class="line"><span class="comment">//⽅法调⽤处理器</span></span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PayServiceJDKInvocationHandler</span>(target);</span><br><span class="line"><span class="comment">//创建⼀个代理类：通过被代理类、被代理实现的接⼝、⽅法调⽤处理器来创建</span></span><br><span class="line"><span class="type">PayService</span> <span class="variable">proxy</span> <span class="operator">=</span> (PayService) Proxy.newProxyInstance(</span><br><span class="line">target.getClass().getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;PayService.class&#125;,handler);</span><br><span class="line">proxy.pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK动态代理</strong></p><p>从 UserServiceProxy 的代码中我们可以发现：</p><ul><li>UserServiceProxy 继承了 Proxy 类，并且实现了被代理的所有接口，以及equals、hashCode、toString等方法</li><li>由于 UserServiceProxy 继承了 Proxy 类，所以每个代理类都会关联一个 InvocationHandler 方法调用处理器</li><li>类和所有方法都被 <code>public final</code> 修饰，所以代理类只可被使用，不可以再被继承</li><li>每个方法都有一个 Method 对象来描述，Method 对象在static静态代码块中创建，以 <code>m + 数字</code> 的格式命名</li><li>调用方法的时候通过 <code>super.h.invoke(this, m1, args)</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 xxxHandler 对象，它继承 InvocationHandler 类，负责实际的调用处理逻辑</li></ul><p>而 LogHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，<strong>然后通过反射让被代理的对象 target 执行方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    before();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);       <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">    after();</span><br><span class="line">    <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以车站卖票的例子来看</strong></p><pre><code>1. 通过代理对象调用sell()方法2. 根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法3. 代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法，传入调用的方法以及参数4. invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法</code></pre><p>JDK动态代理执行方法调用的过程简图如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-776369e13e295f3c8e33489251bd4927_1440w.webp" alt="img"></p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="Error与Exception的区别"><a href="#Error与Exception的区别" class="headerlink" title="Error与Exception的区别"></a>Error与Exception的区别</h4><p>(1)Error类和Exception类都是继承Throwable类<br>(2)Error（错误）<strong>是系统中的错误</strong>，程序员是不能改变的和处理的，是在<strong>程序编译时出现的错误</strong>，只能通过修改程序才能修正。一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。<br>(3)Exception（异常）表示程序可以处理的异常，<strong>可以捕获且可能恢复</strong>。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。<br><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY5ODU2MQ==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><h4 id="异常顶层是什么，有哪些接口实现类"><a href="#异常顶层是什么，有哪些接口实现类" class="headerlink" title="异常顶层是什么，有哪些接口实现类"></a>异常顶层是什么，有哪些接口实现类</h4><p><strong>Java 异常类层次结构图概览</strong>：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640.png" alt="图片"></p><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong><code>Exception</code></strong>: 程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。</li><li>分为 Checked Exception 非运行时异常（编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义unchecked异常。通俗的话说，就是在写代码时出现红线，需要try catch或者throws时出现的异常。</li><li>Unchecked Exception(运行时异常)，都是RuntimeException类及其子类异常，就是我们在开发中测试功能时程序终止，控制台出现的异常，比如：<br>NullPointerException(空指针异常)<br>IndexOutOfBoundsException(下标越界异常)<br>ClassCastException(类转换异常)<br>ArrayStoreException(数据存储异常，操作数组时类型不一致)<br>IO操作的BufferOverflowException异常</li><li><strong><code>Error</code></strong>: <code>Error</code> 属于程序无法处理的错误 ，不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h4 id="全局异常处理器如何实现？"><a href="#全局异常处理器如何实现？" class="headerlink" title="全局异常处理器如何实现？"></a>全局异常处理器如何实现？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用ControllerAdvice注解标识该类为异常处理类</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常处理，指定该方法处理的异常类型为Exception</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="comment">//将返回的Result转化为Json格式，在controller中已经包含此注解</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">error</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.build(<span class="literal">null</span> , <span class="number">201</span>,<span class="string">&quot;出现了异常&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常处理，指定该方法处理的异常类型为GuiguException</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = GuiguException.class)</span><span class="comment">// 处理自定义异常</span></span><br><span class="line">    <span class="comment">//将返回的Result转化为Json格式，在controller中已经包含此注解</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">error</span><span class="params">(GuiguException exception)</span> &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.build(<span class="literal">null</span> , exception.getResultCodeEnum()) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么情况下会报ClassNotFound的异常？"><a href="#什么情况下会报ClassNotFound的异常？" class="headerlink" title="什么情况下会报ClassNotFound的异常？"></a>什么情况下会报ClassNotFound的异常？</h4><p>当应用程序运行的过程中尝试使用类加载器去加载Class文件的时候，如果没有在classpath中查找到指定的类，就会抛出ClassNotFoundException。一般情况下，当我们使用Class.forName()或者ClassLoader.loadClass以及使用ClassLoader.findSystemClass()在运行时加载类的时候，如果类没有被找到，那么就会导致JVM抛出ClassNotFoundException。</p><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><h4 id="字符流与字节流"><a href="#字符流与字节流" class="headerlink" title="字符流与字节流"></a>字符流与字节流</h4><p><strong>流</strong><br>流是一个抽象的概念，可以看作是一连串的数据，在程序中所有的数据都是以流的方式进行传输或保存的，程序需要数据的时候要使用输入流读取数据，而当程序需要将一些数据保存起来的时候，就要使用输出流完成。程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。</p><p>Java中的流是对字节序列的抽象，我们可以想象有一个水管，只不过现在流动在水管中的不再是水，而是字节序列。和水流一样，Java中的流也具有一个“流动的方向”，通常可以从中读入一个字节序列的对象被称为输入流；能够向其写入一个字节序列的对象被称为输出流。</p><blockquote><p>知识补充1：<br>计算机能存储的唯一东西就是 bytes,为了在计算机中存储东西,我们首先得将其编码(encode),例如将其转化为 bytes。<br>比如：要想保存音乐(以字节形式保存),我们首先得用 MP3, WAV 等将其编码；要想保存图片,我们首先得用 PNG, JPEG 等将其编码；要想保存文本,我们首先得用 ASCII, UTF-8 等将其编码.<br>知识补充2:<br>Unicode 是字符集,不是字符编码。Unicode 把全世界的字符都搜集并且编号了,但是没有规定具体的编码规则。编码规则有 UTF-8、GBK等。</p></blockquote><p><strong>字节流</strong><br>Java中的字节流处理的最基本单位为单个字节，它通常用来处理二进制数据。Java中最基本的两个字节流类是InputStream和OutputStream，它们分别代表了最基本的输入字节流和输出字节流。InputStream是所有字节输入流的祖先，而OutputStream是所有字节输出流的祖先，它们都是抽象类。</p><p><strong>字节流在默认情况下是不支持缓存的，字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，这意味着每调用一次read方法都会请求操作系统来读取一个字节，这往往会伴随着一次磁盘IO</strong>，因此效率会比较低。要使用内存缓冲区以提高读取的效率，我们应该使用BufferedInputStream。</p><p>需注意，使用BufferedOutputStream输出数据时如果没有关闭流，数据也是不会输出到文件当中的，即并不是所有字节流都不用到缓冲区，输入缓冲字节流BufferedInputStream和输出缓冲字节流BufferedOutputStream还是要用到缓冲区的。</p><p><strong>字符流</strong></p><p><strong>为什么要有字符流？</strong></p><p>Java中字符是采用Unicode标准，Unicode 编码中，一个英文为一个字节，一个中文为两个字节。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-bc6b06e4cf29ecb425f56eb3e72d6e40_1440w.webp" alt="img"></p><p>而在UTF-8编码中，一个中文字符是3个字节。例如下面图中，“云深不知处”5个中文对应的是15个字节：-28-70-111-26-73-79-28-72-115-25-97-91-27-92-124</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-d10f2fb7a759d08a233fb04dd7ca7b95_1440w.webp" alt="img"></p><p>那么问题来了，如果使用字节流处理中文，如果一次读写一个字符对应的字节数就不会有问题，一旦将一个字符对应的字节分裂开来，就会出现乱码了。为了更方便地处理中文这些字符，Java就推出了字符流。</p><p>Java中的字符流处理的最基本的单元是Unicode码元（大小2字节），它通常<strong>用来处理文本数据</strong>，例如字符、字符数组或字符串。Java中的String类型默认就把字符以Unicode规则编码而后存储在内存中。存储在磁盘上的数据通常有着各种各样的编码方式，不同的编码方式最终输出的字节内容是不同的，所以，字节流的读取和写入都要<strong>设置相应的编码方式。</strong></p><p>由于<strong>字符流在输出前</strong>实际上是要完成<strong>Unicode码元序列</strong>到相应编码方式的<strong>字节序列的转换</strong>，所以它会使用<strong>内存缓冲区</strong>来存放转换后得到的<strong>字节序列</strong>，等待都转换完毕再一同写入磁盘文件中。</p><p>所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列。</p><p>字符流与字节流的区别：</p><ul><li><p>字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元（通常为两个字节）。<br>字节流默认不使用缓冲区；字符流使用缓冲区(用于保存由字符转化为的字节)。</p></li><li><p>字节流在操作的时候本身是不会用到缓冲区的，是与文件本身直接操作的，所以字节流在操作文件时，即使不关闭资源，文件也能输出；字符流在操作的时候是使用到缓冲区的。如果字符流不调用close或flush方法，则不会输出任何内容。</p></li><li><p>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</p></li><li><p>字节流按字节读数据,而字节不需要编码、解码,只有字节与字符之间转换时才需要编码、解码！</p></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="单例模式（重要）"><a href="#单例模式（重要）" class="headerlink" title="单例模式（重要）"></a>单例模式（重要）</h4><p><strong>何为单例模式</strong><br>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。<br><strong>实现思路</strong><br>如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将 类的构造器的访问权限设置为 private ，这样，就不能用 new 操作符在类的外部产生类的对<br>象了，但在类内部仍可以产生该类的对象。</p><p>因为在类的外部开始还无法得到类的对象， 只能调用该类的某个静态方法 以返回类内部创建的对象，</p><p>静态方法只能访问类中的静态成员变量，所以，指向类内部产生的 该类对象的变量也必须定义成静态的 。</p><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 私有化构造器，防止使用构造器new对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 内部提供一个当前类的实例</span></span><br><span class="line">    <span class="comment">// 4. 此实例也必须静态化，才能让静态方法返回该实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 3. 提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="懒汉式-多线程环境下多个线程同时初始化对象会出现线程安全问题，需要加上类锁"><a href="#懒汉式-多线程环境下多个线程同时初始化对象会出现线程安全问题，需要加上类锁" class="headerlink" title="懒汉式(多线程环境下多个线程同时初始化对象会出现线程安全问题，需要加上类锁)"></a>懒汉式(多线程环境下多个线程同时初始化对象会出现线程安全问题，需要加上类锁)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyOne</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyOne instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyOne</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方式 1 ：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazyOne <span class="title function_">getInstance1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式 2 ：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title function_">getInstance2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazyOne.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式 3 ：存在线程安全问题，当线程1获得锁，new instance并不是一个原子操作</span></span><br><span class="line"><span class="comment">//线程2判断instance不为空可能返回未初始化完成的instance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title function_">getInstance2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyOne.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">                    <span class="comment">//分配空间</span></span><br><span class="line">                    <span class="comment">//初始化</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要解决双重检查锁模式带来空指针异常的问题，只需要使用 `volatile` 关键字, `volatile` 关键字可以保证可见性和有序性。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过静态内部类实现懒汉式单例模式，不需要加锁，较为推荐</strong></p><p>静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder</p><p>并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p><h5 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h5><p>使用<strong>序列化与反序列化</strong>可以生成多个实例对象，会破坏单例设计模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//往文件中写对象</span></span><br><span class="line">        <span class="comment">//writeObject2File();</span></span><br><span class="line">        <span class="comment">//从文件中读取对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断两个反序列化后的对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title function_">readObjectFromFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建对象输入流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//第一个读取Singleton对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeObject2File</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="comment">//创建对象输出流</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//将instance对象写出到文件中</span></span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决</strong>：在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面是为了解决序列化反序列化破解单例模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：反射能够调用private的构造方法，破坏单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的字节码对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Singleton.class;</span><br><span class="line">        <span class="comment">//获取Singleton类的私有无参构造方法对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//取消访问检查</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Singleton类的对象s1</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line">        <span class="comment">//创建Singleton类的对象s2</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断通过反射创建的两个Singleton对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决</strong>：在构造器中添加判断逻辑，如果instance不为空，就抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           反射破解单例模式需要添加的代码</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>饿汉式</strong>：</p><ul><li><strong>特点</strong>： 立即加载 ，即在使用类的时候已经将对象创建完毕。</li><li><strong>优点</strong>：实现起来 简单 ；没有多线程安全问题。</li><li><strong>缺点</strong>：当类被加载的时候，会初始化 static 的实例，静态变量被创建并分配内存空间，从这以后，这个 static 的实例便一直占着这块内存，直到类被卸载时，静态变量被摧毁，并释放所占有的内存。因此在某些特定条件下会 耗费内存 。</li></ul><p><strong>懒汉式</strong>：</p><ul><li><strong>特点</strong>： 延迟加载 ，即在调用静态方法时实例才被创建。</li><li><strong>优点</strong>：实现起来比较简单；当类被加载的时候，static 的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会节约内存 。</li><li><strong>缺点</strong>：在多线程环境中，这种实现方法是完全错误的， 线程不安全 ，需要加锁保证单例的唯一性。</li></ul><p><strong>单例模式的优点及应用场景</strong><br>由于单例模式只生成一个实例，减少了 系统性能开销 ，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时，直接产生一个单例对象，然后永久驻留内存的方式来解决。</p><h4 id="Strategy策略模式"><a href="#Strategy策略模式" class="headerlink" title="Strategy策略模式"></a><strong>Strategy策略模式</strong></h4><p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们之间可以相互替换，策略模式可以在不影响客户端的情况下发生变化。 策略模式是处理算法不同变体的一种成熟模式，策略模式通过接口或抽象类封装算法的标识，即在接口中定义一个抽象方法，实现该接口的类将实现接口中的抽象方法。策略模式把针对一个算法标识的一系列具体算法分别封装在不同的类中，使得各个类给出的具体算法可以相互替换。</p><p>策略模式的结构：</p><ul><li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li></ul><p>【例】促销活动</p><p>一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p>代码如下：</p><p>定义百货公司所有促销活动的共同接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为春节准备的促销活动A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买一送一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为中秋准备的促销活动B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满200元减50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为圣诞准备的促销活动C</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalesMan</span> &#123;                        </span><br><span class="line">    <span class="comment">//持有抽象策略角色的引用                              </span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;                 </span><br><span class="line">                                               </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SalesMan</span><span class="params">(Strategy strategy)</span> &#123;       </span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;              </span><br><span class="line">    &#125;                                          </span><br><span class="line">                                               </span><br><span class="line">    <span class="comment">//向客户展示促销活动                                </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">salesManShow</span><span class="params">()</span>&#123;                </span><br><span class="line">        strategy.show();                       </span><br><span class="line">    &#125;                                          </span><br><span class="line">&#125;                                              </span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p><strong>1，优点：</strong></p><ul><li><p>策略类之间可以自由切换</p><p>由于策略类都实现同一个接口，所以使它们之间可以自由切换。</p></li><li><p>易于扩展</p><p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“</p></li><li><p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想。</p></li></ul><p><strong>2，缺点：</strong></p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li></ul><p><strong>使用场景</strong></p><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li></ul><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><strong>工厂模式</strong></h4><p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。现在在以一个具体的例子来简单简化下工厂模式。假如我现在去餐馆吃饭，餐馆有回锅肉，有鱼，有烤鸭可供我选择，然后我点餐餐馆为我做出具体的菜。</p><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>首先我们来创建一个餐馆的接口,因为这里只要有做菜就行，所以写一个cook的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Resaurant</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来写三个实现类，分别是做回锅肉的，做鱼的，做烤鸭的，用这三个实现类去实现餐馆的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> <span class="keyword">implements</span> <span class="title class_">Resaurant</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来一份烤鸭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">implements</span> <span class="title class_">Resaurant</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来一份红烧鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Meet</span> <span class="keyword">implements</span> <span class="title class_">Resaurant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来一份回锅肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在餐馆已经具备了做回锅肉，做鱼，做烤鸭的功能，但是客人来了并不知道餐馆有这些菜，这时候就需要我们来给餐馆做一个菜单，客人来了就可以根据菜单点餐；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wait</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MEAN_MEET</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MEAN_FISH</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MEAN_DUCK</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Resaurant <span class="title function_">getMean</span><span class="params">(<span class="type">int</span> meantype)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (meantype)&#123;</span><br><span class="line">            <span class="keyword">case</span> MEAN_MEET :</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Meet</span>();</span><br><span class="line">            <span class="keyword">case</span> MEAN_FISH :</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">            <span class="keyword">case</span> MEAN_DUCK :</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>菜单也有了，现在客人来了可以点餐了，假如客人根据菜单点了一份烤鸭，那餐馆就可以直接给客人制作一份美味的烤鸭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//简单工厂模式</span></span><br><span class="line">        <span class="type">Resaurant</span> <span class="variable">resaurant</span> <span class="operator">=</span> Wait.getMean(Wait.MEAN_DUCK);</span><br><span class="line">        resaurant.cook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看执行结果</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-fdb9586dea3ad2f16c5e3ba1289117c1_1440w.webp" alt="img"></p><h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>工厂模式除了简单工厂模式还有工厂方法模式和抽象工厂模式，下面我再已餐馆这个例子给大家扩展一下工厂方法模式。工厂方法模式就是把简单工厂中具体的工厂类，划分成两层：抽象工厂层+具体的工厂子类层。</p><p>首先我们来创建一个抽象工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CookFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Resaurant <span class="title function_">createRestaurant</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建两个具体需要的产品实现类去继承上面这个抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DuckFactory</span> <span class="keyword">extends</span> <span class="title class_">CookFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Resaurant <span class="title function_">createRestaurant</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FishFactory</span> <span class="keyword">extends</span> <span class="title class_">CookFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Resaurant <span class="title function_">createRestaurant</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>烤鸭和鱼都做好了，开始享用吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cook</span> &#123;</span><br><span class="line">    <span class="comment">//工厂方法模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Resaurant</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DuckFactory</span>().createRestaurant();</span><br><span class="line">        duck.cook();</span><br><span class="line">        <span class="type">Resaurant</span> <span class="variable">fish</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FishFactory</span>().createRestaurant();</span><br><span class="line">        fish.cook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下执行结果</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-6f3165566e6db1dc7ac0a40aabd93d9e_1440w.webp" alt="img"></p><p><strong>优点和缺点</strong></p><p>优点：</p><ul><li><strong>一个调用者想创建一个对象，只要知道其名称就可以了。</strong></li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li><li>屏蔽产品的具体实现，调用者只关心产品的接口。</li></ul><p>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p><strong>概述</strong>：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p><p><strong>结构</strong>：原型模式包含如下角色：</p><ul><li>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ul><p>接口类图如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png"></p><p><strong>用原型模式生成“三好学生”奖状</strong></p><p>同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。</p><p>类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F1.png" style="zoom:80%;" /><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奖状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试访问类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        c1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制奖状</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> c1.clone();</span><br><span class="line">        <span class="comment">//将奖状的名字修改李四</span></span><br><span class="line">        c2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>对象的创建非常复杂，可以使用原型模式快捷的创建对象。</li><li>性能和安全要求比较高。</li></ul><h5 id="扩展（深克隆）"><a href="#扩展（深克隆）" class="headerlink" title="扩展（深克隆）"></a>扩展（深克隆）</h5><p>将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奖状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStu</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stu = stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(stu.getName() + <span class="string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line">        c1.setStu(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制奖状</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> c1.clone();</span><br><span class="line">        <span class="comment">//获取c2奖状所属学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> c2.getStu();</span><br><span class="line">        stu1.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断stu对象和stu1对象是否是同一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F2.png" style="zoom:80%;" /><p><font color="red">说明：</font></p><p>​stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，</p><p>可以重写clone方法实现。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// constructors, getters and setters</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) <span class="built_in">super</span>.clone();</span><br><span class="line">        user.setAddress(<span class="built_in">this</span>.address.clone());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用序列化实现深拷贝</p><p>Java提供了序列化的能力，我们可以先将源对象进行序列化，再反序列化生成拷贝对象。但是，使用序列化的前提是拷贝的类（包括其成员变量）需要实现Serializable接口。Apache Commons Lang包对Java序列化进行了封装，我们可以直接使用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String country;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// constructors, getters and setters</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// constructors, getters and setters</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serializableCopy</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;杭州&quot;</span>, <span class="string">&quot;中国&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;大山&quot;</span>, address);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 使用Apache Commons Lang序列化进行深拷贝</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">copyUser</span> <span class="operator">=</span> (User) SerializationUtils.clone(user);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 修改源对象的值</span></span><br><span class="line">    user.getAddress().setCity(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 检查两个对象的值不同</span></span><br><span class="line">    assertNotSame(user.getAddress().getCity(), copyUser.getAddress().getCity());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="序列化为JSON"><a href="#序列化为JSON" class="headerlink" title="序列化为JSON"></a>序列化为JSON</h5><p>Gson可以将对象序列化成JSON，也可以将JSON反序列化成对象，所以我们可以用它进行深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gsonCopy</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;杭州&quot;</span>, <span class="string">&quot;中国&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;大山&quot;</span>, address);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 使用Gson序列化进行深拷贝</span></span><br><span class="line">    <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    <span class="type">User</span> <span class="variable">copyUser</span> <span class="operator">=</span> gson.fromJson(gson.toJson(user), User.class);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 修改源对象的值</span></span><br><span class="line">    user.getAddress().setCity(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 检查两个对象的值不同</span></span><br><span class="line">    assertNotSame(user.getAddress().getCity(), copyUser.getAddress().getCity());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p><strong>定义：</strong></p><p>​运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p><p>【例】俄罗斯方块</p><p>下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.jpeg" style="zoom:60%;" /><p><strong>先来看类图：</strong></p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p><strong>代码如下：</strong></p><p>俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getShape</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方块形状：&quot;</span> + <span class="built_in">this</span>.getShape() + <span class="string">&quot; 颜色：&quot;</span> + color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;L&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, AbstractBox&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BoxFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, AbstractBox&gt;();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">iBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">lBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">oBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OBox</span>();</span><br><span class="line">        map.put(<span class="string">&quot;I&quot;</span>, iBox);</span><br><span class="line">        map.put(<span class="string">&quot;L&quot;</span>, lBox);</span><br><span class="line">        map.put(<span class="string">&quot;O&quot;</span>, oBox);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BoxFactory <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BoxFactory</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BoxFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AbstractBox <span class="title function_">getBox</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优缺点和使用场景"><a href="#优缺点和使用场景" class="headerlink" title="优缺点和使用场景"></a>优缺点和使用场景</h5><p><strong>优点</strong></p><ul><li>极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</li></ul><p><strong>使用场景：</strong></p><ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li></ul><h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p><strong>定义：</strong></p><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p><p>【例】炒菜</p><p>炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">cookProcess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//第一步：倒油</span></span><br><span class="line">        <span class="built_in">this</span>.pourOil();</span><br><span class="line">        <span class="comment">//第二步：热油</span></span><br><span class="line">        <span class="built_in">this</span>.heatOil();</span><br><span class="line">        <span class="comment">//第三步：倒蔬菜</span></span><br><span class="line">        <span class="built_in">this</span>.pourVegetable();</span><br><span class="line">        <span class="comment">//第四步：倒调味料</span></span><br><span class="line">        <span class="built_in">this</span>.pourSauce();</span><br><span class="line">        <span class="comment">//第五步：翻炒</span></span><br><span class="line">        <span class="built_in">this</span>.fry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;倒油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：热油是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heatOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;热油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：倒调味料是不一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五步：翻炒是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;炒啊炒啊炒到熟啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_BaoCai</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是包菜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是辣椒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_CaiXin</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是菜心&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是蒜蓉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//炒手撕包菜</span></span><br><span class="line">        <span class="type">ConcreteClass_BaoCai</span> <span class="variable">baoCai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass_BaoCai</span>();</span><br><span class="line">        baoCai.cookProcess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//炒蒜蓉菜心</span></span><br><span class="line">        <span class="type">ConcreteClass_CaiXin</span> <span class="variable">caiXin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass_CaiXin</span>();</span><br><span class="line">        caiXin.cookProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：为防止恶意操作，一般模板方法都加上 final 关键词。</p></blockquote><p><strong>优点：</strong></p><ul><li><p>提高代码复用性</p><p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p></li><li><p>实现了反向控制</p><p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。</p></li></ul><p><strong>缺点：</strong></p><ul><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li></ul><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><p><strong>定义：</strong></p><p>​指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p><p><strong>例子</strong></p><p>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。</p><p>使用继承的方式存在的问题：</p><ul><li><p>扩展性不好</p><p>如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。</p></li><li><p>产生过多的子类</p></li></ul><p>我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.png" style="zoom:75%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快餐接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> price;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">(<span class="type">float</span> price, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">float</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDesc</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span>;  <span class="comment">//获取价格</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒饭</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRice</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedRice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">10</span>, <span class="string">&quot;炒饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedNoodles</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedNoodles</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">12</span>, <span class="string">&quot;炒面&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配料类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Garnish</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FastFood fastFood;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FastFood <span class="title function_">getFastFood</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFastFood</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Garnish</span><span class="params">(FastFood fastFood, <span class="type">float</span> price, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(price,desc);</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鸡蛋配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Egg</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Egg</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(fastFood,<span class="number">1</span>,<span class="string">&quot;鸡蛋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//培根配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bacon</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bacon</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(fastFood,<span class="number">2</span>,<span class="string">&quot;培根&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//点一份炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">&quot; &quot;</span> + food.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加鸡蛋的炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line"></span><br><span class="line">        food1 = <span class="keyword">new</span> <span class="title class_">Egg</span>(food1);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food1.getDesc() + <span class="string">&quot; &quot;</span> + food1.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加培根的炒面</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedNoodles</span>();</span><br><span class="line">        food2 = <span class="keyword">new</span> <span class="title class_">Bacon</span>(food2);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food2.getDesc() + <span class="string">&quot; &quot;</span> + food2.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>好处：</strong></p><ul><li><p>装饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</p></li><li><p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p></li></ul><p><strong>使用场景</strong></p><ul><li><p>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</p><p>不能采用继承的情况主要有两类：</p><ul><li>第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；</li><li>第二类是因为类定义不能继承（如final类）</li></ul></li><li><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p></li><li><p>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</p></li></ul><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p><strong>定义</strong>：又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p>【例】现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。</p><p>类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请假条</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//请假天数</span></span><br><span class="line">    <span class="keyword">private</span> String content;<span class="comment">//请假内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeaveRequest</span><span class="params">(String name, <span class="type">int</span> num, String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理者抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_ONE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_THREE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_SEVEN</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该领导处理的请假天数区间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//领导上面还有领导</span></span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围 上不封顶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart, <span class="type">int</span> numEnd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">        <span class="built_in">this</span>.numEnd = numEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置上级领导</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(Handler nextHandler)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交请假条</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(LeaveRequest leave)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">this</span>.numStart)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果请假天数达到该领导者的处理要求</span></span><br><span class="line">        <span class="keyword">if</span>(leave.getNum() &gt;= <span class="built_in">this</span>.numStart)&#123;</span><br><span class="line">            <span class="built_in">this</span>.handleLeave(leave);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果还有上级 并且请假天数超过了当前领导的处理范围</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> != <span class="built_in">this</span>.nextHandler &amp;&amp; leave.getNum() &gt; numEnd)&#123;</span><br><span class="line">                <span class="built_in">this</span>.nextHandler.submit(leave);<span class="comment">//继续提交</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;流程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各级领导处理请假条方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小组长</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupLeader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//小组长处理1-3天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_ONE, Handler.NUM_THREE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小组长审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//部门经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理3-7天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_THREE, Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;部门经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GeneralManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理7天以上的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//请假条来一张</span></span><br><span class="line">        <span class="type">LeaveRequest</span> <span class="variable">leave</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="string">&quot;小花&quot;</span>,<span class="number">5</span>,<span class="string">&quot;身体不适&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//各位领导</span></span><br><span class="line">        <span class="type">GroupLeader</span> <span class="variable">groupLeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>();</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        <span class="type">GeneralManager</span> <span class="variable">generalManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralManager</span>();</span><br><span class="line"></span><br><span class="line">        groupLeader.setNextHandler(manager);<span class="comment">//小组长的领导是部门经理</span></span><br><span class="line">        manager.setNextHandler(generalManager);<span class="comment">//部门经理的领导是总经理</span></span><br><span class="line">        <span class="comment">//之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交申请</span></span><br><span class="line">        groupLeader.submit(leave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p><strong>优点：</strong></p><ul><li><p>降低了对象之间的耦合度</p><p>该模式降低了请求发送者和接收者的耦合度。</p></li><li><p>增强了系统的可扩展性</p><p>可以根据需要增加新的请求处理类，满足开闭原则。</p></li><li><p>增强了给对象指派职责的灵活性</p><p>当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。</p></li><li><p>责任链简化了对象之间的连接</p><p>一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</p></li><li><p>责任分担</p><p>每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</p></li></ul><p><strong>缺点：</strong></p><ul><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li></ul><p>使用案例：Filter的链式调用</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p><strong>定义：</strong></p><p>又被称为发布-订阅（Publish&#x2F;Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><p><strong>结构</strong></p><ul><li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li><li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li><li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li><li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li></ul><p>【例】微信公众号</p><p>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。</p><p>类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p>代码如下：</p><p>定义抽象观察者类，里面定义一个更新的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体观察者类，微信用户是观察者，里面实现了更新的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeixinUser</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 微信用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeixinUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象主题类，提供了attach、detach、notify三个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//增加订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通知订阅者更新消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//储存订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; weixinUserlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserlist.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserlist.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : weixinUserlist) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SubscriptionSubject mSubscriptionSubject=<span class="keyword">new</span> <span class="title class_">SubscriptionSubject</span>();</span><br><span class="line">        <span class="comment">//创建微信用户</span></span><br><span class="line">        WeixinUser user1=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;孙悟空&quot;</span>);</span><br><span class="line">        WeixinUser user2=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;猪悟能&quot;</span>);</span><br><span class="line">        WeixinUser user3=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;沙悟净&quot;</span>);</span><br><span class="line">        <span class="comment">//订阅公众号</span></span><br><span class="line">        mSubscriptionSubject.attach(user1);</span><br><span class="line">        mSubscriptionSubject.attach(user2);</span><br><span class="line">        mSubscriptionSubject.attach(user3);</span><br><span class="line">        <span class="comment">//公众号更新发出消息给订阅的微信用户</span></span><br><span class="line">        mSubscriptionSubject.notify(<span class="string">&quot;传智黑马的专栏更新了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p><strong>优点：</strong></p><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】</li></ul><p><strong>缺点：</strong></p><ul><li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时</li><li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</li></ul><p><strong>使用场景</strong></p><ul><li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。</li></ul><h3 id="JDK新特性"><a href="#JDK新特性" class="headerlink" title="JDK新特性"></a>JDK新特性</h3><h5 id="JDK1-8的新特性"><a href="#JDK1-8的新特性" class="headerlink" title="JDK1.8的新特性:"></a><strong>JDK1.8的新特性:</strong></h5><ol><li><p>stream流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;gkh&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="comment">//返回符合条件的stream</span></span><br><span class="line">    Stream&lt;String&gt; stringStream = strings.stream().filter(s -&gt; <span class="string">&quot;abc&quot;</span>.equals(s));</span><br><span class="line">    <span class="comment">//计算流符合条件的流的数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringStream.count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//forEach遍历-&gt;打印元素</span></span><br><span class="line">    strings.stream().forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>2、Lambda 表达式<br>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、函数式接口</p><p>Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p><p>4、方法与构造函数引用</p><p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">converter = something::startsWith;</span><br><span class="line"><span class="type">String</span> <span class="variable">converted</span> <span class="operator">=</span> converter.convert(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">System.out.println(converted);</span><br></pre></td></tr></table></figure><ol start="5"><li>日期 Date-timeAPI</li></ol><ul><li>增强了时区处理</li><li>增强各种格式化、和时间计算</li></ul><h5 id="JDK9新特性"><a href="#JDK9新特性" class="headerlink" title="JDK9新特性"></a>JDK9新特性</h5><ol><li><p>JShell，为 Java 提供了类似于 Python 的实时命令行交互工具。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111847441.png" alt="image-20231003111847441"></p></li><li><p>String 改为用byte[]存储。</p></li></ol><h5 id="jdk10新特性"><a href="#jdk10新特性" class="headerlink" title="jdk10新特性"></a>jdk10新特性</h5><p><strong>局部变量类型推断(var)</strong>***</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">id</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">codefx</span> <span class="operator">=</span>newURL(<span class="string">&quot;https://mp.weixin.qq.com/&quot;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span>newArrayList&lt;&gt;();</span><br><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span>List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h5 id="JDK11新特性"><a href="#JDK11新特性" class="headerlink" title="JDK11新特性"></a>JDK11新特性</h5><h5 id="String增强"><a href="#String增强" class="headerlink" title="String增强"></a>String增强</h5><p>增加了一系列的字符串处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断字符串是否为空</span></span><br><span class="line"><span class="string">&quot; &quot;</span>.isBlank();<span class="comment">//true</span></span><br><span class="line"><span class="comment">//去除字符串首尾空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.strip();<span class="comment">// &quot;Java&quot;</span></span><br><span class="line"><span class="comment">//去除字符串首部空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.stripLeading();   <span class="comment">// &quot;Java &quot;</span></span><br><span class="line"><span class="comment">//去除字符串尾部空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.stripTrailing();  <span class="comment">// &quot; Java&quot;</span></span><br><span class="line"><span class="comment">//重复字符串多少次</span></span><br><span class="line"><span class="string">&quot;Java&quot;</span>.repeat(<span class="number">3</span>);             <span class="comment">// &quot;JavaJavaJava&quot;</span></span><br><span class="line"><span class="comment">//返回由行终止符分隔的字符串集合。</span></span><br><span class="line"><span class="string">&quot;A\nB\nC&quot;</span>.lines().count();    <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;A\nB\nC&quot;</span>.lines().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="MySQL："><a href="#MySQL：" class="headerlink" title="MySQL："></a>MySQL：</h2><h3 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h3><h4 id="执行一条-SQL-查询语句，期间发生了什么？"><a href="#执行一条-SQL-查询语句，期间发生了什么？" class="headerlink" title="执行一条 SQL 查询语句，期间发生了什么？"></a>执行一条 SQL 查询语句，期间发生了什么？</h4><ul><li><p>连接器：建立连接，管理连接、校验用户身份；</p></li><li><p>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</p></li><li><p>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</p></li><li><p>执行 SQL：执行 SQL 共有三个阶段：</p><ul><li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p></li></ul><h4 id="为什么禁止使用select"><a href="#为什么禁止使用select" class="headerlink" title="为什么禁止使用select *"></a>为什么禁止使用select *</h4><ul><li>增加查询分析器解析成本。</li><li>增减字段容易与 resultMap 配置不一致。</li><li>无用字段增加网络 消耗，尤其是 text 类型的字段。</li></ul><h4 id="SQL语句执行顺序"><a href="#SQL语句执行顺序" class="headerlink" title="SQL语句执行顺序"></a>SQL语句执行顺序</h4><ol><li><p>from 子句组装来自不同数据源的数据；</p></li><li><p>where 子句基于指定的条件对记录行进行筛选；  </p></li><li><p>group by 子句将数据划分为多个分组；  </p></li><li><p>使用聚集函数进行计算； </p></li><li><p>使用 having 子句筛选分组；</p></li><li><p>计算所有的表达式后，select；  </p></li><li><p>使用 order by 对结果集进行排序。</p></li><li><p>limit限制查询数量、查询偏移量</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111856990.png" alt="image-20231003111856990"></p></li></ol><h4 id="Mysql表字段限制"><a href="#Mysql表字段限制" class="headerlink" title="Mysql表字段限制"></a>Mysql表字段限制</h4><p>（1）innodb引擎对于列的硬性要求是不能超过1017列，MyISAM引擎能达到4096的限制</p><p>（2）一个表最多可以包含64个 二级索引,两种引擎都有这个限制。</p><p>（3）索引键前缀长度限制为767个字节 ，<strong>当某一列中的数据非常多的话，在数据页中只会存储该列的前767个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做行溢出，存储超出767字节的那些页面也被称为溢出页。</strong>主键是聚集索引，也是其他二级索引的基础，所以每个主键要在一个数据页存储，不能分布在其他的溢出页，不能像其他大字段一样溢出数据页</p><p>（4）MySQL本身对所有列的组合大小强加了65535的行大小限制，这个更多对应单个列的字段长度不能大于65535字节</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xKRlBIUA==,size_16,color_FFFFFF,t_70.png" alt="img"></p><h4 id="行溢出后怎么处理"><a href="#行溢出后怎么处理" class="headerlink" title="行溢出后怎么处理"></a>行溢出后怎么处理</h4><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</p><p>Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E8%A1%8C%E6%BA%A2%E5%87%BA.png" alt="img"></p><p>Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。</p><h4 id="varchar-n-中-n-最大取值为多少？"><a href="#varchar-n-中-n-最大取值为多少？" class="headerlink" title="varchar(n) 中 n 最大取值为多少？"></a>varchar(n) 中 n 最大取值为多少？</h4><p>行数据保存格式</p><p>变长字段列表存储各个变长字段的长度 null值列表用一个bit表示该行某一列位null</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A81.png" alt="img"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/COMPACT.drawio.png" alt="img"></p><p><strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节</strong>。</p><p>varchar(n) 字段类型的 n 代表的是最多存储的字符数量，不是字节大小。</p><p>要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。</p><p>我们存储字段类型为 varchar(n) 的数据时，其实分成了三个部分来存储：</p><ul><li>真实数据</li><li>真实数据占用的字节数</li><li>NULL 标识，如果不允许为NULL，这部分不需要</li></ul><p><strong>因为我们这个案例是只有 1 个变长字段，所以「变长字段长度列表」&#x3D; 1 个「变长字段长度」占用的字节数，也就是 2 字节</strong>。</p><p>因为我们在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。所以，<strong>在数据库表只有一个 varchar(n) 字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 &#x3D; 65535 - 2 - 1 &#x3D; 65532</strong>。</p><p><strong>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;&#x3D; 65535</strong>。</p><h4 id="Insert-into和replace-into有什么区别"><a href="#Insert-into和replace-into有什么区别" class="headerlink" title="Insert into和replace into有什么区别"></a>Insert into和replace into有什么区别</h4><p>inset into是不允许添加主键重复列的,而replace可以,且影响行数是2,</p><p>replace into用于不知道操作为更新还是新增的时候,使用时,先尝试直接向库中插入数据,遇到主键或唯一索引而引发的重复键错误时,删除掉冲突行并再次尝试插入,这个过程是MySQL自行处理的,并不会存在用户感知之类的</p><h4 id="union和union-all的区别"><a href="#union和union-all的区别" class="headerlink" title="union和union all的区别"></a>union和union all的区别</h4><p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</p><p>union：对两个结果集进行并集操作，不包括重复行，相当于distinct，同时进行默认规则的排序；</p><p>union all：对两个结果集进行并集操作，包括重复行，不进行排序；</p><p>union因为要进行重复值扫描，所以在结果集庞大的情况下，效率极低，因此建议使用union all。</p><p>若结果集去重是强需求，则在应用程序代码上进行去重，因为数据库资源要比应用服务器资源更加珍贵。</p><h4 id="MySQL根据某一个或者多个字段查找重复数据的sql语句（MySQL如何避免查询重复字段）"><a href="#MySQL根据某一个或者多个字段查找重复数据的sql语句（MySQL如何避免查询重复字段）" class="headerlink" title="MySQL根据某一个或者多个字段查找重复数据的sql语句（MySQL如何避免查询重复字段）"></a>MySQL根据某一个或者多个字段查找重复数据的sql语句（MySQL如何避免查询重复字段）</h4><p><strong>1.表中有id和name 两个字段，查询出name重复的所有数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> xi a <span class="keyword">where</span> (a.username) <span class="keyword">in</span> (<span class="keyword">select</span> username  <span class="keyword">from</span> xi <span class="keyword">group</span> <span class="keyword">by</span> username <span class="keyword">having</span> <span class="built_in">count</span> (<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>2、查询出所有数据进行分组之后，查询重复的name字段和重复次数，先列下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span> (username) <span class="keyword">as</span> <span class="string">&#x27;重复次数&#x27;</span>,username <span class="keyword">from</span> xi <span class="keyword">group</span> <span class="keyword">by</span> username <span class="keyword">having</span> <span class="built_in">count</span> (<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> username <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>3、以下为查看别人的 结果，现列下：查询及删除重复记录的方法大全</p><p>1、查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> people <span class="keyword">where</span> peopleId <span class="keyword">in</span> (<span class="keyword">select</span> peopleId <span class="keyword">from</span> people <span class="keyword">group</span> <span class="keyword">by</span> peopleId <span class="keyword">having</span> <span class="built_in">count</span> (peopleId) <span class="operator">&gt;</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>2、删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断，只留有rowid最小的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> people <span class="keyword">where</span> rowid  <span class="keyword">not</span> <span class="keyword">in</span> ( <span class="keyword">select</span> <span class="built_in">min</span>(rowid)  <span class="keyword">from</span> people  <span class="keyword">group</span> <span class="keyword">by</span> peopleId )</span><br></pre></td></tr></table></figure><p>3、删除两个字段重复的数据，只保留一条</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> group_member</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> b.id</span><br><span class="line">  <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(id) <span class="keyword">AS</span> id</span><br><span class="line">    <span class="keyword">FROM</span> group_member</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> group_id, member_id</span><br><span class="line">  ) <span class="keyword">AS</span> b</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>4、查找表中多余的重复记录（多个字段）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> vitae a <span class="keyword">where</span> rowid  <span class="keyword">in</span> ( <span class="keyword">select</span> rowid  <span class="keyword">from</span> vitae  <span class="keyword">group</span> <span class="keyword">by</span> peopleId,seq  <span class="keyword">having</span> <span class="built_in">count</span> (<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>5、查找表中多余的重复记录（多个字段），不包含id最小的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  group_member</span><br><span class="line"><span class="keyword">where</span> id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(g.id) </span><br><span class="line">    <span class="keyword">from</span> group_member g</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> group_id, member_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>6、查询排名前十的数据，包含并列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">s1.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student s1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student s2 <span class="keyword">ON</span> s1.t_id <span class="operator">=</span> s2.t_id </span><br><span class="line"><span class="keyword">AND</span> s1.score <span class="operator">&lt;</span> s2.score </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">s1.id</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="built_in">COUNT</span>( s2.id ) <span class="operator">&lt;</span> <span class="number">10</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">s1.t_id,</span><br><span class="line">s1.score <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h4 id="使用自增id还是UUID来当主键"><a href="#使用自增id还是UUID来当主键" class="headerlink" title="使用自增id还是UUID来当主键"></a>使用自增id还是UUID来当主键</h4><p>应该使用UUID。</p><p>B+树使用双向链表来保存数据，所以使用自增id能够直接加到尾部，不需要页分裂，效率很高，且占用的空间小。但是如果一些敏感信息设置成自增就很容易被推理，暴露机密。</p><p>同时当单表的数据量上来之后我们就需要进行水平分表操作（将一张数据表的数据分成多张表），如果这时我们还是按照之前的自增形式来做主键 id，就有可能会出现 id 重复的问题。</p><p>如果使用UUID，生成的ID不仅是表独立的，而且是库独立的。对以后的数据操作很有好处，可以说一劳永逸。我们可以使用 UUID 来作为不重复的主键 id，但是 UUID 是无序的字符串，所以主键索引就会失效，而且占用空间大。</p><ul><li>全局唯一性：不能出现重复的 id</li><li>递增性：MySQL 的 InnoDB 使用的是聚簇索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，因此在主键的选择上我们还是应该尽可能地使用有序的主键来保证写入性能，我们保证下一个 id 一定大于上一个 id，以此来满足事务版本号、IM 增量消息或者排序的特殊需求</li><li>安全性：如果 id 是连续的，那么我们在知道一些基本规则的情况下就能很轻松地推测出下一份数据，这在一些机密性较高的业务场景是很危险的。所以我们有时会希望 id 是无规则的，最好还能包含有时间戳，这样就能够在开发中快速了解这个分布式 id 的生成时间</li><li>高性能高可用性：确保在任何时候都能正确地生成 id，并且在高并发的环境下也能表现良好</li></ul><p>UUID：我们可以使用 UUID 来作为不重复的主键 id，但是 UUID 是无序的字符串，所以主键索引就会失效</p><p>优点：简单、方便、性能好、出现数据拆分、合并存储的时候，能达到全局的唯一性<br>缺点：占用空间大，无序性、存储的是字符串、查询效率低、传输数据量大</p><p>雪花算法：雪花算法是 Twitter 推出的针对分布式环境下的 id 生成算法，其结果是一个 Long 型的 64bit id。具体实现上使用 41bit 作为毫秒数，10bit 作为机器的 id（5bit 是数据中心，5bit 是机器 id），12bit 作为毫秒内的流水号（这意味着每个节点在每毫秒内可以产生 4096 个 id），最后还有一个符号位永远是 0</p><p>优点：不依赖数据库、完全在内存中生成 id、高性能高可用、容量大、每秒可生成数百万个 id、id 递增、后续插入数据库的索引时性能较高<br>缺点：严重依赖系统时钟，如果某台机器的系统时钟发生回拨，就有可能会造成 id 冲突甚至 id 乱序</p><h4 id="MySQL三大范式"><a href="#MySQL三大范式" class="headerlink" title="MySQL三大范式"></a>MySQL三大范式</h4><ul><li><h5 id="第一范式（1-NF）：字段不可再拆分。"><a href="#第一范式（1-NF）：字段不可再拆分。" class="headerlink" title="第一范式（1 NF）：字段不可再拆分。"></a>第一范式（1 NF）：字段不可再拆分。</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112028615.png" alt="image-20231003112028615"></p></li><li><h5 id="第二范式（2-NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。"><a href="#第二范式（2-NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。" class="headerlink" title="第二范式（2 NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。"></a>第二范式（2 NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。</h5></li></ul><p>​即一张表只能描述一件事情，学生表中就不要存储成绩，可以专门设计一张成绩表存储学生ID和每一科的成绩。否则造成整张表的数据冗余且更新插入等不方便</p><ol><li>造成整表的数据冗余。</li></ol><p>如，学生表，可能我就只有2个学生，每个学生都有许多的信息，比如，年龄、性别、身高、住址……如果与课程信息放到同一张表中，可能每个学生有3门课程，那数据总条数就会变成6条了。但是通过拆分，学生表我们只需要存储 2 条学生信息，课程表只需要存储 3 条课程信息，成绩表就只需保留学号、课程名称和成绩字段。</p><ol start="2"><li>更新数据不方便。</li></ol><p>假设，课程的学分发生了变更，那我们就需要把整表关于该课程的学分都要更新一次，但如果我们拆分出课程表，那我们就只需要把课程表中的课程信息更新就行。</p><ol start="3"><li>插入数据不方便或产生异常。</li></ol><p>① 假设主键是学号或课程名称，我们新增了某个课程，需要把数据插入到表中，这时，可能只有部分人有选修这门课程，那我们插入数据的时候还要规定给哪些人插入对应的课程信息，同时可能由于成绩还没有，我们需要对成绩置空，后续有成绩后还得重新更新一遍。</p><p>② 假设主键是学号和课程名称的联合主键。同样也是新增了某课程，但是暂时没有人选修这门课，缺少了学号主键字段数据，会导致课程信息无法插入。</p><ul><li><h5 id="第三范式（3-NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段-A-可以获取-某非主键字段-B。"><a href="#第三范式（3-NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段-A-可以获取-某非主键字段-B。" class="headerlink" title="第三范式（3 NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。"></a>第三范式（3 NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。</h5></li></ul><p>如果产生这样情况其实就可以把两者重新建表。如员工表既出现了员工所在的部门id，又出现了部门名称和工作地点，就可以把后面三个单独拆成一张表</p><h4 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h4><table><thead><tr><th>存储引擎</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>InnoDB</td><td>①支持事务②行级锁，提高并发性能③支持外键</td><td>各方面都比较优秀，适合绝大部分的场景</td></tr><tr><td>MyISAM</td><td>①不支持事务②不支持外键③只支持表锁不支持行锁④访问速度快</td><td>适合读操作和插入操作比较频繁的数据，而且对事务和并发要求不高，比如系统配置表等静态表</td></tr><tr><td>Memory</td><td>①存储在内存②hash索引</td><td>通常用于临时表以及缓存</td></tr></tbody></table><h4 id="怎么保证redis和DB的数据一致性"><a href="#怎么保证redis和DB的数据一致性" class="headerlink" title="怎么保证redis和DB的数据一致性"></a>怎么保证redis和DB的数据一致性</h4><h5 id="采用延时双删"><a href="#采用延时双删" class="headerlink" title="采用延时双删"></a>采用延时双删</h5><p><strong>其核心思想是在更新数据库后，先删除缓存中的数据，然后在一段时间后再次删除缓存。这样，即使在这段时间内有新的读请求导致缓存被重建，由于缓存中的数据已经被删除，所以新的读请求会重新从数据库中读取最新数据，从而保证缓存与数据库的一致性。</strong></p><p>这种方案，在并发写的时候，不会出问题。因为都是先更新数据库再删除缓存，不会出现不一致的情况。</p><p>但是在并发读写的时候，还是有可能出现数据不一致。</p><ol><li>读请求查询缓存没数据，然后查询数据库</li><li>写请求更新数据库，删除缓存</li><li>读请求回写缓存</li></ol><p>执行结果是，缓存中是旧数据，而数据库里是新数据，导致数据不一致。</p><p>其实这种情况出现的概率很低，写缓存比写数据库快出几个量级，读写缓存都是内存操作，速度非常快。</p><p>遇到了这种极端场景，我们也需要做一下兜底方案，缓存都要设置过期时间，或者当更新数据后休眠一段时间通过定时任务（可通过整合定时任务框架、创建线程池，从中拿出一个线程休眠一段时间再启动）再删除一次缓存。这种方案属于数据的弱一致性和最终一致性，而不是强一致性。</p><h5 id="异步更新缓存-基于订阅binlog的同步机制"><a href="#异步更新缓存-基于订阅binlog的同步机制" class="headerlink" title="异步更新缓存(基于订阅binlog的同步机制)"></a>异步更新缓存(基于订阅binlog的同步机制)</h5><p>采用缓存淘汰策略，先更新数据库，再删除对应redis缓存后更新缓存。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231012113429919.png" alt="image-20231012113429919"></p><p>通过 Canal（消息推送工具也可以用kafka、rabbitMQ等来实现可靠性消息通信更新Redis。） 组件，（伪装成从节点）监控 Mysql 中 binlog（记录MySQL中新的写入、更新、删除等操作） 的日志，把更新后的数据同步到 Redis 里面，canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231012113453556.png" alt="image-20231012113453556"></p><p>因为这里是基于最终一致性来实现的，如果业务场景不能接受数据的短期不一致性，那就不能使用这个方案来做。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务的四大特性（ACID）："><a href="#事务的四大特性（ACID）：" class="headerlink" title="事务的四大特性（ACID）："></a>事务的四大特性（ACID）：</h4><ul><li>原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性：事务完成时，必须使得所有的数据保持一致状态</li><li>隔离性：数据库系统提供的隔离机制，保证事务不受外部并发操作的影响，在独立的环境下运行。</li><li>持久性：事务一单提交或回滚，会对数据库产生永久的改变</li></ul><table><thead><tr><th>特性</th><th>由什么机制来保证</th></tr></thead><tbody><tr><td>原子性、一致性、持久性</td><td>redo log、 undo log</td></tr><tr><td>隔离性</td><td>MVCC多版本控制、数据库的锁</td></tr></tbody></table><h4 id="并发事务问题："><a href="#并发事务问题：" class="headerlink" title="并发事务问题："></a>并发事务问题：</h4><ol><li><p>脏读：一个事务读到了另一个事务还没有提交的数据。<img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111916626.png" alt="image-20231003111916626"></p></li><li><p>不可重复读：一个事务先后读取同一条记录，但是两次读取的<strong>数据不同</strong>，强调数据不同</p></li></ol><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111926058.png" alt="image-20231003111926058"></p><ol start="3"><li>幻读：前后读取的记录数量不一致，强调说的是存不存在的问题：原来不存在的,现在存在了,则是幻读。<img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111932452.png" alt="image-20231003111932452"></li></ol><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111936844.png" alt="image-20231003111936844"></p><h4 id="undo-log（原子性-一致性）"><a href="#undo-log（原子性-一致性）" class="headerlink" title="undo log（原子性 一致性）"></a>undo log（原子性 一致性）</h4><ul><li>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性、一致性) 和MVCC(多版本并发控制) 。</li><li>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undolog中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</li><li>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</li></ul><h4 id="redo-log（持久性、-一致性）"><a href="#redo-log（持久性、-一致性）" class="headerlink" title="redo log（持久性、 一致性）"></a>redo log（持久性、 一致性）</h4><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo logfile）,前者是在内存中，后者在磁盘中。<strong>当事务提交之后</strong>会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112038852.png" alt="image-20231003112038852"></p><p>有了redolog之后，<strong>当对缓冲区的数据进行增删改之后</strong>，会首先将操作的数据页的变化，记录在redolog buffer中。<strong>在事务提交时</strong>，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样<strong>就保证了事务的持久性</strong>。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="哪些情况适合创建索引"><a href="#哪些情况适合创建索引" class="headerlink" title="哪些情况适合创建索引"></a>哪些情况适合创建索引</h4><ul><li><strong>字段的数值有唯一性的限制</strong></li></ul><p>具有唯一索引的字段，即使是组合字段，也必须建成唯一索引。唯一索引对 insert 的速度损耗可以忽略，但是提高的查找速度是明显的。</p><ul><li><strong>频繁作为 *<em>where*</em> 查询条件的字段</strong></li><li><strong>经常GROUP BY 或 ORDER BY的列</strong></li><li><strong>UPDATE、DELETE 的 WHERE 条件列</strong></li><li><strong>DISTINCT 字段需要创建索引</strong>,排序后去重自然也更快了！</li></ul><h4 id="哪些情况不适合创建索引"><a href="#哪些情况不适合创建索引" class="headerlink" title="哪些情况不适合创建索引"></a>哪些情况不适合创建索引</h4><ul><li><strong>在 WHERE 中使用不到的字段，不要设置索引</strong></li></ul><p>同理，如GROUP BY 或 ORDER BY 条件里用不到的字段，也不要设置索引。原因也很简单，不需要快速定位，设置索引也没有用！</p><ul><li><strong>数据量小的表最好不要使用索引</strong></li></ul><p>在数据量很小的时候，原本查询时间已经很短了，不必要再添加索引。索引的回表等操作可能会使耗费时间更多！</p><ul><li><p><strong>有大量重复数据的列上不要建立索引</strong>, 比如sex、status，否则查找效率也很低</p></li><li><p><strong>避免对经常需要更新的表创建过多的索引</strong>，在对数据进行修改时，索引也会需要调整更新，造成很大负担</p></li></ul><h4 id="B-Tree-与-B-Tree相比"><a href="#B-Tree-与-B-Tree相比" class="headerlink" title="B+Tree 与 B-Tree相比"></a>B+Tree 与 B-Tree相比</h4><ul><li>所有的数据都会出现在叶子节点。</li><li>叶子节点形成一个双向循环链表。</li><li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。<img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111941842.png" alt="image-20231003111941842"></li></ul><h4 id="为什么InnoDB存储引擎选择使用B-tree索引结构"><a href="#为什么InnoDB存储引擎选择使用B-tree索引结构" class="headerlink" title="为什么InnoDB存储引擎选择使用B+tree索引结构?"></a>为什么InnoDB存储引擎选择使用B+tree索引结构?</h4><ol><li>相对于二叉树，层级更少，搜索效率高；</li><li>对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；B+树叶子节点有链表，支持排序和范围查询。</li><li>相对Hash索引，Hash索引会发生Hash冲突，B+tree支持范围匹配及排序操作；</li><li>数据都在叶子节点，搜索效率稳定，且叶子节点形成双向循环链表，便于范围查找和排序</li></ol><p><strong>与shipList相比：****B+树</strong>是多叉树结构，每个结点都是一个16k的数据页，能存放较多索引信息，所以非叶子节点度数很大，三层<strong>左右就可以存储<code>2kw</code>左右的数据。也就是说查询一次数据，如果这些数据页都在磁盘里，那么最多需要查询</strong>三次磁盘IO**。</p><p><strong>跳表</strong>是链表结构，查询都要能达到<strong>二分查找</strong>的效果，相当于一颗二叉搜索树，保存相同量的数据，层数远比B+树高，需要更多的磁盘IO，查询效率更慢。</p><p>而针对<strong>写操作</strong>，B+树会出现页分裂，跳表则独立插入，没有旋转和维持平衡的开销，因此<strong>跳表的写入性能会比B+树要好。</strong></p><p>缺点:B+树用页来保存数据，会产生内存碎片。</p><h4 id="聚集索引-二级索引"><a href="#聚集索引-二级索引" class="headerlink" title="聚集索引&amp;二级索引"></a>聚集索引&amp;二级索引</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111945629.png" alt="image-20231003111945629"></p><p>聚集索引选取规则:</p><ul><li><p>​如果存在主键，主键索引就是聚集索引。</p></li><li><p>​如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p></li><li><p>​如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111949312.png" alt="image-20231003111949312"></p></li><li><p>聚集索引的叶子节点下挂的是这一行的数据 。</p></li><li><p>二级索引的叶子节点下挂的是该字段值对应的主键值。</p></li></ul><h4 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h4><p><font color = gold>聚簇索引和非聚簇索引不是聚集索引与二级索引，而是两种数据存储方式。</font></p><p>聚簇索引存储（InnoDB）：<font color = gold>行数据和主键B+树存储在一起</font>，辅助键B+树只存储辅助键和主键，主键和非主键B+树几乎是两种类型的树。</p><p>非聚簇索引存储（MySAM）：<font color = gold>表数据存储在独立的地方</font>&gt;,主键B+树在叶子节点存储指向真正数据行的<strong>地址指针</strong>，而非主键。</p><p>InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id &#x3D; 14″这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。</p><p>MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个<strong>地址指向真正的表数据</strong>，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索<strong>无需访问主键的索引树</strong>。</p><p>假想一个表如下图存储了4行数据。其中Id作为主索引，Name作为辅助索引。图示清晰的显示了聚簇索引和非聚簇索引的差异。</p><p><a href="https://kyle.ai/blog/wp-content/uploads/2018/03/9.png"><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/9.png" alt="9"></a> <a href="https://kyle.ai/blog/wp-content/uploads/2018/03/10.png"><img src="/./../../../../../../%25E4%25B8%25AA%25E4%25BA%25BA%25E5%258D%259A%25E5%25AE%25A2/hexo/blog/source/imgs/Java%25E7%259F%25A5%25E8%25AF%2586%25E7%2582%25B9%25E6%2580%25BB%25E7%25BB%2593/10.png" alt="10"></a></p><h5 id="聚簇索引的优势"><a href="#聚簇索引的优势" class="headerlink" title="聚簇索引的优势"></a>聚簇索引的优势</h5><p>看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，聚簇索引的优势在哪？</p><ol><li><p>行数据和叶子节点存储在一起，这样主键和行数据是一起载入内存，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。</p></li><li><p>辅助索引使用主键作为”指针” 而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB<strong>在移动行时无须更新辅助索引中的这个”指针”</strong>。也就是说行的位置（会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。</p></li></ol><h4 id="为什么非主键索引存放的是主键ID而不是数据行的地址？"><a href="#为什么非主键索引存放的是主键ID而不是数据行的地址？" class="headerlink" title="为什么非主键索引存放的是主键ID而不是数据行的地址？"></a>为什么非主键索引存放的是主键ID而不是数据行的地址？</h4><p><strong>保持一致性：</strong><br>当数据库表进行DML操作时，可能会出现“页分裂”、’’非叶子节点分裂’’情况，同一行记录的页地址会发生改变，因非主键索引保存的是主键的值，无需同步更改，降低二级索引的维护开销。</p><h4 id="为什么存放主键id而不是行数据？"><a href="#为什么存放主键id而不是行数据？" class="headerlink" title="为什么存放主键id而不是行数据？"></a>为什么存放主键id而不是行数据？</h4><p><strong>节省存储空间：</strong><br>Innodb数据本身就已经汇聚到主键索引所在的B+树上了， 如果普通索引还继续再保存一份数据，就会导致有多少索引就要存多少份数据，造成数据冗余。</p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>存储一些比较长的字符串时，如果建立索引会使得索引变得很大，查询时大量的磁盘IO降低查询效率，此时可以提取字符串的一部分前缀来建立索引，这样可以大大节约索引空间，提高索引效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 截取某个字段的前 n 个字符建立索引</span></span><br><span class="line"><span class="keyword">create</span> index index_name <span class="keyword">on</span> table_name(column_name(n));</span><br></pre></td></tr></table></figure><p>具体截取的字符串的长度是 选择性最高的最小的n，选择性即是不重复的索引值和数据表的记录总数的比值</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p> 覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。索引的b+树的叶子节点中保存了我们需要查询的数据，此时无需进行回表查询。</p><h4 id="联合索引在b-树中怎么存储"><a href="#联合索引在b-树中怎么存储" class="headerlink" title="联合索引在b+树中怎么存储"></a>联合索引在b+树中怎么存储</h4><p>联合索引是对多个列（字段）建立的索引(需要满足最左前缀法则)</p><p><font color = gold><strong>前一个条件</strong>相等的情况下 <strong>当前条件</strong>才会是<strong>有序的</strong>，当<strong>前一个条件</strong>不同 那么无法保证<strong>当前条件</strong>为有序的 所以索引失效</font>,也就是说,只有<strong>记录左边的字段都是相等的时,记录的当前字段才会是有序的,才能使用当前字段索引</strong></p><p>联合索引和其他索引的区别就是在非叶子节点存储的是联合索引上全部字段，按照最左前缀法则排序，叶子节点会存储联合索引全部字段和主键id</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-e6c3ce6effabafb1a96e08cffbeb104b_r.jpg" alt="img"></p><h4 id="索引下推？"><a href="#索引下推？" class="headerlink" title="索引下推？"></a><strong>索引下推？</strong></h4><p><a href="https://juejin.cn/post/7005794550862053412">五分钟搞懂MySQL索引下推 - 掘金 (juejin.cn)</a></p><p><a href="https://blog.csdn.net/wang_luwei/article/details/120274064">Mysql性能优化之什么是索引下推？_索引吓退-CSDN博客</a></p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li><p>索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，是针对非聚集索引得优化（聚集索引没有回表查询这一说法）用于减少存储引擎回表查询的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</p></li><li><p>在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</p></li><li><p>在使用ICP的情况下，如果<font color = gold><strong>存在某些被索引的列</strong>是<strong>判断条件</strong>时，MySQL服务器将<strong>这一部分判断条件</strong>传递给<strong>存储引擎</strong>，然后由存储引擎通过<strong>判断索引是否符合</strong>MySQL服务器传递的<strong>条件</strong>，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器</font>。</p></li></ul><h5 id="优化的原理"><a href="#优化的原理" class="headerlink" title="优化的原理"></a>优化的原理</h5><p>我们先简单了解一下MySQL大概的架构：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/52288fa925f84cef937bb0b46d27c60atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="MySQL大概架构"></p><p>MySQL服务层负责SQL语法解析、生成执行计划等，并调用存储引擎层去执行数据的存储和检索。</p><p><font color = gold><code>索引下推</code>的<strong>下推</strong>其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理，推的是在查数据走联合索引时，将5.6版本之前 （联合）索引中容忽略的字段给添加上，让（联合）索引中的全部字段都用上。</font></p><p>我们来具体看一下，在没有使用ICP的情况下，MySQL的查询：</p><ul><li>存储引擎读取索引记录；</li><li>根据索引中的主键值，定位并读取完整的行记录；</li><li>存储引擎把记录交给<code>Server</code>层去检测该记录是否满足<code>WHERE</code>条件。</li></ul><p>使用ICP的情况下，查询过程：</p><ul><li>存储引擎读取索引记录（不是完整的行记录）；</li><li>判断<code>WHERE</code>条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；</li><li>条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；</li><li>存储引擎把记录交给<code>Server</code>层，<code>Server</code>层检测该记录是否满足<code>WHERE</code>条件的其余部分。</li></ul><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>使用一张用户表<code>tuser</code>，表里创建联合索引（name, age）。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1b49ff7a5bff433688d7640d1ca64fb4tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="用户表"></p><p>如果现在有一个需求：检索出表中<code>名字第一个字是张，而且年龄是10岁的所有用户</code>。那么，SQL语句是这么写的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>假如你了解索引最左匹配原则，那么就知道这个语句在搜索索引树的时候，只能用 <code>%张</code>，<font color = gold>会忽略age这个字段</font>，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为1，4，然后拿着取到的id值一次次的回表查询，因此这个过程需要回表两次。</p><p><strong>（忽略的原因是：<font color = gold>组合索引满足最左匹配，但是遇到非等值判断时匹配停止</font>。name like ‘陈%’ 不是等值匹配，所以 age &#x3D; 20 这里就用不上 (name,age) 组合索引了。如果没有索引下推，组合索引只能用到 name，age 的判定就需要回表才能做了。5.6版本之后有了索引下推，age &#x3D; 20 可以直接在组合索引里判定。）</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/a2db6afbc11546fbb4205b2faa64400ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="B+树联合索引"></p><p><strong>没有使用ICP</strong></p><p>存储引擎根据通过联合索引找到<code>name like &#39;张%&#39;</code> 的主键id（1、4），逐一进行回表扫描，去聚簇索引找到完整的行记录，server层再对数据根据<code>age=10进行筛选</code>。</p><p>我们看一下示意图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/c97ed6c5e395416181cb57591151fb09tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="未使用ICP"></p><p>可以看到需要回表两次，把我们联合索引的另一个字段<code>age</code>浪费了。</p><p><strong>使用ICP</strong></p><p>存储引擎根据（name，age）联合索引，找到<code>name like &#39;张%&#39;</code>，由于<strong>联合索引中包含<code>age</code>列</strong>，InnoDB并没有忽略索引中age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要回表一次。，所以存储引擎直接再联合索引里按照<code>age=10</code>过滤。按照过滤后的数据再一一进行回表扫描。</p><p>我们看一下示意图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/8edc3c9af2e5403da79f77e50adaecd3tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="使用ICP的示意图"></p><p>可以看到只回表了一次。</p><p>除此之外我们还可以看一下执行计划，看到<code>Extra</code>一列里<code> Using index condition</code>，这就是用到了索引下推。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>复制代码<span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tuser <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> na_index      <span class="operator">|</span> na_index <span class="operator">|</span> <span class="number">102</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">25.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure><h5 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h5><ul><li>只能用于<code>range</code>（范围查询）、 <code>ref</code>、 <code>eq_ref</code>、<code>ref_or_null</code>访问方法；</li><li>只能用于<code>InnoDB</code>和 <code>MyISAM</code>存储引擎及其分区表；</li><li>对<code>InnoDB</code>存储引擎来说，索引下推只适用于二级索引（也叫辅助索引）;</li></ul><blockquote><p>索引下推的目的是为了减少回表次数，也就是要减少IO操作。对于<code>InnoDB</code>的<strong>聚簇索引</strong>来说，数据和索引是在一起的，不存在回表这一说。</p></blockquote><ul><li>引用了子查询的条件不能下推；</li><li>引用了存储函数的条件不能下推，因为存储引擎无法调用存储函数。</li></ul><h4 id="为什么范围查找Mysql没有用索引下推优化？"><a href="#为什么范围查找Mysql没有用索引下推优化？" class="headerlink" title="为什么范围查找Mysql没有用索引下推优化？"></a><strong>为什么范围查找Mysql没有用索引下推优化？</strong></h4><p>估计应该是Mysql认为范围查找过滤的结果集过大，like KK% 在绝大多数情况来看，过滤后的结果集比较小，所以这里Mysql选择给 like KK% 用了索引下推优化</p><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><p><a href="https://cloud.tencent.com/developer/article/1992920">15个必知的Mysql索引失效场景，别再踩坑了-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><ol><li><p><strong>在索引列上进行使用内置函数、运算操作（如，+、-、*、&#x2F;）， 索引将失效</strong> ，MySQL 查询优化器无法直接利用索引来定位满足条件的记录，执行全表扫描或使用其他索引进行查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="built_in">SUBSTRING</span>(name, <span class="number">1</span>, <span class="number">5</span>) <span class="operator">=</span> <span class="string">&#x27;Smith&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">-</span> <span class="number">1</span> <span class="operator">&gt;</span> <span class="number">20</span>; </span><br></pre></td></tr></table></figure></li><li><p><strong>发生隐式的类型转换</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> 软件工程 <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>比如字符串不加引号，比如将char转换为int，尽管我们为条件列创建了索引，但由于查询条件中的隐式类型转换，MySQL 将<code>&#39;1&#39;</code>视为一个字符串，而不是整数。这会导致索引无法生效，数据库将会执行全表扫描来搜索匹配的行。</p></li><li><p><strong>头部模糊查询</strong>（尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效） </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%软件%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>因为 % 通配符表示匹配任意数量的字符，导致数据库无法使用索引进行快速查找，而需要执行全表扫描来搜索匹配的行</p></li><li><p><strong>OR连接条件</strong>  OR连接多个条件时，如果一个条件不能使用索引，就需要全表扫描，导致索引失效。这是因为 OR 运算符要求数据库同时检索满足两个条件的数据，而无法利用单一列的索引进行快速查找。我们将查询拆分为两个独立的查询，并分别使用适当的索引，以提高查询性能，可以考虑用union 或者 union all将结果连接起来来替代or</p></li><li><p><strong>联合索引（多列索引）不满足最左前缀法则</strong>。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p></li><li><p>**联合索引中，出现范围查询(&gt;,&lt;)**，范围查询右侧的列索引失效,因为**前一个条件**相等的情况下 **当前条件**才会是**有序的**。<br>当**前一个条件**不同 那么无法保证**当前条件**为有序的 所以索引失效。当范围查询使用&gt;&#x3D; 或 &lt;&#x3D; 时，分为两种， “&#x3D;”走联合索引，不会使右侧的列索引失效， “&lt;” 或者“&gt;”会使索引失效</p></li><li><p><strong>当查询条件使用了is null 或者 is not null</strong>，由于null值不能使用索引，索引也会失效。</p></li><li><p><strong>索引字段上使用 !&#x3D; 或者 &lt;&gt;</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">!=</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure><p>MySQL 的 B-Tree 索引存储的是有序的键值，它只能高效地利用索引来定位特定键值或键值范围的数据。</p><p>但是，使用 !&#x3D; 操作符相当于一个不等条件，无法构建有效的键值范围，因此 MySQL 通常会选择不使用索引，而执行全表扫描来获取结果。</p><p>可以使用等于操作符 &#x3D; 和 NOT 运算符来取代 !&#x3D;，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure><p>或者使用等价的条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="keyword">NOT</span> (age <span class="operator">=</span> <span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>这样可以有效利用索引，提高查询性能。</p></li><li><p><strong>使用not in 或not exists</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_items <span class="keyword">WHERE</span> order_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_id <span class="keyword">FROM</span> orders);</span><br></pre></td></tr></table></figure><p>在这个查询中，子查询 (SELECT order_id FROM orders) 会返回所有的订单ID。如果 orders 表中的订单ID较多，子查询的结果集会很大，导致 MySQL 在执行主查询时需要扫描大量数据，无法高效地利用索引。这可能导致索引失效，性能下降。</p><p>使用 NOT EXISTS：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_items oi <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> orders o <span class="keyword">WHERE</span> o.order_id <span class="operator">=</span> oi.order_id);</span><br></pre></td></tr></table></figure><p>这个查询会查询 order_items 表中的订单项，并使用子查询 (SELECT 1 FROM orders o WHERE o.order_id &#x3D; oi.order_id) 来判断是否存在对应的订单。尽管 NOT EXISTS 子查询只需要找到第一个匹配的结果，就可以确定不存在匹配的结果，但是如果子查询中的条件复杂或执行计划不佳，也可能导致索引失效或影响查询性能。</p><p>为了避免这种情况，可以考虑使用其他方式，比如使用 LEFT JOIN 结合 IS NULL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> oi.<span class="operator">*</span> <span class="keyword">FROM</span> order_items oi <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders o <span class="keyword">ON</span> o.order_id <span class="operator">=</span> oi.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p>这种方式可以利用 LEFT JOIN 并检查 orders 表中的订单ID是否为 NULL，来确定哪些订单项没有对应的订单。这样就能更有效地利用索引，提高查询性能。</p></li><li><p><strong>order by 排序顺序与索引的顺序不匹配</strong>：</p><p>索引是按照升序（ASC）排列的，而我们尝试以降序（DESC）进行排序。虽然数据库可以通过排序结果的逆向扫描来实现降序排序，但这可能会导致索引失效，因为索引无法直接按照所需的顺序匹配。</p></li><li><p>MySQL优化器<strong>评估不走索引比走索引还快</strong>，索引也失效。</p></li></ol><h4 id="如何去合理地创建表的索引"><a href="#如何去合理地创建表的索引" class="headerlink" title="如何去合理地创建表的索引"></a>如何去合理地创建表的索引</h4><ul><li><strong>针对于查询比较频繁建立索引：</strong>常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li><li><strong>尽量选择区分度高的列作为索引</strong>，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li><strong>建立前缀索引</strong>：字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li><strong>建立联合索引</strong>：对进程需要同时查询多个列的语句，建立联合索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li><strong>要控制索引的数量</strong>：索引越多，每次插入删除数据都需要找到多棵B+树进行操作，维护索引结构的代价也就越大，会影响增删改的效率</li><li><strong>定期维护索引</strong>：定期维护索引可以清理无用的索引，以保证数据库的正常运行</li></ul><h4 id="B-树的查询时间复杂度："><a href="#B-树的查询时间复杂度：" class="headerlink" title="B+树的查询时间复杂度："></a>B+树的查询时间复杂度：</h4><p>B+树的搜索过程中的IO次数 &#x3D; 搜索过程中访问节点的数量 &#x3D; B+树的深度 &#x3D; logmN，其中m为B+树一个节点的度数</p><h4 id="通过索引查询数据，会经历几次磁盘IO"><a href="#通过索引查询数据，会经历几次磁盘IO" class="headerlink" title="通过索引查询数据，会经历几次磁盘IO"></a>通过索引查询数据，会经历几次磁盘IO</h4><p>B+树一般高度为3层（3层可以存放约2000W行数据）</p><ul><li><p>如果查询建立了聚集索引，或者能够使用覆盖索引，就不需要回表，也就是需要B+树的层高次，</p></li><li><p>否则要查两次索引，也就是两倍层高次</p></li></ul><p><strong>B+树数据的存储能有多少呢?</strong></p><ol><li>对于非叶子节点，如果key使用的是bigint，则为8字节，指针在mysql中为6字节，一共是14字节，则16k能存放 16 * 1024 &#x2F; 14 &#x3D; 1170 个索引指针。</li><li>对于叶子节点，如果一行数据大小为1k，那么一页就能存16条数据；</li></ol><p><strong>于是可以算出</strong></p><p>高度为2的B+树(18720 条数据)</p><ul><li>根节点存储索引指针节点，那么它有1170个叶子节点存储数据，每个叶子节点可以存储16条数据，一共 1170 x 16 &#x3D; 18720 条数据。</li></ul><p>而对于高度为3的B+树(21902400 条数据)</p><ul><li>就可以存放 1170 x 1170 x 16 &#x3D; 21902400 条数据（两千多万条数据），也就是对于两千多万条的数据，</li></ul><h4 id="为什么Mysql页设置为16KB"><a href="#为什么Mysql页设置为16KB" class="headerlink" title="为什么Mysql页设置为16KB"></a>为什么Mysql页设置为16KB</h4><p>mysql的数据是放在页里面的,一次数据I&#x2F;O至少加载一页数据.这样是为了减少I&#x2F;O资源浪费</p><p> mysql设置16K的大小，数据就可以存<strong>2千多万</strong>就已经足够了吧，既能保证一次磁盘IO不要Load太多的数据 又能保证一次load的性能，即便表的数据在几千万的数量也能保证树的高度在一个可控的范围。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="MySQL锁概述"><a href="#MySQL锁概述" class="headerlink" title="MySQL锁概述"></a>MySQL锁概述</h4><p>锁是计算机协调多个进程或线程并发访问某一资源的机制，在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源，所以数据库也需要使用不同的锁来保证数据并发访问的一致性、有效性，锁冲突也是影响数据库并发访问性能的一个重要因素，所以锁对于数据库是很重要的。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ul><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据</li></ul><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p><strong>锁定数据库中的所有表</strong></p><p>特点：</p><ul><li>加锁后整个数据库实例处于只读状态，</li><li>后续的DML语句，DDL语句，事务提交语句均被阻塞。</li><li>如果在主库上备份，整个数据库处于只读状态，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li></ul><p>应用场景：</p><ul><li>全库的逻辑备份，从而获取一致性视图。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加全局锁</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"><span class="comment">-- 备份文件</span></span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p <span class="number">1234</span> itcast <span class="operator">&gt;</span> itcast.sql</span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p><strong>每次操作锁住整张表</strong>。表级锁主要有三类：<strong>表锁、元数据锁、意向锁</strong>。</p><h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5><p>表锁分为两类，表共享读锁(read lock)和表共享写锁(write lock)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加锁</span></span><br><span class="line">lock <span class="keyword">table</span> table_name read<span class="operator">/</span>write</span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">unlock tables <span class="operator">/</span> 客户端断开连接</span><br></pre></td></tr></table></figure><p><strong>读锁</strong></p><p>客户端A对表a加上读锁，则A和其他客户端均不能执行DDL和DML语句，均可以执行DQL语句，直到客户端A释放读锁。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E8%AF%BB%E9%94%81.png" alt="读锁"></p><p><strong>写锁</strong></p><p>客户端A对表a加上写锁，则A可以执行DDL&#x2F;DML&#x2F;DQL语句，其他客户端均不可以执行DDL&#x2F;DML&#x2F;DQL语句，直到客户端A释放锁。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E5%86%99%E9%94%81.png" alt="写锁"></p><h5 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a>元数据锁（MDL）</h5><p>MDL加锁过程由系统自动控制，不需要显式使用</p><p>在表中有活动事务时，不可以对元数据进行写入操作，元数据简单来说就是一张表的表结构，简单来说就是防止DML语句和DDL语句的冲突，有事务时不能修改表结构，保证读写的正确性。</p><table><thead><tr><th>对表的操作</th><th>加的MDL锁</th></tr></thead><tbody><tr><td>DML和DQL语句(增删改查)</td><td>MDL读锁（共享）</td></tr><tr><td>DDL语句(修改表结构)</td><td>MDL写锁(排他)</td></tr></tbody></table><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p><strong>意向锁是为了防止行锁与表锁发生冲突</strong>，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p><ul><li>当一个事务修改某一行数据时有可能会对表加上行锁，此时如果有另一个事务试图对表加上表锁，就有可能发生锁冲突，表锁需要检查每行数据是否加锁。</li><li>为了防止这种情况，第一个事务在加行锁之前会对整张表加上意向锁，记录行锁信息，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。</li></ul><p>意向锁分为意向共享锁和意向排他锁。意向锁之间不会互斥。</p><p>意向共享锁（IS）：由语句select…lock in share mode添加。与表锁读锁兼容，与表锁写锁互斥。</p><p>意向排他锁（IX）：由insert，update，delect，select…for update添加。与表锁的写锁和读锁都互斥。</p><p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><p><strong>每次操作锁住对应的行数据</strong>。只存在于InnoDB存储引擎之中。行级锁是针对主键索引加锁。行级锁主要分为三类，行锁（Record Lock），间隙锁（Gap Lock），Next-Key Lock。</p><h5 id="行锁-Record-Lock"><a href="#行锁-Record-Lock" class="headerlink" title="行锁 - Record Lock"></a>行锁 - Record Lock</h5><p>锁定单个记录，防止其他事务对此进行update和delete，在读提交和可重复读的隔离级别下均支持。行锁分为两类，<strong>共享锁</strong>和<strong>排他锁</strong>，共享锁之间兼容，排他锁与共享锁和排他锁均不兼容。基本语句的行锁加锁情况如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8A%A0%E9%94%81%E6%83%85%E5%86%B5.png" alt="基本语句的行锁加锁情况"></p><p>特点</p><ul><li>使用update或delete针对唯一索引已存在的记录进行等值匹配时，表锁会优化为行锁，只锁目标记录。</li><li>如果不用索引检索数据，语句不走索引，那么InnoDB会对所有的记录加锁，此时行锁升级为表锁。</li></ul><h5 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁 - Gap Lock"></a>间隙锁 - Gap Lock</h5><p>间隙锁 是 <strong>Innodb 在 RR(可重复读) 隔离级别</strong> 下为了解决<code>幻读问题</code>时引入的锁机制。<strong>间隙锁是innodb中行锁的一种</strong>。</p><p>锁定索引之间的间隙，确保索引之间的间隙不变，防止其他事务对这个间隙的insert的操作。</p><p>请务必牢记：<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据</strong>。</p><p>举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,…,100,101，下面的SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empid <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure><p>当我们用条件检索数据，并请求共享或排他锁时，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p><p>这个时候如果你插入empid等于102的数据的，如果那边事物还没有提交，那你就会处于等待状态，无法插入数据。</p><p>间隙锁在innoDB中的唯一作用就是在一定的“间隙”内防止其他事务的插入操作，以此防止幻读的发生：</p><ul><li>使用update或delete针对<strong>唯一索引</strong>上不存在的记录进行等值匹配时，InnoDB会对数据加上间隙锁，左开右闭。此时会阻塞这个间隙中的insert语句。</li><li>间隙锁之间兼容，同一个间隙可以重复加锁</li><li>普通索引（非唯一索引）上的等值查询向右遍历到第一个不满足要求的记录时，next-key退化为间隙锁，锁住 查询的值所在的区间</li></ul><h5 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h5><ul><li>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</li></ul><p><strong>临键锁</strong>只与<strong>非唯一索引列</strong>有关，在<strong>唯一索引列（包括主键列）上不存在临键锁。</strong>当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。</p><p>当查询的索引含有唯一属性（唯一索引，主键索引）时，Innodb存储引擎会对next-key lock进行优化，将其降为record lock,即仅锁住索引本身，而不是范围，因为是唯一索引，不会插入重复的数据，不会造成幻读。</p><h5 id="何时使用行锁，何时产生间隙锁"><a href="#何时使用行锁，何时产生间隙锁" class="headerlink" title="何时使用行锁，何时产生间隙锁"></a>何时使用行锁，何时产生间隙锁</h5><ol><li>只使用<strong>唯一索引查询</strong>，并且<strong>只锁定一条记录</strong>时，innoDB会<strong>使用行锁</strong>，因为是唯一索引，不能插入已经重复的数据，造成幻读。</li><li>只使用<strong>唯一索引查询</strong>，但是检索条件是<strong>范围检索</strong>，或者是<strong>唯一检索然而检索结果不存在</strong>（试图锁住不存在的数据）时，会产生 <strong>Next-Key Lock</strong>。</li><li>使用<strong>普通索引检索</strong>时，不管是何种查询，<strong>只要加锁</strong>，都会<strong>产生间隙锁</strong>。</li><li>同时使用<strong>唯一索引</strong>和<strong>普通索引</strong>时，由于数据行是<strong>优先根据普通索引排序</strong>，再根据唯一索引排序，所以<strong>也会产生间隙锁</strong>。</li></ol><h4 id="mysql：死锁是什么？-实习中你有遇到死锁的情况吗"><a href="#mysql：死锁是什么？-实习中你有遇到死锁的情况吗" class="headerlink" title="mysql：死锁是什么？ 实习中你有遇到死锁的情况吗"></a>mysql：死锁是什么？ 实习中你有遇到死锁的情况吗</h4><p><strong>1、产生原因：</strong></p><p>所谓死锁：是指两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用，它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。</p><ul><li>死锁的关键在于：两个(或以上)的线程加锁的顺序不一致。</li><li>那么对应的解决死锁问题的关键就是：让不同的线程加锁有次序</li></ul><p><strong>2、产生示例：</strong></p><p>案例一</p><p>需求：将投资的钱拆成几份随机分配给借款人。</p><p>起初业务程序思路是这样的：</p><p>投资人投资后，将金额随机分为几份，然后随机从借款人表里面选几个，然后通过一条条select for update 去更新借款人表里面的余额等。</p><p>例如两个用户同时投资，A用户金额随机分为2份，分给借款人1，2</p><p>B用户金额随机分为2份，分给借款人2，1</p><p>由于加锁的顺序不一样，死锁当然很快就出现了。</p><p>对于这个问题的改进很简单，直接把所有分配到的借款人直接一次锁住就行了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> xxx <span class="keyword">where</span> id <span class="keyword">in</span> (xx,xx,xx) <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><h4 id="乐观锁与悲观锁，在MySQL中怎么实现"><a href="#乐观锁与悲观锁，在MySQL中怎么实现" class="headerlink" title="乐观锁与悲观锁，在MySQL中怎么实现"></a>乐观锁与悲观锁，在MySQL中怎么实现</h4><p>悲观锁，比较消极的一种锁处理方式。直接在操作数据时，抢占锁。其他的事务在进行时就会等待，直到占有锁的事务释放锁为止。</p><p>​    这种处理方式能保证数据的最大一致性，但是容易导致锁超时、并发程度低等问题。 首先我们开启事务一，并且对id&#x3D;1的数据进行update操作，此时我们不提交事务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql root@127.0.0.1:demo&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.002s</span><br><span class="line">mysql root@127.0.0.1:demo&gt; update `user` <span class="built_in">set</span> name = <span class="string">&#x27;张三111111&#x27;</span><span class="built_in">where</span> <span class="built_in">id</span> = 1;</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line">Time: 0.004s</span><br></pre></td></tr></table></figure><p>​    接着我们开启事务二，对id&#x3D;1的数据进行update操作，查看此时会发生什么情况？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql root@127.0.0.1:demo&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.002s</span><br><span class="line">mysql root@127.0.0.1:demo&gt; update `user` <span class="built_in">set</span> sex = 1 <span class="built_in">where</span> <span class="built_in">id</span> = 1;</span><br></pre></td></tr></table></figure><p>​    我们执行完update语句之后，就处于等待状态，SQL语句也不会马上被执行，这是因为事务一没有commit，也就没有释放id&#x3D;1的数据对应的写锁。</p><p>乐观锁认为数据一般情况下不会造成冲突，只有当数据去执行修改情况时，才会针对数据冲突做处理。这里是如何发现冲突了呢？常规的方式，都是在数据行上加一个版本号或者时间戳等字段。(本文使用version作为版本号方式，使用时间戳方式同理)</p><p>​    <strong>乐观锁的实现原理：</strong></p><ul><li>一个事务在读取数据时，将对应的版本号字段读取出来，假设此时的版本号是1。    </li><li>另外一个事务也是执行同样的读取操作。当事务一提交时，对版本号执行+1，此时该数据行的版本号就是2。    </li><li>第二个事务执行修改操作时，针对业务数据做条件，并默认增加一个版本号作为where条件。此时修改语句中的版本号字段是不满足where条件，该事务执行失败。通过这种方式来达到锁的功能。</li></ul><h4 id="MySQL如何解决幻读"><a href="#MySQL如何解决幻读" class="headerlink" title="MySQL如何解决幻读"></a>MySQL如何解决幻读</h4><p><strong>快照读</strong></p><p>快照读，读取的是<strong>快照数据</strong>，不加锁的普通 SELECT 都属于快照读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure><p>通过mvcc机制来解决幻读</p><p><strong>当前读</strong></p><p>当前读就是读的是<strong>最新数据</strong>，而不是历史的数据，加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> <span class="keyword">values</span> ...</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ...</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> ...</span><br></pre></td></tr></table></figure><p>在当前读的条件下，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li><li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止，使用间隙锁锁住区间。</li></ul><p><em>间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会</em><br><em>阻止另一个事务在同一间隙上采用间隙锁。</em></p><p><a href="https://juejin.cn/post/7056583607929798692">MySQL 如何解决幻读（MVCC 原理分析） - 掘金 (juejin.cn)</a></p><h4 id="MVCC机制"><a href="#MVCC机制" class="headerlink" title="MVCC机制"></a>MVCC机制</h4><p>详见<a href="https://juejin.cn/post/7016165148020703246#heading-24">看一遍就理解：MVCC原理详解 - 掘金 (juejin.cn)</a></p><p>InnoDB还会自动的给我们每一条数据添加三个隐藏字段及其含义分别是</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112043284.png" alt="image-20231003112043284"></p><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><p>当某个事务执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，<br>并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112046405.png" alt="image-20231003112046405"></p><p>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致<strong>该记录的undolog生成一条记录版本链表</strong>，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><p>ReadView（读视图）是<strong>快照读 SQL执行时MVCC提取数据的依据</strong>，记录并维护系统当前活跃的事务（未提交的）id。</p><p><strong>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</strong></p><p><strong>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView</strong></p><p>ReadView中包含了四个核心字段：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112049869.png" alt="image-20231003112049869"></p><p>readview中规定版本链数据的访问规则：<br>trx_id 代表当前undolog版本链对应事务ID。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112052634.png" alt="image-20231003112052634"></p><h4 id="MySQL-事务的可重复读和读已提交，Read-View-时机"><a href="#MySQL-事务的可重复读和读已提交，Read-View-时机" class="headerlink" title="MySQL 事务的可重复读和读已提交，Read View 时机"></a>MySQL 事务的可重复读和读已提交，Read View 时机</h4><ul><li>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li><li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li></ul><h4 id="MVCC完全解决了幻读吗？"><a href="#MVCC完全解决了幻读吗？" class="headerlink" title="MVCC完全解决了幻读吗？"></a>MVCC完全解决了幻读吗？</h4><p>整个发生幻读的时序图如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png" alt="img"></p><p>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id &#x3D; 5 的记录并提交。接着，事务 A 对 id &#x3D; 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</p><p>因为这种特殊现象的存在，所以我们认为 <strong>MySQL Innodb 中的 MVCC 并不能完全避免幻读现象</strong></p><h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><h4 id="SQL优化（常规）"><a href="#SQL优化（常规）" class="headerlink" title="SQL优化（常规）"></a>SQL优化（常规）</h4><h5 id="插入数据优化"><a href="#插入数据优化" class="headerlink" title="插入数据优化"></a>插入数据优化</h5><ol><li><p>批量插入数据 <code>Insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;); </code></p></li><li><p>手动控制事务 ，避免频繁开启、提交事务</p><p><code>start transaction; insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;); insert into tb_test values(4,&#39;Tom&#39;),(5,&#39;Cat&#39;),(6,&#39;Jerry&#39;); insert into tb_test values(7,&#39;Tom&#39;),(8,&#39;Cat&#39;),(9,&#39;Jerry&#39;); commit;</code></p></li><li><p>主键顺序插入，性能要高于乱序插入，乱序插入会出现页分裂会降低效率。</p></li><li><p>一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，可以使用MySQL数据库提供的load指令进行插入</p><p><code>-- 客户端连接服务端时，加上参数 -–local-infile</code><br><code>mysql –-local-infile -u root -p</code><br><code>-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</code><br><code>set global local_infile = 1;</code><br><code>-- 执行load指令将准备好的数据，加载到表结构中</code><br><code>load data local infile &#39;/root/sql1.log&#39; into table tb_user fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39; ;</code></p></li></ol><h5 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h5><ul><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改</li></ul><h5 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h5><ul><li>在分组操作时，可以通过索引来提高效率。</li><li>分组操作时，索引的使用也是满足最左前缀法则的。</li></ul><h5 id="表连接优化"><a href="#表连接优化" class="headerlink" title="表连接优化"></a>表连接优化</h5><ul><li>经常在连接的列上,也是外键上创建索引,可以加快连接的速度；</li><li>合理选择驱动表，小表驱动大表。减少创建连接的次数，因为小表连接一次可以在大表中查询多次。</li><li>合理添加过滤条件可以显著减少扫描次数。</li></ul><p>left join的情况下，对右表加索引，左表是驱动表，左连接就是左边都要查出来，所以左边还是all，但是右边是ref了。</p><h5 id="子查询怎么优化"><a href="#子查询怎么优化" class="headerlink" title="子查询怎么优化"></a>子查询怎么优化</h5><p>把子查询转化为表连接，并在右表的连接字段（外键）建立索引实现优化</p><h5 id="limit优化-深度分页怎么优化？"><a href="#limit优化-深度分页怎么优化？" class="headerlink" title="(limit优化)深度分页怎么优化？"></a>(limit优化)深度分页怎么优化？</h5><p><strong>为什么深度分页比较慢？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,balance <span class="keyword">from</span> account <span class="keyword">where</span> update_time<span class="operator">&gt;</span> <span class="string">&#x27;2020-09-19&#x27;</span> limit <span class="number">100000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这条sql的执行流程:</p><ul><li>先从update_time的索引树中找到100010条满足条件的记录，返回主键id给server，server再从主键树中回表查询100010行记录，然后扔掉前面100000行</li></ul><p>由于扫描了100000行无用的记录，还要回表100010次，所以效率很低。</p><ol><li><strong>子查询优化</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,balance <span class="keyword">FROM</span> account <span class="keyword">where</span> id <span class="operator">&gt;=</span> (<span class="keyword">select</span> a.id <span class="keyword">from</span> account a <span class="keyword">where</span> a.update_time <span class="operator">&gt;=</span> <span class="string">&#x27;2020-09-19&#x27;</span> limit <span class="number">100000</span>, <span class="number">1</span>) LIMIT <span class="number">10</span></span><br></pre></td></tr></table></figure><p>一种优化思路是减少回表次数，即子查询优化。即从二级索引树中取出来记录的第一条的主键ID，这个过程是不用回表的，因为2级树的叶子节点中有ID，取到第一个记录的ID，再回到主键树从这个ID开始取十个数，大大减少了回表次数，从而提高了查询效率。</p><ol start="2"><li><strong>延迟关联</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  acct1.id,acct1.name,acct1.balance <span class="keyword">FROM</span> account acct1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> a.id <span class="keyword">FROM</span> account a <span class="keyword">WHERE</span> a.update_time <span class="operator">&gt;=</span> <span class="string">&#x27;2020-09-19&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a.update_time LIMIT <span class="number">100000</span>, <span class="number">10</span>) <span class="keyword">AS</span>  acct2 <span class="keyword">on</span> acct1.id<span class="operator">=</span> acct2.id;</span><br></pre></td></tr></table></figure><p>这个思路也是和子查询优化差不多，同样是先找好ID再回表，区别是从二级索引树中先找出对应的n条数据再两表联查。</p><ol start="3"><li><strong>游标标记法</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span>  birth_date <span class="operator">&gt;</span><span class="string">&#x27;1955-01-01&#x27;</span> <span class="keyword">and</span> emp_no <span class="operator">&gt;</span> <span class="number">229225</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> emp_no limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>记录上一次查询到的主键ID，下一次直接从主键树中该ID往后查询。缺点是在查询过程中数据库数据变化可能导致查询的数据不准，并且要求字段自增，并且每次查询要知道上一次查询结果中的最大Id，所以不能跳页查看，只能前后翻页。</p><h5 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h5><table><thead><tr><th>count(数字)</th><th>InoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，<strong>放一个数字“1”进去，直接按行进行累加</strong>。</th></tr></thead><tbody><tr><td>count(*)</td><td>InnoDB引擎<strong>并不会把全部字段取出来</strong>，而是专门做了优化，不取值，服务层直接按行进行累加。</td></tr><tr><td>count(字段)</td><td>没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，<strong>服务层判断是否为null.不为null，计数累加</strong>。有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</td></tr></tbody></table><p>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(※)，所以尽量使用 count(*※)。</p><h5 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h5><p>尽量给要Update的字段加索引，将表锁降为行锁，缓解锁冲突阻塞。</p><h5 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h5><p><a href="https://mp.weixin.qq.com/s/BLsd1b57-hlILzFvf9Gf0A">https://mp.weixin.qq.com/s/BLsd1b57-hlILzFvf9Gf0A</a></p><p>order by原理：</p><p>查找1000个杭州人，按照名字排序</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/20190505204141450.png" alt="img"></p><h6 id="全字段索引"><a href="#全字段索引" class="headerlink" title="全字段索引"></a>全字段索引</h6><p>我们需要在city上添加一个索引。 我们在执行explain命令来看看这个语句的执行情况。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/2019050520441242.png" alt="在这里插入图片描述"></p><p>Extra这个字段中的”Using filesort“ 表示的就是需要排序，MySql会给每个线程分配分配一块内存用于排序，称为sort_buffer。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyOTYxNjU=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>从图中可以看到，满足city&#x3D;‘杭州’条件的行，是从ID_X到ID_(X+N)的这些记录。<br>通常情况下，这个语句执行流程如下所示：</p><ol><li>初始化sort_buffer, 确定放入name、city、age这三个字段;</li><li>从索引city找到第一个满足city&#x3D;“杭州” 条件的主键id，也就是图中的ID_X;</li><li>到主建索引取出整行数据（回表查询），取name、city、age 三个 字段的值，存入sort_buffer中;</li><li>从索引city取下一个记录的主键id ;</li><li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y;</li><li>对sort_buffer 中的数据<strong>按照字段name做快速排序</strong>;</li><li>按照排序结果取前1000行返回给客户端;</li></ol><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1713193636636-6.webp" alt="图片"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyOTYxNjU=,size_16,color_FFFFFF,t_70-1711682366199-8.png" alt="在这里插入图片描述"></p><p>按照字段 username 做快速排序这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和 sort_buffer 的大小，由参数 <code>sort_buffer_size</code> 决定。</p><p>如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则就需要利用<strong>磁盘临时文件</strong>来辅助排序。</p><p>解释下这里使用磁盘临时文件来进行辅助排序的含义，外部排序常用的排序算法是<strong>多路归并排序算法</strong>，具体步骤如下：</p><ul><li>到主键 id 索引树上查找到对应的整行数据后，取 city、username、age 三个字段的值，存入 sort_buffer 中，能存多少是多少，当 sort_buffer 快要满时，就对 sort_buffer 中的<strong>数据进行排序</strong>，排完后，把数据<strong>临时放到磁盘的一个小文件</strong>中，然后<strong>清空 sort_buffer</strong>（这样的话，一个很大的数据，就会被分成若干个临时磁盘文件）</li><li>继续回到主键 id 索引树取数据，重复上一步，直到取出所有满足条件的数据</li><li>最后，<strong>归并已经有序的若干个临时磁盘文件</strong>，形成一个完整的有序大文件</li></ul><p>可以看出，整个排序过程，我们要查询的 city、username、age 全都参与了，所以，暂且把这个排序过程，称为<strong>全字段排序</strong></p><p><strong>routId 排序</strong><br>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。但这个算法有一个问题，如果查询返回的数据字段多，那么内存中放的数据就要分成多个临时文件，排序的性能就会很差。</p><p>修改参数 max_length_for_sort_data,是MySql中专门控制用于排序的行数据的长度的一个参数，它的意思是，如果单行的长度超过这个值 ，MySQL就认为单行太大，要换一个算法。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/2019050521265030.png" alt="在这里插入图片描述"></p><p>city,name,age这三个字段的定义总长度是36，我把max_length_for_sort_data设置为16，那么放入sort_buffer的字段只有要排序的列(即 name 字段 是order by 后面的关键字)和主键id。<br>但这时，排序的结果就因为少了city和age字段的值 ，不能直接返回了，整个执行的流程就变成 如下所示的样子:</p><ol><li><p>初始化sort_buffer，确定放入两个字段，即name和id;</p></li><li><p>从索引city找到第一个满足city&#x3D;’上海’条件的主键,也就是图中的ID_X;</p></li><li><p>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中;</p></li><li><p>从索引city取下一个记录的主键id;</p></li><li><p>重复3、4步骤，直到找到不city!&#x3D;‘杭州’;</p></li><li><p>对sort_buffer中的数据按照name进行排序;</p></li><li><p>遍历排序结果，取前1000行，并按照id的值回到原表中的city、name和age三个字段返回给客户端。</p></li></ol><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyOTYxNjU=,size_16,color_FFFFFF,t_70-1711682407937-13.png" alt="在这里插入图片描述"></p><h6 id="对排序进行优化"><a href="#对排序进行优化" class="headerlink" title="对排序进行优化"></a>对排序进行优化</h6><p>很显然，如果不排序就能得到正确的结果，那对系统的消耗会小很多，语句的执行时间也会变得更短。</p><p>从上面分析的执行过程我们可以看到，MySQL 之所以需要 sort_buffer，并且在 sort_buffer 上做排序操作，其原因是原来的数据都是无序的。</p><p>回顾下我们的需求：查询出 city 是 “杭州” 的所有 username，并且按照 username 进行排序，返回前 1000 个人的姓名、年龄。</p><p>那，<strong>如果能够保证从 city 这个索引上取出来的数据行，已经天然就是按照 username 进行递增排序的话，不就不用再排序了吗</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> index_city(city,name);</span><br></pre></td></tr></table></figure><p>这样数据的索引就有按照name进行排序。 这样整个排序过程就变成了下面这样。</p><ul><li><p>从索引(city,name)找到第一个满足city&#x3D;”杭州”条件的主键id;</p></li><li><p><font color = "gold">到主键id索引查找整行数据(回表查询),取name、city、age三个字段的值，作为结果集的一部分直接返回,因为索引中name就已经是有序的了，不需要在内存中继续排序。</font></p></li><li><p>从联合索引取出一个记录主键 id；</p></li><li><p>重复2、3步。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640.webp" alt="图片"></p></li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyOTYxNjU=,size_16,color_FFFFFF,t_70-1711682434446-16.png" alt="在这里插入图片描述"></p><p>在使用explain 来分析这个sql</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/20190506211600249.png" alt="在这里插入图片描述"></p><p>可以看到extra字段中没有Using filesort了，也就是不需要排序了。<br>由于覆盖索引的原则，我们可以再进行优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> index_city(city,name,age);</span><br></pre></td></tr></table></figure><p>1）从联合索引 (city, username, age) 树上找到第一个满足 city&#x3D;’杭州’ 条件的记录，把这条记录作为结果集的一部分直接返回；</p><p>2）从联合索引 (city, username, age) 树上取下一个记录，同样将这条记录作为结果集的一部分直接返回</p><p>3）重复执行步骤 2，直到查到第 1000 条记录，或者是不满足 city&#x3D;’南京’ 条件时循环结束</p><p>如下图所示：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1713193542850-3.webp" alt="图片"></p><p>在使用explain 对sql进行分析</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/20190506211915927.png" alt="在这里插入图片描述"></p><p>发现使用Using index，表示的就是使用了覆盖索引，性能上会快很多。</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li><li>尽量使用覆盖索引，避免fileSort。</li><li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）。</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。</li></ul><ol><li>order by 的基本原理其实就是 MySQL 会给每个线程分配一块内存也就是 sort_buffer 用于排序，sort_buffer 中存储的是 select 涉及到的所有的字段，可以称为全字段排序吧。排序这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和 sort_buffer 的大小，由参数 <code>sort_buffer_size</code> 决定。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，就需要利用磁盘临时文件来辅助排序,临时文件存放的是每一次sort后的有序的部分结果,需要将各个磁盘临时文件归并排序来构成完整的结果集。</li><li>这里其实可以优化下，<strong>只存放排序相关的字段</strong>(包括查询字段和主键id,其中主键id用于回表查询)，而不是 select 涉及的所有字段，这样 sort_buffer 中存放的东西就多一点，就尽可能避免使用磁盘进行外部排序，或者说使得划分的磁盘文件相对变少，减少磁盘访问。这种排序称为 rowid 排序。如果表中单行的长度超过 <code>max_length_for_sort_data</code> 定义的值，那 MySQL 就认为单行太大（那么数据量肯定就越大，sort_buffer 可能不够用），由全字段排序改为 rowid 排序, 再排序结束后再根据id会表查询。</li></ol><p>以上是我们说的关于 order by 的两个参数优化，还可以根据索引进行一些优化</p><ol><li>以 <code>select a, b, c from table where a = xxxx order by b</code> 为例，我们为查询条件 a 和排序条件 b 建立联合索引，联合索引就是 a 是从小到大绝对有序的，如果 a 相同，再按 b 从小到大排序，这样就不需要排序了，直接避免了排序这个操作。</li><li>还可以进一步优化，由于联合索引 (a, b) 中没有 c 的值，所以从联合索引树上获取符合条件的对应主键 id 后，还需要回表查询取出 a b c 的值，这个回表查询的过程可以通过建立 (a,b,c) 覆盖索引来避免。</li></ol><h4 id="SQL优化（技巧）"><a href="#SQL优化（技巧）" class="headerlink" title="SQL优化（技巧）"></a>SQL优化（技巧）</h4><h5 id="使用update更新一个大表，怎么优化"><a href="#使用update更新一个大表，怎么优化" class="headerlink" title="使用update更新一个大表，怎么优化"></a>使用update更新一个大表，怎么优化</h5><ol><li>批量更新，而不是一条一条更新</li><li>在分组、排序之前就过滤，过滤优先于一切</li><li>同时过滤、排序条件的列尽量走索引，过滤走索引才能使用行锁，否则会升级为表锁</li><li>尽量走主键索引，联合索引避免回表查询</li><li>分区表：如果可能的话，考虑将大表分成更小的分区表。这样可以将更新操作限制在特定分区内，减少锁定冲突的机会。</li></ol><h5 id="SQL优化，使用索引的时候怎么优化"><a href="#SQL优化，使用索引的时候怎么优化" class="headerlink" title="SQL优化，使用索引的时候怎么优化"></a>SQL优化，使用索引的时候怎么优化</h5><ol><li><p>避免索引失效：</p><ul><li><p>模糊查询 %放在右边<br>原理：模糊查询的时候尽量在字段后面使用模糊查询最左原则</p></li><li><p>避免使用or</p></li><li><p>在where条件中，等式左侧不要进行表带式、函数操作。</p></li><li><p>查询条件不要用 &lt;&gt; 或者 !&#x3D;</p></li><li><p>使用联合索引要符合最左匹配原则</p></li><li><p>避免出现select *</p></li></ul></li><li><p>优先过滤，尽量避免分组后再过滤</p></li><li><p>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p></li><li><p>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p></li></ol><h4 id="慢sql怎么看-怎么解决"><a href="#慢sql怎么看-怎么解决" class="headerlink" title="慢sql怎么看 怎么解决"></a>慢sql怎么看 怎么解决</h4><h5 id="慢查询日志："><a href="#慢查询日志：" class="headerlink" title="慢查询日志："></a>慢查询日志：</h5><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。如果要开启慢查询日志，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 开启MySQL慢日志查询开关`</span><br><span class="line">slow_query_log<span class="operator">=</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line">#设置慢日志的时间为<span class="number">2</span>秒，<span class="keyword">SQL</span>语句执行时间超过<span class="number">2</span>秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#重启mysql服务</span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>检查慢查询日志 ：在慢查询日志中，只会记录执行时间超多我们预设时间（2s）的SQL，执行较快的SQL是不会记录的。</p><p>那这样，通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化</p><h5 id="profile详情"><a href="#profile详情" class="headerlink" title="profile详情"></a>profile详情</h5><p>可以查看执行时间较长的sql，并且了解时间耗费在哪个步骤</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询数据库是否支持profile</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@have_profiling</span>;</span><br><span class="line"><span class="comment">-- 开启profile的开关</span></span><br><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 查看每一条sql的执行情况</span></span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"><span class="comment">-- 查询指定query_id在sql的各个阶段的耗时</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure><p><strong>用explain分析sql</strong></p><p>[explain有哪些字段，分别有什么含义_explain字段含义-CSDN博客](<a href="https://blog.csdn.net/weixin_50998273/article/details/111938295#:~:text=explain%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89">https://blog.csdn.net/weixin_50998273/article/details/111938295#:~:text=explain有哪些字段，分别有什么含义</a> 1 1. id SQL查询中的序列号。 id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行。 2 2.,查询真正使用到的索引。 … 8 8. key_len 查询用到的索引长度（字节数）。 … 更多项目)</p><p>explain命令可以查看select语句的执行计划，包括表连接顺序以及索引使用情况等等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select_sql;</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png" alt="sql的执行计划"></p><ul><li><p>id：指代sql语句中的执行顺序。多表查询中，id相同，执行顺序从上到下，id不同，id值越大越先执行</p></li><li><p>select_type:表示查询类型，常见取值有SIMPLE(简单表，即单表查询)，PRIMARY(子查询中的外层查询)等</p></li><li><p>type：表示查询的连接类型，由好到差依次是<strong>null &gt; system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</strong>。</p><ul><li>system,访问系统表</li><li>const，使用<strong>唯一索引</strong>或者<strong>主键索引</strong>，单表中<strong>最多有一条匹配行</strong>。select * from student where id &#x3D; 1;</li><li>eq_ref ,主键或者唯一索引被连接使用，最多只会返回一个值，常出现在多表查询中。从一个表中查出另一个表的主键然后在另一个表中进行查询。</li><li>ref，使用<strong>普通索引</strong>或者<strong>唯一性索引的部分前缀</strong>，有可能会<strong>返回多条值</strong></li><li>range，使用索引选择行，仅检索给定范围内的行，范围查询。</li><li>index，扫描<strong>全表索引</strong>，比all要快一些</li><li>all，<strong>全表扫描</strong>，效果最差</li></ul></li><li><p>possible_key：查询语句可能用到的索引</p></li><li><p>key：实际使用的索引，如果为NULL则说明没有使用索引</p></li><li><p>key_len：索引使用的字节数，这个值越短越好</p></li><li><p>row：MySQL认为可能扫描的行数，是一个估计值，这个值越小越好</p></li><li><p>filtered：表示返回结果的行数占读取行数的百分比，filtered值越大越好</p></li></ul><p>解决：</p><ol><li>SQL语句优化，尽量精简，去除非必要语句</li><li>索引优化，让所有SQL都能够走索引</li><li>如果是表的瓶颈问题，则分表，单表数据量维持在2000W（理论上）以内</li><li>如果是单库瓶颈问题，则分库，读写分离</li><li>如果是物理机器性能问题，则分多个数据库节点</li></ol><p>第 1 个原因：没有索引或者 导致索引失效。<br>第 2 个原因：单表数据量数据过多，导致查询瓶颈<br>第 3 个原因：网络原因或者机器负载过高。<br>第 4 个原因：热点数据导致单点负载不均衡。</p><p>第 1 种情况：索引失效或者没有没有索引的情况<br>首先，可以打开 MySQL 的慢查询日志，收集一段时间的慢查询日志内容，然后找出耗时最长的 SQL 语句，对这些 SQL 语句进行分析。<br>比如可以利用执行计划 explain 去查看 SQL 是否有命中索引。如果发现慢查询的 SQL 没有命中索引，可以尝试去优化这些 SQL 语句，保证 SQL 走索引执行。如果 SQL 结构没有办法优化的话，可以考虑在表上再添加对应的索引。我们在优化 SQL 或者是添加索引的时候，都需要符合最左匹配原则。</p><p>第 2 种情况：单表数据量数据过多，导致查询瓶颈的情况。即使 SQL 语句走了索引，表现性能也不会特别好。这个时候我们需要考虑对表进行切分。表切分规则一般分为两种，一种是水平切分，一种是垂直切分。水平切分的意思是把一张数据行数达到千万级别的大表，按照业务主键切分为多张小表，这些小表可能达到 100 张甚至 1000 张。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240318112030315.png" alt="image-20240318112030315"></p><p>那垂直切分的意思是，将一张单表中的多个列，按照业务逻辑把关联性比较大的列放到同一张表中去。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240318112110577.png" alt="image-20240318112110577"></p><p>除了这种分表之外，我们还可以分库，</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240318112121184.png" alt="image-20240318112121184"></p><p>比如我们已经拆分完 1000 表，然后，把后缀为 0-100 的表放到同一个数据库实例中，然后，100-200 的表放到另一个数据库实例中，依此类推把 1000 表存放到 10 个数据库实例中。这样的话，我们就可以根据业务主键把请求路由到不同数据库实例，从而让每一个数据库实例承担的流量比较小，达到提高数据库性能的目的。</p><p>第 3 种情况：网络原因或者机器负载过高的情况，我们可以进行读写分离.</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240318112139782.png" alt="image-20240318112139782"></p><p>比如 MySQL 支持一主多从的分布式部署，我们可以将主库只用来处理写数据的操作，而多个从库只用来处理读操作。在流量比较大的场景中，可以增加从库来提高数据库的负载能力，从而提升数据的总体性能。</p><p>第 4 种情况：热点数据导致单点负载不均衡的情况。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240318112149545.png" alt="image-20240318112149545"></p><p>这种情况下，除了对数据库本身的调整以外，还可以增加缓存。将查询比较频繁的热点数据预存到缓存当<br>中，比如 Redis、MongoDB、ES 等，以此来缓解数据的压力，从而提高数据库的响应速度。</p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><h4 id="binlog刷盘策略"><a href="#binlog刷盘策略" class="headerlink" title="binlog刷盘策略"></a>binlog刷盘策略</h4><p>mysql只有在事务提交的时候才会记录binlog日志，此时日志还在内存中，那binlog是什么时候被刷到磁盘中的呢？<br>mysql通过sync_binlog控制刷盘，取值范围0~N</p><ul><li>0：不强制要求刷盘，由系统自行判断什么时候将binlog写入磁盘；</li><li>1：每次提交事务就将binlog写入磁盘；</li><li>n：每提交n个事务将binlog写入磁盘；</li></ul><p>显然，sync_binlog为1是最安全的，每次提交事务就将binlog写入磁盘，数据一致性最好。但实际情况中，往往为了提高数据库的性能，会将sync_binlog适当设大，来减少磁盘IO次数，用数据一致性换性能。<br>在对数据库一致性要求不高或数据没那么重要的业务场景，完全可以把sync_binlog设置在100~1000范围内的某个值，以此来提高数据库的性能。而在对数据一致性要求高的业务场景或特别重要的数据，比如订单则建议将sync_binlog的值设置为1，这样可以保证哪怕数据库挂了也不会丢失数据。<br>sync_binlog的默认值是0，这时由系统会自行判断将binlog写入磁盘的时机。数据库可能会在空闲的时候综合考虑缓存的binlog日志大小来决定是否要将binlog写入磁盘。</p><h5 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h5><blockquote><p>由于每一个binlog与事务相关，随事务的提交而提交，所以每一个事务都有一个binlog cache，如果存储内容超过了这个参数，就要暂存到磁盘，待事务提交后一次性写入文件系统的 page cache，而sync_binlog&#x3D;n这个参数表示文件系统积累多少个事务的binlog后一次性刷盘到磁盘，安全性和一致性要求比较高的场景这个值设置为1，磁盘IO压力比较大的情况下可以增大。</p></blockquote><h4 id="binlog组提交"><a href="#binlog组提交" class="headerlink" title="binlog组提交"></a>binlog组提交</h4><p>MySQL引入binlog来实现主从实例之间的数据同步，提高数据库系统的可用性，但同时也增加了事务整体的资源消耗，需要额外的磁盘空间和IO处理能力。尤其是为了保证本地事务的持久性，必须将binlog刷盘控制参数sync_binlog设置为1，设想如果每一次事务提交，都强制进行一次刷盘操作，数据库整体的性能会受到极大的影响。<br>MySQL引入组提交的目的是为了在高并发下合并多个线程的刷盘操作，降低日志刷盘次数，提高数据库的整体性能</p><h4 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog 归档日志"></a>binlog 归档日志</h4><p>binlog是Server层的日志，binlog的主要作用是归档，即可以把数据库恢复到之前一段时间内的任意一天的状态。</p><p>binlog会记录MySQL执行的SQL原始语句，具体流程就是，当MySQL执行一条update语句时，流程如下：</p><ol><li>更新缓存中的对应行，如果缓存中不存在则从数据库中读入内存然后更新。</li><li>将数据页变化写入redo log，此时处于prepare的状态。</li><li>事务提交前，将执行的sql语句写入binlog</li><li>提交事务，redo log处于commit状态</li></ol><p>sync_binlog&#x3D;1时，每次事务的binlog都会持久化到磁盘，建议设置为1.</p><h5 id="binlog-实现-数据库恢复的原理"><a href="#binlog-实现-数据库恢复的原理" class="headerlink" title="binlog 实现 数据库恢复的原理"></a>binlog 实现 数据库恢复的原理</h5><p>数据库一般隔一段时间比如三天或者五天或者七天会做整库备份，而binlog则会保留一段时间的所有sql语句的逻辑操作。所以进行整库备份的流程：</p><ol><li>找到上一次的全量备份的文件，将这个备份恢复到数据库，同时记录备份时间a</li><li>如果想要恢复到时间点b的状态，则将binlog中a和b之间的逻辑操作全部取出来依次执行</li></ol><h5 id="binlog和redo-log的区别"><a href="#binlog和redo-log的区别" class="headerlink" title="binlog和redo log的区别"></a>binlog和redo log的区别</h5><p>binlog用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。binlog是mysql的逻辑日志，并且由Server层进行记录，使用任何存储引擎的mysql数据库都会记录binlog日志。</p><table><thead><tr><th>binlog</th><th>① Server层 ② 逻辑日志，记录原始逻辑 （命令）③ 循环写，空间固定④主从复制，数据恢复</th></tr></thead><tbody><tr><td>redo log</td><td>①引擎层，InnoDB独有 ②物理日志，记录数据页变化 ③追加写，不会覆盖④故障恢复</td></tr></tbody></table><h4 id="讲一讲mysql主从部署"><a href="#讲一讲mysql主从部署" class="headerlink" title="讲一讲mysql主从部署"></a>讲一讲mysql主从部署</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p><p>MySQL 复制的优点主要包含以下三个方面：</p><ul><li>主库出现问题，可以快速切换到从库提供服务。</li><li>实现读写分离，降低主库的访问压力。</li><li>可以在从库中执行备份，以避免备份期间影响主库服务。</li></ul><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>MySQL主从复制的核心就是 二进制日志，具体的过程如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112012277.png" alt="image-20231003112012277"></p><p>从上图来看，复制分成三步：</p><ol><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li><li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ol><h5 id="主从复制的问题？"><a href="#主从复制的问题？" class="headerlink" title="主从复制的问题？"></a>主从复制的问题？</h5><ol><li>同步延迟：由于主从复制是异步执行的，从服务器需要等待主服务器将数据操作记录到二进制日志（BinLog）并传输到从服务器后才能执行。这可能导致从服务器的数据与主服务器存在一定的时间差，从而引起同步延迟。而且从服务器上只有一个 SQL Thread，当主服务器有大量写操作时，复制延时也可能会增大。</li><li>数据一致性：在主从复制过程中，如果主服务器发生故障或网络中断，从服务器可能会丢失部分尚未复制的数据。</li></ol><ul><li><strong>半同步复制</strong>—解决数据丢失的问题</li><li><strong>并行复制</strong>—-解决从库复制延迟的问题</li></ul><p>半同步复制（5.5集成到mysql，以插件的形式存在，需要单独安装）</p><ul><li>该模式下 MySQL 主节点在发送完 BinLog 后不会立刻提交数据，而是至少等待一个从服务器写完 RelayLog 并返回 ACK 消息后，才提交事务</li><li>确保事务提交后binlog至少传输到一个从库</li><li>不保证从库应用完成这个事务的binlog</li><li>性能有一定的降低</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2jmn5LlhavkuZ0=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><p><strong>并行复制</strong></p><p>单线程的 SQL Thread Relay 操作在 Master 的 TPS 比较高的情况下，会出现严重的性能瓶颈，进而导致主从同步延迟。</p><p>MySQL 为了解决这个问题，将 SQL Thread 演化成了多个 Worker 的形式，在 Slave 端并行应用 Relay Log 中的事务，从而提升 Relay Log 的应用速度，降低复制延迟</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/curr-relay.webp" alt="relay worker"></p><ul><li>并行是指从库多线程并行应用binlog，同一个库数据更改还是串行的</li></ul><h5 id="搭建主从环境："><a href="#搭建主从环境：" class="headerlink" title="搭建主从环境："></a>搭建主从环境：</h5><p>配置主库，修改配置文件 &#x2F;etc&#x2F;my.cnf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 232-1，默认为1</span><br><span class="line">server-id=1</span><br><span class="line">#是否只读,1 代表只读, 0 代表读写</span><br><span class="line">read-only=0</span><br></pre></td></tr></table></figure><p>重启MySQL服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld </span><br></pre></td></tr></table></figure><p>登录mysql，创建远程连接的账号，并授予主从复制权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#创建itcast用户，并设置密码，该用户可在任意主机连接该MySQL服务</span><br><span class="line">CREATE USER &#x27;itcast&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;Root@123456&#x27;</span><br><span class="line">;</span><br><span class="line">#为 &#x27;itcast&#x27;@&#x27;%&#x27; 用户分配主从复制权限</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;itcast&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>通过指令，查看二进制日志坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status ;</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112018880.png" alt="image-20231003112018880"></p><p>字段含义说明：<br>file : 从哪个日志文件开始推送日志文件<br>position ： 从哪个位置开始推送日志<br>binlog_ignore_db : 指定不需要同步的数据库</p><h5 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h5><p>修改配置文件 &#x2F;etc&#x2F;my.cnf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，和主库不一样即可</span><br><span class="line">server-id=2</span><br><span class="line">#是否只读,1 代表只读, 0 代表读写</span><br><span class="line">read-only=1</span><br></pre></td></tr></table></figure><p>重新启动MySQL服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>登录mysql，设置主库配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CHANGE REPLICATION SOURCE TO SOURCE_HOST=&#x27;192.168.200.200&#x27;, SOURCE_USER=&#x27;itcast&#x27;,</span><br><span class="line">SOURCE_PASSWORD=&#x27;Root@123456&#x27;, SOURCE_LOG_FILE=&#x27;binlog.000004&#x27;,</span><br><span class="line">SOURCE_LOG_POS=663;</span><br><span class="line">或者</span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.200.200&#x27;, MASTER_USER=&#x27;itcast&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;Root@123456&#x27;, MASTER_LOG_FILE=&#x27;binlog.000004&#x27;,</span><br><span class="line">MASTER_LOG_POS=663;</span><br></pre></td></tr></table></figure><p>开启同步操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start replica ; #8.0.22之后</span><br><span class="line">start slave ; #8.0.22之前</span><br></pre></td></tr></table></figure><p>查看主从同步状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show replica status ; #8.0.22之后</span><br><span class="line">show slave status ; #8.0.22之前</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112023725.png" alt="image-20231003112023725"></p><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><p>分库分表的原因：</p><ul><li>当某一个数据库被访问得特别频繁时，有可能会占用绝大部分的服务器磁盘IO和网络IO，影响同一台服务器上的其他数据，此时可以将数据库进行拆分，将一台服务器上的数据库拆分到多台服务器上。</li><li>当表的数据量特别大或者表中的字段很多时，可以将字段进行拆分或者分散到多张表中，提高查询效率以及更新效率。</li></ul><h5 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h5><p>垂直拆分</p><p>垂直分库：以表为依据，将不同业务的表拆分到不同的数据库中。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240318140611487.png" alt="image-20240318140611487"></p><ul><li>每个库的表结构都不一样。</li><li>每个库的数据也不一样。</li><li>所有库的并集是全量数据。</li></ul><p>垂直分表：以字段为依据，将一张表中的字段进行分类拆分到不同的表中。不同表可以通过外键进行关联</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240318140637932.png" alt="image-20240318140637932"></p><ul><li>每个表的结构都不一样。</li><li>每个表的数据也不一样，一般通过一列（主键&#x2F;外键）关联。</li><li>所有表的并集是全量数据。</li></ul><p>水平拆分</p><ul><li>水平分库，将数据库中的表复制到多个服务器数据库中，每个数据库中的表结构都是一样的，各自存储一部分的数据。</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240318141105540.png" alt="image-20240318141105540"></p><ul><li>每个库的表结构都一样。</li><li>每个库的数据都不一样。</li><li>所有库的并集是全量数据。</li></ul><ul><li>水平分表：将一张表拆分成多个结构相同的表，每个表中保存一部分数据。</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240318141154799.png" alt="image-20240318141154799"></p><ul><li>每个表的表结构都一样。</li><li>每个表的数据都不一样。</li><li>所有表的并集是全量数据</li></ul><h5 id="分片规则"><a href="#分片规则" class="headerlink" title="分片规则"></a>分片规则</h5><p>范围分片：根据指定的字段及其配置的范围与数据节点的对应情况， 来决定该数据属于哪一个分片。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240318144804381.png" alt="image-20240318144804381"></p><p>取模分片：指定的字段值与节点数量进行求模运算，根据运算结果， 来决定该数据属于哪一个分片</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240318144846254.png" alt="image-20240318144846254"></p><p>哈希切片：对数据库的某个字段进行来求哈希，再除以分片总数后取模，取模后相同的数据为一个分片，这样将数据分成多个分片的方法叫做哈希分片，我们大多数在数据没有时效性的情况下使用哈希分片，就是数据不管是什么时候产生的，系统都需要处理或者查询；复制table_index &#x3D; hash(order_id) % tables_num</p><ul><li>优点：负载均衡，每个表的数据分布相对均匀。</li><li>缺点：不利于二次扩容。</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240318145159998.png" alt="image-20240318145159998"></p><p>时间切片：按照时间的范围将数据分布到不同的分片上，比如我们可以将交易数据按照与进行切片，或者按照季度进行切片，由交易数据的多少来决定按照什么样的时间周期来进行切片</p><p>这种切片方式适合明显时间特点的数据，常见的就是订单历史查询</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240318145310059.png" alt="image-20240318145310059"></p><ul><li><p>一致性hash：计算指定字段的hash值，然后根据hash值不同将数据存储在对应节点。而一致性的意思是即使以后增加节点，原来的数据依然会划分到原来的节点，不会因为节点的增加而发生改变，有效的解决了分布式数据的拓容问题。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240318145000616.png" alt="image-20240318145000616"></p></li><li><p>枚举分片：枚举指定字段的值来决定数据会被分配到哪个节点。适用于按照省份，状态，性别等进行分片的场景</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240318145038787.png" alt="image-20240318145038787"></p></li><li><p>应用指定：根据数据的某个字段的一部分（必须是数字）来直接决定数据存储在哪个节点。如01_xx,02_xx,03_xx</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240318145106020.png" alt="image-20240318145106020"></p></li></ul><h4 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h4><h5 id="普通-hash-算法的缺陷："><a href="#普通-hash-算法的缺陷：" class="headerlink" title="普通 hash 算法的缺陷："></a>普通 hash 算法的缺陷：</h5><p><strong>hash（key）% N</strong></p><p>​        如果增加或者删除服务器节点，那么n的数量就会改变，所有缓存的位置都要发生改变，也就是说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据。</p><ul><li><p>一致性哈希算法将整个哈希值空间按照顺时针方向组织成一个虚拟的圆环，称为 Hash 环；</p></li><li><p>接着将各个服务器使用 Hash 函数进行哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，从而确定每台机器在哈希环上的位置</p></li><li><p>最后使用算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针寻找，第一台遇到的服务器就是其应该定位到的服务器</p></li></ul><p>哈希环的组织：</p><p>​    我们将 2^32 想象成一个圆，像钟表一样，钟表的圆可以理解成由60个点组成的圆，而此处我们把这个圆想象成由2^32个点组成的圆，示意图如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1dabc6d21275466885e876058dd81d7a.png" alt="img"></p><p>​    圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第一个点代表2^32-1，我们把这个由 2^32 个点组成的圆环称为hash环。</p><p>（2）步骤二：确定服务器在哈希环的位置：</p><p>哈希算法：hash（服务器的IP） % 2^32</p><p>​    上述公式的计算结果一定是 0 到 2^32-1 之间的整数，那么上图中的 hash 环上必定有一个点与这个整数对应，所以我们可以使用这个整数代表服务器，也就是服务器就可以映射到这个环上，假设我们有 ABC 三台服务器，那么它们在哈希环上的示意图如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_14,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p> （3）步骤三：将数据映射到哈希环上：</p><p>​    我们还是使用图片的名称作为 key，所以我们使用下面算法将图片映射在哈希环上：hash（图片名称） % 2^32，假设我们有4张图片，映射后的示意图如下，其中橘黄色的点表示图片：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>​    那么，怎么算出上图中的图片应该被缓存到哪一台服务上面呢？我们只要从图片的位置开始，沿顺时针方向遇到的第一个服务器就是图片存放的服务器了。最终，1号、2号图片将会被缓存到服务器A上，3号图片将会被缓存到服务器B上，4号图片将会被缓存到服务器C上。</p><p>一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，只有部分缓存会失效，不至于将所有压力都在同一时间集中到后端服务器上，具有较好的容错性和可扩展性。</p><p>​    假设服务器B出现了故障，需要将服务器B移除，那么移除前后的示意图如下图所示：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>hash 环的倾斜与虚拟节点：<br>        一致性哈希算法在服务节点太少的情况下，容易因为节点分部不均匀而造成数据倾斜问题，也就是被缓存的对象大部分集中缓存在某一台服务器上，从而出现数据分布不均匀的情况，这种情况就称为 hash 环的倾斜。如下图所示：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_20,color_FFFFFF,t_70,g_se,x_16-1712633028188-13.png" alt="img"></p><p>​     hash 环的倾斜在极端情况下，仍然有可能引起系统的崩溃，为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对<strong>每一个服务节点计算多个哈希</strong>，每个<strong>计算结果位置都放置一个此服务节点，称为虚拟节点</strong>，一个实际物理节点可以对应多个虚拟节点，虚拟节点越多，hash环上的<strong>节点就越多</strong>，缓存被均匀分布的概率就越大，hash环倾斜所带来的影响就越小，同时数据定位算法不变，只是多了一步<strong>虚拟节点到实际节点的映射</strong>。<strong>具体做法可以在服务器ip或主机名的后面增加编号来实现</strong>，加入虚拟节点以后的hash环如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_15,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><ul><li><strong>节点数量多了后，节点在哈希环上的分布就相对均匀了</strong>。这时候，如果有访问请求寻址到「A-01」这个虚拟节点，接着再通过「A-01」虚拟节点找到真实节点 A，这样请求就能访问到真实节点 A 了。</li><li>虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。<strong>当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高</strong>。</li><li>有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如对权重更高的节点增加更多的虚拟机节点即可。</li></ul><h4 id="假设有一个用户表，你用ID做的分片键，那么有一个类似于name这样的字段如何查询？"><a href="#假设有一个用户表，你用ID做的分片键，那么有一个类似于name这样的字段如何查询？" class="headerlink" title="假设有一个用户表，你用ID做的分片键，那么有一个类似于name这样的字段如何查询？"></a>假设有一个用户表，你用ID做的分片键，那么有一个类似于name这样的字段如何查询？</h4><p>这里提供几种常见的思路：</p><h5 id="全局索引"><a href="#全局索引" class="headerlink" title="全局索引"></a>全局索引</h5><p>全局索引是一个跨所有分片的索引，它包含了非分片键字段和对应的分片键信息。查询时，先通过全局索引找到相关的分片键，然后在相应的分片中查询详细数据。</p><p>适用场景：适用于查询频率高、数据量大的非分片键字段。</p><p>优点：查询效率高，可以快速定位到数据所在的分片。</p><p>缺点：全局索引维护成本较高，需要定期更新以保持与分片数据的一致性。</p><h5 id="2-数据冗余"><a href="#2-数据冗余" class="headerlink" title="2. 数据冗余"></a>2. 数据冗余</h5><p>在每个分片中存储部分非分片键字段的数据。这样，即使不直接查询分片键，也可以在分片内快速找到相关数据。</p><p>适用场景：适用于查询性能要求极高，且可以接受一定数据冗余的场景。</p><p>优点：查询性能高，无需跨分片查询。</p><p>缺点：数据冗余增加了存储成本和维护复杂性。</p><h5 id="3-应用层处理"><a href="#3-应用层处理" class="headerlink" title="3. 应用层处理"></a>3. 应用层处理</h5><p>在应用层实现复杂的查询逻辑，将多个分片中的查询结果汇总后进行处理。</p><p>适用场景：适用于查询频率不高，或者可以接受一定延迟的场景。</p><p>优点：灵活性高，可以根据业务需求定制查询逻辑。</p><p>缺点：查询性能可能受到网络延迟和分片数量的影响。</p><h5 id="4-使用Elasticsearch（ES）"><a href="#4-使用Elasticsearch（ES）" class="headerlink" title="4. 使用Elasticsearch（ES）"></a>4. 使用Elasticsearch（ES）</h5><p>将非分片键字段的数据同步到Elasticsearch中，利用Elasticsearch强大的搜索和查询能力进行查询。</p><p>适用场景：适用于非结构化数据、全文搜索、复杂查询等场景。</p><p>优点：支持复杂的查询操作，如全文搜索、模糊匹配等；查询性能高，支持分布式部署。</p><p>缺点：需要维护Elasticsearch集群，增加了系统的复杂性；数据同步可能引入一定的延迟。</p><h5 id="5-数据库中间件"><a href="#5-数据库中间件" class="headerlink" title="5. 数据库中间件"></a>5. 数据库中间件</h5><p>使用数据库中间件（如ShardingSphere、MyCAT等）来管理分库分表，中间件可以自动处理非分片键字段的查询，将请求路由到正确的分片。</p><p>适用场景：适用于希望减少应用层复杂性的场景。</p><p>优点：简化了应用层的查询逻辑，减少了开发和维护的工作量。</p><p>缺点：需要配置和维护数据库中间件。</p><h2 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h2><h4 id="Restful风格详解"><a href="#Restful风格详解" class="headerlink" title="Restful风格详解"></a>Restful风格详解</h4><p>RESTful风格是一种基于HTTP协议设计Web API的软件架构风格，它强调使用HTTP动词来表示对资源的操作（GET、POST、PUT、PATCH、DELETE等），并通过URI表示资源的唯一标识符。</p><p><font color=Gold>URL中只使用名词来定位资源，用HTTP协议里的动词（GET、POST、PUT、DELETE）来实现资源的增删改查操作</font>。</p><h5 id="RESTful-API的设计原则"><a href="#RESTful-API的设计原则" class="headerlink" title="RESTful API的设计原则"></a><strong>RESTful API的设计原则</strong></h5><p>RESTful API的设计遵循以下几个原则：</p><ol><li><strong>基于资源：将数据和功能抽象成资源，并通过URI来唯一标识资源</strong>，<strong>URI只应该来表示资源的名称，而不应该包括资源的操作</strong>。例如，一个用户资源可以通过URL“&#x2F;users&#x2F;{id}”来访问，其中“{id}”表示该用户的唯一标识符。</li><li><strong>使用HTTP动词：使用HTTP动词来表示对资源的操作</strong>，如GET（获取资源）、POST（创建资源）、PUT（更新资源）和DELETE（删除资源）等。</li><li><strong>无状态</strong>：客户端自身负责用户状态的维持，并在<strong>每次发送请求时都需要提供足够的信息</strong>，每个请求都包含足够的信息来完成请求，<strong>服务器不需要保存任何上下文信息</strong>。</li><li>统一接口：使用<strong>统一的接口来简化客户端与服务器之间与子系统之间的交互</strong>，包括资源标识符、资源操作和响应消息的格式。</li><li>可缓存性：<strong>客户端可以缓存响应，重用缓存中的响应，以提高性能</strong>和减少网络流量。</li><li>分层系统：将系统分为多个层次，每个层次处理特定的功能，客户端并不会固定地与一个服务器打交道。</li></ol><p>RESTful风格的API设计具有良好的可读性、易用性和可扩展性，广泛应用于Web应用程序和移动应用程序的API设计中。</p><h5 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h5><ul><li>使用URI唯一标识资源，使用http动词来表示对资源的操作，具有很强可读性的，具有自描述性；</li><li>提供无状态的服务接口，服务端不需要保存任何上下文信息，无会话依赖，可提高服务端的扩展性（各服务器之间不需要共享上下文信息）</li><li>客户端缓存响应，可以降低对带宽的占用以及服务器的负载</li></ul><h5 id="使用到的注解"><a href="#使用到的注解" class="headerlink" title="使用到的注解"></a><strong>使用到的注解</strong></h5><p><strong>@RequestMapping</strong></p><ul><li>类型 方法注解</li><li>位置 SpringMVC控制器方法定义上方</li><li>作用 设置当前控制器方法请求访问路径</li><li>范例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;save user&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot; &#x27;&#123;&#x27;module&#x27;: &#x27;user save&#x27; &#125;&#x27; &quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>属性</li></ul><ol><li>value 请求访问路径</li><li>method http请求动作，标准动作（GET、POST、PUT、DELETE）</li></ol><p><strong>@PathVariable</strong></p><ul><li>类型 形参注解</li><li>位置 SpringMVC控制器方法形参定义前面</li><li>作用 绑定路径参数与处理器方法形参间的关系，要求路径参数名与形参名一一对应</li><li>范例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;users/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span></span><br><span class="line"> <span class="meta">@ResponseBody</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> <span class="comment">// PathVariable 路径参数 id对应路径中的id</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;delete user&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#x27;&#123;&#x27;module&#x27;: &#x27;user delete&#x27;&#125;&#x27;&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>@RestControll</strong></p><ul><li>类型 类注解</li><li>位置 基于SpringMVC的RESTful开发控制器类定义上方</li><li>作用 设置当前控制器类为RESTful风格，等同于 @Controller 与 @ResponseBody两个注解的组合功能</li><li>范例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="meta">@RequestMapping(value = &quot;/users&quot;,method = RequestMethod.GET)</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;save user&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot; &#x27;&#123;&#x27;module&#x27;: &#x27;user save&#x27; &#125;&#x27; &quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>@GetMapping @PostMapping @PutMapping @DeleteMapping</strong></p><ul><li>类型 方法注解</li><li>位置 基于SpringMVC的RESTful开发控制器方法定义上方</li><li>作用 设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作</li><li>范例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span> <span class="comment">// 下面的每个控制器方法的请求路径都有前缀 /users</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;getById&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@RequestBody @RequestParam @PathVariable</strong></p><p><strong>区别</strong></p><ul><li>RequestParam 用于接收URL地址传参或表单传参 ?name &#x3D; xqr &amp; age &#x3D; 12</li><li>RequestBody 用于接收JSON数据</li><li>PathVariable 用于接收路径参数，使用 {参数名} 描述路径参数</li></ul><p><strong>应用</strong></p><ul><li><ul><li>后期开发中，发送请求参数超过1个时，以JSON格式为主，所以@RequestBody应用较广泛</li><li>如果发送非JSON格式数据，选用 @RequestParam 接收请求参数</li><li>当参数数量只有一个时，或为数字时，可以采用 @PathVariable接收请求路径变量，通常传递id</li></ul></li></ul><h4 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h4><h5 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h5><p>200 ok（请求成功）<br>204 no content （请求成功，但是没有结果返回）<br>206 partial content （客户端请求一部分资源，服务端成功响应，返回一范围资源）</p><h5 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h5><p>301 move permanently  永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URL，浏览器会自动重定向到新URI。今后任何新的请求都应使用新的URL代替，会自动将请求者转到新URI。<br>302 found  临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI<br>303 see other （查看其他URI，与301类似）<br>304 not modified 客户端在请求一个文件的时候，发现该文件已经在客户端缓存中，会记录该文件的 Last Modified ，那么在请求中会包含 If Modified Since ，这个时间就是缓存文件的 Last Modified 。因此，如果请求中包含 If Modified Since，就说明已经有缓存在客户端。服务端只要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200 ,<font color = gold>本质上是对浏览器缓存的有效性的判断。</font></p><ul><li>对于静态文件，例如：CSS、图片，服务器会自动完成 Last Modified 和 If Modified Since 的比较，完成缓存或者更新。</li><li>但是对于动态页面，就是动态产生的页面，往往没有包含 Last Modified 信息，这样浏览器、网关等都不会做缓存，也就是在每次请求的时候都完成一个 200 的请求。</li><li>因此，对于动态页面做缓存加速，首先要在 Response 的 HTTP Header 中增加 Last Modified 定义，其次根据 Request 中的 If Modified Since 和被请求内容的更新时间来返回 200 或者 304 。虽然在返回 304 的时候已经做了一次数据库查询，但是可以避免接下来更多的数据库查询，<font color = gold>并且没有返回页面内容而返回304（Not Modified）HTTP状态码,告诉浏览器读取本地缓存</font>&gt;，从而大大的降低带宽的消耗，对于用户的感觉也是提高</li></ul><p>307 temporary redirect （临时重定向，和302类似）</p><h5 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h5><p>400 bad request （客户端请求有语法错误，不能被服务器所理解）<br>401 unauthorized （需要认证（第一次返回）或者认证失败（第二次返回））<br>403 forbidden （服务器理解请求客户端的请求，但请求被服务器拒绝了）<br>404 not found （服务器上无法找到请求的资源）</p><h5 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h5><p>500 internal server error （服务端执行请求时发生了错误）<br>503 service unavailable （服务器正在超负载或者停机维护，无法处理请求）</p><h4 id="Get和Post的区别"><a href="#Get和Post的区别" class="headerlink" title="Get和Post的区别"></a>Get和Post的区别</h4><ul><li>语义（主要区别）：GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。</li><li>幂等：GET 符合幂等性和安全性，即多次重复执行不会改变资源的状态，对数据库的一次或多次操作获得的结果是一致的，而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。。安全性是指对数据库操作没有改变数据库中的数据。</li><li>格式：GET 请求的参数通常放在 URL 中，形成查询字符串（querystring），而 POST 请求的参数通常放在请求体（body）中。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的 body 大小则没有明确的限制。</li><li>缓存：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。而 POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。</li><li>安全性：GET 请求和 POST 请求如果使用 HTTP 协议的话，那都不安全，因为 HTTP 协议本身是明文传输的，必须使用 HTTPS 协议来加密传输数据。但是，GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中。</li></ul><h4 id="put与post的区别"><a href="#put与post的区别" class="headerlink" title="put与post的区别"></a>put与post的区别</h4><p>PUT 请求通常用于<strong>更新</strong>或<strong>替换服务器上的资源</strong>。使用 PUT 请求时，客户端需要将整个资源的新版本发送到服务器。如果服务器上已存在该资源，则用客户端提交的新版本替换原有的资源。如果该资源不存在，则会创建一个新的资源。</p><p>PUT 请求的一些特点：</p><ul><li>可以更新整个资源。</li><li>客户端需要发送完整的资源内容。</li><li>如果服务器上不存在该资源，则会创建一个新的资源。</li><li>PUT 请求具有幂等性，即执行多次 PUT 请求的结果应该相同。</li></ul><p>POST 请求通常用于<strong>创建新的资源</strong>或<strong>提交数据到服务器</strong>进行处理。使用 POST 请求时，客户端将数据提交到服务器，服务器根据数据进行处理，并返回响应。通常情况下，<strong>POST 请求会在服务器上创建新的资源，并返回该资源的 URI</strong>。</p><p>POST 请求的一些特点：</p><ul><li>可以创建新的资源或提交数据到服务器进行处理。</li><li>客户端可以只发送部分资源内容。</li><li>如果请求成功，服务器会返回一个表示新资源的 URI。</li><li>POST 请求不具有幂等性。</li></ul><p>PUT 和 POST 的区别主要在以下几个方面：</p><ol><li>语义不同：PUT 请求通常用于<strong>更新或替换服务器上的资源</strong>，而 POST 请求通常用于<strong>创建新的资源或提交数据到服务器进行处理</strong>。</li><li>客户端发送的数据不同：PUT 请求需要<strong>客户端发送完整的资源内容</strong>，而 POST 请求可以只发送部分资源内容。</li><li>响应不同：PUT 请求成功后通常返回 200 OK 状态码，而 POST 请求成功后通常返回 201 Created 状态码，并返回表示新资源的 URI。</li><li>幂等性&#x2F;安全性不同：PUT 请求具<strong>有幂等性</strong>，即执行多次 PUT 请求的结果应该相同，而 POST 请求不具有幂等性，PUT请求不会导致状态的改变，是安全的。</li><li>可缓存性不同：PUT 请求是可缓存的，客户端可以使用缓存的响应来更新资源。而 POST 请求不是可缓存的，客户端不能使用缓存的响应来更新资源。</li></ol><h4 id="转发与重定向的区别"><a href="#转发与重定向的区别" class="headerlink" title="转发与重定向的区别"></a>转发与重定向的区别</h4><h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p><strong>定义</strong>：<br>重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向）。</p><p><strong>由浏览器端进行的页面跳转。</strong></p><p><strong>举例说明</strong>：<br>假设你现在所处的位置是一个论坛的登录页面，你填写了帐号，密码，点击登陆，如果你的帐号密码正确，就自动跳转到论坛的首页，不正确就返回登录页；</p><p>这里的自动跳转，就是重定向的意思。或者可以说，重定向就是，在网页上设置一个约束条件，条件满足，就自动转入到其它网页、网址。</p><p><strong>网页定向</strong><br>我们在网站建设中，时常会遇到需要网页重定向的情况：</p><p>1.网站调整（如改变网页目录结构）；<br>2.网页被移到一个新地址；<br>3.网页扩展名改变(如应用需要把.php改成.Html或.shtml)。</p><p>这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。</p><p><strong>重定向的原理图</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1ODk5MDEz,size_16,color_FFFFFF,t_70.png" alt="img"></p><p><strong>重定向的特点</strong></p><ul><li>地址栏：显示新的地址</li><li>请求次数：2次</li><li>请求域中的数据会丢失，因为是2次请求</li></ul><h5 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h5><p><strong>定义</strong>：<br>由服务器端进行的页面跳转。<br>请求转发：一种在服务器内部的资源跳转方式。</p><p>访问A，A请求转发了B，访问A的同时就也访问到了B。<br>带参数跳到指定的页面，比如request。<br>访问A，进入A的网址，然后在A里面请求转发B，就是带着A的请求到了B。</p><p><strong>特点</strong>：</p><ul><li>浏览器地址栏路径不发生变化。</li><li>只能转发到当前服务器内部资源中。</li><li>转发是一次请求。</li><li>请求域中数据不会丢失。</li></ul><p><strong>转发的原理图</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1ODk5MDEz,size_16,color_FFFFFF,t_70-1712294921842-3.png" alt="img"></p><h5 id="什么时候使用转发，什么时候使用重定向？"><a href="#什么时候使用转发，什么时候使用重定向？" class="headerlink" title="什么时候使用转发，什么时候使用重定向？"></a>什么时候使用转发，什么时候使用重定向？</h5><p>如果要保留请求域中的数据，使用转发，否则使用重定向。<br>以后访问数据库，增删改使用重定向，查询使用转发。</p><p>问：转发或重定向后续的代码是否还会运行？</p><p>无论转发或重定向后续的代码都会执行。</p><h5 id="总结：重定向和转发的区别"><a href="#总结：重定向和转发的区别" class="headerlink" title="总结：重定向和转发的区别"></a><strong>总结：重定向和转发的区别</strong></h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ1ODk5MDEz,size_16,color_FFFFFF,t_70-1712294952252-6.png" alt="img"></p><h4 id="过滤器和拦截器的区别和使用场景"><a href="#过滤器和拦截器的区别和使用场景" class="headerlink" title="过滤器和拦截器的区别和使用场景"></a>过滤器和拦截器的区别和使用场景</h4><p><a href="https://zhuanlan.zhihu.com/p/408809649">Java中的拦截器和过滤器有什么区别 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/weixin_44502804/article/details/93139550">拦截器与过滤器的区别_过滤器和拦截器-CSDN博客</a></p><p><strong>使用范围不同</strong></p><p>过滤器Filter实现了<em>javax.servlet.Filter</em>接口，也就是说过滤器的使用要依赖于Tomcat等容器，所以它只能在web程序中使用。</p><p>拦截器是由Spring容器进行管理，并不依赖Tomcat等容器，既可以应用在web程序中，也可以应用在非web程序中。</p><p><strong>触发时机不同</strong></p><p>过滤器Filter是在请求进入Tomcat等容器后，servlet处理之前进行调用的。</p><p>拦截器Interceptor是在请求进入servlet后，执行Controller之前、之后、结束后进行调用的。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-442f488eba9822bbc852291b27e58d17_1440w.webp" alt="img"></p><p><strong>拦截范围不同</strong></p><p>过滤器Filter几乎可以拦截所有进入容器的请求。</p><p>拦截器Interceptor只会对Controller请求或访问static目录下的静态资源请求起作用。</p><p><strong>初始化时机不同</strong></p><p>过滤器Filter是随着Tomcat等web容器启动时而进行初始化。</p><p>拦截器Interceptor时随着spring启动而进行初始化。</p><p><strong>实现原理不同</strong></p><ul><li><p><strong>Filter是基于函数回调实现的</strong></p></li><li><p><strong>Interceptor是基于反射实现的，在执行方法前后添加逻辑</strong></p></li></ul><h4 id="Nginx怎么做的反向代理"><a href="#Nginx怎么做的反向代理" class="headerlink" title="Nginx怎么做的反向代理"></a>Nginx怎么做的反向代理</h4><h5 id="为什么使用Nginx"><a href="#为什么使用Nginx" class="headerlink" title="为什么使用Nginx"></a>为什么使用Nginx</h5><p>首先，我们知道，为了系统的高可用，我们的系统一般会部署多个实例，即如下图所示，项目部署于多个服务器上。</p><p>但是，这样是存在问题的，我们应该要对用户屏蔽掉这一信息。因为我们是不可能安排好每个用户在特定时刻去访问特定的服务器。这明显是行不通的，首先，用户无法记住这么多的服务器地址，其次，系统管理者难以管理运营。</p><blockquote><p>以百度为例，百度的后台肯定是不止一台服务器的，但我们在访问百度的时候，只需要输入百度的地址，就会被分配到一个服务器上去，以获得服务。</p><p>而我们访问的是哪个服务器我们并不知道，我们只管访问<a href="http://www.baidu.com,后面的事都会有相应的机制帮我们实现./">www.baidu.com，后面的事都会有相应的机制帮我们实现。</a></p></blockquote><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzEyMDQ5,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>要实现此类效果，即无论应用有多少实例，我们只需要访问一个地址就可以得到服务。就需要在客户端与服务端之间加上一层服务器。<br>客户端只管访问这一中介服务器（中介服务器的地址是确定的），再由中介服务器将请求代理到真正部署有实例的服务器上去即可。</p><h5 id="正向代理与反向代理的区别"><a href="#正向代理与反向代理的区别" class="headerlink" title="正向代理与反向代理的区别"></a>正向代理与反向代理的区别</h5><p><strong>正向代理</strong><br><strong>正向代理就是代理客户端，客户是可以感受到它的存在的。</strong></p><ul><li>正向代理就是我们在没有权限访问某些服务器或者速率很慢时，通过代理服务器代表我们去访问，而代理服务器常常是有能力、有权限达到目的的。</li></ul><ol><li>我们在校外、公司外，是访问不到学校、公司的内网的，但是我们想要访问内网资源时，会用到VPN。而一般内网会存在一个VPN服务器，我们使用VPN其实就是让内网的VPN服务器代替我们去进行访问（VPN服务器位于内网是可以访问内网资源的）。这其实就是一种正向代理，通过内网VPN服务器代理客户端进行请求。</li><li>我们在玩一些服务器部署在国外的游戏时（如：吃鸡），延迟会很长，此时，我们会“翻墙”，以此来提升速率。其实，这种方式与上一例是一样的逻辑。同样是让延迟低的服务器代理我们去访问，以提升速率。</li></ol><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzEyMDQ5,size_16,color_FFFFFF,t_70-1712297580508-11.png" alt="在这里插入图片描述"></p><p><strong>反向代理</strong><br><strong>反向代理就是代理服务端，是客户感受不到的。</strong></p><p>而反向代理的应用场景则就是对上述的多实例的情况的处理。使用一台代理服务器（下图中的深色服务器）对底层的应用服务器（下图中的浅色服务器）进行代理。将他们的地址信息对客户端屏蔽，客户端只需要访问代理服务器即可，代理服务器会将请求转发给底层的真正起作用的应用服务器。但在客户端眼里，服务器只有唯一的一台，就是代理服务器。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzEyMDQ5,size_16,color_FFFFFF,t_70-1712297665674-14.png" alt="在这里插入图片描述"></p><p><strong>Nginx的配置使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">#应用服务器的信息，其中包括了应用服务器的地址</span><br><span class="line">#而max_fails: Nginx与服务器通信的尝试失败的次数。在fail_timeout参数定义的时间段内，如果失败的次数达到此值，Nginx就认为服务器不可用。在下一个fail_timeout时间段，服务器不会再被尝试使用。等待下一个周期（同样时常为fail_timeout）再一次去请求，判断是否连接是否成功。</span><br><span class="line">#weight值表示权重，权重越大，被分配到请求的可能性也越大。</span><br><span class="line">upstream myserver &#123;</span><br><span class="line">    server 192.168.240.110:8080 max_fails=3 fail_timeout=30s weight=1;</span><br><span class="line">    server 192.168.240.111:8080 max_fails=3 fail_timeout=30s weight=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#对代理服务器进行配置。listen是其监听的端口号，而HTTP的默认端口号就是80，所以，当监听端口号为80的时候，就不需要在请求路径中加上端口号。</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    #代理服务器的地址</span><br><span class="line">    server_name 192.168.240.240;</span><br><span class="line">    #受请求的路径（“/”则表示根路径）,proxy_pass表示将请求代理到后面的“http://myserver”代表的路径</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://myserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Nginx有什么作用"><a href="#Nginx有什么作用" class="headerlink" title="Nginx有什么作用"></a>Nginx有什么作用</h5><p><strong>反向代理</strong><br>即本文所讲述的功能，Nginx可以作为应用服务器的代理服务器。<br><strong>负载均衡</strong><br>实则在上述的配置文件中也有所体现，即所配置的权重，权重会影响请求被分发到该服务器的概率，权重越大，被分发请求的概率越大。<br><strong>HTTP服务器（动静分离）</strong><br>我们的项目中是存在很多静态资源的，它们不会因项目运行而发送变化，所以可以缓存在Nginx本地，加快访问速度。<br>其实还有例如：虚拟主机等功能。但上述功能是最为常用的功能，所以仅对上述功能进行简单阐述。</p><h4 id="什么是-Cookie，Cookie-的使用过程是怎么样的？"><a href="#什么是-Cookie，Cookie-的使用过程是怎么样的？" class="headerlink" title="什么是 Cookie，Cookie 的使用过程是怎么样的？"></a>什么是 Cookie，Cookie 的使用过程是怎么样的？</h4><p>由于 Http 协议是无状态协议，如果客户通过浏览器访问 web 应用时没有一个保存用户访问状态的机制，那么将不能持续跟踪应用的操作。比如当用户往购物车中添加了商品，web 应用必须在用户浏览别的商品的时候仍保存购物车的状态，以便用户继续往购物车中添加商品，服务器可以把某一些状态数据以 key-value 的方式写入到 Cookie 里面</p><p>cookie 是浏览器的一种缓存机制，它可用于维持客户端与服务器端之间的会话。由于下面一题会讲到 session，所以这里要强调 cookie 会将会话保存在客户端（ session 则是把会话保存在服务端）</p><p>这里以最常见的登陆案例讲解cookie的使用过程：</p><ol><li>首先用户在客户端浏览器向服务器发起登陆请求</li><li>登陆成功后，服务端会把登陆的用户信息设置 cookie 中，返回给客户端浏览器</li><li>客户端浏览器接收到 cookie 请求后，会把 cookie 保存到本地（可能是内存，也可能是磁盘，看具体使用情况而定）</li><li>以后再次访问该 web 应用时，客户端浏览器就会把本地的 cookie 带上，这样服务端就能根据 cookie 获得用户信息了</li></ol><h4 id="什么是-session，有哪些实现-session-的机制？"><a href="#什么是-session，有哪些实现-session-的机制？" class="headerlink" title="什么是 session，有哪些实现 session 的机制？"></a>什么是 session，有哪些实现 session 的机制？</h4><p>session 是一种维持客户端与服务器端会话的机制。但是与 cookie 把会话信息保存在客户端本地不一样，session 把会话保留在服务器端。</p><p>我们同样以登陆案例为例子讲解 session 的使用过程：</p><ol><li>首先用户在客户端浏览器发起登陆请求</li><li>登陆成功后，服务端会把用户信息保存在服务端，并返回一个唯一的 session 标识(sessionId)给客户端浏览器。</li><li>客户端浏览器会把这个唯一的 session 标识保存在起来</li><li>以后再次访问 web 应用时，客户端浏览器会把这个唯一的 session 标识带上，这样服务端就能根据这个唯一标识找到用户信息。</li></ol><p>看到这里可能会引起疑问：把唯一的 session 标识返回给客户端浏览器，然后保存起来，以后访问时带上，这难道不是 cookie 吗？</p><p>没错，session 只是一种会话机制，在许多 web 应用中，session 机制就是通过 cookie 来实现的。也就是说它只是使用了 cookie 的功能，并不是使用 cookie 完成会话保存。与 cookie 在保存客户端保存会话的机制相反，session 通过 cookie 的功能把会话信息保存到了服务端。</p><p>进一步地说，session 是一种维持服务端与客户端之间会话的机制，它可以有不同的实现。以现在比较流行的小程序为例，阐述一个 session 的实现方案：</p><ol><li>首先用户登陆后，需要把用户登陆信息保存在服务端，这里我们可以采用 redis。比如说给用户生成一个 userToken，然后以 userId 作为键，以 userToken 作为值保存到 redis 中，并在返回时把 userToken 带回给小程序端。</li><li>小程序端接收到 userToken 后把它缓存起来，以后每当访问后端服务时就把 userToken 带上。</li><li>在后续的服务中服务端只要拿着小程序端带来的 userToken 和 redis 中的 userToken 进行比对，就能确定用户的登陆状态了。</li></ol><h4 id="session-和-cookie-有什么区别"><a href="#session-和-cookie-有什么区别" class="headerlink" title="session 和 cookie 有什么区别"></a>session 和 cookie 有什么区别</h4><p>经过上面两道题的阐述，这道题就很清晰了</p><ol><li>cookie 是浏览器提供的一种缓存机制，它可以用于维持客户端与服务端之间的会话</li><li>session 指的是维持客户端与服务端会话的一种机制，它可以通过 cookie 实现，也可以通过别的手段实现。</li><li>如果用 cookie 实现会话，那么会话会保存在客户端浏览器中</li><li>而 session 机制提供的会话是保存在服务端的。</li></ol><h4 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a>cookie与session</h4><h5 id="Cookie：客户端浏览器用来保存服务端数据的一种机制。"><a href="#Cookie：客户端浏览器用来保存服务端数据的一种机制。" class="headerlink" title="Cookie：客户端浏览器用来保存服务端数据的一种机制。"></a>Cookie：客户端浏览器用来保存服务端数据的一种机制。</h5><p>当通过浏览器进行网页访问的时候，服务器可以把某一些状态数据以 key-value 的方式写入到 Cookie 里面存储到客户端浏览器。<br>然后客户端下一次再访问服务器的时候，就可以携带这些状态数据发送到服务器端，服务端可以根据 Cookie 里面携带的内容来识别使用者。</p><h5 id="Session-表示一个会话，它是属于服务器端的容器对象"><a href="#Session-表示一个会话，它是属于服务器端的容器对象" class="headerlink" title="Session 表示一个会话，它是属于服务器端的容器对象"></a>Session 表示一个会话，它是属于服务器端的容器对象</h5><p>默认情况下，针对每一个浏览器的请求。Servlet 容器都会分配一个 Session。<br>Session 本质上是一个 ConcurrentHashMap，可以存储当前会话产生的一些状态数据。<br>我们都知道，Http 协议本身是一个无状态协议，也就是服务器并不知道客户端发送过来的多次请求是属于同一个用户。<br>所以 Session 是用来弥补 Http 无状态的不足，简单来说，服务器端可以利用 session来存储客户端在同一个会话里面的多次请求记录。<br>基于服务端的 session 存储机制，再结合客户端的 Cookie 机制，就可以实现有状态的Http 协议。</p><p>具体的工作原理是：<br>客户端第一次访问服务端的时候，服务端会针对这次请求创建一个会话，并生成一个唯一的 sessionId 来标注这个会话。<br>然后服务端把这个 sessionid 写入到客户端浏览器的 cookie 里面，用来实现客户端状态的保存。<br>在后续的请求里面，每次都会携带 sessionid，服务器端就可以根据这个 sessionid 来识别当前的会话状态。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112158828.png" alt="image-20231003112158828"></p><p>所以，总的来看，Cookie 是客户端的存储机制，Session 是服务端的存储机制。<br>这两者结合使用，来实现会话状态的存储，以上就是我对这个问题的理解！</p><h4 id="如何实现Session共享？"><a href="#如何实现Session共享？" class="headerlink" title="如何实现Session共享？"></a>如何实现Session共享？</h4><h5 id="1-Nginx的-IP-Hash-策略（可以使⽤）"><a href="#1-Nginx的-IP-Hash-策略（可以使⽤）" class="headerlink" title="1.Nginx的 IP_Hash 策略（可以使⽤）"></a>1.<a href="https://so.csdn.net/so/search?q=Nginx&spm=1001.2101.3001.7020">Nginx</a>的 IP_Hash 策略（可以使⽤）</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDMzNTE0MA==,size_16,color_FFFFFF,t_70-1712932814095-6.png" alt="在这里插入图片描述"></p><p>同⼀个客户端IP的请求都会被路由到同⼀个⽬标服务器，也叫做会话粘滞<br><strong>优点：</strong></p><ul><li>配置简单，不⼊侵应⽤，不需要额外修改代码<br><strong>缺点：</strong></li><li>服务器重启Session丢失</li><li>存在单点负载⾼的⻛险</li><li>单点故障问题</li></ul><h5 id="2session集中存储，把Session数据存放到Redis-MySQL中"><a href="#2session集中存储，把Session数据存放到Redis-MySQL中" class="headerlink" title="2session集中存储，把Session数据存放到Redis&#x2F;MySQL中"></a>2session集中存储，把Session数据存放到Redis&#x2F;MySQL中</h5><p>key-value : SessionId 和 session</p><p>优点:</p><ul><li><p>能适应各种负载均衡策略</p></li><li><p>服务器重启或者宕机不会造成Session丢失</p></li><li><p>扩展能⼒强</p></li><li><p>适合⼤集群数量使⽤</p></li></ul><p>缺点：</p><ul><li>对应⽤有⼊侵，引⼊了和Redis的交互代码</li></ul><h5 id="基于JWT（JSON-Web-Token）实现Session共享"><a href="#基于JWT（JSON-Web-Token）实现Session共享" class="headerlink" title="基于JWT（JSON Web Token）实现Session共享"></a>基于JWT（<strong>JSON Web Token</strong>）实现Session共享</h5><p><a href="https://zhuanlan.zhihu.com/p/73168768">JWT实现分布式Session？行不？ - 知乎 (zhihu.com)</a></p><p><strong>JWT特点</strong></p><p>1、数据是JSON格式<br>2、用于Web应用<br>3、是一个Token，也就是一个令牌方式</p><p><strong>JWT数据结构</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Header</span><span class="selector-class">.Payload</span><span class="selector-class">.Signature</span></span><br></pre></td></tr></table></figure><p>一个JWT案例</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-963a8e91710c9d530bdc5eac2dd69c49_720w.webp" alt="img"></p><ul><li><strong>Header</strong></li></ul><p>这个是<strong>JWT第一段数据，表示头部信息</strong>，主要的作用是<strong>描述JWT的元数据</strong>，上面的案例就是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> alg: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line"> typ: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1、alg属性表示<strong>签名的算法，默认算法为HS256</strong>，可以自行别的算法。<br>2、typ属性表示这个<strong>令牌的类型</strong>，JWT令牌就为JWT。</p></blockquote><p>上面的JSON数据会通过<strong>Base64算法</strong>进行编码而成，看工具图</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-eccc254faabc5767b9e3fbfedf392272_720w.webp" alt="img"></p><ul><li><strong>Payload</strong></li></ul><p>此为JWT第二段数据，用来存放实际需要传递的数据。JWT官方也规定了7个字段供选用</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-5a380c6d2fbc0bef7252b1e5e1788187_720w.webp" alt="img"></p><p>当然除了官方字段，我们<strong>可以自定义字段</strong>，以上面的案例，我们看下实际的数据</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-b8302b952ef42946b54f25c6a08c7093_720w.webp" alt="img"></p><blockquote><p>注意：这段也是用Base64算法，<strong>JWT默认是不加密的</strong>，任何人都可以获取，只要进行<strong>Base64解码</strong>就行了，所以<strong>不要把隐密的信息放到JWT中</strong></p></blockquote><p><strong>Signature</strong></p><p>此为JWT第三段数据，<strong>主要作用是对前面两段的数据进行签名，防止数据篡改</strong>。一般我们进行签名的时候会<strong>有个密钥（secret）</strong>，<strong>只有服务器知道</strong>，然后<strong>利用Header中的签名算法</strong>进行签名，公式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> + base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>算出签名后，<strong>把Header、Payload、Signature三个部分拼成一个字符串</strong>，之间用（.）分隔，这样就可以把组合而成的字符串返回给用户了。</p><p><strong>JWT的工作方式</strong></p><p>在用户进行认证登录时，<strong>登录成功后服务器会返回一个JWT给客户端</strong>；那这个JWT就是用户的凭证，以后<strong>到哪里去都要带上这个凭证token</strong>。尤其访问受保护的资源的时候，通常把JWT<strong>放在Authorization header中</strong>。要用 Bearer schema，如header请求头中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer <span class="tag">&lt;<span class="name">token</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-0d0eca0fd2bf677f4e1c2984426d9dc1_720w.webp" alt="img"></p><p><strong>基于JWT的身份认证</strong></p><p>上面的JWT的工作方式，其实就是一个<strong>完整的身份认证流程</strong>，我们这里把这个讲的在通俗一点。</p><blockquote><p>1、用户提供用户名和密码登录<br>2、服务器校验用户是否正确，如正确，<strong>就返回token给客户端，此token可以包含用户信息</strong><br>3、客户端存储token，可以<strong>保存在cookie或者local storage</strong><br>4、客户端以后请求时，都要<strong>带上这个token，一般放在请求头中</strong><br>5、服务器判断是否存在token，并且解码后就可以<strong>知道是哪个用户</strong><br>6、服务器这样就可以<strong>返回该用户的相关信息</strong>了</p></blockquote><p>这个流程小伙伴们有没有发现，<strong>用户信息是放在JWT中的</strong>，<strong>是存放在客户端（cookie，local storage）</strong>中的，服务器<strong>只需解码验证就行了，就可以知道获取到用户信息</strong>。</p><p><strong>好处</strong></p><blockquote><p>1、因为token存储在客户端，服务器只负责解码。这样<strong>不需要占用服务器端资源</strong>。<br>2、服务器端可以<strong>无限扩展</strong>，负载均衡器可以将<strong>用户传递到任何服务器</strong>，服务器都能知道用户信息，因为jwt里面包含了。<br>3、<strong>数据安全，因为有签名</strong>，防止了篡改，但信息还是透明的，不要放敏感信息。<br>4、放入请求头提交，很好的<strong>防止了csrf攻击</strong>，</p></blockquote><p><strong>坏处</strong></p><ul><li><strong>token失效问题：JWT方式最大的坏处就是</strong>无法主动让token失效<strong>，小伙伴们会说token不是有过期时间吗？是的，token本身是有过期时间，但</strong>token一旦发出，服务器就无法收回</li></ul><blockquote><p>如：一个jwt的token的失效时间是3天，但我们<strong>发现这个token有异常</strong>，有可能被人登录，那真实的用户可以修改密码。但是即使修改了密码，<strong>那个异常的token还是合法的</strong>，因为3天的失效时间未到，我们<strong>服务器是没法主动让异常token失效</strong>。</p></blockquote><ul><li><strong>数据延时，不一致问题</strong>：还有个问题就是因为jwt中<strong>包含了用户的部分信息</strong>，如果这些<strong>部分信息修改了</strong>，服务器获取的还是<strong>以前的jwt中的用户信息</strong>，导致数据不一致。</li><li><strong>认证安全问题</strong>：JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议加密传输。</li></ul><p><strong>JWT的简单Java代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWT</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SECRET</span> <span class="operator">=</span> <span class="string">&quot;usdfsdJSDG&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SUBJECT</span> <span class="operator">=</span> <span class="string">&quot;TOM&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EFFECT_TIME</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ISSUER</span> <span class="operator">=</span> <span class="string">&quot;Selina&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ISSUE_TIME</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateJsonWebToken</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">            <span class="comment">//主题</span></span><br><span class="line">            .setSubject(SUBJECT)</span><br><span class="line">            <span class="comment">//id</span></span><br><span class="line">                .setId(ID)</span><br><span class="line">            <span class="comment">//签发人</span></span><br><span class="line">                .setIssuer(ISSUER)</span><br><span class="line">            <span class="comment">//过期时间</span></span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(EXPIRE_TIME + System.currentTimeMillis()))</span><br><span class="line">            <span class="comment">//生效时间</span></span><br><span class="line">                .setNotBefore(<span class="keyword">new</span> <span class="title class_">Date</span>(EFFECT_TIME + System.currentTimeMillis()))</span><br><span class="line">            <span class="comment">//签发时间</span></span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>(ISSUE_TIME + System.currentTimeMillis()))</span><br><span class="line">            <span class="comment">//负载内容</span></span><br><span class="line">                .claim(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;tom&quot;</span>)</span><br><span class="line">                .claim(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line">                .claim(<span class="string">&quot;userId&quot;</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="comment">//生成签名的方法和secret</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, SECRET)</span><br><span class="line">                .compact();</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">getClaimsFromToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser().setSigningKey(SECRET).parseClaimsJws(token).getBody();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> generateJsonWebToken();</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> getClaimsFromToken(token);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">userId</span> <span class="operator">=</span> claims.get(<span class="string">&quot;userId&quot;</span>, Integer.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> claims.get(<span class="string">&quot;username&quot;</span>, String.class);</span><br><span class="line">        System.out.println(userId + <span class="string">&quot;,&quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="session复制（需要存储大量冗余数据，一般不采用这种方案）"><a href="#session复制（需要存储大量冗余数据，一般不采用这种方案）" class="headerlink" title="session复制（需要存储大量冗余数据，一般不采用这种方案）"></a>session复制（需要存储大量冗余数据，一般不采用这种方案）</h5><p>服务器将自己的session数据传送给其他服务器，使得每个服务器都拥有全量的数据。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDMzNTE0MA==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>优点：tomcat原生支持，只需要修改配置文件即可<br>缺点：</p><ol><li><p>session同步需要数据传输，会占用大量带宽，降低服务器集群的业务处理能力</p></li><li><p>任意一台web-server保存的都是所有web-server的session总和，浪费了大量的空间，且受内存限制无法水平扩展更多的web-server</p></li><li><p>大型分布式集群情况下，由于所有web-server都要全量保存数据，所以此方案不可取。</p></li></ol><h5 id="客户端存储（一般情况下不会使用这种方案）"><a href="#客户端存储（一般情况下不会使用这种方案）" class="headerlink" title="客户端存储（一般情况下不会使用这种方案）"></a><strong>客户端存储</strong>（一般情况下不会使用这种方案）</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDMzNTE0MA==,size_16,color_FFFFFF,t_70-1712932747791-3.png" alt="在这里插入图片描述"></p><p>用户的信息不再保存在服务器中，而是保存在客户端(浏览器)中。</p><p>优点：服务器不需要保存用户信息，节省服务器资源<br>缺点：</p><ul><li><p>每次http请求，携带用户在cookie中的完整信息，浪费网络带宽</p></li><li><p>用户信息存放在cookie中，cookie有长度4k限制，不能存放大量信息</p></li><li><p>用户信息存储在cookie中，存在泄漏、篡改、窃取等安全隐患</p></li></ul><h2 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h2><h3 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h3><h4 id="Spring与Servlet的区别与联系"><a href="#Spring与Servlet的区别与联系" class="headerlink" title="Spring与Servlet的区别与联系"></a>Spring与Servlet的区别与联系</h4><ol><li><strong>Servlet</strong>：<ul><li>Servlet是Java中的一种规范，用于处理Web请求和响应。</li><li>Servlet是基于Java的服务器端技术，通过Java类来处理HTTP请求，并生成响应。</li></ul></li></ol><p><strong>联系</strong>：</p><ol><li><strong>Spring与Servlet的联系</strong>：<ul><li>Spring框架的Web模块通常是建立在Servlet技术之上的。例如，Spring MVC就是一个基于Servlet的Web框架，它使用Servlet来处理HTTP请求和响应。</li><li>Spring框架可以在Servlet的基础上提供更高级的功能，比如依赖注入、AOP等，使得开发更加方便和灵活。</li></ul></li><li><strong>Spring和Servlet的合作</strong>：<ul><li>在典型的Spring Web应用程序中，Servlet通常用于处理HTTP请求和响应的底层细节，而Spring框架提供了高级的控制器、服务、拦截器等组件来实现业务逻辑。</li></ul></li></ol><p>总的来说，Spring和Servlet都是用于构建Java Web应用程序的技术，Spring提供了更高级的功能和更好的抽象，而Servlet则是底层的HTTP处理机制，两者常常结合使用来实现复杂的Web应用程序。</p><h4 id="BeanFactory和-FactoryBean-的区别"><a href="#BeanFactory和-FactoryBean-的区别" class="headerlink" title="BeanFactory和 FactoryBean 的区别"></a>BeanFactory和 FactoryBean 的区别</h4><p>BeanFactory：<strong>Spring IoC容器的顶级对象</strong>，BeanFactory被翻译为“Bean⼯⼚”，在Spring的IoC容器中，“Bean⼯⼚”<strong>负责创建Bean对象</strong>。BeanFactory是⼯⼚。</p><p>FactoryBean：它是⼀个Bean，是⼀个能够<strong>辅助Spring实例化其它Bean对象</strong>的⼀个<strong>工厂Bean</strong>。<br>在Spring中，Bean可以分为两类：</p><ul><li>第⼀类：普通Bean</li><li>第⼆类：⼯⼚Bean（记住：⼯⼚Bean也是⼀种Bean，只不过这种Bean⽐较特殊，它可以辅助Spring实例化其它Bean对象。）</li></ul><h4 id="Bean-的作用域有哪些"><a href="#Bean-的作用域有哪些" class="headerlink" title="Bean 的作用域有哪些?"></a>Bean 的作用域有哪些?</h4><ul><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><h4 id="Bean-是线程安全的吗？"><a href="#Bean-是线程安全的吗？" class="headerlink" title="Bean 是线程安全的吗？"></a>Bean 是线程安全的吗？</h4><p>Spring 框架中的 Bean 是否线程安全，取决于其作用域和状态。</p><ul><li><p>prototype 作用域下，每次获取都会创建一个新的 bean 实例，不存在资源竞争问题，所以不存在线程安全问题。</p></li><li><p>singleton 作用域下，IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题（取决于 Bean 是否有状态）。如果这个 bean 是有状态的话，那就存在线程安全问题（有状态 Bean 是指包含可变的成员变量的对象，有数据存储的功能）。如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行<strong>「查询」</strong>以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身，这种情况下， Bean 是线程安全的。</p></li></ul><p>对于有状态单例 Bean 的线程安全问题，解决办法：</p><ol><li>最简单的办法就是改变bean的作用域 把  <code>singleton</code> 改为 <code>protopyte</code>， 这样每次请求Bean就相当于是 new Bean() 这样就可以保证线程的安全了。</li><li>在 Bean 中尽量避免定义可变的成员变量。</li><li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）</li></ol><h4 id="bean生命周期（只针对单例的bean，如果是多例，只负责到第九步）"><a href="#bean生命周期（只针对单例的bean，如果是多例，只负责到第九步）" class="headerlink" title="bean生命周期（只针对单例的bean，如果是多例，只负责到第九步）"></a>bean生命周期（只针对单例的bean，如果是多例，只负责到第九步）</h4><ol><li><p><strong>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</strong></p></li><li><p><strong>Bean实例化后对将Bean的引入和值注入到Bean的属性中</strong></p></li><li><p><strong>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</strong></p></li><li><p><strong>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</strong></p></li><li><p><strong>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来</strong></p></li><li><p><strong>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</strong></p></li><li><p><strong>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</strong></p></li><li><p><strong>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</strong></p></li><li><p><strong>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</strong></p></li><li><p><strong>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</strong></p></li></ol><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-8787f1b3800b71f6234e996d432e0a0c_1440w.webp" alt="img"></p><h4 id="Resource-和-Autowired注解的区别"><a href="#Resource-和-Autowired注解的区别" class="headerlink" title="@Resource 和 @Autowired注解的区别"></a>@Resource 和 @Autowired注解的区别</h4><h5 id="来源："><a href="#来源：" class="headerlink" title="来源："></a>来源：</h5><ul><li><p>@Resource注解是JDK扩展包中的，也就是说属于JDK的⼀部分。所以该注解是标准注解，更加具有通⽤性。</p></li><li><p>@Autowired注解是Spring框架⾃⼰的。</p></li></ul><h5 id="装配步骤："><a href="#装配步骤：" class="headerlink" title="装配步骤："></a>装配步骤：</h5><ul><li><em><strong>@Resource注解默认根据名称装配byName，未指定name时，使⽤属性名作为name。通过name</strong></em><em>找不到的话会⾃动启动通过类型byType装配。</em>**</li><li><em><strong>@Autowired注解默认根据类型装配byType，如果想根据名称装配，需要配合@Qualifier注解⼀起⽤。</strong></em></li></ul><h5 id="使用位置："><a href="#使用位置：" class="headerlink" title="使用位置："></a>使用位置：</h5><ul><li>@Resource注解⽤在属性上、setter⽅法上。</li><li>@Autowired注解⽤在属性上、setter⽅法上、构造⽅法上、构造⽅法参数上</li></ul><h4 id="spring如何解决循环依赖问题"><a href="#spring如何解决循环依赖问题" class="headerlink" title="spring如何解决循环依赖问题"></a>spring如何解决循环依赖问题</h4><p><a href="https://juejin.cn/post/7218080360403615804">浅谈 Spring 如何解决 Bean 的循环依赖问题 - 掘金 (juejin.cn)</a></p><p>Spring为什么可以解决<strong>set + singleton</strong>模式下循环依赖？<br><strong>根本的原因在于：这种⽅式可以做到将“实例化Bean”和“给Bean属性赋值”这两个动作分开去完成</strong>。<br>实例化Bean的时候：调⽤⽆参数构造⽅法来完成。此时可以先不给属性赋值，可以<strong>提前</strong>将该<strong>Bean对象“曝光</strong>”给外界。<br>给Bean属性赋值的时候：调⽤set⽅法来完成。<br>两个步骤是完全可以分离开去完成的，并且这两步不要求在同⼀个时间点上完成。<br>也就是说，Bean都是单例的，我们可以<strong>先把所有的单例Bean实例化</strong>出来，放到⼀个集合当中（我们可以称之为缓存），所有的单例Bean全部实例化完成之后，以后我们<strong>再慢慢的调⽤setter⽅法给属性赋值</strong>，这样就解决了循环依赖的问题。</p><p>原理是spring的三级缓存</p><p>三级缓存分为：</p><ul><li>一级缓存（<code>singletonObjects</code>）：缓存的是<strong>已经实例化、属性注入、初始化后</strong>的 Bean 对象，key存储bean名称，<br>value存储Bean对象。</li><li>二级缓存（<code>earlySingletonObjects</code>）：缓存的是<strong>实例化后，但未属性注入、初始化</strong>的 Bean对象（用于提前暴露 Bean），key存储bean名称，value存储早期的Bean对象。</li><li>三级缓存（<code>singletonFactories</code>）：缓存的是一个 <code>ObjectFactory</code>对象，主要作用是生成原始对象进行 AOP 操作后的<strong>代理对象</strong>，key存储bean名称，value存储该Bean对应的ObjectFactory对象。</li></ul><p>这三个缓存其实本质上是三个Map集合，spring会先从⼀级缓存中获取Bean，如果获取不到，则从⼆级缓存中获取Bean，如果⼆级缓存还是获取不到，则从三级缓存中获取之前曝光的ObjectFactory对象，通过ObjectFactory对象获取Bean实例，这样就解决了循环依赖的问题。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-d78848d4c07fd077da0c896087e90885_r.jpg" alt="img"></p><ol><li>对象A要创建到Spring容器中，从一级缓存singletonObject获取A，不存在，开始实例化A，最终在三级缓存singletonObjectFactory添加(A，A的函数式接口创建方法)，这时候A有了自己的内存地址</li><li>设置属性B，B也从一级缓存singletonObject获取B，不存在，开始实例化B，最终在三级缓存singletonObjectFactory添加(B，B的函数式接口创建方法)，这时候B有了自己的内存地址</li><li>B中开始给属性A赋值，此时会找到三级缓存中的A，并将A放入二级缓存中。删除三级缓存</li><li>B初始化完成，从三级缓存singletonObjectFactory直接put到一级缓存singletonObject，并删除二级和三级缓存的自己</li><li>A成功得到B，A完成初始化动作，从二级缓存中移入一级缓存，并删除二级和三级缓存的自己</li><li>最终A和B都进入一级缓存中待用户使用</li></ol><h4 id="只使用二级缓存能解决吗"><a href="#只使用二级缓存能解决吗" class="headerlink" title="只使用二级缓存能解决吗"></a>只使用二级缓存能解决吗</h4><p>在没有AOP的时候是可以解决循环依赖的</p><p>在有AOP时，二级缓存的作用：</p><ul><li>二级缓存保存提前 ”曝光“的bean，如果循环依赖的bean使用了AOP，需要提前创建代理对象出来，然后放入二级缓存。因为Bean的AOP动态代理创建是在初始化之后，但是循环依赖的Bean无法等到解决完循环依赖再创建代理对象，因为这个时候已经需要注入属性了。</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/188b434a81f90ae77c300cb8d8fe9acf.png" alt="img"></p><h4 id="依赖注入的原理"><a href="#依赖注入的原理" class="headerlink" title="依赖注入的原理"></a>依赖注入的原理</h4><p><a href="https://cloud.tencent.com/developer/article/2182665">【源码分析】Spring依赖注入原理-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h5 id="首先进行bean注册"><a href="#首先进行bean注册" class="headerlink" title="首先进行bean注册"></a><strong>首先进行bean注册</strong></h5><p><strong>在入口类上使用@ComponentScan注解，自定义需要扫描的目录</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;&quot;demo_test&quot;,&quot;realDemo&quot;&#125;)</span></span><br></pre></td></tr></table></figure><p><strong>使用scanBasePackages属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &#123;&quot;demo_test&quot;, &quot;realDemo&quot;&#125;)</span></span><br></pre></td></tr></table></figure><p><strong>第一步：获取BasePackages</strong></p><p>获取basePackages分为了那么三个步骤，分别是：</p><ul><li>获取@ComponentScan注解basePackages属性值</li><li>获取@ComponentScan注解basePackageClasses属性值</li><li>将Application入口类所在的package作为默认的basePackages</li></ul><p><strong><code>第二步：</code>扫描Packages下的Bean</strong></p><p>获取到全部的Packages后，通过org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan方法来扫描每一个Package下使用注册注解（@Component、@Service、@RestController…）标注的类：</p><p><strong>第三步：注册Bean</strong></p><p>通过<code>org.springframework.beans.factory.support.BeanDefinitionRegistry#registerBeanDefinition</code>注册器内的方法可以直接将<code>Bean</code>注册到<code>IOC</code>容器内，而<code>BeanName</code>则是它生命周期内的唯一名称</p><h5 id="Bean的实例化"><a href="#Bean的实例化" class="headerlink" title="Bean的实例化"></a>Bean的实例化</h5><p>根据配置生成具体的Bean，最终通过反射方法实现，执行完后Bean已经被创建，但是不完整，没有属性的注入。</p><h4 id="Spring的IOC"><a href="#Spring的IOC" class="headerlink" title="Spring的IOC"></a>Spring的IOC</h4><h5 id="IOC提出背景"><a href="#IOC提出背景" class="headerlink" title="IOC提出背景"></a>IOC提出背景</h5><ul><li>代码书写现状:耦合度太高，我们修改一处代码，往往要修改很多出相关联的代码。</li></ul><p>解决方法：我们在创建对象的时候，不自己创建而是由外部提供对象</p><h5 id="IOC的核心概念"><a href="#IOC的核心概念" class="headerlink" title="IOC的核心概念"></a><strong>IOC的核心概念</strong></h5><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理，IOC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IOC容器中统称为Bean。</p><h5 id="为什么叫控制反转？"><a href="#为什么叫控制反转？" class="headerlink" title="为什么叫控制反转？"></a><strong>为什么叫控制反转？</strong></h5><ul><li><strong>控制</strong>：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong>：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul><p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p><h5 id="IOC的实现方式"><a href="#IOC的实现方式" class="headerlink" title="IOC的实现方式"></a>IOC的实现方式</h5><p>DI-依赖注入<br>在容器中建立bean与bean之间的依赖关系的整个过程叫做依赖注入</p><p>也就是对于 IOC 容器中管理的 Bean，如果 Bean 之间存在依赖关系，那么 IOC 容器需要自动实现依赖对象的实例注入，通常有三种方法来描述 Bean 之间的依赖关系。</p><ol><li>接口注入</li><li>setter 注入</li><li>构造器注入</li></ol><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112104377.png" alt="image-20231003112104377"></p><h4 id="描述动态代理的几种实现方式？分别说出相应的优缺点"><a href="#描述动态代理的几种实现方式？分别说出相应的优缺点" class="headerlink" title="描述动态代理的几种实现方式？分别说出相应的优缺点"></a><strong>描述动态代理的几种实现方式？分别说出相应的优缺点</strong></h4><p>代理可以分为 “静态代理” 和 “动态代理”，动态代理又分为 “JDK动态代理” 和 “CGLIB动态代理” 实现。<br><strong>静态代理</strong>：在编译时生成代理对象，代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是 Real Object</p><ul><li><strong>优点</strong>：可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。</li><li><strong>缺点</strong>：不同的接口要有不同的代理类实现，会很冗余</li></ul><p><strong>JDK 动态代理</strong>：</p><p>使用条件：<strong>只能代理接口</strong>，通过<strong>Java的反射机制生成被代理接口的匿名实现类</strong>，通过invoke方法，调用实际对象的方法，并对方法进行增强</p><p>为了解决静态代理中，生成大量的代理类造成的冗余；JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码（通过被代理类的所有接口、ClassLoader、和被代理类、InvocationHandler实现类），该代理类实现了被代理类所有接口，同时重写了equals()、hashCode()等方法，并生成对象 jdk动态代理之所以<strong>只能代理接口</strong>是因为<strong>代理类本身已经extends了Proxy，而java是不允许多重继承的</strong>，但是允许实现多个接口。</p><p><strong>优点</strong>：解决了静态代理中冗余的代理实现类问题。</p><p><strong>缺点</strong>：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。</p><p><strong>CGLIB 代理</strong>：</p><p>既可以代理接⼝，⼜可以代理类，通过修改代理对象类的字节码生成子类（也就是代理类）来处理，并在子类中采用方法拦截的技术拦截所有父类方法的，调用底层是通过继承的⽅式实现的，所以代理类不能被final修饰，被final修饰的方法无法被代理。性能⽐JDK动态代理要好。 </p><p>由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK方式解决不了；CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类动态创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。由于CGLib由于是采用动态创建子类的方法，对于final类、final方法，无法进行代理。</p><p><strong>优点</strong>：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。</p><p><strong>缺点</strong>：技术实现相对难理解些。</p><h5 id="使用注意："><a href="#使用注意：" class="headerlink" title="使用注意："></a>使用注意：</h5><p>如果要被代理的对象是个实现类（有对应接口），那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）；</p><p>如果要被代理的对象不是个实现类（没有代理接口），那么Spring会强制使用CGLib来实现动态代理。</p><h4 id="AOP实际应用场景，好处，spring中如何实现？"><a href="#AOP实际应用场景，好处，spring中如何实现？" class="headerlink" title="AOP实际应用场景，好处，spring中如何实现？"></a>AOP实际应用场景，好处，spring中如何实现？</h4><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任(交叉业务)（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性，具体体现就是不改变源码或很少改变源码，增强方法功能。</p><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112107747.png" alt="image-20231003112107747"></p><p>⼀般⼀个系统当中都会有⼀些系统服务，例如：⽇志、事务管理、安全等。这些系统服务被称为：交叉业务<br>这些交叉业务⼏乎是通⽤的，不管你是做银⾏账户转账，还是删除⽤户数据。⽇志、事务管理、安全，这些都是需要做的。<br>如果在每⼀个业务处理过程当中，都掺杂这些交叉业务代码进去的话，存在两⽅⾯问题：</p><ul><li>第⼀：交叉业务代码在多个业务流程中反复出现，显然这个交叉业务代码没有得到复⽤。并且修改这些交叉业务代码的话，需要修改多处。</li><li>第⼆：程序员⽆法专注核⼼业务代码的编写，在编写核⼼业务代码的同时还需要处理这些交叉业务。</li></ul><p>使⽤AOP可以很轻松的解决以上问题。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112111175.png" alt="image-20231003112111175"></p><p>⽤⼀句话总结AOP：将与核⼼业务⽆关的代码独⽴的抽取出来，形成⼀个独⽴的组件，然后以横向交叉的⽅式应⽤到业务流程当中的过程被称为AOP。<br>AOP的优点：<br>第⼀：代码复⽤性增强。<br>第⼆：代码易维护。<br>第三：使开发者更关注业务逻辑。</p><h4 id="使用AOP记录代码执行时间"><a href="#使用AOP记录代码执行时间" class="headerlink" title="使用AOP记录代码执行时间"></a>使用AOP记录代码执行时间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">LOG</span> <span class="operator">=</span> LogFactory.getLog(LogAspect.class);</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个切入点.</span></span><br><span class="line"><span class="comment">     * 解释下：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ~ 第一个 * 代表任意修饰符及任意返回值.</span></span><br><span class="line"><span class="comment">     * ~ 第二个 * 定义在web包或者子包</span></span><br><span class="line"><span class="comment">     * ~ 第三个 * 任意方法</span></span><br><span class="line"><span class="comment">     * ~ .. 匹配任意数量的参数.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//定义切入规则</span></span><br><span class="line">     <span class="meta">@Pointcut(&quot;execution(* com.wedo.stream.service..*.*(..))&quot;)</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logPointcut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@org</span>.aspectj.lang.annotation.Around(<span class="string">&quot;logPointcut()&quot;</span>)</span><br><span class="line">     <span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line"><span class="comment">//     LOG.debug(&quot;logPointcut &quot; + joinPoint + &quot;\t&quot;);</span></span><br><span class="line"> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line"> <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"> LOG.error(<span class="string">&quot;+++++around &quot;</span> + joinPoint + <span class="string">&quot;\tUse time : &quot;</span> + (end - start) + <span class="string">&quot; ms!&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> result; </span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"> <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"> LOG.error(<span class="string">&quot;+++++around &quot;</span> + joinPoint + <span class="string">&quot;\tUse time : &quot;</span> + (end - start) + <span class="string">&quot; ms with exception : &quot;</span> + e.getMessage());</span><br><span class="line"> <span class="keyword">throw</span> e;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="AOP失效的场景"><a href="#AOP失效的场景" class="headerlink" title="AOP失效的场景"></a>AOP失效的场景</h4><ul><li><p>方法定义为private时，invocationHandler无法增强方法，AOP会失效</p></li><li><p>内部调用导致失效：在同一个方法中方法互相调用，例如GoodServicce的a()方法调用了本类中的b()方法，默认会调用this.b(),调用到原始对象的未被增强的方法,Aop就会失效，同时被调用的b()方法的事务也失效，如下：</p></li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1748647-20200513102507419-2065662764.png" alt="img"></p><p> 解决办法（一），拿到Spring给我们创建的代理，用代理调用就可以解决，解决如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1748647-20200513102628629-32905165.png" alt="img"></p><p> 不过这个方法要注意的是，主类入口上，必须加上exporseProxy&#x3D;true，表示在线程中强制暴露代理对象，底层是将动态代理对象存在ThreadLocal中</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/eumnm67k12.png" alt="img"></p><p>解决办法（二），把我们要进行调用的方法移出本类，比如到一个公共的Service接口，注入该Service接口，就会注入代理对象，并调用代理对象中的方法</p><p>1、新建公共Service</p><p> <img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1748647-20200513102855578-1710015572.png" alt="img"></p><p> <img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1748647-20200513102902777-2053117750.png" alt="img"></p><p> 2、注入对象再进行调用</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1748647-20200513103000667-982744350.png" alt="img"></p><h4 id="自定义切面类导致事务失效"><a href="#自定义切面类导致事务失效" class="headerlink" title="自定义切面类导致事务失效"></a>自定义切面类导致事务失效</h4><p>在切面类中没有将异常抛出，事务切面类无法感知到异常的存在，就无法回滚事务</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240307202755770.png" alt="image-20240307202755770"></p><h4 id="Spring事务以及对应的传播机制。"><a href="#Spring事务以及对应的传播机制。" class="headerlink" title="Spring事务以及对应的传播机制。"></a>Spring事务以及对应的传播机制。</h4><h5 id="Spring-管理事务的方式有几种？"><a href="#Spring-管理事务的方式有几种？" class="headerlink" title="Spring 管理事务的方式有几种？"></a>Spring 管理事务的方式有几种？</h5><ul><li><strong>编程式事务</strong>：在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li><li><strong>声明式事务</strong>：在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</li></ul><h5 id="什么是事务的传播⾏为？"><a href="#什么是事务的传播⾏为？" class="headerlink" title="什么是事务的传播⾏为？"></a>什么是事务的传播⾏为？</h5><p>在service类中有a()⽅法和b()⽅法，a()⽅法上有事务，b()⽅法上也有事务，当a()⽅法执⾏过程中调⽤了<br>b()⽅法，事务是如何传递的？合并到⼀个事务⾥？还是开启⼀个新的事务？这就是事务传播⾏为。</p><h5 id="一共有7种传播行为"><a href="#一共有7种传播行为" class="headerlink" title="一共有7种传播行为"></a>一共有7种传播行为</h5><ul><li>REQUIRED：⽀持当前事务，如果不存在就新建⼀个(默认)【没有就新建，有就加⼊】 (a方法种如果有事务，b方法种还是使用原有a的事务， a方法没有事务，b方法就开启新事务)</li><li>SUPPORTS：⽀持当前事务，如果当前没有事务，就以⾮事务⽅式执⾏【有就加⼊，没有就不管了】</li><li>MANDATORY： 必须运⾏在⼀个事务中，如果当前没有事务正在发⽣，将抛出⼀个异常【有就加⼊，没有就抛异常】</li><li>REQUIRES_NEW： 开启⼀个新的事务，如果⼀个事务已经存在，则将这个存在的事务挂起【不管有没有，直接开启⼀个新事务，开启的新事务和之前的事务不存在嵌套关系，之前事务被挂起】</li><li>NOT_SUPPORTED： 以⾮事务⽅式运⾏，如果有事务存在，挂起当前事务【不⽀持事务，存在就挂起】</li><li>NEVER： 以⾮事务⽅式运⾏，如果有事务存在，抛出异常【不⽀持事务，存在就抛异常】</li><li>NESTED： 如果当前正有⼀个事务在进⾏中，则该⽅法应当运⾏在⼀个嵌套式事务中。被嵌套的事务可以独⽴于外层事务进⾏提交或回滚。如果外层事务不存在，⾏为就像REQUIRED⼀样。【有事务的话，就在这个事务⾥再嵌套⼀个完全独⽴的事务，嵌套的事务可以独⽴的提交和回滚。没有事务就和 REQUIRED⼀样。</li></ul><h5 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(timeout = 10)</span> </span><br></pre></td></tr></table></figure><p>以上代码表示设置事务的超时时间为10秒。<br>表示超过10秒如果该事务中所有的DML语句还没有执⾏完毕的话，最终结果会选择回滚。<br>默认值-1，表示没有时间限制。<br>这⾥有个坑，事务的超时时间指的是哪段时间？<br>在当前事务当中，最后⼀条DML语句执⾏之前的时间。如果最后⼀条DML语句后⾯很有很多业务逻辑，<br>这些业务代码执⾏的时间不被计⼊超时时间。</p><h4 id="transactional注解什么情况下会失效？"><a href="#transactional注解什么情况下会失效？" class="headerlink" title="@transactional注解什么情况下会失效？"></a>@transactional注解什么情况下会失效？</h4><h5 id="数据库引擎不支持事务"><a href="#数据库引擎不支持事务" class="headerlink" title="数据库引擎不支持事务"></a><strong>数据库引擎不支持事务</strong></h5><p>这种情况出现的概率并不高，事务能否生效数据库引擎是否支持事务是关键。常用的MySQL数据库默认使用支持事务的innodb引擎。一旦数据库引擎切换成不支持事务的myisam，那事务就从根本上失效了。</p><p><strong>@Transactional 应用在非 public 修饰的方法上</strong></p><p>如果Transactional注解应用在非public 修饰的方法上，Transactional将会失效。</p><p>之所以会失效是因为在Spring AOP 代理时，如上图所示 TransactionInterceptor （事务拦截器）在目标方法执行前后进行拦截，DynamicAdvisedInterceptor（CglibAopProxy 的内部类）的 intercept 方法或 JdkDynamicAopProxy 的 invoke 方法会间接调用 AbstractFallbackTransactionAttributeSource的 computeTransactionAttribute 方法，获取Transactional 注解的事务配置信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">computeTransactionAttribute</span><span class="params">(Method method,</span></span><br><span class="line"><span class="params">    Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">        <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。</p><p>注意：protected、private 修饰的方法上使用 @Transactional 注解，虽然事务无效，但不会有任何报错，这是我们很容犯错的一点。</p><h5 id="Transactional-注解属性-propagation-设置错误"><a href="#Transactional-注解属性-propagation-设置错误" class="headerlink" title="@Transactional 注解属性 propagation 设置错误"></a><strong>@Transactional 注解属性 propagation 设置错误</strong></h5><p>这种失效是由于配置错误，若是错误的配置以下三种 propagation，事务将不会发生回滚。</p><ul><li><p>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 </p></li><li><p>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 </p></li><li><p>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</p></li></ul><h5 id="Transactional-注解属性-rollbackFor-设置错误"><a href="#Transactional-注解属性-rollbackFor-设置错误" class="headerlink" title="@Transactional 注解属性 rollbackFor 设置错误"></a><strong>@Transactional 注解属性 rollbackFor 设置错误</strong></h5><p>rollbackFor 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查unchecked异常（继承自 RuntimeException 的异常）或者 Error才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定 rollbackFor属性。</p><p>&#x2F;&#x2F; 希望自定义的异常可以进行回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class</span></span><br></pre></td></tr></table></figure><p>若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。Spring源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(Class&lt;?&gt; exceptionClass, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (exceptionClass.getName().contains(<span class="built_in">this</span>.exceptionName)) &#123;</span><br><span class="line">            <span class="comment">// Found it!</span></span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// If we&#x27;ve gone as far as we can go and haven&#x27;t found it...</span></span><br><span class="line">        <span class="keyword">if</span> (exceptionClass == Throwable.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getDepth(exceptionClass.getSuperclass(), depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="同一个类中方法调用，导致-Transactional失效"><a href="#同一个类中方法调用，导致-Transactional失效" class="headerlink" title="同一个类中方法调用，导致@Transactional失效"></a><strong>同一个类中方法调用</strong>，导致@Transactional失效</h5><p>开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。</p><p>那为啥会出现这种情况？其实这还是由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Transactional</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> Integer <span class="title function_">A</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="type">CityInfoDict</span> <span class="variable">cityInfoDict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CityInfoDict</span>();</span><br><span class="line">      cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * B 插入字段为 3的数据</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="built_in">this</span>.insertB();</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * A 插入字段为 2的数据</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">return</span> insert;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Transactional()</span></span><br><span class="line">  <span class="keyword">public</span> Integer <span class="title function_">insertB</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="type">CityInfoDict</span> <span class="variable">cityInfoDict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CityInfoDict</span>();</span><br><span class="line">      cityInfoDict.setCityName(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">      cityInfoDict.setParentCityId(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">return</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="异常被你的-catch“吃了”导致-Transactional失效"><a href="#异常被你的-catch“吃了”导致-Transactional失效" class="headerlink" title="异常被你的 catch“吃了”导致@Transactional失效"></a>异常被你的 catch“<strong>吃了</strong>”导致@Transactional失效</h5><p>这种情况是最常见的一种@Transactional注解失效场景，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">private</span> Integer <span class="title function_">A</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">CityInfoDict</span> <span class="variable">cityInfoDict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CityInfoDict</span>();</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        cityInfoDict.setParentCityId(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A 插入字段为 2的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        insert = cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * B 插入字段为 3的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        b.insertB();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果B方法内部抛了异常，而A方法此时try catch了B方法的异常，那这个事务还能正常回滚吗？</p><p>答案：不能！</p><p>会抛出异常：</p><p>org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only<br>因为当ServiceB中抛出了一个异常以后，ServiceB标识当前事务需要rollback。但是ServiceA中由于你手动的捕获这个异常并进行处理，ServiceA认为当前事务应该正常commit。此时就出现了前后不一致，也就是因为这样，抛出了前面的UnexpectedRollbackException异常。</p><p>spring的事务是在调用业务方法之前开始的，业务方法执行完毕之后才执行commit or rollback，事务是否执行取决于是否抛出runtime异常。如果抛出runtime exception 并在你的业务方法中没有catch到的话，事务会回滚。</p><p>在业务方法中一般不需要catch异常，如果非要catch一定要抛出throw new RuntimeException()，或者注解中指定抛异常类型@Transactional(rollbackFor&#x3D;Exception.class)，否则会导致事务失效，数据commit造成数据不一致，所以有些时候try catch反倒会画蛇添足。</p><h4 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h4><p><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</p><p><strong>代理设计模式</strong> : Spring AOP 功能的实现。</p><p><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</p><p><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</p><p><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</p><p><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</p><p><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code></p><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><h4 id="JDBC如何操作数据库"><a href="#JDBC如何操作数据库" class="headerlink" title="JDBC如何操作数据库"></a>JDBC如何操作数据库</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zdx.source.code.jdbc;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">JDBC完成Delete</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、注册驱动</span></span><br><span class="line">        <span class="comment">// 2、获取连接</span></span><br><span class="line">        <span class="comment">// 3、获取数据库操作对象</span></span><br><span class="line">        <span class="comment">// 4、执行sql语句</span></span><br><span class="line">        <span class="comment">// 5、获取查询结果集</span></span><br><span class="line">        <span class="comment">// 6、释放资源</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.mysql.jdbc.Driver();</span><br><span class="line">            DriverManager.registerDriver(driver);</span><br><span class="line"> </span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/mydatabase&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;146&quot;</span>;</span><br><span class="line">            conn = DriverManager.getConnection(url,user,password);</span><br><span class="line"> </span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line"> </span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(<span class="string">&quot;delete from dept where deptno = 50&quot;</span>);</span><br><span class="line">            <span class="comment">//如果是select语句就会返回一个ResultSet</span></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;SELECT * FROM ...&quot;</span>) ;    </span><br><span class="line">            <span class="comment">//ResultSet包含符合SQL语句中条件的所有行，并且它通过一套get方法提供了对这些行中数据的访问。</span></span><br><span class="line">    <span class="comment">//列是从左到右编号的，并且从列1开始    </span></span><br><span class="line">             <span class="keyword">while</span>(rs.next())&#123;    </span><br><span class="line">                 <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>) ;    </span><br><span class="line">                 <span class="type">String</span> <span class="variable">pass</span> <span class="operator">=</span> rs.getString(<span class="number">1</span>) ; <span class="comment">// 此方法比较高效    </span></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(count == <span class="number">1</span>? <span class="string">&quot;删除成功&quot;</span>:<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stmt != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mybatis-为什么还要保留"><a href="#mybatis-为什么还要保留" class="headerlink" title="mybatis #{} ${} 为什么还要保留${}"></a>mybatis #{} ${} 为什么还要保留${}</h4><h5 id="MyBatis获取参数值的两种方式：-和"><a href="#MyBatis获取参数值的两种方式：-和" class="headerlink" title="MyBatis获取参数值的两种方式：${}和#{}"></a>MyBatis获取参数值的两种方式：${}和#{}</h5><ul><li>#{}表示一个占位符号 相当于 jdbc中的 ? 符号，会对自动传入的数据加一个双引号。如：select * from user where id&#x3D; #{user_id}，如果传入的值是11,那么解析成sql时的值为where id&#x3D;”11” ，可以防止sql注入</li><li>${}使用字符串拼接的方式拼接sql，$将传入的数据直接显示生成在sql中，会有sql注入的风险</li></ul><h5 id="为什么保留"><a href="#为什么保留" class="headerlink" title="为什么保留"></a>为什么保留</h5><p>在一些需要动态参数的场景下，使用#{}不行，只能使用${}.</p><h6 id="动态传表"><a href="#动态传表" class="headerlink" title="动态传表"></a>动态传表</h6><p>比如开发者不知道实际要操作数据库中具体是哪一张表，可能会通过一系列的判断来动态的获取到要操作的表名</p><ul><li><p>如果要用#{}的方式来处理sql就回出现以下情况</p><p>select * from #{tableName} where…</p><p>这样sql处理完成后就会变成select * from “tableName” where…</p></li><li><p>如果使用${}，sql处理完成后select * from tableName where…，这样这段sql就能正常执行了</p></li></ul><h6 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h6><ul><li>只能使用${}，如果使用#{}，则解析后的sql语句为<code>delete from t_user where id in (&#39;1,2,3&#39;)</code>，这样是将<code>1,2,3</code>看做是一个整体，只有id为<code>1,2,3</code>的数据会被删除。</li><li>正确的语句应该是<code>delete from t_user where id in (1,2,3)</code>，或者<code>delete from t_user where id in (&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)</code></li></ul><h4 id="Mybatis的分页原理"><a href="#Mybatis的分页原理" class="headerlink" title="Mybatis的分页原理"></a>Mybatis的分页原理</h4><p><strong>手写limit分页</strong></p><ul><li>顾名思义，这种方法就是我们自己在SQL中添加<code>limit</code>关键字来实现分页；</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;findPageByHand&quot; parameterType<span class="operator">=</span>&quot;org.apache.ibatis.z_run.pojo.QueryCondition&quot; resultType<span class="operator">=</span>&quot;org.apache.ibatis.z_run.pojo.Purchase&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">    <span class="operator">&lt;</span>include refid<span class="operator">=</span>&quot;Base_Column_List&quot; <span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">from</span> purchase</span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">where</span><span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;id != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            <span class="keyword">And</span> id <span class="operator">=</span> #&#123;id,jdbcType<span class="operator">=</span><span class="type">INTEGER</span>&#125;</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;category != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            <span class="keyword">And</span> category <span class="operator">=</span> #&#123;category,jdbcType<span class="operator">=</span><span class="type">INTEGER</span>&#125;</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">where</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;pageSize != null and pageNum != null&quot;<span class="operator">&gt;</span></span><br><span class="line">        limit #&#123;<span class="keyword">offset</span>&#125;, #&#123;pageSize&#125;</span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><ul><li>另外，为了返回一个总条数，我们还得单独再写一条SQL，用于统计分页查询的总条数，在计算总页数的时候使用。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;count&quot; parameterType<span class="operator">=</span>&quot;org.apache.ibatis.z_run.pojo.QueryCondition&quot; resultType<span class="operator">=</span>&quot;java.lang.Integer&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">    <span class="built_in">count</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span></span><br><span class="line">        <span class="operator">&lt;</span>include refid<span class="operator">=</span>&quot;Base_Column_List&quot;<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line">        <span class="keyword">from</span> purchase</span><br><span class="line">        <span class="operator">&lt;</span><span class="keyword">where</span><span class="operator">&gt;</span></span><br><span class="line">            <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;id != null&quot;<span class="operator">&gt;</span></span><br><span class="line">                <span class="keyword">And</span> id <span class="operator">=</span> #&#123;id,jdbcType<span class="operator">=</span><span class="type">INTEGER</span>&#125;</span><br><span class="line">            <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">            <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;category != null&quot;<span class="operator">&gt;</span></span><br><span class="line">                <span class="keyword">And</span> category <span class="operator">=</span> #&#123;category,jdbcType<span class="operator">=</span><span class="type">INTEGER</span>&#125;</span><br><span class="line">            <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">where</span><span class="operator">&gt;</span></span><br><span class="line">    ) t1</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p><strong>RowBounds分页</strong></p><ul><li><p>Mybatis内置了一个专门处理分页的类——RowBounds，我们使用它可以轻松完成分页。</p><p>RowBounds源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RowBounds</span> &#123;</span><br><span class="line">    <span class="comment">//默认值为0~~Java最大整数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NO_ROW_OFFSET</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NO_ROW_LIMIT</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RowBounds</span> <span class="variable">DEFAULT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowBounds</span>();</span><br><span class="line">    <span class="comment">//偏移量，即从第几行开始读取</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="comment">//限制，即每页显示记录数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> limit;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RowBounds</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.offset = NO_ROW_OFFSET;</span><br><span class="line">        <span class="built_in">this</span>.limit = NO_ROW_LIMIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RowBounds</span><span class="params">(<span class="type">int</span> offset, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.offset = offset;</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOffset</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLimit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①、定义接口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页查询所有用户，通过自带的RowBounds</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">selectAllUserByRowBounds</span><span class="params">(RowBounds rowBounds)</span>;</span><br></pre></td></tr></table></figure><p>②、sql映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 分页查询所有用户，通过自带的RowBounds --&gt;</span><br><span class="line">&lt;select id=<span class="string">&quot;selectAllUserByRowBounds&quot;</span> resultMap=<span class="string">&quot;userMap&quot;</span>&gt;</span><br><span class="line">    select * from t_user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>使用RowBounds分页我们可以不写在映射SQL中写limit关键字，到时候自动回给我们拼接。就两个字，方便！</p><p>③、测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页查询所有用户信息,通过自带的RowBounds</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectAllUserByRowBounds</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> currPage=<span class="number">2</span>;<span class="comment">//当前页码</span></span><br><span class="line">    <span class="type">int</span> pageSize=<span class="number">3</span>;<span class="comment">//当前页显示记录数量</span></span><br><span class="line">    <span class="comment">//注意：currPage和start别搞错了，一个表示当前页码，一个是从第几行读取记录</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (currPage-<span class="number">1</span>)*pageSize;<span class="comment">//计算从第几行读取记录</span></span><br><span class="line">    <span class="type">RowBounds</span> <span class="variable">rowBounds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowBounds</span>(start,pageSize);</span><br><span class="line">    List&lt;User&gt; userList = mapper.selectAllUserByRowBounds(rowBounds);</span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>RowBounds</code>对象后，就不需要在SQL语句中写<code>limit</code>语句了，但是仍然要对满足条件的数据条数进行单独查询，其结果将用于计算总页数，语句同上。</li></ul><p>使用<code>RowBounds</code>进行分页时，SQL语句中并没有添加<code>limit</code>关键字进行分页，这是因为<code>RowBounds</code>分页是将所有的数据查询到内存中以后，再使用<code>RowBounds</code>参数进行分页的，对内存的压力很大，性能很低，因此这种方式不建议使用。</p><p><strong>Pagehelper插件</strong></p><p>Pagehelper插件的原理是使用拦截器拦截SQL语句的执行，它内部帮助我们实现了Interceptor的功能。所以实际上我们在执行查询方法之前，PageHelper分页插件同样是对我们的 sql 进行拦截，然后对分页参数进行拼接。并为SQL语句添加<code>limit</code>关键字进行分页查询，以及count语句来查询总数（就不需要我们自己手写count方法来计算数据总条数了），</p><ul><li>导入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>XML语句同<code>RowBounds</code>相同，不需要在SQL语句中写<code>limit</code>关键字。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;findByCondition&quot; parameterType<span class="operator">=</span>&quot;org.apache.ibatis.z_run.pojo.QueryCondition&quot; resultType<span class="operator">=</span>&quot;org.apache.ibatis.z_run.pojo.Purchase&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">    <span class="operator">&lt;</span>include refid<span class="operator">=</span>&quot;Base_Column_List&quot; <span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">from</span> purchase</span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">where</span><span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;id != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            <span class="keyword">And</span> id <span class="operator">=</span> #&#123;id,jdbcType<span class="operator">=</span><span class="type">INTEGER</span>&#125;</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;category != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            <span class="keyword">And</span> category <span class="operator">=</span> #&#123;category,jdbcType<span class="operator">=</span><span class="type">INTEGER</span>&#125;</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">where</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--固定开头部分--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--保证映射文件的命名空间和mapper接口的全类名保持一致--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.spzx.manager.mapper.SysUserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用于select查询公用抽取的列 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;columns&quot;</span>&gt;</span></span><br><span class="line">id,username userName ,password,name,phone,avatar,description,status,create_time,update_time,is_deleted</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span>&gt;</span> <span class="comment">&lt;!--id要和对应方法名一致--&gt;</span></span><br><span class="line">update sys_user set update_time = now() , is_deleted = 1 where id = #&#123;userId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--id与方法名一致，定义返回类型，也可以用map表示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByUserName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.spzx.model.entity.system.SysUser&quot;</span>&gt;</span></span><br><span class="line">select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;columns&quot;</span> /&gt;</span></span><br><span class="line">from sys_user</span><br><span class="line">         where username = #&#123;userName&#125;</span><br><span class="line">         and is_deleted = 0</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;findPageWhere&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--test表示测试方法中的参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;keyword != null and keyword != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--and username like CONCAT(&#x27;%&#x27;,#&#123;keyword&#125;,&#x27;%&#x27;)--&gt;</span></span><br><span class="line">and (username like CONCAT(&#x27;%&#x27;,#&#123;keyword&#125;,&#x27;%&#x27;)</span><br><span class="line">or name like CONCAT(&#x27;%&#x27;,#&#123;keyword&#125;,&#x27;%&#x27;)</span><br><span class="line">or phone like CONCAT(&#x27;%&#x27;,#&#123;keyword&#125;,&#x27;%&#x27;))</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;createTimeBegin != null and createTimeBegin != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and create_time &gt;= #&#123;createTimeBegin&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;createTimeEnd != null and createTimeEnd != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and create_time <span class="symbol">&amp;lt;</span>= #&#123;createTimeEnd&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">and is_deleted = 0</span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByPage&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.spzx.model.entity.system.SysUser&quot;</span> &gt;</span></span><br><span class="line">select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;columns&quot;</span> /&gt;</span><span class="comment">&lt;!--引用定义的column，提高复用性--&gt;</span></span><br><span class="line">from sys_user</span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;findPageWhere&quot;</span>/&gt;</span><span class="comment">&lt;!--引用定义的where条件--&gt;</span></span><br><span class="line">order by id desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;saveSysUser&quot;</span>&gt;</span></span><br><span class="line">insert into sys_user (</span><br><span class="line">id,</span><br><span class="line">username,</span><br><span class="line">password,</span><br><span class="line">name,</span><br><span class="line">phone,</span><br><span class="line">avatar,</span><br><span class="line">description,</span><br><span class="line">status</span><br><span class="line">) values (</span><br><span class="line"> #&#123;id&#125;,</span><br><span class="line"> #&#123;userName&#125;,</span><br><span class="line"> #&#123;password&#125;,</span><br><span class="line"> #&#123;name&#125;,</span><br><span class="line"> #&#123;phone&#125;,</span><br><span class="line"> #&#123;avatar&#125;,</span><br><span class="line"> #&#123;description&#125;,</span><br><span class="line"> #&#123;status&#125;</span><br><span class="line"> )</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateSysUser&quot;</span>&gt;</span></span><br><span class="line">update sys_user set</span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName != null and userName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">username = #&#123;userName&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null and password != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">password = #&#123;password&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">name = #&#123;name&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;phone != null and phone != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">phone = #&#123;phone&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;avatar != null and avatar != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">avatar = #&#123;avatar&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;description != null and description != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">description = #&#123;description&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null and status != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">status = #&#123;status&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">update_time =  now()</span><br><span class="line">where</span><br><span class="line">id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><h4 id="SpringMVC的工作流程"><a href="#SpringMVC的工作流程" class="headerlink" title="SpringMVC的工作流程"></a>SpringMVC的工作流程</h4><p>Spring MVC 的工作流程可以分为几个步骤</p><ol><li>用户发起请求，请求先被 Servlet 拦截转发给 Spring MVC 框架</li><li>Spring MVC 里面的 DispatcherSerlvet 核心控制器，会接收到请求并转发给HandlerMapping</li><li>HandlerMapping负责解析请求，根据请求信息和配置信息找到匹配的Controller类，不过这里如果有配置拦截器，就会按照顺序执行拦截器里面的 preHandle 方法</li><li>找到匹配的 Controller 以后，把请求参数传递给 Controller 里面的方法</li><li>Controller 中的方法执行完以后，会返回一个 ModeAndView，这里面会包括视图名称和需要传递给视图的模型数据</li><li>视图解析器根据名称找到视图，然后把数据模型填充到视图里面再渲染成 Html 内容返回给客户端</li></ol><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240318204559445.png" alt="image-20240318204559445"></p><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><ul><li><p>@Controller</p><p>应用在MVC层（控制层）,DispatcherServlet会自动扫描注解了此注解的类，然后将web请求映射到注解了@RequestMapping的方法上。</p></li><li><p>@Service<br>应用在service层（业务逻辑层）</p></li><li><p>@Reponsitory<br>应用在dao层（实现类）（数据访问层）</p></li><li><p>@component<br>通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注</p></li><li><p>@Autowired<br>由Spring的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入，Spring提供的工具。</p></li><li><p>@Resource<br>依赖注入，是JDK扩展包中的，给对象的属性注入数据，可以定义在字段上，也可以定义在方法上。一般用在注入dao层数据源，跟@Autowired相似，区别就是@Autowired默认是先根据类型，而@Resource默认是先根据名称</p></li><li><p>@value通过<code>@Value</code>注解将常量、配置文件中的值、其他bean的属性值注入到变量中，作为变量的初始值。支持表达式、直接赋值、配置文件三种方式。</p></li><li><p>@RequestParam：将请求参数绑定到你控制器的方法参数上 @RequestParam(“参数名”)  &#x2F;blogs?state&#x3D;publish</p></li><li><p>@PathVariable 放置在参数前，用来接受路径参数。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;user/&#123;username&#125;&quot;)</span></span><br></pre></td></tr></table></figure><ul><li><p>@ResponseBody：将返回值放在response体内。返回的是数据而不是页面。在异步请求返回json数据时使用。</p></li><li><p>@RequestBody：允许request的参数在request请求体中，而不是在直接链接在地址的后面。用来接收在请求体中的json数据，转化为实体类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 直接以String接收前端传过来的json数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> str:json格式的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: json格式的字符串</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">   <span class="meta">@PostMapping(&quot;/test&quot;)</span></span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(<span class="meta">@RequestBody</span> String str)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> str;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>@RestController使用此注解后，在方法层就不用添加@ResponseBody注解了，并且这个类中所有的方法都默认添加@ResponseBody注解，都返回的是数据而不是界面。</li><li>@ExceptionHandler用在方法上定义全局处理，通过他的value属性可以过滤拦截的条件：<code>@ExceptionHandler(value=Exception.class)</code>–表示拦截所有Exception。</li><li>@SpringBootTest  把一个类标记为测试类</li><li>@Test   将一个普通方法修饰为一个测试方法。</li><li>@Transactional：事务声明。在类上使用，对整个类的方法，事务起作用。无异常时正常提交，有异常时数据回滚。 方法上使用，事务正常起作用。无异常时正常提交，有异常时数据回滚</li></ul><h4 id="springBoot启动流程"><a href="#springBoot启动流程" class="headerlink" title="springBoot启动流程"></a>springBoot启动流程</h4><ul><li>首先从main找到run()方法，在执行run()方法之前new一个SpringApplication对象</li><li>进入run()方法，创建应用监听器SpringApplicationRunListeners开始监听</li><li>然后加载SpringBoot配置环境(ConfigurableEnvironment)，然后把配置环境(Environment)加入监听对象中</li><li>然后加载应用配置上下文(ConfigurableApplicationContext)，当做run方法的返回对象</li><li>最后创建Spring容器，refreshContext(context)，实现starter自动化配置和bean的实例化等工作。</li></ul><p>首先进入run()方法，run方法中new创建了一个SpringApplication实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">SpringApplication</span>(primarySources)).run(args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在SpringApplication的构造方法里为SpringApplication对象赋一些初值。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUmljYXJkbzAzMjQ=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center.png" alt="img"></p><p>构造方法执行完后，回到run()方法</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUmljYXJkbzAzMjQ=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center-1713538955269-1.png" alt="img"></p><p>该方法中实现了如下几个关键步骤：</p><ul><li><p>创建了应用的监听器SpringApplicationRunListeners并开始监听</p></li><li><p>加载SpringBoot配置环境(ConfigurableEnvironment)，如果是通过web容器发布，会加载StandardEnvironment，其最终也是继承了ConfigurableEnvironment</p></li><li><p>配置环境(Environment)加入到监听器对象中(SpringApplicationRunListeners)</p></li><li><p>创建run方法的返回对象：ConfigurableApplicationContext(应用配置上下文)</p></li><li><p>回到run方法内，prepareContext方法将listeners、environment、applicationArguments、banner等重要组件与上下文对象关联</p></li><li><p>接下来的refreshContext(context)方法(初始化方法如下)将是实现spring-boot-starter-*(mybatis、redis等)自动化配置的关键，包括spring.factories的加载，bean的实例化等核心工作。</p></li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUmljYXJkbzAzMjQ=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center-1713538955269-2.png" alt="img"></p><p>配置结束后，Springboot做了一些基本的收尾工作，返回了应用环境上下文。回顾整体流程，Springboot的启动，主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的Bean，至此，通过SpringBoot启动的程序已经构造完成。</p><h4 id="SpringBoot的自动装配"><a href="#SpringBoot的自动装配" class="headerlink" title="SpringBoot的自动装配"></a>SpringBoot的自动装配</h4><p>自动装配：<strong>自动把第三方组件的 Bean 装载到 Spring IOC 器里面</strong>，不需要开发人员再去写 Bean 的装配配置。<br>在 Spring Boot 应用里面，只需要在启动类加上@SpringBootApplication 注解就可以实现自动装配，真正实现自动装配的注解是@EnableAutoConfiguration。</p><p> Starter 启动依赖组件(其中包含多个配置类，通过@Configuration来标记，这个配置类中通过@Bean 注解声明需要装配到 IOC 容器的 Bean 对象) —–&gt; 这些第三方jar包配置类的全路径都放在classpath:&#x2F;META_INF&#x2F;spring.factories下 —–&gt; 通过spring提供的ImportSelector接口，实现对这些配置类的动态加载，实现对第三方组件Bean的自动装配。</p><p>自动装配，简单来说就是自动把第三方组件的 Bean 装载到 Spring IOC 器里面，不需要开发人员再去写 Bean 的装配配置。<br>在 Spring Boot 应用里面，只需要在启动类加上@SpringBootApplication 注解就可以实现自动装配。<br>@SpringBootApplication 是一个复合注解，真正实现自动装配的注解是@EnableAutoConfiguration。<br>（如图）自动装配的实现主要依靠三个核心关键技术。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/94d6e1a060ac41db97043e1758789026tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp"></p><ul><li>引入 Starter 启动依赖组件的时候，这个组件里面必须要包含@Configuration 配置类，在这个配置类里面通过@Bean 注解声明需要装配到 IOC 容器的 Bean 对象。</li><li>这个配置类是放在第三方的 jar 包里面，然后通过 SpringBoot 中的约定优于配置思想，把这个配置类的全路径放在 classpath:&#x2F;META-INF&#x2F;spring.factories 文件中。这样 SpringBoot 就可以知道第三方 jar 包里面的配置类的位置，这个步骤主要是用到了 Spring 里面的 SpringFactoriesLoader 来完成的。</li><li>SpringBoot 拿到所第三方 jar 包里面声明的配置类以后，再通过 Spring 提供的ImportSelector 接口，实现对这些配置类的动态加载。</li></ul><p>在我看来，SpringBoot 是约定优于配置这一理念下的产物，所以在很多的地方，都会看到这类的思想。它的出现，让开发人员更加聚焦在了业务代码的编写上，而不需要去关心和业务无关的配置。</p><h4 id="starter的作用"><a href="#starter的作用" class="headerlink" title="starter的作用"></a>starter的作用</h4><h5 id="starter介绍"><a href="#starter介绍" class="headerlink" title="starter介绍"></a><strong>starter介绍</strong></h5><p>spring boot 在配置上相比spring要简单许多, 其核心在于spring-boot-starter, 在使用spring boot来搭建一个项目时, 只需要引入官方提供的starter, 就可以直接使用, 免去了各种配置。starter简单来讲就是引入了一些相关依赖和一些初始化的配置。</p><p>Spring官方提供了很多starter，第三方也可以定义starter。为了加以区分，starter从名称上进行了如下规范：</p><ul><li>Spring官方提供的starter名称为：spring-boot-starter-xxx 例如Spring官方提供的spring-boot-starter-web</li><li>第三方提供的starter名称为：xxx-spring-boot-starter 例如由mybatis提供的mybatis-spring-boot-starter</li></ul><h5 id="2-2-starter原理"><a href="#2-2-starter原理" class="headerlink" title="2.2 starter原理"></a><strong>2.2 starter原理</strong></h5><p>Spring Boot之所以能够帮我们简化项目的搭建和开发过程，主要是基于它提供的起步依赖和自动配置。</p><h5 id="2-2-1-起步依赖"><a href="#2-2-1-起步依赖" class="headerlink" title="2.2.1 起步依赖"></a><strong>2.2.1 起步依赖</strong></h5><p>起步依赖，其实就是将具备某种功能的坐标打包到一起，可以简化依赖导入的过程。例如，我们导入spring-boot-starter-web这个starter，则和web开发相关的jar包都一起导入到项目中了。如下图所示：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-7a008a160c27a8010e1217de29cceb49_720w.png" alt="img"></p><h5 id="2-2-2-自动配置"><a href="#2-2-2-自动配置" class="headerlink" title="2.2.2 自动配置"></a><strong>2.2.2 自动配置</strong></h5><p>自动配置，就是无须手动配置xml，自动配置并管理bean，可以简化开发过程。</p><p>自动配置涉及到如下几个关键步骤：</p><ul><li>基于Java代码的Bean配置</li><li>自动配置条件依赖</li><li>Bean参数获取</li><li>Bean的发现</li><li>Bean的加载</li></ul><h4 id="如何自定义一个starter"><a href="#如何自定义一个starter" class="headerlink" title="如何自定义一个starter"></a>如何自定义一个starter</h4><h5 id="为什么要自定义starter"><a href="#为什么要自定义starter" class="headerlink" title="为什么要自定义starter"></a>为什么要自定义starter</h5><p>　　在我们的日常开发工作中，经常会有一些独立于业务之外的配置模块，我们经常将其放到一个特定的包下，然后如果另一个工程需要复用这块功能的时候，需要将代码硬拷贝到另一个工程，重新集成一遍，麻烦至极。如果我们将这些可独立于业务代码之外的功配置模块封装成一个个starter，复用的时候只需要将其在pom中引用依赖即可，SpringBoot为我们完成自动装配。</p><h5 id="自定义starter的命名规则"><a href="#自定义starter的命名规则" class="headerlink" title="自定义starter的命名规则"></a>自定义starter的命名规则</h5><p>　　SpringBoot提供的starter以<code>spring-boot-starter-xxx</code>的方式命名的。官方建议自定义的starter使用<code>xxx-spring-boot-starter</code>命名规则。以区分SpringBoot生态提供的starter。</p><h5 id="新建一个工程"><a href="#新建一个工程" class="headerlink" title="新建一个工程"></a>新建一个工程</h5><p>　　命名为demo-spring-boot-starter</p><p>　　下图为工程目录结构</p><p>　　<img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1635748-20190514214456549-79818005.png" alt="img"></p><h5 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"> 2 <span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">3</span>          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"> 4     <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> 5     <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"> 6         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> 7         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 8         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> 9     <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">10     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">11     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">12     <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">13     <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo-spring-boot-starter<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">14     <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">15 </span><br><span class="line">16     <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">17         <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">18     <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">19 </span><br><span class="line">20     <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">21 </span><br><span class="line">22         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">23             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">24             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">25             <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">26         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">27 </span><br><span class="line">28         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">29             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">30             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">31         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">32     <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">33 <span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="定义一个实体类映射配置信息"><a href="#定义一个实体类映射配置信息" class="headerlink" title="定义一个实体类映射配置信息"></a>定义一个实体类映射配置信息</h5><p> @ConfigurationProperties(prefix &#x3D; “demo”) 它可以把相同前缀的配置信息通过配置项名称映射成实体类，比如我们这里指定 prefix &#x3D; “demo” 这样，我们就能将以demo为前缀的配置项拿到了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.starter.properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：配置信息 实体</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> shf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/5/7 22:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> V1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String sayWhat;</span><br><span class="line">    <span class="keyword">private</span> String toWho;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSayWhat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sayWhat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSayWhat</span><span class="params">(String sayWhat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sayWhat = sayWhat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getToWho</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toWho;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setToWho</span><span class="params">(String toWho)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.toWho = toWho;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、定义一个Service"><a href="#4、定义一个Service" class="headerlink" title="4、定义一个Service"></a>4、定义一个Service</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.starter.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：随便定义一个Service</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> shf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/5/7 21:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> V1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String sayWhat;</span><br><span class="line">    <span class="keyword">public</span> String toWho;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoService</span><span class="params">(String sayWhat, String toWho)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.sayWhat = sayWhat;</span><br><span class="line">        <span class="built_in">this</span>.toWho = toWho;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.sayWhat + <span class="string">&quot;!  &quot;</span> + toWho;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5，定义一个配置类"><a href="#5，定义一个配置类" class="headerlink" title="5，定义一个配置类"></a>5，定义一个配置类</h5><p>这里，我们将DemoService类定义为一个Bean，交给Ioc容器。</p><p>▲ @Configuration 注解就不多说了。</p><p>▲ @EnableConfigurationProperties 注解。该注解是用来开启对3步骤中 @ConfigurationProperties 注解配置Bean的支持。也就是@EnableConfigurationProperties注解告诉Spring Boot 能支持@ConfigurationProperties。</p><p>当然了，也可以在 @ConfigurationProperties 注解的类上添加 @Configuration 或者 @Component 注解</p><p>▲ @ConditionalOnProperty 注解控制 @Configuration 是否生效。简单来说也就是我们可以通过在yml配置文件中控制 @Configuration 注解的配置类是否生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.starter.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.starter.properties.DemoProperties;</span><br><span class="line"><span class="keyword">import</span> com.demo.starter.service.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述：配置类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> shf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/5/7 21:50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> V1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DemoProperties.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">        prefix = &quot;demo&quot;,</span></span><br><span class="line"><span class="meta">        name = &quot;isopen&quot;,</span></span><br><span class="line"><span class="meta">        havingValue = &quot;true&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DemoProperties demoProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;demo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DemoService <span class="title function_">demoService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DemoService</span>(demoProperties.getSayWhat(), demoProperties.getToWho());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6、最重要的来了"><a href="#6、最重要的来了" class="headerlink" title="6、最重要的来了"></a>6、最重要的来了</h5><p>如图，新建META-INF文件夹，然后创建spring.factories文件，</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1635748-20190514220933924-541927671.png" alt="img"></p><p> 在该文件中加入如下配置，该配置指定上步骤中定义的配置类为自动装配的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 #-------starter自动装配---------</span><br><span class="line">2 org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.demo.starter.config.DemoConfig</span><br></pre></td></tr></table></figure><h5 id="7、测试"><a href="#7、测试" class="headerlink" title="7、测试"></a>7、测试</h5><p>在demo-spring-boot-starter工程中执行mvn clean install 进行starter打包，一个自定义的starter新鲜出炉。</p><p>新建测试工程</p><p>引入starter依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1         &lt;dependency&gt;</span><br><span class="line">2             &lt;groupId&gt;com.demo&lt;/groupId&gt;</span><br><span class="line">3             &lt;artifactId&gt;demo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">4             &lt;version&gt;0.0.1-RELEASE&lt;/version&gt;</span><br><span class="line">5         &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="springboot比spring优势"><a href="#springboot比spring优势" class="headerlink" title="springboot比spring优势"></a>springboot比spring优势</h4><h5 id="可快速构建独立的Spring应用"><a href="#可快速构建独立的Spring应用" class="headerlink" title="可快速构建独立的Spring应用"></a><strong>可快速构建独立的Spring应用</strong></h5><p>在构建Spring Boot项目时，只要根据需求选择对应的场景依赖，Spring Boot会自动添加该场景所需要的全部依赖并提供自动化配置，在无需额外手动添加配置的情况下可以快速构建出一个独立的Spring应用程序</p><h5 id="直接嵌入Tomcat、Jetty和Undertow服务器-无需部署WAR文件"><a href="#直接嵌入Tomcat、Jetty和Undertow服务器-无需部署WAR文件" class="headerlink" title="直接嵌入Tomcat、Jetty和Undertow服务器(无需部署WAR文件)"></a><strong>直接嵌入Tomcat、Jetty和Undertow服务器(无需部署WAR文件)</strong></h5><p>Spring Boot项目不需要像传统的Spring应用一样打成WAR包的形式部署到Tomcat、Jetty或Undertow服务器中，运行一个Spring Boot项目，可以直接将项目打成JAR包的形式，并通过命令“java -jar xx.jar”运行。这是因为，Spring Boot项目内嵌了Tomcat、Jetty和Undertow服务器，因此在部署过程中减少了对第三方插件的依赖和管理</p><h5 id="提供依赖启动器简化构建配置"><a href="#提供依赖启动器简化构建配置" class="headerlink" title="提供依赖启动器简化构建配置"></a><strong>提供依赖启动器简化构建配置</strong></h5><p>在Spring Boot项目构建过程中，<strong>无需准备各种独立的JAR文件</strong>，只需在构建项目时<strong>根据开发场景需求选择对应的依赖启动器“starter”即可</strong>，在引入的依赖启动器“starter”内部已经<strong>包含了对应开发场景所需的依赖</strong>，并会自动下载和拉取相关JAR包</p><h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><h4 id="什么是CAP理论和BASE思想？"><a href="#什么是CAP理论和BASE思想？" class="headerlink" title="什么是CAP理论和BASE思想？"></a>什么是CAP理论和BASE思想？</h4><p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标：</p><ul><li><strong>C</strong>onsistency（一致性）</li><li><strong>A</strong>vailability（可用性）</li><li><strong>P</strong>artition tolerance （分区容错性）</li></ul><p>它们的第一个字母分别是 <code>C</code>、<code>A</code>、<code>P</code>。Eric Brewer认为任何分布式系统架构方案都不可能同时满足这3个目标，这个结论就叫做 CAP 定理。</p><h5 id="Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。"><a href="#Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。" class="headerlink" title="Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。"></a><code>Consistency</code>（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。</h5><p>比如现在包含两个节点，其中的初始数据是一致的：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240326093108376.png" alt="image-20240326093108376"></p><p>当我们修改其中一个节点的数据时，两者的数据产生了差异：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240326093123964.png" alt="image-20240326093123964"></p><p>要想保住一致性，就必须实现node01 到 node02的数据 同步：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240326093135628.png" alt="image-20240326093135628"></p><h5 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h5><p>Availability （可用性）：用户访问分布式系统时，读或写操作总能成功。</p><p>只能读不能写，或者只能写不能读，或者两者都不能执行，就说明系统弱可用或不可用。</p><h5 id="分区容错"><a href="#分区容错" class="headerlink" title="分区容错"></a>分区容错</h5><p><code>Partition</code>，就是分区，就是当分布式系统节点之间出现网络故障导致节点之间无法通信的情况：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240326093155620.png" alt="image-20240326093155620"></p><p>如上图，node01和node02之间网关畅通，但是与node03之间网络断开。于是node03成为一个独立的网络分区；node01和node02在一个网络分区。</p><p><code>Tolerance</code>，就是容错，即便是系统出现网络分区，整个系统也要持续对外提供服务。</p><h5 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h5><p>在分布式系统中，网络不能100%保证畅通，也就是说网络分区的情况一定会存在。而我们的系统必须要持续运行，对外提供服务。所以分区容错性（<code>P</code>）是硬性指标，所有分布式系统都要满足。而在设计分布式系统时要取舍的就是一致性（<code>C</code>）和可用性（<code>A</code>）了。</p><p>假如现在出现了网络分区，如图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240326093213366.png" alt="image-20240326093213366"></p><p>由于网络故障，当我们把数据写入node01时，可以与node02完成数据同步，但是无法同步给node03。现在有两种选择：</p><ul><li>允许用户任意读写，保证可用性。但由于node03无法完成同步，就会出现数据不一致的情况。满足AP</li><li>不允许用户写，可以读，直到网络恢复，分区消失。这样就确保了一致性，但牺牲了可用性。满足CP</li></ul><h5 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h5><p>分布式系统要遵循CAP定理，人们在总结系统设计经验时，最终得到了一些心得：</p><ul><li><strong>B</strong>asically <strong>A</strong>vailable <strong>（</strong>基本可用<strong>）</strong>：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li><li><strong>S</strong>oft State<strong>（</strong>软状态<strong>）：</strong>在一定时间内，允许出现中间状态，比如临时的不一致状态。</li><li><strong>Ev</strong>entually Consistent<strong>（</strong>最终一致性<strong>）</strong>：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</li></ul><p>简单来说，BASE理论就是一种取舍的方案，不再追求完美，而是最终达成目标。因此解决分布式事务的思想也是这样，有两个方向：</p><ul><li>AP思想：各个子事务分别执行和提交，无需锁定数据。允许出现结果不一致，然后采用弥补措施恢复，实现最终一致即可。例如<code>AT</code>模式就是如此</li><li>CP思想：各个子事务执行后不要提交，而是等待彼此结果，然后同时提交或回滚。在这个过程中锁定资源，不允许其它人访问，数据处于不可用状态，但能保证一致性。例如<code>XA</code>模式</li></ul><h4 id="强一致性和最终一致性，要求举例"><a href="#强一致性和最终一致性，要求举例" class="headerlink" title="强一致性和最终一致性，要求举例"></a>强一致性和最终一致性，要求举例</h4><ul><li><strong>Strong consistency.</strong> 一旦更新操作完成，任何后续的访问都是最新的值。</li></ul><p>例子：MySQL的全同步复制模式，在该模式下用户与MySQL交互，主库和备库同binlog时，主库只有在收到备库的成功响应之后，才能够向客户端反馈提交成功。因此在用户获得响应时，主库和备库的数据副本已经达到了一致，所以后续的读操作肯定不会出现问题，这种模式称为<strong>强一致性</strong>。</p><ul><li><strong>Weak consistency.</strong> 系统并不保证续进程或者线程的访问都会返回最新的更新过的值。用户读到某一操作对系统特定数据的更新需要一段时间，我们称这段时间为“不一致性窗口”。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。</li><li><strong>Eventual consistency.</strong> 弱一致性的一种特殊形式；存储系统保证如果再也没有新的update，那么最终所有的访问将会返回最新更改的updated value。在没有故障的前提下，不一致窗口期由下列因素确定：通信延迟、系统负载、涉及的副本数量。最常见的实现最终一致性的系统是DNS，在DNS中，一个域名的更新操作将结合有过期机制的缓存被分发出去，最终所有的客户端都能看到最新的值。</li></ul><p>例子：数据库缓存的双写一致性</p><h4 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h4><p><strong>跨域的概念和原理</strong><br>跨域：请求位置和被请求位置不同源就会发生跨域。</p><p>这里的不同源包括两个点：</p><p>域名不同：<a href="http://www.baidu.com/">www.baidu.com</a> 和 <a href="http://www.taobao.com.(ip不同也是相同道理)/">www.taobao.com。（IP不同也是相同道理）</a><br>端口不同：127.0.0.1:8080和127.0.0.1:8081。<br>而浏览器又会禁止请求的发起者与服务端发生跨域AJAX请求。</p><p>如果发生了跨域请求，服务器端是能够正常响应的，但是响应的结果会被浏览器拦截。</p><p><strong>方式一，网关配置，统一处理跨域</strong></p><p>配置网关application.yml文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域配置</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line">        <span class="comment"># options请求 就是一种询问服务器是否浏览器可以跨域的请求</span></span><br><span class="line">        <span class="comment"># 如果每次跨域都有询问服务器是否浏览器可以跨域对性能也是损耗</span></span><br><span class="line">        <span class="comment"># 可以配置本次跨域检测的有效期maxAge</span></span><br><span class="line">        <span class="comment"># 在maxAge设置的时间范围内，不去询问，统统允许跨域</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求 </span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span><span class="comment"># 允许在请求中携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 本次跨域检测的有效期(单位毫秒)</span></span><br><span class="line">            <span class="comment"># 有效期内，跨域请求不会一直发option请求去增大服务器压力</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>方式2，全局配置跨域配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;HEAD&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>方式3，在各个controller上添加@CrossOrigin注解配置允许跨域规则</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsController</span> &#123;</span><br><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://localhost:4000&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;goods-url&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">queryGoodsWithGoodsUrl</span><span class="params">(<span class="meta">@RequestParam</span> String goodsUrl)</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>通过 CorsFilter 跨域</strong></p><p>此实现方式和上一种实现方式类似，<strong>它也可以实现全局跨域</strong>，它的具体实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 一定不能忽略此注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCorsFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建 CORS 配置对象</span></span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        <span class="comment">// 支持域</span></span><br><span class="line">        config.addAllowedOriginPattern(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 是否发送 Cookie</span></span><br><span class="line">        config.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 支持请求方式</span></span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 允许的原始请求头部信息</span></span><br><span class="line">        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 暴露的头部信息</span></span><br><span class="line">        config.addExposedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.添加地址映射</span></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">corsConfigurationSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        corsConfigurationSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br></pre></td></tr></table></figure><h4 id="讲讲使用过的RPC框架，RPC的意义？"><a href="#讲讲使用过的RPC框架，RPC的意义？" class="headerlink" title="讲讲使用过的RPC框架，RPC的意义？"></a>讲讲使用过的RPC框架，RPC的意义？</h4><h5 id="openFeign是不是RPC框架？是的"><a href="#openFeign是不是RPC框架？是的" class="headerlink" title="openFeign是不是RPC框架？是的"></a>openFeign是不是RPC框架？是的</h5><p>RPC尽可以不那么复杂，你像调本地接口一样调用<a href="https://www.zhihu.com/search?q=%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1249221512%7D">远程接口</a>的方式，就是RPC。</p><p>实际上RPC也就是一种编程模型，初衷就是你可以不在乎底层的网络<a href="https://www.zhihu.com/search?q=%E6%8A%80%E6%9C%AF%E5%8D%8F%E8%AE%AE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1249221512%7D">技术协议</a>而实现远程调用</p><p>无论基于Http协议还是基于TCP协议都不影响他是RPC框架</p><p>意义：服务拆分之后，不同微服务在不同服务器上，不可避免的会出现跨微服务的业务，此时微服务之间就需要进行远程调用</p><h4 id="SpringCloud有哪些常用组件？分别是什么作用？"><a href="#SpringCloud有哪些常用组件？分别是什么作用？" class="headerlink" title="SpringCloud有哪些常用组件？分别是什么作用？"></a>SpringCloud有哪些常用组件？分别是什么作用？</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711251119152-5.png" alt="img"></p><h5 id="服务发现："><a href="#服务发现：" class="headerlink" title="服务发现："></a>服务发现：</h5><p>每个<code>服务提供者</code>的实例其IP或端口不同，服务注册发现就是提供对服务提供者的注册服务、心跳检测，提供对服务消费者的服务订阅（推送服务提供者的地址和状态）和变更推送（服务提供者宕机、新增实例等）</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711259708542-8.jpeg" alt="img"></p><p>流程如下：</p><ul><li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡，挑选一个实例</li><li>调用者向该实例发起远程调用</li></ul><p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p><ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表</li></ul><h5 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h5><p>让远程调用像调用本地方法一样简单，feign替我们完成了服务拉取、负载均衡、发送http请求的所有工作。</p><p>远程调用的抽取分析：</p><p>相信大家都能想到，避免重复编码的办法就是<strong>抽取</strong>。不过这里有两种抽取思路：</p><ul><li>思路1：抽取到微服务之外的公共module</li><li>思路2：每个微服务自己抽取一个module</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711260973599-11.jpeg" alt="img"></p><p>方案1抽取更加简单，工程结构也比较清晰，但缺点是整个项目耦合度偏高。</p><p>方案2抽取相对麻烦，工程结构相对更复杂，但服务之间耦合度降低。</p><h5 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h5><p>网关就是<strong>网</strong>络的<strong>关</strong>口。数据在网络间传输，从一个网络传输到另一网络时就需要经过网关来做数据的<strong>路由和转发以及数据安全的校验</strong>。</p><p>前端请求不能直接访问微服务，而是要请求网关：</p><ul><li>网关可以做安全控制，也就是登录身份校验，校验通过才放行</li><li>通过认证后，网关再根据请求判断应该访问哪个微服务，将请求转发过去</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711261382102-14.jpeg" alt="img"></p><p><strong>网关过滤器</strong></p><p>登录校验必须在请求转发到微服务之前做，否则就失去了意义。而网关的请求转发是<code>Gateway</code>内部代码实现的，要想在请求转发之前做登录校验，就必须了解<code>Gateway</code>内部工作的基本原理。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240324143603975.png" alt="image-20240324143603975"></p><p>如图所示：</p><ol><li>客户端请求进入网关后由<code>HandlerMapping</code>对请求做判断，找到与当前请求匹配的路由规则（**<code>Route</code>**），然后将请求交给<code>WebHandler</code>去处理。</li><li><code>WebHandler</code>则会加载当前路由下需要执行的过滤器链（**<code>Filter chain</code><strong>），然后按照顺序逐一执行过滤器（后面称为</strong><code>Filter</code>**）。</li><li>图中<code>Filter</code>被虚线分为左右两部分，是因为<code>Filter</code>内部的逻辑分为<code>pre</code>和<code>post</code>两部分，分别会在请求路由到微服务<strong>之前</strong>和<strong>之后</strong>被执行。</li><li>只有所有<code>Filter</code>的<code>pre</code>逻辑都依次顺序执行通过后，请求才会被路由到微服务。</li><li>微服务返回结果后，再倒序执行<code>Filter</code>的<code>post</code>逻辑。</li><li>最终把响应结果返回。</li></ol><p>如图中所示，最终请求转发是有一个名为<code>NettyRoutingFilter</code>的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最靠后的一个。<strong>如果我们能够定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到</strong>**<code>NettyRoutingFilter</code>**<strong>之前</strong>，这就符合我们的需求了！</p><h5 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h5><p>解决的问题：</p><ul><li>网关路由在配置文件中写死了，如果变更必须重启微服务</li><li>某些业务配置在配置文件中写死了，每次修改都要重启服务</li><li>每个微服务都有很多重复的配置，维护成本高</li></ul><p>这些问题都可以通过统一的<strong>配置管理器服务</strong>解决。而Nacos不仅仅具备注册中心功能，也具备配置管理的功能：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711263205925-131.jpeg" alt="img"></p><p>微服务共享的配置可以统一交给Nacos保存和管理，在Nacos控制台修改配置后，Nacos会将配置变更推送给相关的微服务，并且无需重启即可生效，实现配置热更新。</p><p>网关的路由同样是配置，因此同样可以基于这个功能实现动态路由功能，无需重启网关即可修改路由配置。</p><h5 id="流控管理（请求限流、线程隔离、熔断降级）"><a href="#流控管理（请求限流、线程隔离、熔断降级）" class="headerlink" title="流控管理（请求限流、线程隔离、熔断降级）"></a>流控管理（请求限流、线程隔离、熔断降级）</h5><p><strong>请求限流</strong></p><p>请求限流，就是<strong>限制或控制</strong>接口访问的并发流量，避免服务因流量激增而出现故障。</p><p>请求限流往往会有一个限流器，数量高低起伏的并发请求曲线，经过限流器就变的非常平稳。这就像是水电站的大坝，起到蓄水的作用，可以通过开关控制水流出的大小，让下游水流始终维持在一个平稳的量。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711264180168-134.jpeg" alt="img"></p><p><strong>线程隔离</strong></p><p>当一个业务接口响应时间长，而且并发高时，就可能耗尽服务器的线程资源，导致服务内的其它接口受到影响。所以我们必须把这种影响降低，或者缩减影响的范围。线程隔离正是解决这个问题的好办法。</p><p>为了避免某个接口故障或压力过大导致整个服务不可用，我们可以限定每个接口可以使用的资源范围（线程数），也就是将其“隔离”起来。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240324151113019.png" alt="image-20240324151113019"></p><p>如图所示，我们给查询购物车业务限定可用线程数量上限为20，这样即便查询购物车的请求因为查询商品服务而出现故障，也不会导致服务器的线程资源被耗尽，不会影响到其它接口。</p><p><strong>服务熔断</strong></p><p>线程隔离虽然避免了雪崩问题，但故障服务（商品服务）依然会拖慢购物车服务（服务调用方）的接口响应速度。而且商品查询的故障依然会导致查询购物车功能出现故障，购物车业务也变的不可用了。</p><p>所以，我们要做两件事情：</p><ul><li><strong>编写服务降级逻辑</strong>：就是服务调用失败后的处理逻辑，根据业务场景，可以抛出异常，也可以返回友好提示或默认数据。</li><li><strong>异常统计和熔断</strong>：统计服务提供方的异常比例，当比例过高表明该接口会影响到其它服务，应该拒绝调用该接口，而是直接走降级逻辑。</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240324151036427.png" alt="image-20240324151036427"></p><h5 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h5><p><strong>Seata的XA模型</strong></p><p>Seata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711264557508-140.png" alt="img"></p><p><code>RM</code>一阶段的工作：</p><ol><li>注册分支事务到<code>TC</code></li><li>执行分支业务sql但不提交</li><li>报告执行状态到<code>TC</code></li></ol><p><code>TC</code>二阶段的工作：</p><ol><li><code>TC</code>检测各分支事务执行状态<ol><li>如果都成功，通知所有RM提交事务</li><li>如果有失败，通知所有RM回滚事务</li></ol></li></ol><p><code>RM</code>二阶段的工作：</p><ul><li>接收<code>TC</code>指令，提交或回滚事务</li></ul><p><strong>优缺点</strong></p><p><code>XA</code>模式的优点是什么？</p><ul><li>事务的强一致性，满足ACID原则</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p><code>XA</code>模式的缺点是什么？</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul><p><strong>AT模式</strong></p><p><code>AT</code>模式同样是分阶段提交的事务模型，不过缺弥补了<code>XA</code>模型中资源锁定周期过长的缺陷。</p><p><strong>Seata的AT模型</strong></p><p>基本流程图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711264557508-142.png" alt="img"></p><p><strong>AT与XA的区别</strong></p><p>简述<code>AT</code>模式与<code>XA</code>模式最大的区别是什么？</p><ul><li><code>XA</code>模式一阶段不提交事务，锁定资源；<code>AT</code>模式一阶段直接提交，不锁定资源。</li><li><code>XA</code>模式依赖数据库机制实现回滚；<code>AT</code>模式利用数据快照实现数据回滚。</li><li><code>XA</code>模式强一致；<code>AT</code>模式最终一致</li></ul><p>可见，AT模式使用起来更加简单，无业务侵入，性能更好。因此企业90%的分布式事务都可以用AT模式来解决。</p><h4 id="Eureka和Nacos有哪些区别？"><a href="#Eureka和Nacos有哪些区别？" class="headerlink" title="Eureka和Nacos有哪些区别？"></a>Eureka和Nacos有哪些区别？</h4><p>Eureka和Nacos都能起到注册中心的作用，用法基本类似。但还是有一些区别的，例如：</p><ul><li>Nacos支持配置管理，而Eureka则不支持。</li></ul><p>而且服务注册发现上也有区别，我们来做一个实验：</p><p>我们停止<code>user-service</code>服务，然后观察Eureka控制台，你会发现很长一段时间过去后，Eureka服务依然没有察觉<code>user-service</code>的异常状态。</p><p>这与Eureka的健康检测机制有关。在Eureka中，健康检测的原理如下：</p><ul><li>微服务启动时注册信息到Eureka，这点与Nacos一致。</li><li>微服务每隔30秒向Eureka发送心跳请求，报告自己的健康状态。Nacos中默认是5秒一次。</li><li>Eureka如果90秒未收到心跳，则认为服务疑似故障，可能被剔除。Nacos中则是15秒超时，30秒剔除。</li><li>Eureka如果发现超过85%比例的服务都心跳异常，会认为是自己的网络异常，暂停剔除服务的功能。</li><li>Eureka每隔60秒执行一次服务检测和清理任务；Nacos是每隔5秒执行一次。</li></ul><p>综上，你会发现Eureka是尽量不剔除服务，避免“误杀”，宁可放过一千，也不错杀一个。这就导致当服务真的出现故障时，迟迟不会被剔除，给服务的调用者带来困扰。</p><p>不仅如此，当Eureka发现服务宕机并从服务列表中剔除以后，并不会将服务列表的变更消息推送给所有微服务。而是等待微服务自己来拉取时发现服务列表的变化。而微服务每隔30秒才会去Eureka更新一次服务列表，进一步推迟了服务宕机时被发现的时间。</p><p>而Nacos中微服务除了自己定时去Nacos中拉取服务列表以外，Nacos还会在服务列表变更时主动推送最新的服务列表给所有的订阅者。</p><p>综上，Eureka和Nacos的相似点有：</p><ul><li>都支持服务注册发现功能</li><li>都有基于心跳的健康监测功能</li><li>都支持集群，集群间数据同步默认是AP模式，即最全高可用性</li></ul><p>Eureka和Nacos的区别有：</p><ul><li>Eureka的心跳是30秒一次，Nacos则是5秒一次</li><li>Eureka如果90秒未收到心跳，则认为服务疑似故障，可能被剔除。Nacos中则是15秒超时，30秒剔除。</li><li>Eureka每隔60秒执行一次服务检测和清理任务；Nacos是每隔5秒执行一次。</li><li>Eureka只能等微服务自己每隔30秒更新一次服务列表；Nacos即有定时更新，也有在服务变更时的广播推送</li><li>Eureka仅有注册中心功能，而Nacos同时支持注册中心、配置管理</li><li>Eureka和Nacos都支持集群，而且默认都是AP模式</li></ul><h4 id="Nacos的分级存储模型是什么意思？"><a href="#Nacos的分级存储模型是什么意思？" class="headerlink" title="Nacos的分级存储模型是什么意思？"></a>Nacos的分级存储模型是什么意思？</h4><h4 id="Ribbon和SpringCloudLoadBalancer有什么差异"><a href="#Ribbon和SpringCloudLoadBalancer有什么差异" class="headerlink" title="Ribbon和SpringCloudLoadBalancer有什么差异"></a>Ribbon和SpringCloudLoadBalancer有什么差异</h4><h4 id="什么是服务雪崩，常见的解决方案有哪些？"><a href="#什么是服务雪崩，常见的解决方案有哪些？" class="headerlink" title="什么是服务雪崩，常见的解决方案有哪些？"></a>什么是服务雪崩，常见的解决方案有哪些？</h4><h4 id="Hystix和Sentinel有什么区别和联系？"><a href="#Hystix和Sentinel有什么区别和联系？" class="headerlink" title="Hystix和Sentinel有什么区别和联系？"></a>Hystix和Sentinel有什么区别和联系？</h4><h4 id="限流的常见算法有哪些？"><a href="#限流的常见算法有哪些？" class="headerlink" title="限流的常见算法有哪些？"></a>限流的常见算法有哪些？</h4><p>首先我们来看下线程隔离功能，无论是Hystix还是Sentinel都支持线程隔离。不过其实现方式不同。</p><p>线程隔离有两种方式实现：</p><ul><li><strong>线程池****隔离</strong>：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果</li><li><strong>信号量****隔离</strong>：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求</li></ul><p>如图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711441007531-254.jpeg" alt="img"></p><h5 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h5><p>在熔断功能中，需要统计异常请求或慢请求比例，也就是计数。在限流的时候，要统计每秒钟的QPS，同样是计数。可见计数算法在熔断限流中的应用非常多。sentinel中采用的计数器算法就是滑动窗口计数算法。</p><p><strong>固定窗口计数</strong></p><p>要了解滑动窗口计数算法，我们必须先知道固定窗口计数算法，其基本原理如图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711441289343-266.png" alt="img"></p><p>说明：</p><ul><li>将时间划分为多个窗口，窗口时间跨度称为<code>Interval</code>，本例中为1000ms；</li><li>每个窗口维护1个计数器，每有1次请求就将计数器<code>+1</code>。限流就是设置计数器阈值，本例为3，图中红线标记</li><li>如果计数器超过了限流阈值，则超出阈值的请求都被丢弃。</li></ul><p>示例：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711441289343-267.png" alt="img"></p><p>说明：</p><ul><li>第1、2秒，请求数量都小于3，没问题</li><li>第3秒，请求数量为5，超过阈值，超出的请求被拒绝</li></ul><p>但是我们考虑一种特殊场景，如图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711441289343-268.png" alt="img"></p><p>说明：</p><ul><li>假如在第5、6秒，请求数量都为3，没有超过阈值，全部放行</li><li>但是，如果第5秒的三次请求都是在4.5<del>5秒之间进来；第6秒的请求是在5</del>5.5之间进来。那么从第4.5~5.之间就有6次请求！也就是说每秒的QPS达到了6，远超阈值。</li></ul><p>这就是固定窗口计数算法的问题，它只能统计当前某1个时间窗的请求数量是否到达阈值，无法结合前后的时间窗的数据做综合统计。</p><p>因此，我们就需要滑动时间窗口算法来解决。</p><p><strong>滑动窗口计数</strong></p><p>固定时间窗口算法中窗口有很多，其跨度和位置是与时间区间绑定，因此是很多固定不动的窗口。而滑动时间窗口算法中只包含1个固定跨度的窗口，但窗口是可移动动的，与时间区间无关。</p><p>具体规则如下：</p><ul><li>窗口时间跨度<code>Interval</code>大小固定，例如1秒</li><li>时间区间跨度为<code>Interval / n</code> ，例如n&#x3D;2，则时间区间跨度为500ms</li><li>窗口会随着当前请求所在时间<code>currentTime</code>移动，窗口范围从<code>currentTime-Interval</code>时刻之后的第一个时区开始，到<code>currentTime</code>所在时区结束。</li></ul><p>如图所示：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711441289344-269.png" alt="img"></p><p>限流阈值依然为3，绿色小块就是请求，上面的数字是其<code>currentTime</code>值。</p><ul><li>在第1300ms时接收到一个请求，其所在时区就是1000~1500</li><li>按照规则，currentTime-Interval值为300ms，300ms之后的第一个时区是500<del>1000，因此窗口范围包含两个时区：500</del>1000、1000~1500，也就是粉红色方框部分</li><li>统计窗口内的请求总数，发现是3，未达到上限。</li></ul><p>若第1400ms又来一个请求，会落在1000~1500时区，虽然该时区请求总数是3，但滑动窗口内总数已经达到4，因此该请求会被拒绝：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711441289344-270.png" alt="img"></p><p>假如第1600ms又来的一个请求，处于1500<del>2000时区，根据算法，滑动窗口位置应该是1000</del>1500和1500~2000这两个时区，也就是向后移动：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711441289344-271.png" alt="img"></p><p>这就是滑动窗口计数的原理，解决了我们之前所说的问题。而且滑动窗口内划分的时区越多，这种统计就越准确。</p><h5 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h5><p>限流的另一种常见算法是令牌桶算法。Sentinel中的热点参数限流正是基于令牌桶算法实现的。其基本思路如图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711441149182-263.png" alt="img"></p><p>说明：</p><ul><li>以固定的速率生成令牌，存入令牌桶中，如果令牌桶满了以后，多余令牌丢弃</li><li>请求进入后，必须先尝试从桶中获取令牌，获取到令牌后才可以被处理</li><li>如果令牌桶中没有令牌，则请求等待或丢弃</li></ul><p>基于令牌桶算法，每秒产生的令牌数量基本就是QPS上限。</p><p>当然也有例外情况，例如：</p><ul><li>某一秒令牌桶中产生了很多令牌，达到令牌桶上限N，缓存在令牌桶中，但是这一秒没有请求进入。</li><li>下一秒的前半秒涌入了超过2N个请求，之前缓存的令牌桶的令牌耗尽，同时这一秒又生成了N个令牌，于是总共放行了2N个请求。超出了我们设定的QPS阈值。</li></ul><p>因此，在使用令牌桶算法时，尽量不要将令牌上限设定到服务能承受的QPS上限。而是预留一定的波动空间，这样我们才能应对突发流量。</p><h6 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h6><p>漏桶算法与令牌桶相似，但在设计上更适合应对并发波动较大的场景，以解决令牌桶中的问题。</p><p>简单来说就是请求到达后不是直接处理，而是先放入一个队列。而后以固定的速率从队列中取出并处理请求。之所以叫漏桶算法，就是把请求看做水，队列看做是一个漏了的桶。</p><p>如图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711441109905-257.png" alt="img"></p><p>说明：</p><ul><li>将每个请求视作”水滴”放入”漏桶”进行存储；</li><li>“漏桶”以固定速率向外”漏”出请求来执行，如果”漏桶”空了则停止”漏水”；</li><li>如果”漏桶”满了则多余的”水滴”会被直接丢弃。</li></ul><p>漏桶的优势就是<strong>流量整型</strong>，桶就像是一个大坝，请求就是水。并发量不断波动，就如图水流时大时小，但都会被大坝拦住。而后大坝按照固定的速度放水，避免下游被洪水淹没。</p><p>因此，不管并发量如何波动，经过漏桶处理后的请求一定是相对平滑的曲线：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711441109905-258.png" alt="img"></p><h4 id="项目中碰到过分布式事务问题吗？怎么解决的？"><a href="#项目中碰到过分布式事务问题吗？怎么解决的？" class="headerlink" title="项目中碰到过分布式事务问题吗？怎么解决的？"></a>项目中碰到过分布式事务问题吗？怎么解决的？</h4><h5 id="RocketMQ实现分布式事务原理"><a href="#RocketMQ实现分布式事务原理" class="headerlink" title="RocketMQ实现分布式事务原理"></a>RocketMQ实现分布式事务原理</h5><p>RocketMQ在4.3版本开始提供了分布式事务功能，使用RocketMQ事务消息来达到 分布式事务的最终一致性；而不是像其他分布式事务的解决方案：2PC、3PC、TCC那样是强一致性事务。</p><p>在聊具体实现之前，我们先聊一下相关的基础概念：半消息、消息回查。</p><p>1、基础概念<br><strong>半消息（Half Message）：</strong></p><p>暂时无法被消费的消息。生产者将消息发送到MQ Server，但这个消息会被标记为“暂不能投递”状态，先存储起来；消费者不会去消费这条消息。<br>只有Producer对消息进行confirm之后，消费者才会消费这条消息或丢弃这条消息。<br><strong>消息回查：</strong></p><p>网络断开或生产者重启可能会导致丢失事务消息的第二次确认。所以当MQ Server发现消息长时间处于半消息状态时，将向消息生产者发送请求，询问该消息的最终状态是提交还是回滚。</p><p><strong>事务消息的三种状态：</strong></p><p>Commit：提交事务消息，消费者可以消费此消息<br>Rollback：回滚事务消息，broker会删除该消息，消费者不能消费<br>UNKNOWN：broker需要回查确认该消息的状态。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzE0ODgy,size_16,color_FFFFFF,t_70.jpeg" alt="img"></p><ul><li><strong>分布式事务交互流程</strong>在系统A处理任务A前，首先向消息中间件发送一条消息,如果MQ发送失败直接取消操作</li><li>消息中间件收到后将该条消息持久化，但并不投递(未conmmit提交)。此时下游系统B仍然不知道该条消息的存在</li><li>消息中间件持久化成功后，便向系统A返回一个确认应答(传递到MQ消息队列,等待Conmiit)</li><li>系统A收到确认应答后，则可以开始处理任务A的本地事务</li><li>任务A处理完成后，向消息中间件发送Commit请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了，此时它可以处理别的任务了</li><li>消息中间件收到Commit指令后，便向系统B投递该消息，从而触发任务B的执行</li><li>当任务B执行完成后，系统B向消息中间件返回一个确认应答，此时，这个分布式事务完成</li><li>从上面流程可以得知只有A服务本地事务执行成功 ，B服务才能消费该message。</li></ul><p>然后，我们思考几个问题。</p><p>1）为什么要发送半消息？</p><ul><li><p>让我们知道Broker服务是否还活着，如果半消息发送失败，说明broker挂了。</p></li><li><p>确保Producer端的事务执行完毕之后，consumer端事务可以执行；Producer端事务执行失败，consumer端事务则不会执行。</p></li><li><p>通过回查机制保障由于网络中断、Producer宕机引起的事务消息无法确认问题。</p></li></ul><p>2）什么情况下会回查？</p><ul><li><p>Producer重启或宕机导致丢失事务消息的第二次确认。</p></li><li><p>Producer发送二次确认消息时，网络问题导致Broker未接收到第二次确认。</p></li><li><p>说白了一种是Producer没发确认消息、另一种是Producer发了确认消息但Broker没收到。</p></li></ul><p>3）为什么说RocketMQ的分布式事务是最终一致性？</p><p>服务A发送确认半消息之后，服务B可以消费到消息，但是服务B可能会处理消息失败，然而服务A不关心，我已经投递消息成功了，我就认为这个事务成功了。<br>消息中间件向系统B投递完消息后便进入阻塞等待状态，如果消息在传递过程中丢失或者消息的确认应答在返回途中丢失，那么消息中间件在等待超时后会重新投递(重试机制)直到消息被系统B成功消费为止,多次重试失败后，也没有关系，将该异常记录下来，由人工处理，人工兜底处理后，就可以让事务达到最终的一致性。</p><p>RocketMQ通过TransactionListener的两个方法实现执行本地事务、回查机制：</p><p>executeLocalTransaction –&gt; 半消息发送成功触发此方法来执行本地事务</p><p>checkLocalTransaction –&gt; broker将发送检查消息来检查事务状态，并将调用此方法来获取本地事务状态</p><h4 id="AT模式如何解决脏读和脏写问题的？"><a href="#AT模式如何解决脏读和脏写问题的？" class="headerlink" title="AT模式如何解决脏读和脏写问题的？"></a>AT模式如何解决脏读和脏写问题的？</h4><p>AT模式分为两个阶段：</p><p>第一阶段是记录数据快照，执行并提交事务：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711417093753-230.png" alt="img"></p><p>第二阶段根据阶段一的结果来判断：</p><ul><li>如果每一个分支事务都成功，则事务已经结束（因为阶段一已经提交），因此删除阶段一的快照即可</li><li>如果有任意分支事务失败，则需要根据快照恢复到更新前数据。然后删除快照</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711417093753-231.png" alt="img"></p><p>这种模式在大多数情况下（99%）并不会有什么问题，不过在极端情况下，特别是多线程并发访问AT模式的分布式事务时，有可能出现脏写问题，如图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711417093753-232.png" alt="img"></p><p>解决思路就是引入了全局锁的概念。在释放DB锁之前，先拿到全局锁。避免同一时刻有另外一个事务来操作当前数据。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711417093753-233.png" alt="img"></p><h4 id="TCC模式与AT模式对比，有哪些优缺点"><a href="#TCC模式与AT模式对比，有哪些优缺点" class="headerlink" title="TCC模式与AT模式对比，有哪些优缺点"></a>TCC模式与AT模式对比，有哪些优缺点</h4><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><h4 id="说说Redis的理解"><a href="#说说Redis的理解" class="headerlink" title="说说Redis的理解"></a>说说Redis的理解</h4><ol><li>Redis 是一个高性能的基于 Key-Value 结构存储的 Nosql 开源数据库。</li><li>目前市面上绝大部分公司都采用 Redis 来实现分布式缓存，从而提高数据的检索效率。</li><li>Redis 之所以这么流行，主要有几个特点：<br>a. 它是基于内存存储，在进行数据 IO 操作时，能够 10WQPS<br>b. 提供了非常丰富的数据存储结构，如 String、List、Hash、Set、ZSet 等。<br>c. Redis 底层采用单线程实现数据的 IO，所以在数据算法层面并不需要要考虑并发安全性，所以底层算法上的时间复杂度基本上都是常量。</li><li>Redis 虽然是内存存储，但是它也可以支持持久化，避免因为服务器故障导致数据丢失的问题<br>基于这些特点，Redis 一般用来实现分布式缓存，从而降低应用程序对关系型数据库检索带来的性能影响。除此之外，Redis 还可以实现分布式锁、分布式队列、排行榜、查找附近的人等功能，为复杂应用提供非常方便和成熟的解决方案</li></ol><h3 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h3><h4 id="redis为什么更快？"><a href="#redis为什么更快？" class="headerlink" title="redis为什么更快？"></a>redis为什么更快？</h4><ul><li>Redis 基于内存，内存的访问速度是磁盘的上千倍；</li><li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，像单线程事件循环和 IO 多路复用等模式</li><li>Redis 采用单线程模型可以<strong>避免了多线程之间的竞争</strong>，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题</li><li>Redis 内置了多种优化过后的数据结构实现，性能非常高。</li></ul><h4 id="为什么要用-Redis？为什么不用本地缓存？"><a href="#为什么要用-Redis？为什么不用本地缓存？" class="headerlink" title="为什么要用 Redis？为什么不用本地缓存？"></a>为什么要用 Redis？为什么不用本地缓存？</h4><p><strong>高性能</strong></p><p>redis是基于内存的，数据库是基于磁盘的，访问Redis缓存的速度比直接访问数据库要快得多</p><p><strong>高并发</strong></p><p>相比于数据库，使用Redis能够承受更多的请求，我们可以把数据库中高频数据放到Redis缓存中，可以提高系统整体的并发度。</p><h5 id="1、本地缓存资源浪费"><a href="#1、本地缓存资源浪费" class="headerlink" title="1、本地缓存资源浪费"></a>1、本地缓存资源浪费</h5><p>存在本地缓存，同一个数据每一个节点都需要存一份，10过节点的集群就浪费了9份，造成数据冗余。</p><h5 id="2、本地缓存有内存一致性问题"><a href="#2、本地缓存有内存一致性问题" class="headerlink" title="2、本地缓存有内存一致性问题"></a>2、本地缓存有内存一致性问题</h5><p>不同节点的本地内存数据，版本会不一致。就是说A节点数据值是x2，而B节点还没来得及更新还是x1。会导致不同用户请求，甚至同一个用户请求打到不同节点上，值不一样，造成业务错误。</p><h5 id="3、本地缓存的机器内存有限"><a href="#3、本地缓存的机器内存有限" class="headerlink" title="3、本地缓存的机器内存有限"></a>3、本地缓存的机器内存有限</h5><p>redis集群模式，是分片的，内存理论上可以无线扩展，轻松存个几百G。而业务程序不可能存的下。</p><h4 id="Redis-常用的数据结构有哪些"><a href="#Redis-常用的数据结构有哪些" class="headerlink" title="Redis 常用的数据结构有哪些"></a>Redis 常用的数据结构有哪些</h4><p><strong>5 种基础数据结构</strong></p><ul><li><h5 id="String-最常用的数据结构"><a href="#String-最常用的数据结构" class="headerlink" title="String  最常用的数据结构"></a>String  最常用的数据结构</h5></li></ul><p>​缓存验证码，保存数量，存储对象数据</p><ul><li><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5></li></ul><p></p><p>​简易消息队列：利用List的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。</p><ul><li><h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5></li></ul><p>​主要用于存储部分经常变更的数据，比如存储用户信息</p><ul><li><h5 id="set：去重的集合，通过hash-table实现的，可以进行添加、删除和查找。对集合我们可以取并集，交集，差集"><a href="#set：去重的集合，通过hash-table实现的，可以进行添加、删除和查找。对集合我们可以取并集，交集，差集" class="headerlink" title="set：去重的集合，通过hash table实现的，可以进行添加、删除和查找。对集合我们可以取并集，交集，差集."></a>set：去重的集合，通过hash table实现的，可以进行添加、删除和查找。对集合我们可以取并集，交集，差集.</h5><p>微博、用户将所有关注的人都放入到一个set集合当中，将它的粉丝也放在一个集合中。</p><p>共同关注、共同爱好、QQ的好友推荐</p></li><li><h5 id="Zset：在set的基础上，每一个value都还有一个score"><a href="#Zset：在set的基础上，每一个value都还有一个score" class="headerlink" title="Zset：在set的基础上，每一个value都还有一个score"></a>Zset：在set的基础上，每一个value都还有一个score</h5><p>存储班级成绩表、工资表排序、点赞按时间排序等</p></li></ul><p><strong>3 种特殊数据结构</strong></p><h5 id="Geospatial-地理位置-：用经纬度来添加地点，范围搜索，地点间距离等。"><a href="#Geospatial-地理位置-：用经纬度来添加地点，范围搜索，地点间距离等。" class="headerlink" title="Geospatial (地理位置)：用经纬度来添加地点，范围搜索，地点间距离等。"></a>Geospatial (地理位置)：用经纬度来添加地点，范围搜索，地点间距离等。</h5><p>应用场景：附近的人，附件店铺</p><h5 id="HyperLogLogs（基数统计）：基于统计学的基数统计，有轻微误差，占用的内存是固定的，2-64不同元素的技术，只需要费12KB内存"><a href="#HyperLogLogs（基数统计）：基于统计学的基数统计，有轻微误差，占用的内存是固定的，2-64不同元素的技术，只需要费12KB内存" class="headerlink" title="HyperLogLogs（基数统计）：基于统计学的基数统计，有轻微误差，占用的内存是固定的，2^64不同元素的技术，只需要费12KB内存"></a>HyperLogLogs（基数统计）：基于统计学的基数统计，有轻微误差，占用的内存是固定的，2^64不同元素的技术，只需要费12KB内存</h5><p>网页的UV（Unique Visitor一个人访问一个网站多次，但是还是算作一个人）</p><h5 id="Bitmap-（位存储）：位图，都是操作二进制位来进行记录，每一位就只有0和1两个状态。"><a href="#Bitmap-（位存储）：位图，都是操作二进制位来进行记录，每一位就只有0和1两个状态。" class="headerlink" title="Bitmap （位存储）：位图，都是操作二进制位来进行记录，每一位就只有0和1两个状态。"></a>Bitmap （位存储）：位图，都是操作二进制位来进行记录，每一位就只有0和1两个状态。</h5><p>统计用户信息、活跃、不活跃、登录、未登录、打卡等等… 两个状态的都可以使用Bitmap。</p><h4 id="String-还是-Hash-存储对象数据更好呢？"><a href="#String-还是-Hash-存储对象数据更好呢？" class="headerlink" title="String 还是 Hash 存储对象数据更好呢？"></a>String 还是 Hash 存储对象数据更好呢？</h4><ul><li>String 存储的是序列化后的对象数据，<strong>存放的是整个对象</strong>。Hash 是把对象的<strong>每个字段单独存储</strong>，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中<strong>某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息</strong>，Hash 就非常适合。</li><li>String 存储相对来说<strong>更加节省内存</strong>，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li></ul><p>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</p><h4 id="使用keys指令会发生什么"><a href="#使用keys指令会发生什么" class="headerlink" title="使用keys指令会发生什么"></a>使用keys指令会发生什么</h4><p>Redis是单线程的，keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取指令模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h4 id="redis缓存穿透、缓存击穿、缓存雪崩是什么？怎么解决？（重要）"><a href="#redis缓存穿透、缓存击穿、缓存雪崩是什么？怎么解决？（重要）" class="headerlink" title="redis缓存穿透、缓存击穿、缓存雪崩是什么？怎么解决？（重要）"></a>redis缓存穿透、缓存击穿、缓存雪崩是什么？怎么解决？（重要）</h4><h5 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="什么是缓存穿透？"></a>什么是缓存穿透？</h5><p>缓存穿透说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><ul><li>首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端</li><li>缓存空对象，如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</li><li>布隆过滤器</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240319204503970.png" alt="image-20240319204503970"></p><h5 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h5><p>布隆过滤器是一种数据结构用于快速检查一个元素是否属于某个集合中。它可以快速判断一个元素是否在一个大型集合中，且判断速度很快且不占用太多内存空间。</p><p>布隆过滤器原理：<br>布隆过滤器的主要原理是使用一组哈希函数，将元素映射成一组bit数组中的索引位置。</p><ul><li>当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。</li><li>检索的时候，使用同样的方式去映射，只要看到每个映射的位置的值是不是 1，就可以大概知道该元素是否存在集合中了。</li><li>如果这些点有任何一个 0，则被检查的元素一定不在；如果都是 1，则被检查的元素很可能存在。</li></ul><p>例子：</p><p>比如我们一共有3个key，我们对这3个key分别进行3次hash运算，key1经过三次hash运算后的结果分别为2&#x2F;6&#x2F;10，那么就把布隆过滤器中下标为2&#x2F;6&#x2F;10的元素值更新为1，然后再分别对key2和key3做同样操作，结果如下图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112356582.png" alt="image-20231003112356582"></p><p>这样，当客户端查询时，也对查询的key做3次hash运算得到3个位置，然后看布隆过滤器中对应位置元素的值是否为1，如果所有对应位置元素的值都为1，就证明key在库中存在，则继续向下查询；如果3个位置中有任意一个位置的值不为1，那么就证明key在库中不存在，直接返回客户端空即可。如下图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112359294.png" alt="image-20231003112359294"></p><p>当客户端查询key4时，key4的3次hash运算中，有一个位置8的值为0，就说明key4在库中不存在，直接返回客户端空即可。</p><p>所以，布隆过滤器就相当于一个位于客户端与缓存层中间的拦截器一样，负责判断key是否在集合中存在。如下图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112407380.png" alt="image-20231003112407380"></p><h6 id="布隆过滤器优缺点："><a href="#布隆过滤器优缺点：" class="headerlink" title="布隆过滤器优缺点："></a>布隆过滤器优缺点：</h6><p>布隆过滤器的优点包括：</p><p>1.时间和空间效率高：布隆过滤器的时间复杂度和空间复杂度都是O(k)，其中k为哈希函数的数量。因此，它可以在较小的空间内快速判断某个元素是否在集合中。</p><p>2.误判率低：布隆过滤器虽然可能出现误判，但是误判率可以通过调整哈希函数数量和位数组大小来控制，可以根据实际需求进行调整。</p><p>3.支持高并发：布隆过滤器支持并发查询和添加数据，可以在多线程环境下使用。</p><p>4.易于实现：布隆过滤器的实现比较简单，只需要实现几个哈希函数和一个位数组即可。</p><p>布隆过滤器的缺点包括：</p><p>1.无法删除已添加的数据：由于布隆过滤器的哈希函数不具有逆向性，所以无法删除已添加的数据。</p><p>2.误判率无法避免：由于布隆过滤器的设计原理，误判率无法避免。当哈希函数的数量不足或位数组的大小不够时，误判率可能会很高。</p><p>3.无法精确判断元素是否存在：由于布隆过滤器的设计原理，无法精确判断某个元素是否在集合中，只能判断它可能存在或一定不存在。</p><p>减少布隆过滤器的误判：<br>布隆过滤器的误判率是根据哈希函数的数量和位数组大小来确定的。如果哈希函数的数量太少或者位数组太小，那么误判率会增加。反之，如果哈希函数的数量太多或者位数组太大，那么可能会导致空间浪费和查询效率降低。因此，在实际使用中，需要根据具体的应用场景来确定哈希函数数量和位数组大小，以达到误判率和空间利用率的平衡。</p><p>1.使用多个布隆过滤器：将同一个元素添加到多个布隆过滤器中，查询时需要在所有布隆过滤器中查询。这种方法可以显著降低误判率，但是会增加存储空间和查询时间。</p><p>2.使用加密哈希函数：加密哈希函数可以使哈希值更难以预测，从而减少哈希冲突的概率。常见的加密哈希函数包括MD5、SHA-1等。</p><p>3.使用高质量的哈希函数：使用高质量的哈希函数可以减少哈希冲突的概率。常见的高质量哈希函数包括MurmurHash、CityHash等。</p><p>4.对于数据量较小的情况，可以使用简单的线性查找代替布隆过滤器，这样可以避免误判率过高的问题。</p><p>需要注意的是，误判率是布隆过滤器的本质限制，无法完全避免。因此，在使用布隆过滤器时，需要根据实际需求来平衡误判率和空间利用率，同时采用多个布隆过滤器、使用高质量的哈希函数等方法来尽量减少误判率。</p><h5 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240319210815713.png" alt="image-20240319210815713"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240319211101370.png" alt="image-20240319211101370"></p><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><ul><li>设置热点数据永不过期或者过期时间比较长。</li><li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li><li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li></ul><h5 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="什么是缓存雪崩？"></a>什么是缓存雪崩？</h5><p>缓存在同一时间大面积的失效或者Redis宕机，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</p><ol><li><p>过期时间可以设置随机数，如30+（0~5）分钟随机，不要同时过期，每个key的过期时间分散，让他们的过期时间尽量均匀分散开</p></li><li><p>给缓存业务添加降级限流策略</p></li><li><p>给业务添加多级缓存</p></li><li><p>使用redis集群（主从、哨兵、redis集群）提高可用性（redis宕机）</p></li><li><p>数据预热：数据预热的含义就是在正式部署之前，先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。</p></li></ol><h4 id="什么是热Key问题，如何解决热key问题"><a href="#什么是热Key问题，如何解决热key问题" class="headerlink" title="什么是热Key问题，如何解决热key问题"></a>什么是热Key问题，如何解决热key问题</h4><p><strong>什么是热Key呢</strong>？在Redis中，我们把访问频率高的key，称为热点key。</p><p>如果某一热点key的请求到服务器主机时，由于请求量特别大，可能会导致主机资源不足，甚至宕机，从而影响正常的服务。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-caba55257b9de9ff85867d40daa8eb31_1440w.png" alt="img"></p><p>而热点Key是怎么产生的呢？主要原因有两个：</p><blockquote><ul><li>用户消费的数据远大于生产的数据，如秒杀、热点新闻等读多写少的场景。</li><li>请求分片集中，超过单Redi服务器的性能，比如固定名称key，Hash落入同一台服务器，瞬间访问量极大，超过机器瓶颈，产生热点Key问题。</li></ul></blockquote><p>那么在日常开发中，如何识别到热点key呢？</p><blockquote><ul><li><p>凭经验判断哪些是热Key；</p></li><li><p><strong>使用 Redis 自带的 <code>--hotkeys</code> 参数来查找。</strong></p><p>Redis 4.0.3 版本中新增了 <code>hotkeys</code> 参数，该参数能够返回所有 key 的被访问次数。</p><p>使用该方案的前提条件是 Redis Server 的 <code>maxmemory-policy</code> 参数设置为 LFU 算法，不然就会出现如下所示的错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-cli -p 6379 --hotkeys</span></span><br></pre></td></tr></table></figure><p><code>hotkeys</code> 参数命令也会增加 Redis 实例的 CPU 和内存消耗（全局扫描），因此需要谨慎使用。</p></li></ul></blockquote><p>如何解决热key问题？</p><blockquote><ul><li><p><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求,增加slave节点来实现读请求的负载均衡。</p><p><strong>使用 Redis Cluster</strong>：热key加上前缀或者后缀，把热key的数量从1个变成实例个数，利用分片特性将这n个key分散在不同节点上，这样就可以在访问的时候，采用客户端负载均衡的方式，随机选择一个key进行访问，将访问压力分散到不同的实例中</p><p><strong>二级缓存</strong>：使用JVM本地缓存，减少Redis的读请求,需要保障本地缓存和redis数据的一致性</p></li></ul></blockquote><h4 id="Redis如何查看慢查询"><a href="#Redis如何查看慢查询" class="headerlink" title="Redis如何查看慢查询"></a>Redis如何查看慢查询</h4><h5 id="慢查询：在Redis执行时耗时超过某个阈值的命令"><a href="#慢查询：在Redis执行时耗时超过某个阈值的命令" class="headerlink" title="慢查询：在Redis执行时耗时超过某个阈值的命令"></a>慢查询：在Redis执行时耗时超过某个阈值的命令</h5><p>危害：由于Redis是单线程的，所以当客户端发出指令后，他们都会进入到redis底层的任务队列（queue）来执行，如果此时有一些慢查询的指令，就会导致大量请求阻塞。</p><p>慢查询的阈值和日志长度可以通过配置指定：</p><p>slowlog-log-slower-than：慢查询阈值，单位是微秒。默认是10000，建议1000</p><p>slowlog-max-len：慢查询日志（本质是一个队列）的长度。默认是128，建议1000</p><p>修改这两个配置可以使用：config set命令：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231012153436030.png" alt="image-20231012153436030"></p><h5 id="4-2-如何查看慢查询"><a href="#4-2-如何查看慢查询" class="headerlink" title="4.2 如何查看慢查询"></a>4.2 如何查看慢查询</h5><p>知道了以上内容之后，那么咱们如何去查看慢查询日志列表呢：</p><ul><li>slowlog len：查询慢查询日志长度</li><li>slowlog get [n]：读取n条慢查询日志</li><li>slowlog reset：清空慢查询列表</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231012153506081.png" alt="image-20231012153506081"></p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><h4 id="优雅的key结构"><a href="#优雅的key结构" class="headerlink" title="优雅的key结构"></a>优雅的key结构</h4><p>Redis的Key虽然可以自定义，但最好遵循下面的几个最佳实践约定：</p><ul><li>遵循基本格式：[业务名称]:[数据名]:[id]</li><li>长度不超过44字节</li><li>不包含特殊字符</li></ul><p>例如：我们的登录业务，保存用户信息，其key可以设计成如下格式：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20220521120213631.png" alt="image-20220521120213631"></p><p>这样设计的好处：</p><ul><li>可读性强</li><li>避免key冲突</li><li>方便管理</li><li>更节省内存： key是string类型，底层编码包含int、embstr和raw三种。embstr在小于44字节使用，采用连续内存空间，内存占用更小。当字节数大于44字节时，会转为raw模式存储，在raw模式下，内存空间不是连续的，而是采用一个指针指向了另外一段内存空间，在这段空间里存储SDS内容，这样空间不连续，访问的时候性能也就会收到影响，还有可能产生内存碎片</li></ul><p>BigKey通常以Key的大小和Key中成员的数量来综合判定，例如：</p><ul><li>Key本身的数据量过大：一个String类型的Key，它的值为5 MB</li><li>Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个</li><li>Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB</li></ul><p>redis也给我们提供了命令</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20220521124650117.png" alt="image-20220521124650117"></p><p>推荐值：</p><ul><li>单个key的value小于10KB</li><li>对于集合类型的key，建议元素数量小于1000</li></ul><h4 id="BigKey的危害"><a href="#BigKey的危害" class="headerlink" title="BigKey的危害"></a>BigKey的危害</h4><ul><li>网络阻塞<ul><li>对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢</li></ul></li><li>数据倾斜<ul><li>BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡</li></ul></li><li>Redis阻塞<ul><li>对元素较多的hash、list、zset等做运算、bigKey的持久化备份耗时较久，使主线程被阻塞</li></ul></li><li>CPU压力<ul><li>对BigKey的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其它应用</li></ul></li></ul><h4 id="如何发现BigKey"><a href="#如何发现BigKey" class="headerlink" title="如何发现BigKey"></a>如何发现BigKey</h4><h5 id="①redis-cli-–bigkeys"><a href="#①redis-cli-–bigkeys" class="headerlink" title="①redis-cli –bigkeys"></a>①redis-cli –bigkeys</h5><p>利用redis-cli提供的–bigkeys参数，可以遍历分析所有key，并返回Key的整体统计信息与每个数据的Top1的big key</p><p>命令：<code>redis-cli -a 密码 --bigkeys</code></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20220521133359507.png" alt="image-20220521133359507"></p><h5 id="③第三方工具"><a href="#③第三方工具" class="headerlink" title="③第三方工具"></a>③第三方工具</h5><ul><li>利用第三方工具，如 Redis-Rdb-Tools 分析RDB快照文件，全面分析内存使用情况</li><li><a href="https://github.com/sripathikrishnan/redis-rdb-tools">https://github.com/sripathikrishnan/redis-rdb-tools</a></li></ul><h5 id="④网络监控"><a href="#④网络监控" class="headerlink" title="④网络监控"></a>④网络监控</h5><ul><li>自定义工具，监控进出Redis的网络数据，超出预警值时主动告警</li><li>一般阿里云搭建的云服务器就有相关监控页面</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20220521140415785.png" alt="image-20220521140415785"></p><h4 id="删除bigKey"><a href="#删除bigKey" class="headerlink" title="删除bigKey"></a>删除bigKey</h4><ul><li>redis 3.0 及以下版本<ul><li>如果是集合类型，则遍历BigKey的元素，先逐个删除子元素，最后删除BigKey</li></ul></li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20220521140621204.png" alt="image-20220521140621204"></p><ul><li>Redis 4.0以后<ul><li>Redis在4.0后提供了异步删除的命令：unlink</li></ul></li></ul><h4 id="处理BigKey"><a href="#处理BigKey" class="headerlink" title="处理BigKey"></a>处理BigKey</h4><ol><li><strong>将BigKey分割为多个小key来存储</strong>，并<strong>分布到不同redis实例</strong>上，比如把一个大的Hash结构分割为小的Hash结构，每个Hash结构代表一部分数据，从而减小单个key大小</li></ol><p>拆分为小的hash，将 id &#x2F; 100 作为key， 将id % 100 作为field，这样每100个元素为一个Hash</p><table>    <tr style="color:red">        <td>key</td>        <td>field</td>        <td>value</td>    </tr>    <tr>        <td rowspan="3">key:0</td>        <td>id:00</td>        <td>value0</td>    </tr>    <tr>        <td>.....</td>        <td>.....</td>    </tr>    <tr>        <td>id:99</td>        <td>value99</td>    </tr>    <tr>        <td rowspan="3">key:1</td>        <td>id:00</td>        <td>value100</td>    </tr>    <tr>        <td>.....</td>        <td>.....</td>    </tr>    <tr>        <td>id:99</td>        <td>value199</td>    </tr>    <tr>        <td colspan="3">....</td>    </tr>    <tr>        <td rowspan="3">key:9999</td>        <td>id:00</td>        <td>value999900</td>    </tr>    <tr>        <td>.....</td>        <td>.....</td>    </tr>    <tr>        <td>id:99</td>        <td>value999999</td>    </tr></table><ol start="2"><li><p><strong>搭建redis cluster集群，把key分配到不同hash slot所在分片上</strong>，降低单个redis节点的存储压力</p></li><li><p><strong>使用压缩算法进行压缩</strong>，减少存储空间的占用。存储数据前进行压缩，读取时进行解压，节省存储空间和网络传输的数据量</p></li></ol><h3 id="分布式-1"><a href="#分布式-1" class="headerlink" title="分布式"></a>分布式</h3><h4 id="分布式锁了解吗？为什么要给分布式锁加ttl呢？"><a href="#分布式锁了解吗？为什么要给分布式锁加ttl呢？" class="headerlink" title="分布式锁了解吗？为什么要给分布式锁加ttl呢？"></a>分布式锁了解吗？为什么要给分布式锁加ttl呢？</h4><p>随着技术快速发展，数据规模增大，分布式系统越来越普及，一个应用往往会部署在多台机器上（多节点），在有些场景中，跨JVM的互斥机制来控制共享资源的访问，为了保证共享资源被安全地访问，我们需要使用互斥操作对共享资源进行保护，即同一时刻只允许一个线程访问共享资源，其他线程需要等待当前线程释放后才能访问。这样可以避免数据竞争和脏数据问题，保证程序的正确性和稳定性。</p><p>对于单机多线程来说，在 Java 中，我们通常使用 <code>ReetrantLock</code> 类、<code>synchronized</code> 关键字这类 JDK 自带的 <strong>本地锁</strong> 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。</p><p>下面是我对本地锁画的一张示意图。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/jvm-local-lock.png" alt="本地锁">本地锁</p><p>从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。</p><p>分布式系统下，不同的服务&#x2F;客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，<strong>分布式锁</strong> 就诞生了。</p><p>举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于不同的 JVM 进程中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 JVM 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。</p><p>下面是我对分布式锁画的一张示意图。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/distributed-lock.png" alt="分布式锁">分</p><p>从图中可以看出，这些独立的进程中的线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到分布式锁访问共享资源。</p><p> 实现机制： 加锁通过一个 set 指令，可以<strong>原子性的实现setnx并添加过期时间ttl。</strong></p><p>解锁：</p><p>问题：解锁可能出现释放不属于自己锁的情况，可能会因为阻塞发生锁超时释放，其他线程获得锁，当阻塞线程恢复执行时，可能会释放其他线程的锁。</p><p>解决：锁是通过key-value实现的，可以设置锁的value值当前线程id，释放锁之前可以判断锁的value值中线程id是否和当前线程id符合，再释放锁</p><p>更为极端的误删逻辑问题：</p><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题</p><p>因为判断是不是自己锁和释放锁两个动作不是原子性，可能判断完之后发生线程切换，在这个过程中锁超时释放，然后释放不属于自己的锁，通过一段Lua脚本，保障判断删除操作的原子性，首先获取锁对应的value（设置为UUID+ 线程值）值，检查<strong>是否与requestId相等，如果相等则删除锁（解锁</strong>）。否则可能会出现释放不属于自己锁的情况</p><p>应用程序遇到一些问题比如释放锁的逻辑突然挂掉，或者一个线程获得锁后Redis宕机，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程&#x2F;进程访问。所有要给这个 key（也就是锁） 设置一个过期时间** 。<strong>一定要保证设置指定 key 的值和过期时间是一个原子操作！！！</strong> 不然的话，可能会出现只获取锁但是还没有设置过期时间就宕机，依然可能会出现锁无法被释放的问题。</p><p>但是只使用setnx + ttl的分布式锁存在 不可重入、不可重试、容易超时、主从一致性问题（主从集群下，主从同步存在延迟，当主宕机时，如果从节点未同步主中的锁数据，则会出现锁失效）</p><p>使用Redisson（提供了许多分布式服务）</p><ul><li>可重入，同一个线程可多次获取同一把锁，在同一个线程中可能有多个方法获取锁，获取时如果是本线程的锁可以重入（利用hash结构记录线程id和重入次数）</li><li>可重试 获取锁失败后可重试（获取锁的时候可以设置等待时间，在时间内获取失败可以订阅当前 锁释放的消息， 等锁释放了再尝试获取锁）</li><li>超时续约：虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患，主从一致性（当锁有效期设置为-1，当任务执行时，通过定时任务来动态重置锁的有效期，避免锁超时释放，这就是看门狗机制），在释放锁时，会发送释放锁的消息，取消这个watchDog</li><li>提供联锁（MultiLock）红锁（RedLock）等分布式锁，具有高可用性</li></ul><h4 id="看门狗机制"><a href="#看门狗机制" class="headerlink" title="看门狗机制"></a>看门狗机制</h4><p>背景：</p><blockquote><p>分布式锁是不能设置永不过期的，这是为了避免在分布式的情况下，一个节点获取锁之后宕机从而出现死锁的情况，所以需要个分布式锁设置一个过期时间。但是这样会导致一个线程拿到锁后，在锁的过期时间到达的时候程序还没运行完，导致锁超时释放了，那么其他线程就能获取锁进来，从而解决问题。</p></blockquote><p>看门狗机制是Redission提供的一种自动延期机制，这个机制使得<strong>Redission提供的分布式锁是可以自动续期的</strong>。</p><p>如果一个线程获取锁后，运行程序到释放锁所花费的时间大于锁自动释放时间（也就是看门狗机制提供的超时时间30s），那么Redission会自动给redis中的目标锁延长超时时间。</p><p>使用条件：</p><ul><li><p>在Redission中想要启动看门狗机制，那么我们就不用获取锁的时候自己定义leaseTime(锁自动释放时间)。</p></li><li><p>如果自己定义了锁自动释放时间的话，无论是通过lock还是tryLock方法，都无法启用看门狗机制。</p></li><li><p>但是，如果传入的leaseTime为-1，也是会开启看门狗机制的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">       <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;guodong&quot;</span>);    <span class="comment">// 拿锁失败时会不停的重试</span></span><br><span class="line">       <span class="comment">// 具有Watch Dog 自动延期机制 默认续30s 每隔30/3=10 秒续到30s</span></span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="comment">// 尝试拿锁10s后停止重试,返回false 具有Watch Dog 自动延期机制 默认续30s</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">res1</span> <span class="operator">=</span> lock.tryLock(<span class="number">10</span>, TimeUnit.SECONDS); </span><br><span class="line">       <span class="comment">// 没有Watch Dog ，10s后自动释放</span></span><br><span class="line">       lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">       <span class="comment">// 尝试拿锁100s后停止重试,返回false 没有Watch Dog ，10s后自动释放</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">res2</span> <span class="operator">=</span> lock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">       Thread.sleep(<span class="number">40000L</span>);</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>首先获取到锁（这个锁30s后自动释放），然后对锁设置一个延迟任务（10s后执行），延迟任务给锁的释放时间刷新为30s，并且还为锁再设置一个相同的延迟任务（10s后执行），这样就达到了如果一直不释放锁（程序没有执行完）的话，看门狗机制会每10s将锁的自动释放时间刷新为30s。</strong>当锁释放后，看门狗机制会订阅锁释放的消息，然后取消关门狗机制。</p><p>而当程序出现异常，那么看门狗机制就不会继续递归调用<code>renewExpiration</code>，这样锁会在30s后自动释放。</p><h4 id="redis-怎么实现持久化的？"><a href="#redis-怎么实现持久化的？" class="headerlink" title="redis 怎么实现持久化的？"></a>redis 怎么实现持久化的？</h4><h5 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h5><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。<strong>把内存中的所有数据都记录到磁盘中</strong>。当Redis实例故障重启后，从磁盘<strong>读取快照文件，恢复数据</strong>。快照文件称为RDB文件，默认是保存在当前运行目录。</p><p>RDB持久化在四种情况下会执行：</p><ul><li>执行save命令</li><li>执行bgsave命令</li><li>Redis停机时</li><li>触发RDB条件时</li></ul><p>（数据备份）bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p><p>fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231011233434794.png" alt="image-20231011233434794" style="zoom: 67%;" /><h5 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h5><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><p>它有三种命令记录的策略</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231011233713172.png" alt="image-20231011233713172"></p><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><h5 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231011233915482.png" alt="image-20231011233915482"></p><p>AOF文件是文本文件，记录命令，比RDB直接存储内存数据（二进制文件）要大</p><p>AOF以重演命令的形式恢复数据，速度比RDB慢</p><h5 id="Redis-4-0-混合持久化"><a href="#Redis-4-0-混合持久化" class="headerlink" title="Redis 4.0 混合持久化"></a>Redis 4.0 混合持久化</h5><ul><li>仅使用RDB快照方式恢复数据，由于快照时间粒度较大，时回丢失大量数据。</li><li>仅使用AOF重放方式恢复数据，日志性能相对 rdb 来说要慢。在 Redis 实例很大的情况下，启动需要花费很长的时间。</li></ul><p>Redis 4.0 为了解决这个问题，发明一个新的持久化方式<strong>混合持久化</strong>。</p><p>在你执行bgrewriteaof（AOF文件后台重写）或触发自动AOF重写的时候，将AOF文件转化为RDB文件格式（二进制压缩）写到AOF文件中。而在下次重写之前，依然用aof文件格式追加到上面二进制数据的后面。</p><p>这样既可以让数据恢复时和RDB一样快速，又可以和AOF文件一样准确。兼顾了性能和安全性。<br><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/2021010620344716.png" alt="img"></p><p>在 Redis 重启的时候，可以先加载 RDB的内容，然后再重演AOF格式的内容，就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。</p><h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><ol><li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件<strong>可读性变的更差。</strong></li><li><strong>兼容性差</strong>。混合持久化 AOF 文件，就不能用在 Redis 4.0 之前的版本了。</li></ol><h4 id="Redis崩溃时，优先使用哪个文件来恢复"><a href="#Redis崩溃时，优先使用哪个文件来恢复" class="headerlink" title="Redis崩溃时，优先使用哪个文件来恢复"></a>Redis崩溃时，优先使用哪个文件来恢复</h4><p>当 Redis 崩溃时，恢复数据的首要方式是使用 AOF（Append-Only File）日志文件。AOF 日志文件记录了每个写操作（如命令、操作等）的追加操作，这使得在Redis重新启动时可以通过重新执行这些写操作来重建数据集。AOF 日志文件通常比 RDB（Redis 数据库备份）更可靠，因为它可以提供更精确的数据恢复，而 RDB 文件只是在特定时间点上的数据库快照。</p><h4 id="讲一讲redis主从部署，是从节点还是主节点主动？"><a href="#讲一讲redis主从部署，是从节点还是主节点主动？" class="headerlink" title="讲一讲redis主从部署，是从节点还是主节点主动？"></a>讲一讲redis主从部署，是从节点还是主节点主动？</h4><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力和可用性，就需要搭建主从集群，实现读写分离。</p><h5 id="是从节点主动，通过修改配置文件或者在客户端使用slaveof（replicaof）指令来与master节点建立连接"><a href="#是从节点主动，通过修改配置文件或者在客户端使用slaveof（replicaof）指令来与master节点建立连接" class="headerlink" title="是从节点主动，通过修改配置文件或者在客户端使用slaveof（replicaof）指令来与master节点建立连接"></a><strong>是从节点主动</strong>，通过修改配置文件或者在客户端使用slaveof（replicaof）指令来与master节点建立连接</h5><ul><li><p>修改配置文件（永久生效）</p><ul><li>在redis.conf中添加一行配置：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li></ul></li><li><p>使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="主从数据同步原理"><a href="#主从数据同步原理" class="headerlink" title="主从数据同步原理"></a>主从数据同步原理</h5><h6 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a><strong>全量同步</strong></h6><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231011235106171.png" alt="image-20231011235106171"></p><p>master节点通过Replication Id和offset来判断salve是否第一次连接</p><ul><li><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li><li><strong>offset</strong>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li></ul><p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。</p><p>由于slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。</p><p>master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p><p>master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</p><p>因此，<strong>master判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。</p><h6 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h6><p>全量同步需要先做RDB，然后将RDB文件通过网络传输给slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong>。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231011235516752.png" alt="image-20231011235516752"></p><h6 id="repl-backlog原理"><a href="#repl-backlog原理" class="headerlink" title="repl_backlog原理"></a>repl_backlog<strong>原理</strong></h6><p>master通过全量同步时的repl_baklog文件（一个固定大小的环形数组），记录master当前的offset 和slave的offset，增量拷贝就是要发送salve的offset之后还未同步的命令</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231011235702397.png" alt="image-20231011235702397"></p><p>如果slave出现网络阻塞，导致master的offset远远超过了slave的offset，其offset就会覆盖还未同步到slave的数据</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231012094823179.png" alt="image-20231012094823179"></p><p>如果slave恢复，需要同步，却发现自己的offset被覆盖了，无法完成增量同步了。只能做全量同步。</p><h5 id="主从同步优化"><a href="#主从同步优化" class="headerlink" title="主从同步优化"></a><strong>主从同步优化</strong></h5><ul><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</li></ul><h4 id="redis哨兵集群"><a href="#redis哨兵集群" class="headerlink" title="redis哨兵集群"></a>redis哨兵集群</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231012095535582.png" alt="image-20231012095535582"></p><h5 id="哨兵的作用"><a href="#哨兵的作用" class="headerlink" title="哨兵的作用"></a>哨兵的作用</h5><ul><li><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作</li><li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</li><li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li></ul><h5 id="集群监控原理"><a href="#集群监控原理" class="headerlink" title="集群监控原理"></a>集群监控原理</h5><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><p>•主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p><p>•客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231012095742414.png" alt="image-20231012095742414"></p><h4 id="集群故障恢复原理"><a href="#集群故障恢复原理" class="headerlink" title="集群故障恢复原理"></a>集群故障恢复原理</h4><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li><li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li><li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的运行id大小，越小优先级越高。</li></ul><p>当选出一个新的master后，该如何实现切换呢？</p><p>流程如下：</p><ul><li>sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master</li><li>sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li><li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231012095805494.png" alt="image-20231012095805494"></p><h4 id="Redis分片集群"><a href="#Redis分片集群" class="headerlink" title="Redis分片集群"></a>Redis分片集群</h4><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p><ul><li><p>海量数据存储问题</p></li><li><p>高并发写的问题</p></li></ul><p>使用分片集群可以解决上述问题，如图:</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231012100307109.png" alt="image-20231012100307109"></p><p>分片集群特征：</p><ul><li><p>集群中有多个master，每个master保存不同数据</p></li><li><p>每个master都可以有多个slave节点</p></li><li><p>master之间通过ping监测彼此健康状态</p></li><li><p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p></li></ul><h5 id="插槽原理"><a href="#插槽原理" class="headerlink" title="插槽原理"></a><strong>插槽原理</strong></h5><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231012100352320.png" alt="image-20231012100352320"></p><p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p><ul><li>key中包含”{}”，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</li><li>key中不包含“{}”，整个key都是有效部分</li></ul><p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p><p>Redis如何判断某个key应该在哪个实例？</p><ul><li>将16384个插槽分配到不同的实例</li><li>根据key的有效部分计算哈希值，对16384取余</li><li>余数作为插槽，寻找插槽所在实例即可</li></ul><p>如何将同一类数据固定的保存在同一个Redis实例？</p><ul><li>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</li></ul><h5 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h5><p>当集群中有一个master宕机会发生什么呢？</p><p>直接停止一个redis实例，例如7002：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7002 shutdown</span><br></pre></td></tr></table></figure><p>1）首先是该实例与其它实例失去连接</p><p>2）然后是疑似宕机：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231012101253081.png" alt="image-20231012101253081"></p><p>3）最后是确定下线，自动提升一个slave为新的master：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231012101257045.png" alt="image-20231012101257045"></p><p>4）当7002再次启动，就会变为一个slave节点了：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231012101300616.png" alt="image-20231012101300616"></p><h5 id="手动故障转移"><a href="#手动故障转移" class="headerlink" title="手动故障转移"></a>手动故障转移</h5><p>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231012101356847.png" alt="image-20231012101356847"></p><h4 id="为什么Redis把整个数据库被分为16384个slot（槽）"><a href="#为什么Redis把整个数据库被分为16384个slot（槽）" class="headerlink" title="为什么Redis把整个数据库被分为16384个slot（槽）"></a>为什么Redis把整个数据库被分为16384个slot（槽）</h4><p>master节点间心跳数据包格式</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1801c7a20d19daa332aa4f80df9cac61.png" alt="img"></p><p>其中，消息头有一个myslots的char类型数组，数组长度就是插槽的数量，底层存储其实是一个bitmap，每一个位代表一个槽，如果该位为1，表示这个槽是属于这个节点。</p><p>CRC16 算法，产生的hash值有 16 bit 位，可以产生 65536（2^16）个值，但是使用65536个插槽那么这个数组会占用8KB的空间，而这个心跳数据包每秒都需要同步给其他的节点，所以会浪费带宽。但是16384个插槽的话只需要2KB的空间，心跳数据包较小。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/82ce57ff7744df16bfdae65b5a3876dd.png" alt="image"></p><p>传输过程中，会对bitmap进行压缩，bitmap的填充率越低，压缩率越高。</p><blockquote><p>bitmap 填充率 &#x3D; slots &#x2F; N (N表示节点数)，</p></blockquote><p>所以，插槽数偏低的话， 填充率会降低，压缩率会升高。</p><p>集群节点之间会不断的互相Ping来确定集群中其它节点的状态。每次Ping携带的信息至少包括：</p><ul><li>插槽信息</li><li>集群状态信息</li></ul><p>集群中节点越多，集群状态信息数据量也越大，10个节点的相关信息可能达到1kb，此时每次集群互通需要的带宽会非常高，这样会导致集群中大量的带宽都会被ping信息所占用。</p><ol><li><p>每秒 redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为 65536，这个ping消息的消息头太大了，浪费带宽。</p></li><li><p>业务上看，集群主节点数量基本不可能超过1000个。因为集群节点越多，心跳包的消息体（携带一定数量的其他节点信息（集群状态信息）用于交换，约为集群总节点数量的1&#x2F;10，节点数量越多，消息体内容越大。）携带的数据越多。如果节点超过1000个，会导致网络拥堵。所以16384个插槽能够确保每个master节点都有足够的插槽</p></li><li><p>槽位越小，节点少的情况下，压缩率更高</p></li></ol><h3 id="数据结构底层实现"><a href="#数据结构底层实现" class="headerlink" title="数据结构底层实现"></a>数据结构底层实现</h3><h4 id="Redis数据结构-RedisObject"><a href="#Redis数据结构-RedisObject" class="headerlink" title="Redis数据结构-RedisObject"></a>Redis数据结构-RedisObject</h4><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject</p><p>从Redis的使用者的角度来看，Redis节点每一个database维护了从key space到object space的映射关系。这个映射关系的key是string类型（可用SDS来表示），⽽value可以是多种数据类型，比如：string, list, hash、set、sorted set等。<br>为了在同⼀个dict内能够存储不同类型的value，这就需要⼀个通⽤的数据结构，这个通用的数据结构就是redisObject。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013202808977.png" alt="image-20231013202808977"></p><p>每个RedisObject都有16个字节的对象头（包含 type 4bit  、 encoding 4bit、 lru 24bits、 refcount 16bits、 prt 8byte）</p><h5 id="Redis中各种数据类型的编码方式"><a href="#Redis中各种数据类型的编码方式" class="headerlink" title="Redis中各种数据类型的编码方式"></a>Redis中各种数据类型的编码方式</h5><table><thead><tr><th align="left">数据类型</th><th align="left">编码方式</th></tr></thead><tbody><tr><td align="left">OBJ_STRING</td><td align="left">int（存储整数）、embstr基于动态字符串（SDS）、raw基于动态字符串（SDS）</td></tr><tr><td align="left">OBJ_LIST</td><td align="left">3.2之后：QuickList          3.2之前：LinkedList 或 ZipList（元素少于512个，大小小于64个字节时）</td></tr><tr><td align="left">OBJ_SET</td><td align="left"><strong>intset</strong>（存储整数）、<strong>HT</strong></td></tr><tr><td align="left">OBJ_ZSET</td><td align="left">ZipList（当元素数量小于zset_max_ziplist_entries,默认128，每个元素小于zset_max_ziplist_value默认64Byte） 或者 HT+SkipList（两个都比较占用内存）</td></tr><tr><td align="left">OBJ_HASH</td><td align="left">ZipList、HT</td></tr></tbody></table><h4 id="SDS（简单动态字符串）"><a href="#SDS（简单动态字符串）" class="headerlink" title="SDS（简单动态字符串）"></a>SDS（简单动态字符串）</h4><p>动态字符串的结构体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">hisdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/*无符号整数类型，可以表示0-255 已使用的字符串字节数，不包含结束符&#x27;\0&#x27; */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* 申请的总字节数，不包含结束符&#x27;\0&#x27; */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/*不同的SDS头类型，用来控制SDS的头大小，它们的区别主要是len 和 alloc的长度不同，可以根据不同字符串长度，选择不同的结构体来节省空间*/</span></span><br><span class="line">    <span class="type">char</span> buf[]; <span class="comment">/* 真正存储数据的数组 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不同的SDS类型，主要是len 和 alloc 不同，根据不同字符串长度，选择合适的SDS结构体来节省空间</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013095357710.png" alt="image-20231013095357710"></p><p>例如，一个包含字符串“name”的sds结构如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231012233851352.png" alt="image-20231012233851352" style="zoom:150%;" /><p>SDS叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为“hi”的SDS：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231012234035937.png" alt="image-20231012234035937"></p><p>假如我们要给SDS追加一段字符串“,Amy”，这里首先会申请新内存空间：</p><ul><li><p>如果新字符串小于1M，则新空间为（扩展后字符串长度）的两倍+1；</p></li><li><p>如果新字符串大于1M，则新空间为（扩展后字符串长度）+1M+1。称为内存预分配。</p></li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231012234043113.png" alt="image-20231012234043113"></p><p>优点：</p><ul><li>获取字符串长度可以直接读取len字段</li><li>支持动态扩容</li><li>尽量减少内存分配次数（通过扩容时的内存预分配来实现）</li><li>二进制安全（有长度字段 , 一些特殊字符比如 ‘\0’ 不会产生歧义）</li></ul><h4 id="IntSet（Set实现方式之一）"><a href="#IntSet（Set实现方式之一）" class="headerlink" title="IntSet（Set实现方式之一）"></a>IntSet（Set实现方式之一）</h4><p>当Set中所有的数据都是整数，并且元素个数不超过set-max-intset-entries时，底层使用intSet，以节省内存  长度可变，编码类型可升级，有序</p><p>结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">inset</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;<span class="comment">/*指定contents数组的编码方式*/</span></span><br><span class="line">    <span class="type">uint32_t</span> length;<span class="comment">/*元素个数*/</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];<span class="comment">/*整数数组，这里只是保存数组的指针，真正的类型需要根据encoding来指定*/</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>其中的encoding包含三种模式，表示存储的整数大小不同：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013104047765.png" alt="image-20231013104047765"></p><p>为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中，结构如图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013104057922.png" alt="image-20231013104057922"></p><p>现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：<br>encoding：4字节<br>length：4字节<br>contents：2字节 * 3  &#x3D; 6字节</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013104110044.png" alt="image-20231013104110044"></p><p>我们向该其中添加一个数字：50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。<br>以当前案例来说流程如下：</p><ul><li>升级编码为INTSET_ENC_INT32, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组</li><li><strong>倒序</strong>依次将数组中的元素拷贝到扩容后的正确位置</li><li>将待添加的元素放入数组末尾</li><li>最后，将inset的encoding属性改为INTSET_ENC_INT32，将length属性改为4</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013104152255.png" alt="image-20231013104152255"></p><p>底层采用有序数组来实现，当插入元素时，要先判断元素编码是否超过了当前intset的编码。</p><ul><li>如果超出就升级类型，并伸展所有元素。</li><li>没超过当前编码，二分查找到对应位置，移动元素并插入。</li></ul><p>小总结：</p><p>Intset可以看做是特殊的整数数组，具备一些特点：</p><ul><li>Redis会确保Intset中的元素唯一、有序</li><li>具备类型升级机制，可以节省内存空间</li><li>底层采用二分查找方式来查询</li></ul><h4 id="Dict（Hash底层、Set底层（只使用key判断是否存在，value置为null））"><a href="#Dict（Hash底层、Set底层（只使用key判断是否存在，value置为null））" class="headerlink" title="Dict（Hash底层、Set底层（只使用key判断是否存在，value置为null））"></a>Dict（Hash底层、Set底层（只使用key判断是否存在，value置为null））</h4><p>Dict由三部分组成，分别是：字典（Dict）、哈希表（DictHashTable）、哈希节点（DictEntry）</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013110724201.png" alt="image-20231013110724201"></p><p>当我们向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用 h &amp; sizemask来计算元素应该存储到数组中的哪个索引位置。我们存储k1&#x3D;v1，假设k1的哈希值h &#x3D;1，则1&amp;3 &#x3D;1，因此k1&#x3D;v1要存储到数组角标1位置。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1653985640422.png" alt="1653985640422"></p><h5 id="Dict的扩容"><a href="#Dict的扩容" class="headerlink" title="Dict的扩容"></a>Dict的扩容</h5><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。<br>Dict在每次新增键值对时都会检查负载因子（LoadFactor &#x3D; used&#x2F;size） ，满足以下两种情况时会触发哈希表扩容：</p><ul><li>哈希表的 LoadFactor &gt;&#x3D; 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程（这些后台进程消耗大量CPU资源，如果同时进行会导致Redis阻塞）；</li><li>哈希表的 LoadFactor &gt; 5 ；</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013114927376.png" alt="image-20231013114927376"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013114931976.png" alt="image-20231013114931976"></p><p><strong>Dict的rehash</strong></p><p>Redis中Dict默认使用了两个全局哈希表，一个用于当前使用，称为主哈希表，<strong>一个用于扩容，称为备用哈希表</strong>。扩容或收缩，必定会使用新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表。</p><ul><li>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：<ul><li>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n</li><li>如果是收缩（LoadFactor小于0.1），则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li></ul></li><li>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</li><li>设置dict.rehashidx &#x3D; 0，标示开始rehash</li><li>每次执行增删改查操作时，都检查一下dict.rehashidx是否大于-1，如果是则将dict.ht[0].table[rehashidx]的entry链表转移到dict.ht[1],并且将rehashidx++。直到dict.ht[0]的所有数据都rehash到dict.ht[1]，将 rehash 分散到多次请求过程中，避免耗时阻塞；</li><li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li><li>将rehashidx赋值为-1，代表rehash结束</li><li>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</li></ul><p>整个过程可以描述成：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013114943605.png" alt="image-20231013114943605"></p><p>小总结：</p><p>Dict的结构：</p><ul><li>类似java的HashTable，底层是数组加链表来解决哈希冲突,通过头插法和*next指针来构建链表</li><li>Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash</li></ul><p>Dict的伸缩：</p><ul><li>扩容大小为第一个大于等于used + 1的2^n</li><li>收缩大小为第一个大于等于used 的2^n</li><li>Dict采用渐进式rehash，每次访问Dict时执行一次rehash，将rehash分散到多次请求中，避免发生Redis阻塞</li><li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li></ul><h4 id="zipList（Zset底层、list底层）"><a href="#zipList（Zset底层、list底层）" class="headerlink" title="zipList（Zset底层、list底层）"></a>zipList（Zset底层、list底层）</h4><p>ZipList 是可压缩的“双端链表” ，由连续内存块组成，所以不适合存储大量的数据，会经常发生内存块迁移，发生用户态与内核态的转换。可以在任意一端进行压入&#x2F;弹出操作, 并且该操作的时间复杂度为 O(1)。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013190915509.png" alt="image-20231013190915509"></p><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>长度</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>zlbytes</td><td>uint32_t</td><td>4 字节</td><td>记录整个压缩列表占用的内存字节数</td></tr><tr><td>zltail</td><td>uint32_t</td><td>4 字节</td><td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾节点的地址。</td></tr><tr><td>zllen</td><td>uint16_t</td><td>2 字节</td><td>记录了压缩列表包含的节点数量。 最大值为UINT16_MAX （65534），如果超过这个值，此处会记录为65535，但节点的真实数量需要遍历整个压缩列表才能计算得出。</td></tr><tr><td>entry</td><td>列表节点</td><td>不定</td><td>压缩列表包含的各个节点（节点不定长），节点的长度由节点保存的内容决定。</td></tr><tr><td>zlend</td><td>uint8_t</td><td>1 字节</td><td>特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td></tr></tbody></table><h5 id="ZipListEntry"><a href="#ZipListEntry" class="headerlink" title="ZipListEntry"></a><strong>ZipListEntry</strong></h5><p>ZipList 中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用了下面的结构：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013191152942.png" alt="image-20231013191152942"></p><ul><li><p>previous_entry_length：前一节点的长度，占1个或5个字节。</p><ul><li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li><li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li></ul></li><li><p>encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节</p></li><li><p>contents：负责保存节点的数据，可以是字符串或整数</p></li></ul><p>ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。例如：数值0x1234，采用小端字节序后实际存储值为：0x3412</p><h5 id="Encoding编码"><a href="#Encoding编码" class="headerlink" title="Encoding编码"></a><strong>Encoding编码</strong></h5><p>ZipListEntry中的encoding编码分为字符串和整数两种：</p><ul><li>字符串：如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串</li></ul><table><thead><tr><th><strong>编码</strong></th><th><strong>编码长度</strong></th><th><strong>字符串大小</strong></th></tr></thead><tbody><tr><td>|00pppppp|</td><td>1 bytes</td><td>&lt;&#x3D; 63 bytes</td></tr><tr><td>|01pppppp|qqqqqqqq|</td><td>2 bytes</td><td>&lt;&#x3D; 16383 bytes</td></tr><tr><td>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</td><td>5 bytes</td><td>&lt;&#x3D; 4294967295 bytes</td></tr></tbody></table><p>例如，我们要保存字符串：“ab”和 “bc”</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013191212784.png" alt="image-20231013191212784"></p><ul><li>整数：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节</li></ul><table><thead><tr><th><strong>编码</strong></th><th><strong>编码长度</strong></th><th><strong>整数类型</strong></th></tr></thead><tbody><tr><td>11000000</td><td>1</td><td>int16_t（2 bytes）</td></tr><tr><td>11010000</td><td>1</td><td>int32_t（4 bytes）</td></tr><tr><td>11100000</td><td>1</td><td>int64_t（8 bytes）</td></tr><tr><td>11110000</td><td>1</td><td>24位有符整数(3 bytes)</td></tr><tr><td>11111110</td><td>1</td><td>8位有符整数(1 bytes)</td></tr><tr><td>1111xxxx</td><td>1</td><td>直接在xxxx位置保存数值，范围从0001~1101，减1后结果为实际值</td></tr></tbody></table><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013191229681.png" alt="image-20231013191229681"></p><h5 id="ZipList连锁更新问题"><a href="#ZipList连锁更新问题" class="headerlink" title="ZipList连锁更新问题"></a>ZipList连锁更新问题</h5><p>ZipList的每个Entry都包含previous_entry_length来记录上一个节点的大小，长度是1个或5个字节：<br>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值<br>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据<br>现在，假设我们有N个连续的、长度为250~253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示，如图所示：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013193335838.png" alt="image-20231013193335838"></p><p>ZipList这种特殊情况下产生的连续多次空间扩展操作称之为连锁更新（Cascade Update）。新增、删除都可能导致连锁更新的发生。</p><p><strong>小总结：</strong></p><h5 id="ZipList特性："><a href="#ZipList特性：" class="headerlink" title="ZipList特性："></a><strong>ZipList特性：</strong></h5><ul><li>压缩列表的可以看做一种连续内存空间的”双向链表”</li><li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li><li>如果列表数据过多，导致链表过长，可能影响查询性能</li><li>增或删较大数据时有可能发生连续更新问题</li></ul><h4 id="QuickList（List底层）"><a href="#QuickList（List底层）" class="headerlink" title="QuickList（List底层）"></a>QuickList（List底层）</h4><p>redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013194946103.png" alt="image-20231013194946103"></p><p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：list-max-ziplist-size(默认为-2)来限制。<br>如果值为正，则代表ZipList的允许的entry个数的最大值<br>如果值为负，则代表ZipList的最大内存大小，分5种情况：</p><ul><li><p>-1：每个ZipList的内存占用不能超过4kb</p></li><li><p>-2：每个ZipList的内存占用不能超过8kb</p></li><li><p>-3：每个ZipList的内存占用不能超过16kb</p></li><li><p>-4：每个ZipList的内存占用不能超过32kb</p></li><li><p>-5：每个ZipList的内存占用不能超过64kb</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013195020655.png" alt="image-20231013195020655"></p></li></ul><p>QuickList的特点：</p><ul><li><p>是一个节点为ZipList的双端链表</p></li><li><p>节点采用ZipList，解决了传统链表的内存占用问题</p></li><li><p>控制了ZipList大小，解决连续内存空间申请效率问题</p></li><li><p>中间节点可以压缩，<strong>list 中间的数据被访问的频率比较低，可以选择进行压缩以减少内存占用</strong></p></li></ul><h4 id="SkipList（Zset的实现之一，重要）"><a href="#SkipList（Zset的实现之一，重要）" class="headerlink" title="SkipList（Zset的实现之一，重要）"></a>SkipList（Zset的实现之一，重要）</h4><p>SkipList（跳表）是特殊的链表</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>类似一棵B+树，以空间换时间</li><li>元素按照Score值，Socre值相同则按照ele值存储</li></ul><ul><li>跳跃表是一个双向链表，每个节点都包含score（分数）和ele（元素）值</li><li>每个节点都可以包含多级索引指针（用结构体数组表示），层数是1到32之间的随机数</li><li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li><li>支持平均<strong>O（logN）</strong>,最坏 O（N）复杂度的节点查找</li><li>增删改查效率与红黑树基本一致，实现却更简单</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013200648465.png" alt="image-20231013200648465"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013200654882.png" alt="image-20231013200654882"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013200700958.png" alt="image-20231013200700958"></p><h4 id="String数据结构"><a href="#String数据结构" class="headerlink" title="String数据结构"></a>String数据结构</h4><p>String 类型的数据结构并不是采用 C 语言中自带的字符串类型，C 语言中的数据结构存在很多问题，比如：</p><ul><li>获取字符串长度的需要通过运算(通过字符串数组长度 - 最后一位结束标识符长度    ||  通过一位一位遍历累加)</li><li>非二进制安全（无法保存如’\0’一样的特殊字符 ）</li><li>不可修改</li></ul><p>因此，String 在 Redis 中有其他三种编码方式： <code>int、embstr、raw</code> 。</p><h5 id="EMBSTR"><a href="#EMBSTR" class="headerlink" title="EMBSTR"></a>EMBSTR</h5><ul><li>如果存储在 SDS 中的数据小于等于 44 字节，则会采用 EMBSTR 编码，此时 <strong>RedisObject 与 SDS 是一段连续空间。而不是像 RAW 的编码方式一样，由 ptr 指向另外一片空间，</strong>申请内存时只需要调用一次内存分配函数，效率更高。结构如下， <img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/35752424145c4f3c81947746043955fatplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="Untitled 3.png"></li></ul><p>为什么是 44 字节？Redis 默认的内存分配器 jemalloc 分配内存大小的单位是  2^n   如果分配的空间为2^n 字节，就不会产生内存碎片。</p><p>而 <code>redisObject</code> 和 <code>hisdshdr8</code> 中 <code>len alloc flags &#39;\0&#39;</code>四个变量加起来刚刚好是 16 + 4 &#x3D; 20 字节，如果 <code>char[]</code> （数据大小）的大小为 44 字节时，加起来刚刚好是 64 字节，不会产生内存碎片。</p><h5 id="RAW"><a href="#RAW" class="headerlink" title="RAW"></a>RAW</h5><ul><li>raw 是 string 的基本编码方式，基于简单动态字符串（SDS）实现，存储上限为512mb。当一个字符串采用 raw 的编码方式的时候，它的结构如图所示，空间不连续，会产生内存碎片。</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/f46f04cd5391419ab3e32dfac88005cdtplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="Untitled 2.png"></p><h5 id="INT"><a href="#INT" class="headerlink" title="INT"></a>INT</h5><ul><li>如果存储的字符串是整数值，并且大小在 LONG MAX （刚好八个字节）范围内，则会采用 INT 编码</li><li><strong>直接将数据保存在 RedisObject 的 ptr 指针位置（刚好8字节)，不再需要SDS了。</strong></li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013204846636.png" alt="image-20231013204846636"></p><h4 id="List数据结构"><a href="#List数据结构" class="headerlink" title="List数据结构"></a>List数据结构</h4><p><strong>3.2版本之前：</strong>Redis采用ZipList和LinkedList来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码。</p><p><strong>3.2版本之后：</strong>Redis统一采用QuickList来实现List：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013211641297.png" alt="image-20231013211641297"></p><ul><li>len：总的entry个数，是每个zipList中entry个数的和</li><li>fill：每个entry不能超过指定大小</li><li>compress：quickList链表首尾几个元素不压缩</li></ul><h4 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h4><ul><li>不保证有序性</li><li>保证元素唯一</li><li>求交集、并集、差集</li></ul><ul><li>为了查询效率和唯一性，set采用HT编码（Dict）。Dict中的key用来存储元素保证元素的唯一，value统一为null。</li><li>当存储的所有数据都是整数，并且元素数量不超过set-max-intset-entries时，Set会采用IntSet编码，以节省内存（HT中有大量指针，需要比较多内存）</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013104057922.png" alt="image-20231013104057922"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013213906456.png" alt="image-20231013213906456"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013213917752.png" alt="image-20231013213917752"></p><h4 id="zset底层用的什么数据结构-重要"><a href="#zset底层用的什么数据结构-重要" class="headerlink" title="zset底层用的什么数据结构(重要)"></a>zset底层用的什么数据结构(重要)</h4><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值：</p><ul><li>可以根据score值排序</li><li>member必须唯一（去重）</li><li>可以根据member查询分数（键值存储）</li></ul><p><strong>可以使用以下二者结合</strong></p><ul><li>SkipList：可以排序，并且可以同时存储score和ele值（member）</li><li>HT（Dict）：可以去重，按照键值存储，并且可以根据key找value</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013215535152.png" alt="image-20231013215535152"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013215541423.png" alt="image-20231013215541423"></p><p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件：</p><ul><li>元素数量小于zset_max_ziplist_entries，默认值128</li><li>每个元素都小于zset_max_ziplist_value字节，默认值64</li></ul><p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p><ul><li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后</li><li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013215613107.png" alt="image-20231013215613107"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013215623238.png" alt="image-20231013215623238"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231013220409267.png" alt="image-20231013220409267"></p><h4 id="为什么ZSet要使用SkipList而不是二叉搜索树或者b-树？"><a href="#为什么ZSet要使用SkipList而不是二叉搜索树或者b-树？" class="headerlink" title="为什么ZSet要使用SkipList而不是二叉搜索树或者b+树？"></a>为什么ZSet要使用SkipList而不是二叉搜索树或者b+树？</h4><ul><li><p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p></li><li><p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p></li><li><p>skiplist能够更好的支持range 操作（通过指针next向后遍历就可以了）</p></li><li><p><strong>从内存占用上来比较，<a href="https://www.zhihu.com/search?q=%E8%B7%B3%E8%A1%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2619230497%7D">跳表</a>比平衡树更灵活一些</strong>。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1&#x2F;(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p&#x3D;1&#x2F;4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</p></li></ul><h4 id="Hash数据结构"><a href="#Hash数据结构" class="headerlink" title="Hash数据结构"></a>Hash数据结构</h4><p>Hash结构与Redis中的Zset非常类似：</p><ul><li>都是键值存储，键必须唯一，需要根据键获取值</li></ul><p>区别如下：</p><ul><li>zset的键是member，值是score（必须为数值）；hash的键和值都是任意值</li><li>zset要根据score排序；hash则无需排序</li></ul><h5 id="底层实现方式：压缩列表ziplist-数据量较小时-或者-字典dict-通过HT的key来实现去重"><a href="#底层实现方式：压缩列表ziplist-数据量较小时-或者-字典dict-通过HT的key来实现去重" class="headerlink" title="底层实现方式：压缩列表ziplist(数据量较小时) 或者 字典dict(通过HT的key来实现去重)"></a><strong>底层实现方式</strong>：压缩列表ziplist(数据量较小时) 或者 字典dict(通过HT的key来实现去重)</h5><p>当Hash中数据项比较少的情况下，Hash底层才⽤压缩列表ziplist进⾏存储数据，随着数据的增加，底层的ziplist就可能会转成dict，具体配置如下：</p><ul><li>ZipList中的元素数量超过了hash-max-ziplist-entries（默认512）</li><li>ZipList中的任意entry大小超过了hash-max-ziplist-value（默认64字节）</li></ul><p>当满足上面两个条件其中之⼀的时候，Redis就使⽤dict字典来实现hash。<br>Redis的hash之所以这样设计，是因为当ziplist变得很⼤的时候，它有如下几个缺点：</p><ul><li>每次插⼊或修改引发的realloc操作会有更⼤的概率造成内存拷贝（把一块内存的数据转移到另一块内存），从而降低性能。</li><li>查找指定的数据项需要遍历各个enrty，效率很低</li><li>需要占用较大的连续内存空间，难以在内存中申请符合的空间</li></ul><p>总之，ziplist本来就设计为各个数据项挨在⼀起组成连续的内存空间，这种结构并不擅长做修改操作。⼀旦数据发⽣改动，就会引发内存realloc，可能导致内存拷贝。</p><p>Hash结构默认采用ZipList编码，用以节省内存。 ZipList中相邻的两个entry 分别保存field和value</p><p>当数据量较大（个数&gt;512, 单个entry &gt; 64Byte, 占用总内存 &gt; 1G ）时，Hash结构会转为HT编码</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014103737548.png" alt="image-20231014103737548"></p><h3 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h3><h4 id="redis命令执行过程："><a href="#redis命令执行过程：" class="headerlink" title="redis命令执行过程："></a>redis命令执行过程：</h4><p>Redis 是基于 I&#x2F;O 多路复用技术，为了能够处理多个客户端的请求，Redis 在本地为每一个链接到 Redis 服务器的客户端创建了一个 redisClient 的数据结构，这个数据结构包含了每个客户端各自的状态和执行的命令。 Redis 服务器使用一个链表来维护多个 redisClient 数据结构。</p><p>在服务器端用一个链表来管理所有的 redisClient。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    list *clients;              <span class="comment">/* List of active clients */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于io多路复用程序监听多个socket，将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用  函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。当客户端和服务器端的嵌套字变得可读的时候，服务器将会调用命令请求处理器来执行以下操作：</p><ol><li>读取嵌套字中的数据，写入 querybuf。</li><li>解析 querybuf 中的命令，记录到 argc 和 argv 中。</li><li>根据 argv[0] 查找对应的 recommand。</li><li>执行 recommand 对应的实现函数。</li><li>执行以后将结果存入 buf &amp; bufpos &amp; reply 中，返回给调用方。</li></ol><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/2034687-20210713205056685-2030878324.png" alt="img"></p><h4 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h4><p>为了防止用户应用随意操作系统资源（CPU、内存、网卡等），需要把用户应用和系统应用隔离开，用户应用运行在用户空间，系统应用运行在内核空间，</p><p>进程可能执行普通命令，也有可能执行一些特权命令，切换到内核态调用系统资源（发生用户态–&gt;内核态的转换）</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014110623614.png" alt="image-20231014110623614"></p><h4 id="Redis网络模型-1"><a href="#Redis网络模型-1" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h4><h5 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h5><p>应用程序去读取数据，无法直接去读取磁盘数据</p><ul><li>需要先到内核里边去等待内核操作硬件拿到数据，是需要等待的，</li><li>等到内核从磁盘上把数据加载出来之后，再把这个数据写给用户的缓存区</li></ul><p>如果是阻塞IO，那么整个过程中，用户从发起读请求开始，一直到读取到数据，都是一个阻塞状态。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014111852615.png" alt="image-20231014111852615"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014111911162.png" alt="image-20231014111911162"></p><h5 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h5><ul><li>非阻塞IO模型中，用户进程在第一个阶段是非阻塞，而是让CPU空转，不断地调用Recvfrom指令来请求数据。</li><li>第二个阶段是非阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014112736400.png" alt="image-20231014112736400"></p><h5 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h5><ul><li>如果调用recvfrom时，恰好没有数据，阻塞IO会使CPU阻塞，非阻塞IO使CPU空转，都不能充分发挥CPU的作用。</li><li>如果调用recvfrom时，恰好有数据，则用户进程可以直接进入第二阶段，读取并处理数据</li></ul><p>单线程情况下，只能依次处理IO事件，如果正在处理的IO事件恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有IO事件都必须等待，性能自然会很差。</p><p>就比如服务员给顾客点餐，<strong>分两步</strong>：</p><ul><li>顾客思考要吃什么（等待数据就绪）</li><li>顾客想好了，开始点餐（读取数据）</li></ul><p>要提高效率有几种办法？</p><p>方案一：增加更多服务员（多线程）<br>方案二：不排队，谁想好了吃什么（数据就绪了），服务员就给谁点餐（用户应用就去读取数据）</p><p>那么问题来了：用户进程如何知道内核中数据是否就绪呢？通过FD</p><p>文件描述符（File Descriptor）：简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件（在Linux中，一切皆文件，包括常规文件、网络套接字(Socket)、视频、硬件设备等）</p><p><strong>通过FD，我们的网络模型可以利用一个线程监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</strong></p><p>阶段一：</p><ul><li>用户进程调用select，指定要监听的FD集合</li><li>监听FD对应的多个socket</li><li>任意一个或多个socket数据就绪则返回readable</li><li>此过程中用户进程阻塞</li></ul><p>阶段二：</p><ul><li>用户进程找到就绪的socket</li><li>依次调用recvfrom读取数据</li><li>内核将数据拷贝到用户空间</li><li>用户进程处理数据</li></ul><p><strong>当用户去读取数据的时候，不再去直接调用recvfrom了，而是调用select的函数</strong>，select函数会将需要监听的数据（文件）的FD交给内核，由内核去检查这些数据是否就绪了，如果说这个数据就绪了，就会通知应用程序数据就绪，然后来读取数据，再从内核中把数据拷贝给用户态，完成数据处理，如果N多个FD一个都没处理完，此时就进行等待。</p><p><strong>IO多路复用是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，可以确保去读数据的时候，数据是一定存在的</strong>，从而避免无效的等待，充分利用CPU资源。他的效率比原来的阻塞IO和非阻塞IO性能都要高</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014114539467.png" alt="image-20231014114539467"></p><p>不过监听FD的方式、通知的方式又有多种实现，常见的有：</p><ul><li>select ：当被监听的数据准备好之后，他会把监听的FD整个数据都发给你，需要到整个FD中去遍历，哪些数据准备好了，所以性能也并不是那么好。相当于只通知有几个数据准备好了，但是没有指明是哪些数据准备好了。</li><li>poll ：和select一样</li><li>epoll：内核准备好了之后，他会把准备好的数据，直接发给你，咱们就省去了遍历的动作</li></ul><h5 id="IO多路复用—select方式"><a href="#IO多路复用—select方式" class="headerlink" title="IO多路复用—select方式"></a>IO多路复用—select方式</h5><p>是最早的I&#x2F;O多路复用技术，是用fd_set结构实现的。</p><ul><li>其中包含一个long类型的数组长度为1024&#x2F;32, 每一个bit代表一个fd，1表示就绪（传入时表示需要监听），0表示未就绪（传入时表示不需要监听），在传入时，会将需要监听的fd对应bit置为1，内核态会遍历监听每一个位。</li><li>如果发现对应fd的数据都没有就绪，进程就休眠，</li><li>直到有数据准备好，就会被唤醒，唤醒后将未准备好的数据对应bit置为0，准备好数据的对应位保持为1</li></ul><p>最后再将这个FD集合写回到用户态中去，并返回 准备好的数据个数。此时用户态只知道有多少数据准备好，并不知道哪些数据准备好了，所以用户态也需要去进行遍历每一个bit，然后找到对应准备好数据的节点，再去发起读请求。</p><p>这种模式下他虽然比阻塞IO和非阻塞IO好，但是依然有些麻烦的事情， 比如说频繁的传递fd集合，频繁的去遍历FD等问题</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014145021040.png" alt="image-20231014145021040"></p><h5 id="IO多路复用模型-poll模式"><a href="#IO多路复用模型-poll模式" class="headerlink" title="IO多路复用模型-poll模式"></a>IO多路复用模型-poll模式</h5><p>poll模式对select模式做了简单改进，但性能提升不明显</p><p><strong>IO流程：</strong></p><ul><li>创建pollfd数组，向其中添加关注的fd信息，数组大小自定义</li><li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</li><li>内核遍历fd，判断是否就绪</li><li>数据就绪（会将实际发生的事件类型写入revents， 未就绪就把pollfd的revents置为0）或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</li><li>用户进程判断n是否大于0，大于0则遍历pollfd数组，找到就绪的fd</li></ul><p><strong>与select对比：</strong></p><ul><li>select模式中的fd_set大小固定为1024，而pollfd在内核中采用链表，理论上无上限</li><li>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014152100009.png" alt="image-20231014152100009"></p><h5 id="IO多路复用模型-epoll函数（重要）"><a href="#IO多路复用模型-epoll函数（重要）" class="headerlink" title="IO多路复用模型-epoll函数（重要）"></a>IO多路复用模型-epoll函数（重要）</h5><p>epoll模式是对select和poll的改进，通过在内核空间创建一个eventpoll结构（包含红黑树，list），可将要监听的FD加入到红黑树中，并给每一个FD设置一个监听函数，当FD数据就绪，这个监听函数就会把对应FD添加到链表中，并将链表中的FD拷贝到用户空间的events数组中，用户进程就可以读取events数组中的FD，并调用方法去获取对应数据。</p><p>它提供了三个函数：</p><p><img src="/./../../../../../../%25E4%25B8%25AA%25E4%25BA%25BA%25E5%258D%259A%25E5%25AE%25A2/hexo/blog/source/imgs/Java%25E7%259F%25A5%25E8%25AF%2586%25E7%2582%25B9%25E6%2580%25BB%25E7%25BB%2593/image-20231014154846654.png" alt="image-20231014154846654"></p><p><strong>epoll_ctl函数：</strong></p><p>将要监听的数据添加到红黑树上去，并且给每个fd设置一个回调函数(ep_poll_callback)，这个函数会在fd数据就绪时触发，就把fd把数据添加到list_head中去</p><p><strong>epoll_wait函数：</strong></p><ul><li>在用户态创建一个空的events数组，当数据就绪之后，我们的回调函数(ep_poll_callback)会把数据添加到list_head中去。当调用epoll_wait函数的时候，会在一段时间内不断去检查list_head，当然这个过程需要参考配置的等待时间，可以等一定时间，也可以一直等.</li><li>如果在此过程中，检查到了list_head中有数据会将数据添加到链表中，此时将准备好的数据放入到events数组中，并且返回有事件发生的文件描述符的个数</li><li>用户态的此时收到响应后，从events中拿到对应准备好的数据的节点，再去调用方法去拿准备好的数据。</li></ul><p>小总结：</p><p>select模式存在的三个问题：</p><ul><li>能监听的FD最大不超过1024</li><li>每次select都需要把<strong>所有</strong>要监听的FD都拷贝到内核空间（频繁的重复在内核空间拷贝FD的集合）</li><li>每次都要<strong>遍历所有FD</strong>来判断就绪状态</li></ul><p>poll模式的问题：</p><ul><li>poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li></ul><p>epoll模式中如何解决这些问题的？</p><ul><li>用红黑树保存要监听的FD，理论上无上限，而且增删改查效率为O(logn)，非常高</li><li>每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间，所以只需要传入一个待检测的FD，减少了内核和用户空间大量的数据拷贝和内存分配。</li><li>利用ep_poll_callback（回调函数）机制来监听FD状态，无需遍历所有FD，性能较好</li></ul><h5 id="epoll中的ET和LT"><a href="#epoll中的ET和LT" class="headerlink" title="epoll中的ET和LT"></a>epoll中的ET和LT</h5><p>当FD有数据可读时，我们调用epoll_wait（或者select、poll）可以得到通知。但是事件通知的模式有两种：</p><ul><li>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；</li><li>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取；</li></ul><p>举个栗子：</p><ol><li>假设一个客户端socket对应的FD已经注册到了epoll实例中</li><li>客户端socket发送了2kb的数据</li><li>服务端调用epoll_wait，得到通知说FD就绪</li><li>服务端从FD读取了1kb数据</li><li>回到步骤3（再次调用epoll_wait，形成循环）</li></ol><p>结论</p><ul><li>如果我们采用LT模式，因为FD中仍有1kb数据，则第⑤步依然会返回结果，并且得到通知</li><li>如果我们采用ET模式，因为第③步已经消费了FD可读事件，第⑤步FD状态没有变化，因此epoll_wait不会返回，剩余数据无法读取，客户端响应超时。</li><li>LT可能产生惊群现象，当多个用户进程监听同一个FD时，有的进程已经读完该数据，还是会被重复通知，导致被唤醒。<img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014164047101.png" alt="image-20231014164047101"></li></ul><h5 id="基于epoll的服务器端流程"><a href="#基于epoll的服务器端流程" class="headerlink" title="基于epoll的服务器端流程"></a>基于epoll的服务器端流程</h5><p>我们来梳理一下这张图</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014165723629.png" alt="image-20231014165723629"></p><p>服务器启动以后，服务端会去调用epoll_create，创建一个epoll实例，epoll实例中包含两个数据</p><ul><li><p>红黑树（为空）：rb_root 用来去记录需要被监听的FD</p></li><li><p>链表（为空）：list_head，用来存放已经就绪的FD</p></li></ul><p>创建好了之后，会去调用epoll_ctl函数，此函数会将需要监听的数据添加到rb_root中去，并且对当前这些存在于红黑树的节点设置回调函数，当这些被监听的数据一旦准备完成，就会被调用，而调用的结果就是将红黑树的fd添加到list_head中去</p><p>当第二步完成后，就会调用epoll_wait函数，这个函数会不断去校验是否有数据准备完毕（因为数据一旦准备就绪，就会被回调函数添加到list_head中），在等待了一段时间后(可以进行配置)，如果等够了超时时间，则返回没有数据，如果有，则进一步判断当前是什么事件，如果是建立连接时间，则调用accept() 接受客户端socket，拿到建立连接的socket，然后建立起来连接，如果是其他事件，则把数据进行写出</p><h5 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h5><p>信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p><p>阶段一：</p><ul><li>用户进程调用sigaction，注册信号处理函数</li><li>内核返回成功，开始监听FD</li><li>用户进程不阻塞等待，可以执行其它业务</li><li>当内核数据就绪后，回调用户进程的SIGIO处理函数</li></ul><p>阶段二：</p><ul><li>收到SIGIO回调信号</li><li>调用recvfrom，读取</li><li>内核将数据拷贝到用户空间</li><li>用户进程处理数据</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014171132706.png" alt="image-20231014171132706"></p><p>当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出，而且内核空间与用户空间的频繁信号交互性能也较低。</p><h5 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h5><p>这种方式，不仅仅是用户态在试图读取数据后，不阻塞，而且当内核的数据准备完成后，也不会阻塞</p><p>他会由内核将所有数据处理完成后，由内核将数据写入到用户态中，然后才算完成，所以性能极高，不会有任何阻塞，全部都由内核完成，可以看到，异步IO模型中，用户进程在两个阶段都是非阻塞状态。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014171100289.png" alt="image-20231014171100289"></p><p>异步IO与同步IO的对比：数据从内核拷贝到用户空间是阻塞还是非阻塞</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014171143906.png" alt="image-20231014171143906"></p><h4 id="Redis单线程还是单线程？为什么Redis6-0之后要改多线程呢？"><a href="#Redis单线程还是单线程？为什么Redis6-0之后要改多线程呢？" class="headerlink" title="Redis单线程还是单线程？为什么Redis6.0之后要改多线程呢？"></a>Redis单线程还是单线程？为什么Redis6.0之后要改多线程呢？</h4><ul><li>如果仅是Redis的核心业务部分（命令处理），是单线程</li><li>如果是聊整个Redis，那就是多线程</li></ul><p>在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p><ul><li>Redis v4.0：引入多线程异步处理一些耗时较久的任务，例如异步删除命令unlink</li><li>Redis v6.0：在核心网络模型中引入 多线程，进一步提高对于多核CPU的利用率</li></ul><p>对于Redis的核心网络模型，在Redis 6.0之前确实都是单线程。是利用epoll（Linux系统）这样的IO多路复用技术在事件循环中不断处理客户端情况。</p><p><strong>为什么Redis（命令处理）要选择单线程？</strong></p><ul><li>抛开持久化不谈Redis是纯  内存操作，执行速度非常快，它的性能瓶颈是网络延迟和IO阻塞而不是执行速度，因此多线程并不会带来巨大的性能提升。</li><li>多线程会导致过多的上下文切换，带来不必要的开销</li><li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li></ul><p><strong>Redis引入多线程的原因</strong></p><p>多线程只用来异步处理一些耗时较久的任务、网络模型以及数据的IO读写，避免耗时较久的任务造成redis阻塞</p><ul><li>硬件升级迭代，多线程可以更好的利用硬件资源</li><li>redis的性能瓶颈在于网络延迟、IO阻塞而非CPU，使用多线程能提升网络IO读写的效率，从而整体提高redis的性能。</li></ul><h4 id="redis单线程在多核机器里使用会不会浪费机器资源？"><a href="#redis单线程在多核机器里使用会不会浪费机器资源？" class="headerlink" title="redis单线程在多核机器里使用会不会浪费机器资源？"></a>redis单线程在多核机器里使用会不会浪费机器资源？</h4><p>不会。</p><p><strong>CPU 并不是制约 Redis 性能表现的瓶颈所在</strong>，更多情况下是受到内存大小和网络I&#x2F;O的限制，所以 Redis 核心网络模型使用单线程并没有什么问题，如果你想要使用服务的多核CPU，可以在一台服务器上启动多个节点或者采用分片集群的方式。</p><p>使用了单线程后，可维护性高，多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，<strong>增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗</strong>。</p><h4 id="redis-执行命令还是单线程，那如何利用多核心来提升性能？"><a href="#redis-执行命令还是单线程，那如何利用多核心来提升性能？" class="headerlink" title="redis 执行命令还是单线程，那如何利用多核心来提升性能？"></a>redis 执行命令还是单线程，那如何利用多核心来提升性能？</h4><p>所以 Redis 核心网络模型使用单线程并没有什么问题，如果你想要使用服务的多核CPU，可以在一台服务器上启动多个节点或者采用分片集群的方式。</p><h3 id="Redis内存回收"><a href="#Redis内存回收" class="headerlink" title="Redis内存回收"></a>Redis内存回收</h3><h4 id="Redis的过期策略和内存淘汰策略"><a href="#Redis的过期策略和内存淘汰策略" class="headerlink" title="Redis的过期策略和内存淘汰策略"></a>Redis的过期策略和内存淘汰策略</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-e6220bf60f2760694f3a26dbc8fc64c2_1440w.png" alt="img"></p><h4 id="Redis的过期策略"><a href="#Redis的过期策略" class="headerlink" title="Redis的过期策略"></a>Redis的过期策略</h4><p>Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在之前学习过的Dict结构中。不过在其database结构体中，有两个Dict：一个用来记录key-value；另一个用来记录key-TTL。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014200720351.png" alt="image-20231014200720351"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014200730317.png" alt="image-20231014200730317"></p><p>几种过期删除策略：</p><h6 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h6><p>每个设置过期时间的key都需要创建一个定时器，到过期时间立即对key进行清除。</p><p>该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p><h6 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h6><p>只有当访问一个key时，才会判断该key是否已过期，过期则清除。</p><p>该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p><h6 id="周期删除"><a href="#周期删除" class="headerlink" title="周期删除"></a>周期删除</h6><p>每隔一定的时间，会扫描expires字典中一定数量的key，并清除其中已过期的key。</p><p>expires字典会保存所有设置了过期时间的key的过期时间数据，key保存键，value是该键的毫秒精度的UNIX时间戳表示的过期时间。</p><p>Redis中同时使用了<strong>惰性过期和定期过期</strong>两种过期策略。</p><p>其中定期删除有SLOW 和 FAST模式</p><p>SLOW模式规则：</p><ul><li>执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。</li><li>执行清理耗时不超过一次执行周期的25%.默认slow模式耗时不超过25ms</li><li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</li><li>如果没达到时间上限（25ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li></ul><p>FAST模式规则（过期key比例小于10%不执行 ）：</p><ul><li>执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms</li><li>执行清理耗时不超过1ms</li><li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期<br>如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li></ul><p>小总结：</p><p>RedisKey的TTL记录方式：</p><ul><li>在RedisDB中通过一个Dict记录每个Key的TTL时间</li></ul><p>过期key的删除策略：</p><ul><li><p>惰性清理：每次查找key时判断是否过期，如果过期则删除</p></li><li><p>定期清理：定期抽样部分key，判断是否过期，如果过期则删除。</p></li></ul><p>定期清理的两种模式：</p><ul><li><p>SLOW模式执行频率默认为10，每次不超过25ms</p></li><li><p>FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</p></li></ul><h4 id="Redis-内存淘汰策略"><a href="#Redis-内存淘汰策略" class="headerlink" title="Redis 内存淘汰策略"></a>Redis 内存淘汰策略</h4><p>内存淘汰：就是当Redis内存使用达到设置的上限时，主动挑选部分key删除以释放更多内存的流程，尽管是挑选部分key，但是每次都会把最需要删除的key挑选并留在淘汰池中，淘汰的准确率也会越来越高。Redis会在处理客户端命令的方法processCommand()中尝试做内存淘汰：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014201817988.png" alt="image-20231014201817988"></p><ul><li>noeviction：默认策略，不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</li><li>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</li><li>allkeys-random：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选</li><li>volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选。</li><li>allkeys-lru： 对全体key，基于LRU（最近最少使用）算法进行淘汰</li><li>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</li><li>allkeys-lfu： 对全体key，基于LFU（最少频率使用）算法进行淘汰</li><li>volatile-lfu： 对设置了TTL的key，基于LFU算法进行淘汰<br>比较容易混淆的有两个：<ul><li>LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</li><li>LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</li></ul></li></ul><p>Redis的数据都会被封装为RedisObject结构：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014202022671.png" alt="image-20231014202022671"></p><p>LFU的访问次数之所以叫做逻辑访问次数，是因为并不是每次key被访问都计数，而是通过运算：</p><ul><li>生成0~1之间的随机数R</li><li>计算 (旧次数 * lfu_log_factor + 1)，记录为P，lfu_log_factor默认为10</li><li>如果 R &lt; P ，则计数器 + 1，且最大不超过255</li><li>访问次数会随时间衰减，距离上一次访问时间每隔 lfu_decay_time （默认为1）分钟，计数器 -1</li></ul><p>最后用一副图来描述当前的内存淘汰方法performEvictions()的流程，尽管是挑选部分key，但是每次都会把最需要删除的key挑选并留在淘汰池中，淘汰的准确率也会越来越高</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231014202027774.png" alt="image-20231014202027774"></p><h2 id="计算机网络："><a href="#计算机网络：" class="headerlink" title="计算机网络："></a>计算机网络：</h2><h4 id="网络的构成"><a href="#网络的构成" class="headerlink" title="网络的构成"></a>网络的构成</h4><p><strong>节点</strong></p><ul><li><p>主机及其上运行的应用程序</p></li><li><p>路由器、交换机等网络交换设备</p></li></ul><p><strong>边：通信链路</strong></p><ul><li><p>接入网链路：主机连接到互联网的链路</p></li><li><p>主干链路：路由器间的链路</p></li></ul><p><strong>协议</strong></p><ul><li>传输层TCP、UDP协议</li><li>网络层IP协议</li><li>应用层FTP、SMTP、HTTP、DNS协议等</li></ul><p><strong>协议的定义</strong>：对等层实体，在通信过程中，需要遵守的规则的集合、包括语法、语义、报文格式以及次序。</p><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112121217.png" alt="image-20231003112121217"></p><p>1、物理层：发送时将数据bit流转化为物理信号（电磁波，光波），接收时将物理信号转换为bit流数据。实现计算机节点之间比特流的传输，规定传输媒体接口的标准，屏蔽掉具体传输介质和物理设备的差异，使数据链路层不必关心网络的具体传输介质，按照物理层规定的标准传输数据就行</p><p>2、数据链路层：向上:将物理层的一个个bit，组合转换为帧包括帧头和帧尾，向下:把网络层数据报加头和尾，封装成帧，帧头中包括源MAC地址和目的MAC地址。 提供相邻两个节点之间的数据传输</p><p>通过差错控制、流量控制等方法，使有差错的物理线路变为无差错的数据链路。</p><p>数据链路层的几个基本方法：数据封装成桢、透明传输、差错控制、流量控制。</p><p>封装成桢：把网络层数据报加头和尾，封装成帧，帧头中包括源MAC地址和目的MAC地址。<br>透明传输：零比特填充、转义字符。<br>差错控制：接收者检测错误,如果发现差错，丢弃该帧，差错控制方法有 CRC 循环冗余码<br>流量控制：控制发送的传输速度，使得接收方来得及接收。传输层TCP也有流量控制功能，但TCP是端到端的流量控制，链路层是点到点（比如一个路由器到下一个路由器）<br>3、网络层：<strong>实现网络地址与物理地址的转换</strong>，并通过<strong>路由选择算法为分组通过通信子网选择最适当的路径</strong></p><p>网络层最重要的一个功能就是：路由选择。路由一般包括路由表和路由算法两个方面。每个路由器都必须建立和维护自身的路由表，一种是静态维护，也就是人工设置，适用于小型网络；另一种就是动态维护，是在运行过程中根据网络情况自动地动态维护路由表。</p><p>4、传输层：提供源端与目的端之间提供可靠的透明数据传输，传输层协议为不同主机上运行的进程提供逻辑通信。</p><p>网络层协议负责的是提供主机间的逻辑通信，而传输层协议负责的是提供进程间的逻辑通信。</p><p>5、会话层：管理（建立、维护、重连）应用之间的会话，是用户<strong>应用程序和网络之间的接口</strong>，负责在网络中的<strong>两节点之间建立、维持、终止通信</strong>。</p><p>6、表示层：<strong>处理用户数据的表示问题</strong>，如数据的编码、<strong>格式转换、加密和解密、压缩和解压缩</strong>。</p><p>7、应用层(FTP、SMTP、HTTP、DNS)：传输层基础上实现网络应用，为<strong>用户的应用进程提供网络通信服务</strong>，完成和实现用户请求的各种服务。</p><h4 id="各个设备工作在哪一层"><a href="#各个设备工作在哪一层" class="headerlink" title="各个设备工作在哪一层"></a>各个设备工作在哪一层</h4><ul><li><p>网桥：工作在<strong>数据链路层</strong>，在不同或相同类型的LAN之间存储并转发数据帧，必要时进行链路层上的协议转换。可连接两个或多个网络，在其中传送信息包。</p></li><li><p>交换机：工作在<strong>数据链路层</strong>，原理等同于多端口网桥。作用是连接数个相同网段的不同主机，减少网内冲突，隔离冲突域。利用存储转发和过滤技术来从物理上分割网段。</p></li><li><p>路由器：工作在<strong>网络层</strong>，在不同的网络间存储并转发分组。可在异种网络之间（即不同类型的局域网互连，局域网与广域网，广域网与广域网）传输数据并进行路径选择，使用专门的软件协议从逻辑上对整个网络进行划分。</p></li><li><p>网关：对高层协议（包括传输层及更高层次）进行转换的网间连接器。允许使用不兼容的协议，比如SPX&#x2F;IPX和TCP&#x2F;IP的系统和网络互连。因为协议转换是网关最重要的功能，所以答案是工作<strong>在传输层及以上层次</strong>。</p></li><li><p>网卡：在物理层上网卡主要是完成物理接口的连接,电信号的传送以及将数据分解为适当大小的数据包之后向网络上发送的功能. 数据链路层功能包括链路建立和拆除，帧定界同步顺序差错控制这些。大多认为主要工作在物理层。通常包含<strong>物理层以及链路层</strong></p></li></ul><h4 id="TCP粘包拆包问题"><a href="#TCP粘包拆包问题" class="headerlink" title="TCP粘包拆包问题"></a>TCP粘包拆包问题</h4><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><p>TCP在接受数据的时候，有一个滑动窗口来控制接受数据的大小，这个滑动窗口你就可以理解为一个缓冲区的大小。缓冲区满了就会把数据发送。数据包的大小是不固定的，有时候比缓冲区大有时候小。</p><ul><li>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题；</li><li>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/864571e427ea43eeb8db63e4bcd53455.png" alt="img"></p><h5 id="为什么会发生"><a href="#为什么会发生" class="headerlink" title="为什么会发生"></a>为什么会发生</h5><p>1.TCP会发生粘包问题：TCP 是面向连接的传输协议,TCP 传输的数据是以流的形式,而流数据是没有明确的开始结尾边界,所以 TCP 也没办法判断哪一段流属于一个消息;内容与内容之间没有明确的分界标志,需要认为手动地去给这些协议划分边界。<br>粘包时：发送方每次写入数据 &lt; 接收方套接字(Socket)缓冲区大小。<br>拆包时：发送方每次写入数据 &gt; 接收方套接字(Socket)缓冲区大小。</p><p>2.UDP不会发生粘包问题：UDP具有保护消息边界,在每个UDP包中就有了消息头(UDP长度、源端口、目的端口、校验和)。</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>1、客户端在发送数据包的时候，每个包都固定长度，比如1024个字节大小，如果客户端发送的数据长度不足1024个字节，则通过补充空格的方式补全到指定长度；</p><p>2、客户端在每个包的末尾使用固定的分隔符，例如\r\n，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的\r\n，然后对其拆分后的头部部分与前一个包的剩余部分进行合并，这样就得到了一个完整的包；</p><p>3、将消息分为头部和消息体，在头部中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；</p><h4 id="HTTP如何解决粘包问题的？"><a href="#HTTP如何解决粘包问题的？" class="headerlink" title="HTTP如何解决粘包问题的？"></a>HTTP如何解决粘包问题的？</h4><p>http请求报文格式<br>1）请求行：以\r\n结束；<br>2）请求头：以\r\n结束；<br>3）\r\n；<br>3）数据；</p><p>http响应报文格式<br>1）响应行：以\r\n结束；<br>2）响应头：以\r\n结束；<br>3）\r\n；<br>4）数据；</p><p>4.1、读取请求行&#x2F;请求头、响应行&#x2F;响应头<br>1、遇到第一个\r\n表示读取请求行或响应行结束；<br>2、遇到\r\n\r\n表示读取请求头或响应头结束；</p><p>4.2、 怎么读取body数据呢？<br>HTTP协议通常使用Content-Length来标识body的长度。在服务器端，需要先申请对应长度的buffer，然后再赋值。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1279a01571164f2ba3c2a8141a0e996a.png" alt="img"></p><p>如果需要一边生产数据一边发送数据，就需要使用”Transfer-Encoding: chunked” 来代替Content-Length，也就是对数据进行分块传输。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/de563592ba4c4d42b9d1acfbda2af5f5.png" alt="img"></p><p>4.2.1、 Content-Length 描述<br>http server接收数据时，发现header中有Content-Length属性，则读取Content-Length的值，确定需要读取body的长度。<br>http server发送数据时，根据需要发送byte的长度，在header中增加Content-Length项，其中value为byte的长度，然后将byte数据当做body发送到客户端。<br>4.2.2、 chunked描述<br>http server接收数据时，发现header中有Transfer-Encoding: chunked，则会按照chunked协议分批读取数据。<br>http server发送数据时，如果需要分批发送到客户端，则需要在header中加上Transfer-Encoding:chunked，然后按照chunked协议分批发送数据。<br>chunked协议具体如下图：</p><p> <img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/8ba16c3c85684457a1bfa01ce4014491.png" alt="img"></p><p>1、主要包含三部分: chunk，last-chunk和trailer。如果分多次发送，则chunk有多份。</p><p>2、 chunk主要包含大小和数据，大小表示这个这个chunk包的大小，使用16进制标示。其中chunk之间的分隔符为CRLF。</p><p>3、通过last-chunk来标识chunk发送完成。一般读取到last-chunk(内容为0)的时候，代表chunk发送完成。</p><p>4、trailer表示增加header等额外信息，一般情况下header是空。通过CRLF来标识整个chunked数据发送完成。</p><p>4.2.3 优&#x2F;缺点<br>优点</p><p>1、假如body的长度是10K，对于Content-Length则需要申请10K连续的buffer，而对于Transfer-Encoding:chunked可以申请1k的空间，然后循环使用10次。节省了内存空间的开销。</p><p>2、如果内容的长度不可知，则可使用chunked方式能有效的解决Content-Length的问题</p><p>3、http服务器压缩可以采用分块压缩，而不是整个块压缩。分块压缩可以一边进行压缩，一般发送数据，来加快数据的传输时间。</p><p>缺点</p><p>1、chunked协议解析比较复杂。</p><p>2、在http转发的场景下(比如nginx)难以处理，比如如何对分块数据进行转发。</p><h4 id="TCP队头阻塞问题"><a href="#TCP队头阻塞问题" class="headerlink" title="TCP队头阻塞问题"></a>TCP队头阻塞问题</h4><p>客户端接收端可能会先收到窗口末端的数据，这个时候 TCP 是不会向上层应用交付数据的，它得等到前面的数据都接收到了才向上交付，所以这就出现了队头阻塞，即队头的包如果发生延迟或者丢失，队尾必须等待发送端重新发送并接收到数据后才会一起向上交付。</p><h4 id="TCP和UDP的区别和应用场景"><a href="#TCP和UDP的区别和应用场景" class="headerlink" title="TCP和UDP的区别和应用场景"></a>TCP和UDP的区别和应用场景</h4><ul><li><p><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</p></li><li><p><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，确保通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p></li><li><p><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了</p></li><li><p><strong>传输效率</strong>：由于使用 TCP 建立连接有握手的机制，进行传输的时候多了连接、确认、重传等机制，TCP 的使用效率会比 UDP 要低</p></li><li><p><strong>传输形式</strong>：TCP 是面向字节流（把应用程序交下来的数据看成无结构的字节流）的，UDP 是面向报文（对应用层的报文既不合并也不拆分，对长度大小都不做任何改变）的。</p></li><li><p><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</p></li><li><p><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</p></li></ul><h5 id="TCP使用场景"><a href="#TCP使用场景" class="headerlink" title="TCP使用场景"></a>TCP使用场景</h5><p>效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</p><h5 id="UDP使用场景"><a href="#UDP使用场景" class="headerlink" title="UDP使用场景"></a>UDP使用场景</h5><p>效率要求相对高，对准确性要求相对低的场景。举几个例子：游戏、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播），即使出现传输错误也可以容忍。</p><h4 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h4><p>QUIC 全称：Quick UDP Internet Connections，是一种基于 UDP 的传输层协议。</p><p><strong>可靠传输</strong></p><p>QUIC 是基于 UDP 协议的，而 UDP 是不可靠传输协议，那 QUIC 是如何实现可靠传输的呢？</p><p>可靠传输有 2 个重要特点：</p><p>（1）完整性：发送端发出的数据包，接收端都能收到</p><p>（2）有序性：接收端能按序组装数据包，解码得到有效的数据</p><p>问题 1：发送端怎么知道发出的包是否被接收端收到了？</p><p>解决方案：通过包号（PKN）和确认应答（SACK）</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-aace93419dd55c73ab4b5fd2976e1375_1440w.webp" alt="img"></p><p>（1）客户端：发送 3 个数据包给服务器（PKN &#x3D; 1，2，3）</p><p>（2）服务器：通过 SACK 告知客户端已经收到了 1 和 3，没有收到 2</p><p>（3）客户端：重传第 2 个数据包（PKN&#x3D;4）</p><p>由此可以看出，QUIC 的数据包号是单调递增的。也就是说，之前发送的数据包（PKN&#x3D;2）和重传的数据包（PKN&#x3D;4），虽然数据一样，但包号不同。</p><p>问题 2：既然包号是单调递增的，那接收端怎么保证数据的有序性呢？</p><p>解决方案：通过数据偏移量 offset</p><p>每个数据包都有一个 offset 字段，表示在整个数据中的偏移量。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-e6abef5bc9316fd87905a5e97b547050_1440w.webp" alt="img"></p><p>接收端根据 offset 字段就可以对异步到达的数据包进行排序了。为什么 QUIC 要将 PKN 设计为单调递增？解决 TCP 的重传歧义问题：</p><p>由于原始包和重传包的序列号是一样的，客户端不知道服务器返回的 ACK 包到底是原始包的，还是重传包的。但 QUIC 的原始包和重传包的序列号是不同的，也就可以判断 ACK 包的归属。</p><h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><strong>流量控制</strong></h5><p>和 TCP 一样，QUIC 也是利用滑动窗口机制实现流量控制：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-2b659a36da1993c1a65bed4830606997_1440w.webp" alt="img"></p><p>发送端的窗口大小由接收端告知，包括发送窗口和可用窗口，如果发送端收到了接收端的 ACK 确认应答（比如 ACK 36），那整个窗口就会向右滑动，发送新的数据包。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-62c627de56caf4617f97628215c4fa03_1440w.webp" alt="img"></p><p>和 TCP 不同的是，QUIC 的滑动窗口分为 Connection 和 Stream 两种级别。Connection 流量控制：规定了所有数据流的总窗口大小；Stream 流量控制：规定了每个流的窗口大小。</p><p>假设现在有 3 个 Stream，滑动窗口分别如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-a5f95afac0935ae11f4672d3fdf9bf3e_1440w.webp" alt="img"></p><p>则整个 Connection 的可用窗口大小为：20+30+10 &#x3D; 60</p><h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><strong>拥塞控制</strong></h5><p>拥塞控制是通过拥塞窗口限制发送方的数据量，避免整个网络发生拥塞。那拥塞窗口（cwnd）和滑动窗口（发送窗口：swnd，接收窗口：rwnd）有什么关系呢？</p><p>swnd &#x3D; min（cwnd，rwnd）</p><p>也就是说，发送窗口的大小是由接收窗口和拥塞窗口共同决定的。那拥塞窗口的大小是如何计算的？通过 4 个拥塞控制算法：慢启动、拥塞避免、拥塞发生、快速恢复</p><h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a><strong>慢启动</strong></h5><p>初始拥塞窗口大小 cwnd&#x3D;1，也就是可以传输 1 个 MDS（Max Datagram Size）大小的数据包，一般网卡允许传输的最大数据单元 MTU 的大小是 1500 字节。对于 UDP 数据报而言：MDS &#x3D; 1500（MTU）- 20（IP 首部）- 8（UDP 首部） &#x3D; 1472 字节</p><p><strong>慢启动算法</strong>： 当发送方每收到一个 ACK，拥塞窗口就加 1（cwnd++）</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-54d7f3cc6ec67a9ae47fa5dfa3fccfc0_1440w.webp" alt="img"></p><p>由此可以看出，慢启动阶段，拥塞窗口呈指数增长，那增长到多少是个头？</p><p>有一个上限值：ssthresh（slow start threshold），从源码看，这个值是 2000 * MDS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const QuicPacketCount kDefaultMaxCongestionWindowPackets = 2000;</span><br></pre></td></tr></table></figure><ul><li>当 <strong>cwnd &lt; ssthresh</strong> 时，使用慢启动算法</li><li>当 <strong>cwnd &gt;&#x3D; ssthresh</strong> 时，使用拥塞避免算法</li></ul><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a><strong>拥塞避免</strong></h5><p>当拥塞窗口大小超过慢启动上限后，就会进入拥塞避免阶段。</p><p><strong>拥塞避免算法：</strong> 当发送方每收到一个 ACK，拥塞窗口就加 1&#x2F;cwnd</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-1072c63fd6e97e671affe2d9346c3836_1440w.webp" alt="img"></p><p>假设现在的 cwnd&#x3D;8，可以发送 8 个数据包，当收到这 8 个包的 ACK 时，拥塞窗口才会加 1，由此可知，在拥塞避免阶段，拥塞窗口是线性增长的。</p><p>那啥时候是个头呢？不管，让它继续增长，直到网络发生拥塞，出现丢包，这时就会触发重传机制，进入拥塞发生阶段</p><h5 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a><strong>拥塞发生</strong></h5><p>重传有 2 种：超时重传和快速重传</p><p>如果发生超时重传，使用的拥塞发生算法为：</p><ul><li>ssthresh &#x3D; cwnd &#x2F; 2</li><li>cwnd &#x3D; 1</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-dcefc32fcbaca9acf5a347580b56ff3c_1440w.webp" alt="img"></p><p>重新使用慢启动和拥塞避免算法增加拥塞窗口的大小。</p><p>如果发生快速重传（发送方收到 3 个相同的 ACK），使用的拥塞发生算法为：</p><ul><li>cwnd &#x3D; cwnd &#x2F; 2</li><li>ssthresh &#x3D; cwnd</li></ul><p>接下来就会进入快速恢复阶段。</p><h5 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a><strong>快速恢复</strong></h5><p>快速恢复算法：cwnd &#x3D; ssthresh + 3（因为收到 3 个 ACK），然后进入拥塞避免阶段。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-9158217fe2e02f6b17a29aadf649cdd2_1440w.webp" alt="img"></p><h4 id="QUIC相比于TCP的优势"><a href="#QUIC相比于TCP的优势" class="headerlink" title="QUIC相比于TCP的优势"></a>QUIC相比于TCP的优势</h4><p>安全性:QUIC它完全以加密形式通信，未加密的通信是完全被禁止的</p><p><strong>0-RTT 握手</strong>:其实原理很简单：客户端缓存了 ServerConfig（B&#x3D;b*G%P），下次建连直接使用缓存数据计算通信密钥。</p><p>多路复用方面，QUIC可以复用多个stream，同时其中一个stream的丢包并不会影响其他stream，这也说明了在QUIC中，每个stream是相对独立的,解决了TCP协议中队头阻塞问题。</p><h4 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h4><p>建立一个 TCP 连接需要“三次握手”，缺一不可：</p><ul><li><strong>一次握手</strong>:客户端发送带有 SYN（SEQ&#x3D;x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</li><li><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态</li><li><strong>三次握手</strong>:客户端发送带有 ACK(ACK&#x3D;y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成 TCP 三次握手。</li></ul><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p><ol><li><strong>第一次握手</strong>：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li><li><strong>第二次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li><li><strong>第三次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li><li>防止失效的请求报文又请求建立连接，浪费服务器资源</li></ol><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240104135112905.png" alt="image-20240104135112905"></p><p>三次握手就能确认双方收发功能都正常，缺一不可。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112124898.png" alt="image-20231003112124898"></p><h5 id="第-2-次握手传回了-ACK，为什么还要传回-SYN？"><a href="#第-2-次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="第 2 次握手传回了 ACK，为什么还要传回 SYN？"></a>第 2 次握手传回了 ACK，为什么还要传回 SYN？</h5><p>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信也是正常的。</p><blockquote><p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP&#x2F;IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p></blockquote><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112128868.png" alt="image-20231003112128868"></p><p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p><ol><li><strong>第一次挥手</strong>：客户端发送一个 FIN（SEQ&#x3D;x） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li><li><strong>第二次挥手</strong>：服务器收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （ACK&#x3D;x+1）标志的数据包-&gt;客户端 。然后服务端进入 <strong>CLOSE-WAIT</strong> 状态，客户端进入 <strong>FIN-WAIT-2</strong> 状态。</li><li><strong>第三次挥手</strong>：服务端发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 <strong>LAST-ACK</strong> 状态。</li><li><strong>第四次挥手</strong>：客户端发送 ACK (ACK&#x3D;y+1)标志的数据包-&gt;服务端，然后客户端进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (ACK&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li></ol><p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p><h5 id="为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？"><a href="#为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？" class="headerlink" title="为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？"></a>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</h5><p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p><h5 id="如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？"><a href="#如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？" class="headerlink" title="# 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？"></a><a href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84-ack-%E6%B2%A1%E6%9C%89%E9%80%81%E8%BE%BE%E5%AE%A2%E6%88%B7%E7%AB%AF-%E4%BC%9A%E6%80%8E%E6%A0%B7">#</a> 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h5><p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p><h5 id="为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？"><a href="#为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？" class="headerlink" title="# 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85-2-msl-%E6%8A%A5%E6%96%87%E6%AE%B5%E6%9C%80%E9%95%BF%E5%AF%BF%E5%91%BD-%E6%97%B6%E9%97%B4%E5%90%8E%E6%89%8D%E8%BF%9B%E5%85%A5-closed-%E7%8A%B6%E6%80%81">#</a> 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h5><p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p><blockquote><p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接，可根据具体实现动态调整MSL。</p></blockquote><h4 id="讲一讲SYN洪泛攻击，以及解决策略"><a href="#讲一讲SYN洪泛攻击，以及解决策略" class="headerlink" title="讲一讲SYN洪泛攻击，以及解决策略"></a>讲一讲SYN洪泛攻击，以及解决策略</h4><p>洪泛攻击： 在 TCP 的三次握手机制的第一步中，客户端会向服务器发送 SYN 报文段。服务器接收到 SYN 报文段后会为该 TCP分 配缓存和变量，如果攻击分子大量地往服务器发送 SYN 报文段，服务器的连接资源终将被耗尽，导致内存溢出无法继续服务。</p><p>解决策略：当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源 IP，目的 IP，端口号以及只有服务器自己知道的一个秘密函数生成一个 cookie，并把 cookie 作为序列号响应给客户端。</p><p>如果客户端是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段。接下来服务器会根据确认报文的源 Id，目的 Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1 等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源。</p><p>这样一来就不会为恶意攻击的 SYN 报文段分配资源空间，避免了攻击。</p><h4 id="详细介绍一下-TCP-的四次挥手机制，为什么要有-TIME-WAIT-状态，为什么需要四次握手？服务器出现了大量-CLOSE-WAIT-状态如何解决"><a href="#详细介绍一下-TCP-的四次挥手机制，为什么要有-TIME-WAIT-状态，为什么需要四次握手？服务器出现了大量-CLOSE-WAIT-状态如何解决" class="headerlink" title="详细介绍一下 TCP 的四次挥手机制，为什么要有 TIME_WAIT 状态，为什么需要四次握手？服务器出现了大量 CLOSE_WAIT 状态如何解决"></a>详细介绍一下 TCP 的四次挥手机制，为什么要有 TIME_WAIT 状态，为什么需要四次握手？服务器出现了大量 CLOSE_WAIT 状态如何解决</h4><p>当客户端要服务器断开连接时，客户端 TCP 会向服务器发送一个特殊的报文段，该报文段的 FIN 标志位会被置 1，接着服务器会向客户端发送一个确认报文段。然后服务器也会客户端发送一个 FIN 标志位为 1 的终止报文段，随后客户端回送一个确认报文段，服务器立即断开连接。客户端等待一段时间后也断开连接。</p><p>为什么要有 TIME_WAIT 状态？因为客户端最后向服务器发送的确认 ACK 是有可能丢失的，当出现超时，服务端会再次发送 FIN 报文段，如果客户端已经关闭了就收不到了。</p><p>大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。</p><p>详情可参考以下博客：<a href="https://www.cnblogs.com/sunxucool/p/3449068.html">https://www.cnblogs.com/sunxucool/p/3449068.html</a></p><h4 id="TCP的可靠传输是如何保障的"><a href="#TCP的可靠传输是如何保障的" class="headerlink" title="TCP的可靠传输是如何保障的"></a>TCP的可靠传输是如何保障的</h4><ul><li><strong>基于数据块传输</strong>：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li><li><strong>连接稳定可靠</strong>：通过三次握手四次挥手，保证了连接的可靠性，数据传输的完整性。</li><li><strong>序号机制，对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号（序列号是数据第一个字节的序号），有了序列号能够将接收到的数据<strong>根据序列号排序</strong>，并且<strong>去掉重复序列号的数据</strong>就可以实现数据包去重。</li><li><strong>校验和</strong> : TCP添加伪首部，TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个<strong>相应的确认信息</strong>（ACK）。<strong>超过该定时器时间依旧未收到对方确认，那么对应的数据包就被假设为已丢失并进行重传，便会重新发送该数据</strong></li><li><strong>流量控制</strong> : <strong>接收方根据自己接收缓冲的大小，可在设置确认报文字段的窗口字段，动态调整发送方发送窗口大小。</strong>TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制，窗口大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值）。</li><li><strong>拥塞控制</strong> : 通过慢启动，当网络拥塞时（发送方的数据迟迟无法到达接收方），发送方估算网络拥堵程度减少数据的发送。</li></ul><p>总结：TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112139329.png" alt="image-20231003112139329"></p><p>udp第四个字段为17</p><h4 id="详细讲一下TCP的滑动窗口"><a href="#详细讲一下TCP的滑动窗口" class="headerlink" title="详细讲一下TCP的滑动窗口"></a>详细讲一下TCP的滑动窗口<img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/tcp-send-window.png" alt="TCP发送窗口结构"></h4><p>从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。</p><h5 id="先讲流量控制："><a href="#先讲流量控制：" class="headerlink" title="先讲流量控制："></a>先讲流量控制：</h5><p><strong>接收方根据自己接收缓冲的大小，可在设置确认报文字段的窗口字段，动态调整发送方发送窗口大小。</strong>TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失</p><h5 id="接着讲解拥塞控制："><a href="#接着讲解拥塞控制：" class="headerlink" title="接着讲解拥塞控制："></a>接着讲解拥塞控制：</h5><p>拥塞控制是指发送方先设置一个小的窗口值作为发送速率，当成功发包并接收到 ACK 时，便以<strong>指数速率增大发送窗口的大小</strong>，直到遇到丢包（超时&#x2F;三个冗余 ACK ），才停止并调整窗口的大小。这么做能最大限度地利用带宽，又不至于让网络环境变得太过拥挤。</p><p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p><p><a href="https://blog.csdn.net/qq_41431406/article/details/97926927">TCP的拥塞控制（详解）-CSDN博客</a></p><p><strong>UDP接收缓冲区</strong></p><p>每个UDP socket都有一个接收缓冲区，没有发送缓冲区，从概念上来说就是只要有数据就发，不管对方是否可以正确接收，所以不缓冲，不需要发送缓冲区。</p><p>UDP：当套接口接收缓冲区满时，新来的数据报无法进入接收缓冲区，此数据报就被丢弃。UDP是没有流量控制的；快的发送者可以很容易地就淹没慢的接收者，导致接收方的UDP丢弃数据报。</p><h4 id="讲述浏览器中输入一个网址之后背后的过程："><a href="#讲述浏览器中输入一个网址之后背后的过程：" class="headerlink" title="讲述浏览器中输入一个网址之后背后的过程："></a><strong>讲述浏览器中输入一个网址之后背后的过程：</strong></h4><ol><li><p>URL 解析：</p><p><strong>地址解析</strong>：首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，（如果是关键词就直接按照关键词搜索）并且根据你输入的内容进行自动完成、字符编码等操作。浏览器还会进行一些额外的操作，比如安全检查、访问限制</p></li><li><p>DNS 查询</p><p><strong>1</strong>.<strong>浏览器缓存</strong>：浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p><p><strong>2. 操作系统缓存</strong>：操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p><p><strong>3. 路由器缓存</strong>：路由器也有自己的缓存。</p><p><strong>4. 本地 DNS 缓存</strong>：ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，也就是本地DNS服务器，它们在大多数情况下都会有缓存。</p><p><strong>5.根域名服务器查询</strong>：本地 DNS 服务器会将请求转发到互联网上的根域,再查询顶级域名服务器，权威域名服务器，找到对应服务器的ip地址</p></li><li><p>通过ip地址找到服务器，并与服务器建立TCP 连接</p></li><li><p>浏览器向web服务器发送一个HTTP请求</p></li><li><p>服务器对发送的请求进行处理，并发回一个HTML响应</p></li><li><p>浏览器接收到来自服务器的响应资源后，会对资源进行分析接受响应，浏览器渲染页面，得到我们看到的网页</p></li></ol><h4 id="一个请求达到后端整个过程"><a href="#一个请求达到后端整个过程" class="headerlink" title="一个请求达到后端整个过程"></a>一个请求达到后端整个过程</h4><ol><li><strong>建立连接</strong>：客户端通过TCP&#x2F;IP协议与服务器建立连接，这是HTTP的基础。</li><li><strong>发送请求</strong>：客户端向服务器发送一个HTTP请求，其中包含请求方法（例如GET或POST）和要访问的资源的URL。</li><li><strong>处理请求</strong>：服务器接收到请求后，会解析请求，查找所请求的资源，并准备好将其发送回客户端的响应。</li><li><strong>发送响应</strong>：服务器将响应发送回客户端，响应通常包括状态码、响应头和响应体。</li><li><strong>关闭连接</strong>：连接在请求和响应之后通常会被关闭，但HTTP&#x2F;1.1引入了持久连接以改善性能。</li></ol><h4 id="讲讲TCP的表头有哪些字段，这些字段你是背的还是了解过有什么作用，有过对每个字段的功能的测试吗"><a href="#讲讲TCP的表头有哪些字段，这些字段你是背的还是了解过有什么作用，有过对每个字段的功能的测试吗" class="headerlink" title="讲讲TCP的表头有哪些字段，这些字段你是背的还是了解过有什么作用，有过对每个字段的功能的测试吗"></a>讲讲TCP的表头有哪些字段，这些字段你是背的还是了解过有什么作用，有过对每个字段的功能的测试吗</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112148772.png" alt="image-20231003112148772"></p><ol><li><p>源端口和目的端口       各占2个字节，分别写入源端口和目的端口。</p></li><li><p>序号 在一个TCP连接中传送的字节流中的每一个字节都按照顺序编号，本字段表示本报文段所发送数据的第一个字节的序号。</p></li><li><p>确认号 起到收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则证明到序号N-1为止的所有数据都已正确收到。</p></li><li><p>数据偏移（TCP首部长度） TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B为单位，即一个数值是4B</p></li><li><p>保留          占6位，保留为今后使用，但目前应置为0 。</p></li><li><p>当URG置为1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。</p></li><li><p>确认ACK（ACKnowledgment）      仅当ACK &#x3D; 1时确认号字段才有效，当ACK &#x3D; 0时确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。</p></li><li><p>推送 PSH（PuSH）    当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。接收方TCP收到PSH&#x3D;1的报文段，就尽快地（即“推送”向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付。</p></li><li><p>复位RST（ReSeT）       当RST&#x3D;1时，表明 TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。</p></li><li><p>同步SYN（SYNchronization）       在连接建立时用来同步序号。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN&#x3D;1和ACK&#x3D;1，因此SYN置为1就表示这是一个连接请求或连接接受报文。</p></li><li><p>终止FIN（FINis，意思是“完”“终”）          用来释放一个连接。当FIN&#x3D;1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p></li><li><p>窗口             占2字节。窗口值是【0，2^16-1】之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。</p></li><li><p>检验和       占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式和UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）；把第5字段中的UDP中的长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用IPv6,则相应的伪首部也要改变。</p></li><li><p>紧急指针            占2字节。紧急指针仅在URG&#x3D;1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0时也可以发送紧急数据。</p></li><li><p>选项       长度可变，最长可达4字节。当没有使用“选项”时，TCP的首部长度是20字节。</p></li></ol><h4 id="IP头部"><a href="#IP头部" class="headerlink" title="IP头部"></a>IP头部</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzM5NDMw,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>一行32bit</p><p>版本号（4bit）：告知IP地址是ipv4地址还是ipv6地址</p><p>首部长度（4bit）：告知这个数据包头的长度，由此推断出有无可选项</p><p>服务类型（8bit）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">按位被定义为 PPP DTRM0</span><br><span class="line">PPP：定义包的优先级，取值越大数据越重要</span><br><span class="line"> 000 普通 (Routine)</span><br><span class="line">   001 优先的 (Priority)</span><br><span class="line"> 010 立即的发送 (Immediate)</span><br><span class="line"> 011 闪电式的 (Flash)</span><br><span class="line">  100 比闪电还闪电式的 (Flash Override)</span><br><span class="line"> 101 CRI/TIC/ECP(找不到这个词的翻译)</span><br><span class="line"> 110 网间控制 (Internetwork Control)</span><br><span class="line"> 111 网络控制 (Network Control)</span><br><span class="line">D 时延: 0:普通 1:延迟尽量小</span><br><span class="line">T 吞吐量: 0:普通 1:流量尽量大</span><br><span class="line">R 可靠性: 0:普通 1:可靠性尽量大</span><br><span class="line">M 传输成本: 0:普通 1:成本尽量小</span><br><span class="line">0 最后一位被保留，恒定为0</span><br></pre></td></tr></table></figure><p>总长度（16bit）：告知IP数据报文的总长度（包括被分片数据在内），最大承载量为1500字节，超过将进行数据分片</p><p>片偏移量（13bit）：决定IP分片数据的先后顺序，只能是0或1480的倍数，第一个分片数据发送时偏移量为0，第二个为1480，第三个为2960，以此类推。目的端重组数据包时靠偏移量来按顺序组合分片数据</p><p>标志位（3bit）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一位bit未启用为0               </span><br><span class="line">第二位bit如果需要分片第二位为0，不需要分片第二位为1               </span><br><span class="line">第三位比特为1代表还有后续分片，为0代表为最后一个分片 </span><br><span class="line">共有三种情况：</span><br><span class="line">001（需要分片且还有后续分片）</span><br><span class="line">000（需要分片且当前为最后一个分片）</span><br><span class="line">010（不需要分片）</span><br></pre></td></tr></table></figure><p>标识符（16bit）：区分不同的IP数据包的分片数据，在目的端重组分片数据时能快速找到同一数据包的分片数据</p><p>生存时间TTL（8bit）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">范围为1-255；</span><br><span class="line">单位为跳数，数据包每经过一台路由器即为一跳，TTL值减一；当TTL为0时，丢弃数据包。</span><br><span class="line">作用是防止数据包在网络中永久的循环</span><br><span class="line">Windows系统TTL一般为128，Linux系统TTL为1-128之间，通常为56,64。</span><br><span class="line">注：跳点跟踪命令：tracert IP地址</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>协议（8bit）：区分上层协议；6代表TCP协议，17代表UDP协议</p><p>首部校验和（16bit）：校验三层IP包头是否有误</p><p>源IP地址（32bit）：指发送数据包的主机地址</p><p>目标IP地址（32bit）：指接收数据包的目标主机地址</p><p>选项字段（长度可变，0-40Byte）：通常不会使用到，因为IP包头部分的长度单位为32bit，因此可选项字段的长度必须为32bit的整数倍，当使用时且剩余部分不足32bit会自动填充无用数据来补足32bit。</p><h4 id="http和tcp的区别，分别在哪一层"><a href="#http和tcp的区别，分别在哪一层" class="headerlink" title="http和tcp的区别，分别在哪一层"></a>http和tcp的区别，分别在哪一层</h4><p><strong>TCP协议是传输层协议</strong>，主要解决数据如何在网络中传输，<em><strong>而HTTP是应用层协议</strong></em>**，主要解决如何包装数据，两者本质上没有可比性。</p><p>我们在传输数据时，可以只使用（传输层）TCP&#x2F;IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET 等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP&#x2F;IP做传输层协议将它发到网络上。</p><p><strong>Http协议是建立在TCP协议基础之上的</strong>，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的，所以Http连接是一种短连接，是一种无状态的连接。</p><p>说明：从HTTP&#x2F;1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p><p><strong>Http是无状态的短连接</strong>，直观地说，就是每个请求都是独立的，与前面的请求和后面的请求都是没有直接联系的，因此加入了cookie、session等机制实现有状态的的web。<strong>而TCP是有状态的长连接</strong></p><h4 id="tcp慢启动是怎么实现的"><a href="#tcp慢启动是怎么实现的" class="headerlink" title="tcp慢启动是怎么实现的"></a>tcp慢启动是怎么实现的</h4><p>最初的TCP的实现方式是，在连接建立成功后便会向网络中发送大尺寸的数据包，假如网络出现问题，很多这样的大包会积攒在路由器上，很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此现在的TCP协议规定了，新建立的连接不能够一开始就发送大尺寸的数据包，而只能从一个小尺寸的包开始发送，在发送和数据被对方确认的过程中去计算对方的接收速度，来逐步增加每次发送的数据量（最后到达一个稳定的值，进入高速传输阶段。相应的，慢启动过程中，TCP通道处在低速传输阶段），以避免上述现象的发生。这个策略就是慢启动。</p><p>TCP刚刚开始传输数据时，会<strong>从一个较小的cwnd &#x3D; 1开始，然后按照2的幂逐步增长到sshthresh的过程称为慢启动</strong>，直到<strong>cwnd（拥塞窗口）&gt;（慢启动门限）ssthresh</strong>，则<strong>结束慢启动过程</strong>，<strong>进入到拥塞避免阶段</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1036177bbd5c4ad6bdbe70a70bde14c4.png" alt="img"></p><h4 id="拥塞避免-1"><a href="#拥塞避免-1" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>当TCP经过慢启动阶段，wnd&gt;ssthresh时，就开始使用拥塞避免算法来进行拥塞控制，这个阶段cwnd是以线性方式增长的，每次收到前面发出去的所有包时，cwnd &#x3D; cwnd + 1（实际是每收到一个ACK, cwnd &#x3D; cwnd + 1&#x2F;cwnd），cwnd线性增长直到检测到拥塞发生。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/7a2514f97e0648cf8e44c127a298ca71.png" alt="img"></p><h4 id="快速重传与超时重传算法"><a href="#快速重传与超时重传算法" class="headerlink" title="快速重传与超时重传算法"></a>快速重传与超时重传算法</h4><p>首先， 我们要区别快速重传与超时重传。</p><p>当接收方发现重复的收到三次或者更多个前一个包的 ACK时，就说明中间丢了一个报文，这时候，发送端就不必等待超时再重传，而是可以直接快速地启动重传———这就是快速重传。</p><p>当接收方直到超时，也没有收到ACK和重复时，发送方TCP发送定时器超时后，也会主动发起重传————这就是超时重传。</p><p>发生超时重传和发生快速重传时，拥塞控制的算法是不一样的，当发生快速重传时，就引入了快速重传的算法。</p><h4 id="http和https有什么区别？"><a href="#http和https有什么区别？" class="headerlink" title="http和https有什么区别？"></a>http和https有什么区别？</h4><p>http与https都是常用的网络通信协议</p><p><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</p><p><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</p><p><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p><p><strong>SEO（搜索引擎优化）</strong>：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。</p><h4 id="说一说https实现加密通信的实现原理？CA证书是怎么获得的？一定安全吗？能有中间人吗？"><a href="#说一说https实现加密通信的实现原理？CA证书是怎么获得的？一定安全吗？能有中间人吗？" class="headerlink" title="说一说https实现加密通信的实现原理？CA证书是怎么获得的？一定安全吗？能有中间人吗？"></a>说一说https实现加密通信的实现原理？CA证书是怎么获得的？一定安全吗？能有中间人吗？</h4><ul><li>https是基于tcp协议的，首先客户端会和服务端发起链接建立</li><li>服务端返回它的证书给客户端，证书中包含了服务端公钥S.pub、颁发机构和有效期等信息，证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</li><li>客户端通过操作系统、浏览器内置的根证书（内部包含CA机构的公钥C.pub）验证证书的合法性</li><li>客户端生成随机的对称加密密钥Z，然后通过服务端的公钥S.pub加密发送给服务端</li><li>服务器通过私钥进行解密，获得客户端浏览器的对称加密密钥</li><li>客户端和服务端之后就通过对称加密密钥Z加密数据来进行http通信</li></ul><p>CA证书由网站向CA机构申请，由CA机构颁发，其中包含证书持有者的公钥、域名。同时通过数字签名来做到防止证书被篡改。</p><p>网站在使用HTTPS前，需要向<strong>CA机构</strong>申领一份<strong>数字证书</strong>，数字证书里含有证书持有者信息、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明“该公钥对应该网站”。而这里又有一个显而易见的问题，“<strong>证书本身的传输过程中，如何防止被篡改”</strong>？即如何证明证书本身的真实性？身份证运用了一些防伪技术，而数字证书怎么防伪呢？解决这个问题我们就接近胜利了！</p><h5 id="如何放防止数字证书被篡改？"><a href="#如何放防止数字证书被篡改？" class="headerlink" title="如何放防止数字证书被篡改？"></a><strong>如何放防止数字证书被篡改？</strong></h5><p>我们把证书原本的内容生成一份“签名”，比对证书内容和签名是否一致就能判别是否被篡改。这就是数字证书的“防伪技术”，这里的“签名”就叫<code>数字签名</code>：</p><h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a><strong>数字签名</strong></h5><p>这部分内容建议看下图并结合后面的文字理解，图中左侧是数字签名的制作过程，右侧是验证过程：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-7c78935389af46e197e96d9cd91c06dd_1440w-1696303314365-11.webp" alt="img"></p><p>数字签名的生成与验证（<a href="https://cheapsslsecurity.com/blog/digital-signature-vs-digital-certificate-the-difference-explained/%EF%BC%89">https://cheapsslsecurity.com/blog/digital-signature-vs-digital-certificate-the-difference-explained/）</a></p><p>数字签名的制作过程：</p><ol><li>CA机构拥有非对称加密的私钥和公钥。</li><li>CA机构对证书明文数据T进行hash。</li><li>对hash后的值用私钥加密，得到数字签名S。</li></ol><p>明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。<br>那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）</p><p>浏览器验证过程：</p><ol><li>拿到证书，得到明文T，签名S。</li><li>用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。</li><li>用证书里指明的hash算法对明文T进行hash得到T’。</li><li>显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。</li></ol><p>为何么这样可以保证证书可信呢？我们来仔细想一下。</p><h5 id="中间人有可能篡改该证书吗？"><a href="#中间人有可能篡改该证书吗？" class="headerlink" title="中间人有可能篡改该证书吗？"></a><strong>中间人有可能篡改该证书吗？</strong></h5><p>假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。</p><p>既然不可能篡改，那整个证书被掉包呢？</p><h5 id="中间人有可能把证书掉包吗？"><a href="#中间人有可能把证书掉包吗？" class="headerlink" title="中间人有可能把证书掉包吗？"></a><strong>中间人有可能把证书掉包吗？</strong></h5><p>假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，这确实会导致上文“中间人攻击”那里提到的漏洞？</p><p>其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</p><h5 id="为什么制作数字签名时需要hash一次？。"><a href="#为什么制作数字签名时需要hash一次？。" class="headerlink" title="为什么制作数字签名时需要hash一次？。"></a><strong>为什么制作数字签名时需要hash一次？</strong>。</h5><p>最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加解密就快很多。</p><h4 id="HTTP是基于TCP还是UDP？"><a href="#HTTP是基于TCP还是UDP？" class="headerlink" title="HTTP是基于TCP还是UDP？"></a>HTTP是基于TCP还是UDP？</h4><p>HTTP&#x2F;3.0 之前是基于 TCP 协议的，由于TCP的队头阻塞问题， HTTP&#x2F;3.0 将弃用 TCP，改用 <strong>基于 UDP 的 QUIC 协议</strong> 。</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>进程作为资源分配的基本单位,线程作为调度的基本单位。</p><ul><li>进程可看做是正在执行的程序,每个进程都有独立的代码和数据空间，所以进程间的切换会有较大的开销。一个进程在其执行的过程中可以产生多个线程。</li><li><strong>线程是进程当中的一条执行流程。</strong>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器（</strong>线程切换后能恢复到正确的执行位置<strong>）</strong>、<strong>虚拟机栈（</strong>保证线程中的局部变量不被别的线程访问到<strong>）</strong>和<strong>本地方法栈</strong>（包含局部变量，本地方法），在所以系统在产生一个线程要分配的资源更少，或是在各个线程之间作切换工作时，只需要保存栈和寄存器等不共享的数据，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul><p>线程相比进程能减少开销，体现在：</p><ul><li>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li><li>线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</li><li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li><li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</li></ul><p>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响,因为它们共享了堆和方法区资源。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231016143302701.png" alt="image-20231016143302701"></p><ul><li>堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存</li><li>方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li></ul><h4 id="有了进程为什么还需要线程"><a href="#有了进程为什么还需要线程" class="headerlink" title="有了进程为什么还需要线程?"></a>有了进程为什么还需要线程?</h4><ul><li>进程切换是一个开销很大的操作，线程切换的成本较低。</li><li>线程更轻量，一个进程可以创建多个线程。</li><li>多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。</li><li>同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。</li></ul><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p><strong>协程，又称用户态线程，因为创建一个线程需要调用操作系统的功能（系统调用）, 而创建一个线程则只需要在用户态下完成，一个线程可以有多个协程。</strong></p><p>协程抽象于线程之上，线程是被分割的CPU资源, 协程是组织好的代码流程，可以看作是一种特殊的函数，这个函数可以在某个地方挂起，又可以重新在挂起出继续运行，<strong>协程的调度完全由用户程序控制（也就是在用户态执行）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销。</strong></p><p>协程与线程不同：同一个线程下协程只有并发没有并行，多个协程可以并发地执行任务，在发生IO阻塞地时候就挂起并切换到其他的协程，不需要发生线程的切换，而线程的创建、切换又很消耗系统资源，所以协程能提高效率</p><p>不需要多线程的锁机制。由于只有一个线程，也不存在同时写变量的冲突，在协程中控制共享资源不需要加锁，只需要判断数据的状态，所以执行效率远高于线程</p><h5 id="协程的优点"><a href="#协程的优点" class="headerlink" title="协程的优点"></a>协程的优点</h5><ul><li>由用户程序来控制协程的切换，而不是操作系统的任务调度器来调度，不需要发起系统调用切换到内核态，</li><li>使用寄存器和栈来保存协程的上下文，占用资源少，保存、恢复上下文比线程更高效</li><li>不需要多线程的锁机制。由于只有一个线程，也不存在同时写变量的冲突，在协程中控制共享资源不需要加锁，只需要判断数据的状态，所以执行效率远高于线程。</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODQ3NTYxMQ==,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>协程与线程的区别：</p><ol><li>由于协程的特性, 适合执行大量的<strong>I&#x2F;O 密集型任务</strong>, 而线程在这方面弱于协程</li><li>协程涉及到函数的切换, 多线程涉及到线程的切换, 所以都有<strong>执行上下文</strong>切换, 但是协程不是被操作系统内核所管理, 而完全是由用户程序所控制（也就是在<strong>用户态</strong>执行）, 不会像线程那样需要<strong>在内核态进行上下文切换</strong>来消耗资源，因此<strong>协程的开销远远小于线程的开销</strong></li><li>同一时间, 在多核处理器的环境下, <strong>多个线程是可以并行的</strong>，但是<strong>运行的协程的函数却只能有一个</strong>，<strong>其他的协程的函数都被挂起</strong>, 即<strong>协程是并发的</strong></li><li>由于协程在同一个线程中,也不存在同时写变量的冲突，在协程中控制共享资源不需要加锁。</li></ol><p>使用场景：</p><p><strong>协程适用于IO密集型任务</strong>，有了协程，我们在函数的执行过程中，如果遇到了<strong>I&#x2F;O密集型任务</strong>，函数可以临时让出控制权，<strong>让 CPU 执行其他函数</strong>，等 I&#x2F;O 操作执行完毕以后再收回其他函数的控制权.</p><h4 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h4><h5 id="内核态：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。其他的属于用户态。用户程序运行在用户态-操作系统运行在内核态-（操作系统内核运行在内核态，而服务器运行在用户态）。用户态不能干扰内核态"><a href="#内核态：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。其他的属于用户态。用户程序运行在用户态-操作系统运行在内核态-（操作系统内核运行在内核态，而服务器运行在用户态）。用户态不能干扰内核态" class="headerlink" title="内核态：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。其他的属于用户态。用户程序运行在用户态,操作系统运行在内核态.（操作系统内核运行在内核态，而服务器运行在用户态）。用户态不能干扰内核态."></a>内核态：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。其他的属于用户态。用户程序运行在用户态,操作系统运行在内核态.（操作系统内核运行在内核态，而服务器运行在用户态）。用户态不能干扰内核态.</h5><h5 id="用户态："><a href="#用户态：" class="headerlink" title="用户态："></a>用户态：</h5><p>不能直接使用系统资源，也不能改变 CPU 的工作状态，并且只能访问这个用户程序自己的存储空间！</p><h5 id="内核态："><a href="#内核态：" class="headerlink" title="内核态："></a>内核态：</h5><p>内核态可以使用计算机所有的硬件资源，操作系统运行在内核态。为了安全性和稳定性，操作系统的程序不能随便访问，这就是内核态。即需要执行操作系统的程序就必须转换到内核态才能执行</p><h5 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h5><p>在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。如果所有的程序都能使用这些指令，那么你的系统一天死机N回就不足为奇了。<br>所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。<br>如此设计的本质意义是进行权限保护。 限定用户的程序不能乱搞操作系统，如果人人都可以任意读写任意地址空间软件管理便会乱套.</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg5a2f5rWpX2pheQ==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h4 id="使用哪个命令去查看一个进程的信息"><a href="#使用哪个命令去查看一个进程的信息" class="headerlink" title="使用哪个命令去查看一个进程的信息"></a>使用哪个命令去查看一个进程的信息</h4><h5 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h5><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li>tasklist 查看进程</li><li>taskkill 杀死进程</li></ul><h5 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h5><ul><li>ps -fe 查看所有进程</li><li>ps -fT -p <PID> 查看某个进程（PID）的所有线程</li><li>kill 杀死进程</li><li>top 按大写 H 切换是否显示线程</li><li>top -H -p <PID> 查看某个进程（PID）的所有线程</li></ul><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><ul><li>jps 命令查看所有 Java 进程</li><li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</li><li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li></ul><h4 id="多线程通信方式"><a href="#多线程通信方式" class="headerlink" title="多线程通信方式"></a>多线程通信方式</h4><p>在Java中，多线程通信是通过一些机制和方法来实现的，以确保不同线程之间能够协同工作。以下是一些常见的多线程通信方式：</p><ol><li><strong>共享变量：</strong> 多个线程可以共享一个变量，通过读写该变量来进行通信。为了确保线程安全，通常需要使用<code>volatile</code>关键字或者<code>synchronized</code>关键字来控制访问。例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeclass SharedResource &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> sharedValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        sharedValue = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sharedValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>wait()和notify()：</strong> 这是基于对象监视器（Object Monitor）的机制，用于线程之间的等待和通知。<code>wait()</code>方法让一个线程等待，而<code>notify()</code>方法通知等待的线程继续执行。通常与<code>synchronized</code>关键字一起使用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeclass SharedResource &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sharedValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        sharedValue = value;</span><br><span class="line">        notify(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (sharedValue == <span class="number">0</span>) &#123;</span><br><span class="line">            wait(); <span class="comment">// 等待通知</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sharedValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>BlockingQueue：</strong> 使用<code>java.util.concurrent.BlockingQueue</code>可以方便地实现线程之间的通信。它提供了阻塞操作，当队列为空或已满时，线程会自动阻塞或等待。例如，<code>LinkedBlockingQueue</code>可以用于生产者-消费者问题。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code<span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    queue.put(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> queue.take();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>CountDownLatch和CyclicBarrier：</strong> 这两个类用于协调多个线程的执行。<code>CountDownLatch</code>用于等待一个或多个线程的完成，而<code>CyclicBarrier</code>用于等待多个线程到达某个同步点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个线程执行任务</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        latch.countDown(); <span class="comment">// 任务完成，计数减一</span></span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程等待所有任务完成</span></span><br><span class="line">latch.await();</span><br></pre></td></tr></table></figure><ol><li><strong>Semaphore：</strong> <code>java.util.concurrent.Semaphore</code>用于控制同时访问的线程数量。它允许多个线程同时访问一个共享资源。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javaCopy <span class="type">codeSemaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>); <span class="comment">// 最多允许3个线程同时访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程尝试获取许可</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    semaphore.acquire(); <span class="comment">// 获取许可</span></span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些是Java中常见的多线程通信方式。选择合适的通信方式取决于问题的性质和需求。需要注意，不正确的多线程通信可能导致竞态条件和死锁等问题，因此在设计多线程应用程序时应格外小心。</p><h4 id="虚拟内存的作用"><a href="#虚拟内存的作用" class="headerlink" title="虚拟内存的作用"></a>虚拟内存的作用</h4><p>如果直接使用物理内存，可能多个进程会同时使用同一个物理内存导致冲突。</p><p>我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「<strong>虚拟地址</strong>」，大家自己玩自己的地址就行，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，<strong>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</strong></p><p>如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/298fb68e3da94d767b02f2ed81ebf2c4.png" alt="进程的中间层"></p><h4 id="进程间通信方式，进程通信的时候信号量是如何实现的"><a href="#进程间通信方式，进程通信的时候信号量是如何实现的" class="headerlink" title="进程间通信方式，进程通信的时候信号量是如何实现的"></a>进程间通信方式，进程通信的时候信号量是如何实现的</h4><p><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E6%80%BB%E7%BB%93">5.2 进程间有哪些通信方式？ | 小林coding (xiaolincoding.com)</a></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/3-%E6%8F%90%E7%BA%B2.jpg" alt="img"></p><p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/4-%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4.jpg" alt="img"></p><h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>其实，<strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/5-%E7%AE%A1%E9%81%93-pipe.jpg" alt="img"></p><p>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/8-%E7%AE%A1%E9%81%93-pipe-shell.jpg" alt="img"></p><p>所以说，在 shell 里通过「<code>|</code>」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。</p><p>我们可以得知，<strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p><p>另外，<strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p><p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><hr><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="#消息队列"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">#</a>消息队列</h5><p>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。</p><p>对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p><p>再来，<strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p><p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</p><p>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p><p>但邮件的通信方式存在不足的地方有两点，<strong>一是通信不及时，二是附件也有大小限制</strong>，这同样也是消息队列通信不足的点。</p><p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 <code>MSGMAX</code> 和 <code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p><p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p><hr><h5 id="共享内存"><a href="#共享内存" class="headerlink" title="#共享内存"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98">#</a>共享内存</h5><p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</p><p>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p><p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/9-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.jpg" alt="img"></p><hr><h5 id="信号量"><a href="#信号量" class="headerlink" title="#信号量"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E4%BF%A1%E5%8F%B7%E9%87%8F">#</a>信号量</h5><p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p><p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p><p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p><p>接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 <code>1</code>。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/10-%E4%BF%A1%E5%8F%B7%E9%87%8F-%E4%BA%92%E6%96%A5.jpg" alt="img"></p><p>具体的过程如下：</p><ul><li>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。</li><li>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。</li><li>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的进程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。</li></ul><p>可以发现，信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p><p>另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。</p><p>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。</p><p>那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 <code>0</code>。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/11-%E4%BF%A1%E5%8F%B7%E9%87%8F-%E5%90%8C%E6%AD%A5.jpg" alt="img"></p><p>具体过程：</p><ul><li>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；</li><li>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；</li><li>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。</li></ul><p>可以发现，信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p><hr><h5 id="信号"><a href="#信号" class="headerlink" title="#信号"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E4%BF%A1%E5%8F%B7">#</a>信号</h5><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p><p>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。</p><p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 命令，查看所有的信号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -l</span></span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p><ul><li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li><li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li></ul><p>如果进程在后台运行，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p><ul><li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li></ul><p>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</p><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p><p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。</p><p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p><p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p><hr><h5 id="Socket"><a href="#Socket" class="headerlink" title="#Socket"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#socket">#</a>Socket</h5><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p><p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p><p>我们来看看创建 socket 的系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocal)</span></span><br></pre></td></tr></table></figure><p>三个参数分别代表：</p><ul><li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL&#x2F;AF_UNIX 用于本机；</li><li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；</li><li>protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；</li></ul><p>根据创建 socket 类型的不同，通信的方式也就不同：</p><ul><li>实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；</li><li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li><li>实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li></ul><p>接下来，简单说一下这三种通信的编程模式。</p><blockquote><p>针对 TCP 协议通信的 socket 编程模型</p></blockquote><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/12-TCP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" alt="img"></p><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li></ul><p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p><p>所以，监听的 socket 和真正用来传送数据的 socket，是「<strong>两个</strong>」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><blockquote><p>针对 UDP 协议通信的 socket 编程模型</p></blockquote><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/13-UDP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" alt="img"></p><p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p><p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p><p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。</p><blockquote><p>针对本地进程间通信的 socket 编程模型</p></blockquote><p>本地 socket 被用于在<strong>同一台主机上进程间通信</strong>的场景：</p><ul><li>本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；</li><li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</li></ul><p>对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。</p><p>对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。</p><p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</p><hr><h5 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E6%80%BB%E7%BB%93">#</a>总结</h5><p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。</p><p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。</p><p><strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「<code>|</code>」竖线就是匿名管道，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来<strong>匿名管道是只能用于存在父子关系的进程间通信</strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</p><p><strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是<strong>缓存在内核</strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><p><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></p><p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p><p>那么，就需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p><p>与信号量名字很相似的叫<strong>信号</strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是<strong>异步通信机制</strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，<strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SIGSTOP</code>，这是为了方便我们能在任何时候结束或停止某个进程。</p><p>前面说到的通信机制，都是工作于同一台主机，如果<strong>要与不同主机的进程间通信，那么就需要 Socket 通信了</strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p><h4 id="线程崩溃了进程也会崩溃吗"><a href="#线程崩溃了进程也会崩溃吗" class="headerlink" title="线程崩溃了进程也会崩溃吗"></a>线程崩溃了进程也会崩溃吗</h4><p>线程崩溃了，在正常情况下，操作系统为了保证系统安全，所以针对非法内存访问会发送一个 SIGSEGV 信号，而操作系统一般会调用默认的信号处理函数（一般会让相关的进程崩溃）。</p><p>但如果进程觉得”罪不致死”，那么它也可以选择自定义一个信号处理函数，这样的话它就可以做一些自定义的逻辑，比如记录 crash 信息等有意义的事。</p><p>回过头来看为什么JVM虚拟机会针对 StackoverflowError 和 NullPointerException 做额外处理让线程恢复呢，针对 stackoverflow 其实它采用了一种栈回溯的方法保证线程可以一直执行下去，而捕获空指针错误主要是这个错误实在太普遍了。</p><p>为了这一个很常见的错误而让 JVM 崩溃那线上的 JVM 要宕机多少次，所以出于工程健壮性的考虑，与其直接让 JVM 崩溃倒不如让线程起死回生，并且将这两个错误&#x2F;异常抛给用户来处理。</p><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><h5 id="传统的文件传输有多糟糕？"><a href="#传统的文件传输有多糟糕？" class="headerlink" title="传统的文件传输有多糟糕？"></a>传统的文件传输有多糟糕？</h5><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p><p>传统 I&#x2F;O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I&#x2F;O 接口从磁盘读取或写入。</p><p>代码通常如下，一般会需要两个系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure><p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png" alt="img"></p><p>首先，期间共<strong>发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 <code>read()</code> ，一次是 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p><p>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p><p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p><ul><li><em>第一次拷贝</em>，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li><li><em>第二次拷贝</em>，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li><li><em>第三次拷贝</em>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li><li><em>第四次拷贝</em>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li></ul><p>我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。</p><p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p><p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p><ul><li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li><li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li></ul><p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="img"></p><p>这就是所谓的<strong>零拷贝（*Zero-copy*）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</strong>。</p><p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p><p>所以，总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。</p><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><h4 id="进程与线程-1"><a href="#进程与线程-1" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>进程作为资源分配的基本单位,线程作为调度的基本单位。</p><ul><li>进程可看做是正在执行的程序,每个进程都有独立的代码和数据空间，所以进程间的切换会有较大的开销。一个进程在其执行的过程中可以产生多个线程。</li><li>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器（</strong>线程切换后能恢复到正确的执行位置<strong>）</strong>、<strong>虚拟机栈（</strong>保证线程中的局部变量不被别的线程访问到<strong>）</strong>和<strong>本地方法栈</strong>（包含局部变量，本地方法），所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul><p>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响,因为它们共享了堆和方法区资源。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231016143302701.png" alt="image-20231016143302701"></p><ul><li>堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存）</li><li>方法区保存在着被加载过的每一个类的信息，包括类的方法、构造器，成员方法，属性等，这些信息由<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">类加载</a>器在加载类时，从类的源文件中抽取出来；<strong>运行时常量池</strong>：当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址转换为真实地址。</li></ul><h4 id="线程创建方法"><a href="#线程创建方法" class="headerlink" title="线程创建方法"></a>线程创建方法</h4><ol><li>继承Thread类并重写run方法</li></ol><ul><li><p>d定义Thread类的子类，并重写该类的run()方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。</p></li><li><p>创建Thread子类的实例，也就是创建了线程对象</p></li><li><p>启动线程，即调用线程的start()方法，本质上调用的是runable接口中的run方法</p></li></ul><p>代码实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;<span class="comment">//继承Thread类</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">new</span> <span class="title class_">MyThread</span>().start();<span class="comment">//创建并启动线程</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过实现Runnable接口并重写run方法</li></ol><ul><li><p>定义Runnable接口的实现类，一样要重写run()方法，这个run（）方法和Thread中的run()方法一样是线程的执行体</p></li><li><p>创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象</p></li><li><p>第三部依然是通过调用线程对象的start()方法来启动线程</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;<span class="comment">//实现Runnable接口</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　　<span class="comment">//创建并启动线程</span></span><br><span class="line">　　　　MyThread2 myThread=<span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">　　　　Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">　　　　thread().start();</span><br><span class="line">　　　　<span class="comment">//或者    new Thread(new MyThread2()).start();</span></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>实现Callable接口并实现call()方法</li></ol><ul><li><p>创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。</p></li><li><p>使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值</p></li><li><p>使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）</p></li><li><p>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread3</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　MyThread3 th=<span class="keyword">new</span> <span class="title class_">MyThread3</span>();</span><br><span class="line">      th.start();</span><br><span class="line">　　　<span class="comment">//也可以直接使用Lambda表达式创建Callable对象</span></span><br><span class="line">　　   <span class="comment">//使用FutureTask类来包装Callable对象</span></span><br><span class="line">　　　FutureTask&lt;Integer&gt; future=<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(</span><br><span class="line">　　　　(Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　  );</span><br><span class="line"></span><br><span class="line">　　　<span class="keyword">new</span> <span class="title class_">Thread</span>(future,<span class="string">&quot;有返回值的线程&quot;</span>).start();<span class="comment">//实质上还是以Callable对象来创建并启动线程</span></span><br><span class="line">　　  <span class="keyword">try</span> &#123;</span><br><span class="line">　　　　System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span>+future.get());<span class="comment">//get()方法会阻塞，直到子线程执行结束才返回</span></span><br><span class="line"> 　　 &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">　　　　ex.printStackTrace();</span><br><span class="line">　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用线程池来创建线程</li></ol><h4 id="Future-类有什么用？"><a href="#Future-类有什么用？" class="headerlink" title="Future 类有什么用？"></a>Future 类有什么用？</h4><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p><p>这其实就是多线程中经典的 <strong>Future 模式</strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p><p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li>取消任务；</li><li>判断任务是否被取消;</li><li>判断任务是否已经执行完成;</li><li>获取任务执行结果。</li></ul><h4 id="Java内存区域，内存模型？"><a href="#Java内存区域，内存模型？" class="headerlink" title="Java内存区域，内存模型？"></a>Java内存区域，内存模型？</h4><p><strong>Java内存模型（JMM）</strong></p><p>可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112214089.png" alt="image-20231003112214089"></p><p>在当前的 Java 内存模型下，线程可以把变量保存 <strong>本地内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p><p><strong>Java内存区域</strong></p><p>Java的内存区域和内存模型是不一样的东西，内存区域是指 JVM 运行时将数据分区域存储，强调对内存空间的划分。</p><p>Java内存区域主要由栈、堆、方法区组成</p><p><strong>栈</strong>：每个线程有自己独立、不共享的虚拟机栈，由多个栈帧（每个方法运行时需要的内存）组成，其中存放参数、局部变量，返回地址等，每个线程只能有一个活动栈帧，对应当前正在执行的那个方法。</p><p><strong>堆</strong>：多个线程共享同一个堆，通过new关键字构建的对象都需要使用堆内存，里面存放了实例对象、字符串常量池，静态变量等。</p><p><strong>方法区</strong>：保存在着被加载过的每一个类的信息，包括类的方法、构造器，成员方法，属性等，这些信息由<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">类加载</a>器在加载类时，从类的源文件中抽取出来；<strong>运行时常量池</strong>：当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址转换为真实地址。</p><p><strong>程序计数器：</strong>每个线程都有一个独立的程序计数器，记录下一条JVM指令的执行地址</p><p><strong>本地方法栈：</strong>调用本地方法（由C或者C++编写的底层的方法，与操作系统的底层API打交道）时给本地方法提供的内存空间</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112225692.png" alt="image-20231003112225692"></p><h4 id="线程的上下文切换是什么"><a href="#线程的上下文切换是什么" class="headerlink" title="线程的上下文切换是什么"></a>线程的上下文切换是什么</h4><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 CPU 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行，CPU被抢占</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li><li>主动让出CPU调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li></ul><p>线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念<br>就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><p>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等<br>Context Switch 频繁发生会影响性能</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112229884.png" alt="image-20231003112229884"></p><h4 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h4><p>多个线程同时被阻塞，处于相互等待的状态，如果没有外界干预，线程会被无限期地阻塞，因此程序不可能正常终止</p><h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><p>互斥条件：该资源任意一个时刻只由一个线程占用。</p><p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p><p>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系</p><h5 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h5><p><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</p><p><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><ul><li><h4 id="同步、异步、阻塞、非阻塞的理解"><a href="#同步、异步、阻塞、非阻塞的理解" class="headerlink" title="同步、异步、阻塞、非阻塞的理解"></a>同步、异步、阻塞、非阻塞的理解</h4><p>同步与异步关注的是<strong>消息通信机制</strong>（synchronous communication&#x2F; asynchronous communication）关注的<strong>是在发出调用后需不需要等待调用结果再返回调用</strong>。</p><p>阻塞和非阻塞关注的是<strong>程序在等待调用结果</strong>（消息，返回值）时的状态，关注的<strong>是等待调用结果时线程能否处理其他事情</strong>。</p><p><strong>阻塞</strong>调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<strong>非阻塞</strong>调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p><strong>(1)阻塞(blocking)、非阻塞（non-blocking）：</strong>可以简单理解为需要做一件事能不能立即得到返回应答，如果不能立即获得返回，需要等待，那就阻塞了(进程或线程就阻塞在那了，不能做其它事情)，否则就可以理解为非阻塞(在等待的过程中可以做其它事情)。</p><p><strong>(2)同步(synchronous)、异步(asynchronous)：</strong> 总是做完一件再去做另一件，不管是否需要时间等待，这就是同步(在发出一个功能调用时，在没有得到结果之前，该调用就不返回,即此时不能做下一件事情)；异步则反之，可以同时做几件事，并非一定需要一件事做完再做另一件事(当一个异步过程调用发出后，调用者不能立刻得到结果,此时可以接着做其它事情)。</p><p>同步简单理解成一问一答同步进行，异步可以简单理解为不必等一个问题有了答案再去问另一个问题，尽管问，有答了再通知你。</p></li></ul><h4 id="start和-run方法的区别"><a href="#start和-run方法的区别" class="headerlink" title="start和 run方法的区别"></a>start和 run方法的区别</h4><ul><li><p>直接调用 run 是在主线程中执行了 run，没有启动新的线程</p></li><li><p>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</p></li></ul><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p><h4 id="java里面线程有几种状态？"><a href="#java里面线程有几种状态？" class="headerlink" title="java里面线程有几种状态？"></a>java里面线程有几种状态？</h4><h5 id="操作系统-层面来描述"><a href="#操作系统-层面来描述" class="headerlink" title="操作系统 层面来描述"></a>操作系统 层面来描述</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112235300.png" alt="image-20231003112235300"></p><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li><li>【运行状态】指获取了 CPU 时间片运行中的状态 ：当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li><li>【阻塞状态】：如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】：等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】，阻塞状态与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h5 id="Java-API-层面来描述"><a href="#Java-API-层面来描述" class="headerlink" title="Java API 层面来描述"></a>Java API 层面来描述</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112238774.png" alt="image-20231003112238774"></p><ul><li><p>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code>。</p><p>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</p><p>BLOCKED：阻塞状态，需要等待锁释放。</p><p>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</p><p>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</p><p>TERMINATED：终止状态，表示该线程已经运行完毕.</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112242092.png" alt="image-20231003112242092"></p></li></ul><h4 id="阻塞和等待有什么区别？"><a href="#阻塞和等待有什么区别？" class="headerlink" title="阻塞和等待有什么区别？"></a>阻塞和等待有什么区别？</h4><p>造成原因不同：线程因为对共享资源竞争失败进入阻塞，而等待是因为api调用而进入等待</p><p>我们说一个操作是”阻塞”的，我们的意思是这个操作会<strong>停止线程的执行</strong>，直到某个条件得到满足。例如，在传统的同步I&#x2F;O中，一个读操作会阻塞线程，直到数据可用为止。<strong>在阻塞期间，线程不能做任何其他的事情，它只是停在那里，等待读操作完成。</strong></p><p>当我们说一个操作是”等待”的，我们的意思是这个操作会<strong>让出线程的控制权</strong>，直到某个条件得到满足。例如，在异步I&#x2F;O中，一个读操作（如ReadAsync）会立即返回一个任务，代表这个操作的完成情况。<strong>在等待这个任务时，线程可以去做其他的事情。这就是所谓的”非阻塞”行为。</strong></p><h4 id="什么情况下会让线程进入-block-状态"><a href="#什么情况下会让线程进入-block-状态" class="headerlink" title="什么情况下会让线程进入 block 状态"></a>什么情况下会让线程进入 block 状态</h4><ul><li>t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED</li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED</li></ul><h4 id="线程调用sleep方法，sleep-10s-，结束后，调用sleep的线程处于什么状态？"><a href="#线程调用sleep方法，sleep-10s-，结束后，调用sleep的线程处于什么状态？" class="headerlink" title="线程调用sleep方法，sleep(10s)，结束后，调用sleep的线程处于什么状态？"></a>线程调用sleep方法，sleep(10s)，结束后，调用sleep的线程处于什么状态？</h4><p><strong>Runable状态</strong></p><p>在sleep的时间内，线程不会释放临界资源，在sleep结束之后，线程正常运行，sleep一般是模拟一些业务，之后unlock就释放了临界资源，比如锁</p><h4 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h4><p><strong>使用位置不同</strong>：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用</p><p><strong>释放资源不同</strong>：调用wait方法时，该线程必须持有锁资源，<strong>wait 方法会主动的释放锁，而 sleep 方法则不会</strong></p><p><strong>源头不同</strong>：wait 方法属于 Object 类的方法，而 sleep 属于 Thread 类的方法</p><p>sleep 方法必须要传递一个超时时间的参数，且过了超时时间之后，线程会自动唤醒。而 wait 方法可以不传递任何参数，不传递任何参数时表示永久休眠，直到另一个线程调用了 notify 或 notifyAll 之后，休眠的线程才能被唤醒。也就是说 <strong>sleep 方法具有主动唤醒功能，而不传递任何参数的 wait 方法只能被动的被唤醒</strong>。<strong>调用 sleep 方法线程会进入 TIMED_WAITING 有时限等待状态，而调用无参数的 wait 方法，线程会进入 WAITING 无时限等待状态</strong></p><h4 id="为什么wait和notify方法要写在synchronized同步代码块中？"><a href="#为什么wait和notify方法要写在synchronized同步代码块中？" class="headerlink" title="为什么wait和notify方法要写在synchronized同步代码块中？"></a>为什么wait和notify方法要写在synchronized同步代码块中？</h4><p>这是Java设计者为了避免使用者出现lost wake up(可能导致线程陷入永久等待)问题而搞出来的。</p><p>列举下面永久等待的场景：</p><p>所以需要synchronized这样的同步机制来避免多线程并发修改这个共享变量，造成永久等待的问题</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112303623.png" alt="image-20231003112303623"></p><p>问题的根源在于，消费者在检查count到调用wait()之间，count就可能被改掉了。</p><p>常见的解决方式是加锁</p><p> wait 和 notify 用来实现多线程之间的协调，wait 表示让线程进入到阻塞状态，notify 表示让阻塞的线程唤醒。</p><p>wait 和 notify 必然是成对出现的，如果一个线程被 wait()方法阻塞，那么必然需要另外一个线程通过 notify()方法来唤醒这个被阻塞的线程，从而实现多线程之间的通信。</p><p>在多线程里面，要实现多个线程之间的通信，除了管道流以外，只能通过共享变量的方法来实现，也就是线程 t1 修改共享变量 s，线程 t2 获取修改后的共享变量 s，从而完成数据通信。</p><p>但是多线程本身具有并行执行的特性，也就是在同一时刻，多个线程可以同时执行。在这种情况下，线程 t2 在访问共享变量 s 之前，必须要知道线程 t1 已经修改过了共享变量 s，否则就需要等待。<br>同时，线程 t1 修改过了共享变量 S 之后，还需要通知在等待中的线程 t2。所以要在这种特性下要去实现线程之间的通信，就必须要有一个竞争条件控制线程在什么条件下等待，什么条件下唤醒。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231015195346379.png" alt="image-20231015195346379"></p><p>而 Synchronized 同步关键字就可以实现这样一个互斥条件，也就是在通过共享变量来实现多个线程通信的场景里面，参与通信的线程必须要竞争到这个共享变量的锁资源，才有资格对共享变量做修改，修改完成后就释放锁，那么其他的线程就可以再次来竞争同一个共享变量的锁来获取修改后的数据，从而完成线程之前的通信。</p><p>所以这也是为什么 wait&#x2F;notify 需要放在 Synchronized 同步代码块中的原因，有了 Synchronized 同步锁，就可以实现对多个通信线程之间的互斥，实现条件等待和条件唤醒。</p><h3 id="关键字与锁"><a href="#关键字与锁" class="headerlink" title="关键字与锁"></a>关键字与锁</h3><h4 id="类锁与对象锁的区别："><a href="#类锁与对象锁的区别：" class="headerlink" title="类锁与对象锁的区别："></a>类锁与对象锁的区别：</h4><h5 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a><strong>类锁</strong></h5><p>用synchronized修饰静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> method（）</span><br></pre></td></tr></table></figure><p>作用在代码块上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> method（）&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(object.class)&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类锁是加载类上的，而类信息是存在 JVM 方法区的，并且整个 JVM 只有一份，方法区又是所有线程共享的，所以类锁是所有线程共享的，所以同一时刻，只能有一个线程使用加了类锁的方法或方法体，不管是不是同一个实例。</p><h5 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h5><p>作用在实例方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> method（）&#123;&#125;</span><br></pre></td></tr></table></figure><p>作用在代码块上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> method（）&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">   <span class="comment">//这里是需要同步的部分</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用对象锁的情况，只有使用同一实例的线程才会受对象锁的影响，多个实例调用同一方法也不会受影响。</p><p><strong>类锁和对象锁不存在冲突</strong>，<strong>对象锁和类锁互不影响</strong>，可同时申请一个类的类锁、和该类某实例的对象锁</p><h4 id="说一下synchronized关键字底层原理"><a href="#说一下synchronized关键字底层原理" class="headerlink" title="说一下synchronized关键字底层原理"></a>说一下synchronized关键字底层原理</h4><p>synchronized的底层是通过monitor对象来实现的。</p><p>Java对象在内存中的布局大致可以分为三部分：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>填充对齐</strong>。因为<code>synchronized</code>用的锁是存在对象头里的，这里我们需要重点了解对象头。如果对象头是数组类型，则对象头由<strong>Mark Word</strong>、<strong>Class MetadataAddress</strong>和<strong>Array length</strong>组成，如果对象头非数组类型，对象头则由<strong>Mark Word</strong>和<strong>Class MetadataAddress</strong>组成。</p><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112246654.png" alt="image-20231003112246654"></p><p>monitor对象中有owner用来指示拥有锁的线程，entrylist来存放阻塞的线程（竞争失败的线程），waitSet来存放wating的线程（wait()方法），初始时，Monitor中的Owner为null，当第一个竞争锁的线程获得锁，其他的竞争这个锁的线程就会被放入EntryList等待，当获得锁的线程执行完同步代码块中的内容，就会唤醒EntryList中等待的线程，发生非公平竞争这个锁。<br>注意：<br>synchronized 必须是进入同一个对象的 monitor 才有上述的效果</p><p><strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p><p>上面的字节码中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 **对象监视器 <code>monitor</code>**（每个Java对象都可以关联一个monitor对象） 的持有权。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由[ObjectMonitoropen in new window](https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp)实现的。每个对象中都内置了一个 `ObjectMonitor`对象。</span><br><span class="line"></span><br><span class="line">另外，`wait/notify`等方法也依赖于`monitor`对象，这就是为什么只有在同步的块或者方法中才能调用`wait/notify`等方法，否则会抛出`java.lang.IllegalMonitorStateException`的异常的原因。</span><br></pre></td></tr></table></figure><p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112249933.png" alt="image-20231003112249933"></p><p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112256314.png" alt="image-20231003112256314"></p><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><h5 id="synchronized-修饰方法的的情况"><a href="#synchronized-修饰方法的的情况" class="headerlink" title="synchronized 修饰方法的的情况"></a>synchronized 修饰方法的的情况</h5><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p><p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p><h4 id="讲一讲AQS"><a href="#讲一讲AQS" class="headerlink" title="讲一讲AQS"></a>讲一讲AQS</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p><code>AbstractQueuedSynchronizer(AQS)</code>提供了一套可用于实现锁同步机制和其他同步组件的框架。<code>AQS通过一个</code>FIFO<code>队列维护线程同步状态，实现类只需要继承该类，并重写指定方法即可实现一套线程同步机制</code>。在JUC<code>中，诸如</code>ReentrantLock<code>、</code>CountDownLatch<code>等都基于</code>AQS&#96;实现。</p><p><code>AQS</code>根据资源互斥级别提供了<strong>独占和共享</strong>两种资源访问模式；同时其定义<code>Condition</code>结构提供了<code>wait/signal</code>等待唤醒机制。</p><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p><code>AQS</code>维护了一个<code>volatile int state</code>变量（state &#x3D; 0 表示锁可用， state &#x3D;&gt; 1 表示锁已被占用）用来记录锁竞争的状态。</p><ul><li>一个线程来获得锁资源的时候首先会判断state是否等于0，如果是就把state更新为1，表示获得这个锁，为了防止多个线程同时更新state，AQS使用CAS保障state互斥变量更新的原子性。</li><li>未获得到锁的线程会阻塞，并按照先进先出的原则加入到双向链表中。</li></ul><p>当获得锁资源的线程释放锁后会从双向链表唤醒阻塞的线程。 </p><ul><li>AQS获取锁有公平竞争和非公平竞争，公平竞争就是在获取锁的时候，需要判断双向链表是否有阻塞的线程，如果有就需要去排队等待。 </li><li>非公平锁不管双向链表是否存在阻塞的线程，都会直接尝试更改state去获取锁。对于双向队列中阻塞的线程是不公平的</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112335241.png" alt="image-20231003112335241"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/e22dfb7003ee44afb6f80ddfbce68a93tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-1696303417939-13.webp" alt="img"></p><p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul><p><strong><code>Node</code>主要包含5个核心字段：</strong></p><ul><li><p>waitStatus</p><p>：当前节点状态，该字段共有5种取值：</p><ul><li><code>CANCELLED = 1</code>。节点引用线程由于等待超时或被打断时的状态。</li><li><code>SIGNAL = -1</code>。后继节点线程需要被唤醒时的当前节点状态。当队列中加入后继节点被挂起<code>(block)</code>时，其前驱节点会被设置为<code>SIGNAL</code>状态，表示该节点需要被唤醒。</li><li><code>CONDITION = -2</code>。当节点线程进入<code>condition</code>队列时的状态。(见<code>ConditionObject</code>)</li><li><code>PROPAGATE = -3</code>。仅在释放共享锁<code>releaseShared</code>时对头节点使用。(见共享锁分析)</li><li><code>0</code>。节点初始化时的状态。</li></ul></li><li><p><code>prev</code>：前驱节点。</p></li><li><p><code>next</code>：后继节点。</p></li><li><p><code>thread</code>：引用线程，头节点不包含线程。</p></li><li><p><code>nextWaiter</code>：<code>condition</code>条件队列。(见<code>ConditionObject</code>)</p></li></ul><h4 id="jdk1-7对synchorinzed的优化？"><a href="#jdk1-7对synchorinzed的优化？" class="headerlink" title="jdk1.7对synchorinzed的优化？"></a>jdk1.7对synchorinzed的优化？</h4><p>JDK1.6为了减少获得锁和释放锁所带来的性能消耗，引入了<strong>“偏向锁”</strong>和<strong>“轻量级锁”</strong>，所以在JDK1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。<strong>锁可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率</p><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁，顾名思义，它会偏向于第一个访问锁的线程</p><p>如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。线程第二次到达同步代码块时，会判断此时持有锁的线程是否就是自己，如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。<br>如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。<br>级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致<code>STW(stop the word)</code>操作</p><ul><li><h6 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h6><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象<br>的 Thread ID<br>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程</p></li><li><h6 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h6><p>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p></li></ul><h5 id="轻量级锁（还未关联monitor对象）"><a href="#轻量级锁（还未关联monitor对象）" class="headerlink" title="轻量级锁（还未关联monitor对象）"></a>轻量级锁（还未关联monitor对象）</h5><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以<br>使用轻量级锁来优化。当存在竞争时，锁膨胀升级为重量级锁来互斥访问。</p><p>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164622798.png" alt="image-20240322164622798"></p><p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164644569.png" alt="image-20240322164644569"></p><p>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164712066.png" alt="image-20240322164712066"></p><p>如果 cas 失败，有两种情况</p><ol><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li><li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li></ol><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164748554.png" alt="image-20240322164748554"></p><p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164814658.png" alt="image-20240322164814658"></p><p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</p><ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164905678.png" alt="image-20240322164905678"></p><p>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<strong>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</strong><br>然后自己进入 Monitor 的 EntryList BLOCKED</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164942030.png" alt="image-20240322164942030"></p><p>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁<br>流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</p><h5 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h5><p>重量级锁竞争的时候，如果竞争锁失败，该线程不会马上阻塞，使用自旋重试来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p><h4 id="Reentrantlock-与-synchronized-的区别"><a href="#Reentrantlock-与-synchronized-的区别" class="headerlink" title="Reentrantlock 与 synchronized 的区别"></a>Reentrantlock 与 synchronized 的区别</h4><p>Synchronized 可以通过两种方式来控制锁的粒度</p><ul><li>一种是把 synchronized 关键字修饰在方法层面，</li><li>另一种是修饰在代码块上，并且我们可以通过 Synchronized 加锁对象的声明周期来控制锁的作用范围，比如锁对象是静态对象或者类对象，那么这个锁就是全局锁。如果锁对象是普通实例对象，那这个锁的范围取决于这个实例的声明周期。</li></ul><p>Lock 锁的粒度是通过它里面提供的 lock()和 unlock()方法决定的（贴图），包裹在这两个方法之间的代码能够保证线程安全性。而锁的作用域取决于 Lock 实例的生命周期</p><p>相对于 synchronized 它具备如下特点</p><ul><li><strong>可以设置超时时间</strong>， Lock 还提供了非阻塞的竞争锁方法 tryLock(int time)方法，在规定时间获取不到锁会返回false</li><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li><li><strong>可实现选择性通知（支持多个条件变量）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul><p>与 synchronized 一样，都支持可重入</p><h4 id="公平锁与非公平锁？底层实现是什么"><a href="#公平锁与非公平锁？底层实现是什么" class="headerlink" title="公平锁与非公平锁？底层实现是什么"></a>公平锁与非公平锁？底层实现是什么</h4><p>底层都是AQS，默认一般使用<strong>非公平锁</strong>，它的效率和吞吐量都比公平锁高的多。由于公平锁需要关心队列的情况，得按照队列里的先后顺序来获取锁(会造成大量的线程上下文切换)，而非公平锁则没有这个限制。所以也就能解释非公平锁的效率会被公平锁更高。</p><p><strong>公平锁</strong>：</p><p>线程在tryAcquire（arg）尝试获得锁之前会利用 hasQueuedPredecessors() 方法来判断 AQS 的队列中中是否有其他线程，如果有则不会尝试获取锁(<strong>这是公平锁特有的情况</strong>)。</p><p>如果队列中没有线程就利用 CAS 来将 AQS 中的 state 修改为1，也就是获取锁，获取成功则将当前线程置为获得锁的独占线程(setExclusiveOwnerThread(current))。</p><p>如果 state 大于 0 时，说明锁已经被获取了，则需要判断获取锁的线程是否为当前线程(ReentrantLock 支持重入)，是则需要将 state + 1，并将值更新。</p><p>如果tryAcquire(arg) 获取锁失败，则需要用 addWaiter(Node.EXCLUSIVE) 将当前线程写入队列中。</p><p>写入之前需要将当前线程包装为一个 Node 对象(addWaiter(Node.EXCLUSIVE))，通过自旋加上 CAS 保证一定能写入队列。</p><p><strong>非公平锁</strong>：尝试获取锁时tryAcquire(arg)，非公平锁是不需要判断队列中是否还有其他线程，也是直接尝试获取锁：</p><h4 id="可中断锁和不可中断锁有什么区别？"><a href="#可中断锁和不可中断锁有什么区别？" class="headerlink" title="可中断锁和不可中断锁有什么区别？"></a>可中断锁和不可中断锁有什么区别？</h4><ul><li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li><li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁</li></ul><h4 id="volatile关键字的原理？怎么用？是否保证原子性？"><a href="#volatile关键字的原理？怎么用？是否保证原子性？" class="headerlink" title="volatile关键字的原理？怎么用？是否保证原子性？"></a>volatile关键字的原理？怎么用？是否保证原子性？</h4><p>由于JVM缓存优化，线程读变量值时，可能会到自己的工作缓存去读而不是到内存，所以当一个线程对变量执行写操作到内存，可能其他线程无法读到最新的变量值。</p><p>用法：在多线程读，一线程写的情况下，用来修饰成员变量和静态成员变量，这就指示 JVM，这个变量是共享且不稳定的，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。</p><h5 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112310433.png" alt="image-20231003112310433"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112313979.png" alt="image-20231003112313979"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112317775.png" alt="image-20231003112317775"></p><p>Volatile关键字底层实现主要是<strong>通过汇编lock指令</strong>，当某个CPU修改了缓存里面的数据，该数据会马上通过总线同步回主存，（lock指令开启其他CPU的总线嗅探机制）其他CPU通过一个<strong>总线嗅探机制</strong>来感知数据的变化从而将自己缓存里面的数据失效，需要使用这个数据，必须重新去内存中获取最新的数据，来保证数据的可见性。</p><h5 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h5><p>当对volatile修饰变量赋值，会加上写屏障，写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当对volatile修饰变量取值，会加上读屏障，读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不能解决指令交错（无法保证原子性）："><a href="#不能解决指令交错（无法保证原子性）：" class="headerlink" title="不能解决指令交错（无法保证原子性）："></a>不能解决指令交错（无法保证原子性）：</h5><p>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去<br>而有序性的保证也只是保证了本线程内相关代码不被重排序</p><h4 id="synchronized关键字保证可见性和有序性"><a href="#synchronized关键字保证可见性和有序性" class="headerlink" title="synchronized关键字保证可见性和有序性"></a>synchronized关键字保证可见性和有序性</h4><p>我们都知道sychronized底层是通过monitorenter的指令来进行加锁的、通过monitorexit指令来释放锁的。</p><p>但是很多人都不知道的一点是，monitorenter指令其实还具有Load屏障的作用。</p><p>也就是通过monitorenter指令之后，synchronized内部的共享变量，每次读取数据的时候被强制从主内存读取最新的数据。</p><p>同样的道理monitorexit指令也具有Store屏障的作用，也就是让synchronized代码块内的共享变量，如果数据有变更的，强制刷新回主内存。</p><p>这样通过这种方式，数据修改之后立即刷新回主内存，其他线程进入synchronized代码块后，使用共享变量的时候强制读取主内存的数据，上一个线程对共享变量的变更操作，它就能立即看到了。</p><p>同时synchronized加的内存屏障也能保证内部代码的有序性</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112322766.png" alt="image-20231003112322766"></p><h4 id="为什么单线程不需要这个volatile关键字多线程需要"><a href="#为什么单线程不需要这个volatile关键字多线程需要" class="headerlink" title="为什么单线程不需要这个volatile关键字多线程需要"></a>为什么单线程不需要这个volatile关键字多线程需要</h4><p>因为在单线程的环境下，只有一个线程会使用修改的变量，变量不存在可见性问题。同时，单线程下，JVM的指令重排序也不会改变执行结果。</p><h4 id="为什么会出现指令重排序："><a href="#为什么会出现指令重排序：" class="headerlink" title="为什么会出现指令重排序："></a>为什么会出现指令重排序：</h4><p>指令还可以再划分成一个个更小的阶段，在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行，从而提高CPU的吞吐率。</p><h4 id="讲一下CAS"><a href="#讲一下CAS" class="headerlink" title="讲一下CAS"></a>讲一下CAS</h4><p>CAS（Compare And Swap）是一种无锁同步机制，基于乐观锁的思想，但是它底层还是有用到锁的，使用总线锁锁住总线，确保在比较替换的过程中没有其他线程对该值进行修改，保障比较并替换的原子性。</p><p><strong>CAS 必须借助 volatile</strong> 才能读取到共享变量的最新值来实现【比较并交换】的效果</p><p>CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。</p><p>CAS指令执行时，通过发送一个lock指令锁住总线，确保整个比较并替换的操作是一个原子操作。<strong>当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则放弃对数据的操作。</strong></p><p>cas可以不用自旋重试机制，失败也可以直接返回false。只是一般应用场景下，cas都会带有重试机制（while和for实现空转，不断尝试）</p><h5 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h5><ul><li>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、竞争较少，多核 CPU 的场景下。</li><li>CAS 是基于乐观锁的思想：最乐观的估计，预计很少出现并发问题，当出现后，再重试。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，当一个线程上了锁，其他线程只能阻塞等待解锁。使得线程只能串行访问同步代码块，效率较低。</li><li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思</li><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到CAS自旋重试必然频繁发生，反而效率会受影响</li></ul><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p><strong>CAS长时间自旋开销很大：</strong>我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</p><p><strong>只能保证一个共享变量的原子操作：</strong>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p><p><strong>ABA*问题</strong>：<strong>通过版本号法解决。</strong>Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p><h5 id="用处："><a href="#用处：" class="headerlink" title="用处："></a>用处：</h5><p>Automic原子类，多线程的互斥同步等</p><h4 id="乐观锁和悲观锁的区别？"><a href="#乐观锁和悲观锁的区别？" class="headerlink" title="乐观锁和悲观锁的区别？"></a>乐观锁和悲观锁的区别？</h4><h5 id="什么悲观锁？"><a href="#什么悲观锁？" class="headerlink" title="什么悲观锁？"></a><strong>什么悲观锁？</strong></h5><p>悲观锁是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;</p><p>特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p><h5 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a><strong>什么是乐观锁？</strong></h5><p>乐观锁是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);</p><p>特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。</p><h5 id="理论上来说："><a href="#理论上来说：" class="headerlink" title="理论上来说："></a>理论上来说：</h5><ul><li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li><li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li></ul><h4 id="ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？"><a href="#ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？" class="headerlink" title="ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？"></a>ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112342131.png" alt="image-20231003112342131"></p><p>threadLocal 是一个用来解决线程安全性问题的工具。它相当于让每个线程都开辟一块内存空间，用来存储共享变量的副本。<br>然后每个线程只需要访问和操作自己的共享变量副本即可，从而避免多线程竞争同一个共享资源。<br>它的工作原理很简单（如图）</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112345346.png" alt="image-20231003112345346"></p><p>每个线程里面有一个成员变量 ThreadLocalMap,<br>当线程访问用 ThreadLocal 修饰的共享数据的时候<br>这个线程就会在自己成员变量 ThreadLocalMap 里面保存一份数据副本。<br>key 指向 ThreadLocal 这个引用，并且是弱引用关系，而 value 保存的是共享数据的副本。<br>因为每个线程都持有一个副本，所以就解决了线程安全性问题。</p><p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用<strong>弱引用</strong>的ThreadLocal实例，value为线程变量的副本。这些对象之间的引用关系如下,</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112348542.png" alt="image-20231003112348542"></p><blockquote><p>实心箭头表示强引用，空心箭头表示弱引用</p></blockquote><h5 id="ThreadLocal-内存泄漏的原因"><a href="#ThreadLocal-内存泄漏的原因" class="headerlink" title="ThreadLocal 内存泄漏的原因"></a>ThreadLocal 内存泄漏的原因</h5><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</p><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>由于Thread中包含变量ThreadLocalMap，因此ThreadLocalMap与Thread的生命周期是一样长，如果都没有手动删除对应key，都会导致内存泄漏。</p><p>但是使用<strong>弱引用</strong>可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set(),get(),remove()的时候会被清除。</p><p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p><h5 id="ThreadLocal正确的使用方法"><a href="#ThreadLocal正确的使用方法" class="headerlink" title="ThreadLocal正确的使用方法"></a>ThreadLocal正确的使用方法</h5><ul><li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li><li>(将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 )</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="单核-CPU-上运行多个线程效率一定会高吗？"><a href="#单核-CPU-上运行多个线程效率一定会高吗？" class="headerlink" title="单核 CPU 上运行多个线程效率一定会高吗？"></a>单核 CPU 上运行多个线程效率一定会高吗？</h4><p>单核CPU同时运行多个线程的效率是否会高，取决于线程的类型和任务的性质。两种类型的线程：CPU密集型和IO密集型。</p><ul><li>CPU密集型的线程主要进行计算和逻辑处理，需要占用大量的CPU资源。</li><li>IO密集型的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待IO设备的响应，而不占用太多的CPU资源。</li></ul><p>在单核CPU上，同一时刻只能有一个线程在运行，其他线程需要等待CPU的时间片分配。如果线程是CPU密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。</p><p>如果线程是IO密集型的，那么多个线程同时运行可以利用CPU在等待IO时的空闲时间，提高了效率。</p><p>因此，对于单核CPU来说，如果任务是CPU密集型的，那么开很多线程会影响效率；如果任务是IO密集型的，那么开很多线程会提高效率。当然，这里的“很多”也要适度，不能超过系统能够承受的上限。</p><h4 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h4 id="线程池的缺点"><a href="#线程池的缺点" class="headerlink" title="线程池的缺点"></a>线程池的缺点</h4><ul><li>可能引发死锁：在使用线程池时，如果任务之间存在依赖关系，或者线程因为资源的竞争，可能会引发死锁问题，需要额外的注意和处理。</li><li>不能对于线程池中任务设置优先级，只能按照先来先服务的策略</li><li><strong>难以调试</strong>: 线程池中的线程是由线程池管理的，因此在出现问题时，很难追踪和调试特定的线程。这可能会增加故障排除的难度。</li></ul><h4 id="线程池的拒绝策略有哪些？"><a href="#线程池的拒绝策略有哪些？" class="headerlink" title="线程池的拒绝策略有哪些？"></a>线程池的拒绝策略有哪些？</h4><p>若线程池中的核心线程数被用完且阻塞队列已排满，则此时线程池的资源已耗尽，线程池将没有足够的线程资源执行新的任务。为了保证操作系统的安全，线程池将通过拒绝策略处理新添加的线程任务。</p><h5 id="1-AbortPolicy（默认策略）"><a href="#1-AbortPolicy（默认策略）" class="headerlink" title="1. AbortPolicy（默认策略）"></a><strong>1. AbortPolicy</strong>（默认策略）</h5><p>第一种拒绝策略是 <code>AbortPolicy</code>，这种拒绝策略在拒绝任务时，会直接抛出一个类型为 RejectedExecutionException的RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。</p><h5 id="2-DiscardPolicy"><a href="#2-DiscardPolicy" class="headerlink" title="2.DiscardPolicy"></a><strong>2.DiscardPolicy</strong></h5><p>第2种拒绝策略是 <code>DiscardPolicy</code>，这种拒绝策略正如它的名字所描述的一样，当新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失。</p><h5 id="3-DiscardOldestPolicy"><a href="#3-DiscardOldestPolicy" class="headerlink" title="3.DiscardOldestPolicy"></a><strong>3.DiscardOldestPolicy</strong></h5><p>第3种拒绝策略是 <code>DiscardOldestPolicy</code>，如果线程池没被关闭且没有能力执行，则会丢弃任务队列中的头结点，通常是存活时间最长的任务，这种策略与第二种不同之处在于它丢弃的不是最新提交的，而是队列中存活时间最长的，这样就可以腾出空间给新提交的任务，但同理它也存在一定的数据丢失风险。</p><h5 id="4-CallerRunsPolicy"><a href="#4-CallerRunsPolicy" class="headerlink" title="4.CallerRunsPolicy"></a><strong>4.CallerRunsPolicy</strong></h5><p>第4种拒绝策略是 CallerRunsPolicy，相对而言它就比较完善了，当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。这样做主要有两点好处。</p><ol><li>第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。</li><li>第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。</li></ol><h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>本文中我们学习线程池中的4 种默认的拒绝策略。线程池会在以下两种情况下会拒绝新提交的任务。</p><ul><li>第一种情况是当我们调用 shutdown 等方法关闭线程池后，即便此时可能线程池内部依然有没执行完的任务正在执行，但是由于线程池已经关闭，此时如果再向线程池内提交任务，就会遭到拒绝。</li><li>第二种情况是线程池没有能力继续处理新提交的任务，也就是工作已经非常饱和的时候。</li></ul><p>线程池状态</p><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112330381.png" alt="image-20231003112330381"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c 为旧值， ctlOf 返回结果为新值</span></span><br><span class="line">ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));</span><br><span class="line"><span class="comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><h4 id="Excetors工具类提供了哪些线程池？有什么问题吗？"><a href="#Excetors工具类提供了哪些线程池？有什么问题吗？" class="headerlink" title="Excetors工具类提供了哪些线程池？有什么问题吗？"></a>Excetors工具类提供了哪些线程池？有什么问题吗？</h4><p>四种阻塞队列</p><p>*<strong>基于数组的先进先出队列，有界</strong></p><ul><li>new ArrayBlockingQueue&lt;&gt;(10)</li></ul><p>生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行</p><p><strong>由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列</strong></p><ul><li>new LinkedBlockingQueue&lt;&gt;()</li></ul><p>生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p><p><strong>无缓冲的等待队列，无界</strong></p><ul><li>new SynchronousQueue&lt;&gt;()</li></ul><p>不存储元素的阻塞队列，也即单个元素的队列。</p><p><strong>使用优先级队列实现的延迟无界阻塞队列。</strong></p><p>new DelayQueue&lt;&gt;()<br>DelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p><p>Executors中创建线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Executors</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建固定数量线程的线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这是最后一个参数--阻塞队列调用的方法，长度是Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     * public LinkedBlockingQueue() &#123;</span></span><br><span class="line"><span class="comment">     *    this(Integer.MAX_VALUE);</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建只有一个线程的线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这是最后一个参数--阻塞队列调用的方法，长度也是Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     * public LinkedBlockingQueue() &#123;</span></span><br><span class="line"><span class="comment">     *    this(Integer.MAX_VALUE);</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created single-threaded Executor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *创建一个缓冲线程池 </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这是最后一个参数--阻塞队列调用的方法</span></span><br><span class="line"><span class="comment">     * public SynchronousQueue() &#123;</span></span><br><span class="line"><span class="comment">     *    this(false);</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 它的第二个参数，maximumPoolSize 为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a thread pool that can schedule commands to run after a</span></span><br><span class="line"><span class="comment">     * given delay, or to execute periodically.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 创建一个可以在给定延迟后再执行或定期执行命令的线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ScheduledThreadPoolExecutor 是 ThreadPoolExecutor 的子类，代码如下：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor</span></span><br><span class="line"><span class="comment">        implements ScheduledExecutorService &#123;</span></span><br><span class="line"><span class="comment">            //这是下面调用的构造方法，其实是调用了父类的构造方法,这些参数都是下面分析的参数</span></span><br><span class="line"><span class="comment">            public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span></span><br><span class="line"><span class="comment">               super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span></span><br><span class="line"><span class="comment">               new DelayedWorkQueue());</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FixedThreadPool 和 SingleThreadExecutor 传入的最后一个参数阻塞队列 ”workQueue“，默认的长度是INTEGER.MAX_VALUE，而它们允许的最大线程数量又是有限的，所以当请求线程的任务过多线程不够用时，它们会在队列中等待，又因为队列的长度特别长，所以可能会堆积大量的请求，导致OOM。</p><p>CachedThreadPool 和 ScheduledThreadPool 它们的阻塞队列长度有限，但是传入的第二个参数maximumPoolSize 为Integer.MAX_VALUE，这就意味着当请求线程的任务过多线程不够而且队列也满了的时候，线程池就会创建新的线程，因为它允许的最大线程数量是相当大的，所以可能会创建大量线程，导致OOM。</p><p>Executors类中封装好的创建线程池的方法使用方便，但是也有其局限性和风险性，所以我们可以使用 ThreadPoolExecutor 类中的构造方法手动创建线程池的实例， 从而可以根据我们的使用情况来指定参数，满足使用的同时又能规避风险。<br>所以，说白了，使用Executors类创建线程池与使用ThreadPoolExecutor类的区别就是使用ThreadPoolExecutor类可以自定义传入我们设置的线程池的参数，更加灵活。</p><h4 id="线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列"><a href="#线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列" class="headerlink" title="线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列"></a>线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列</h4><ul><li><h5 id="corePoolSize-核心线程数目-正常情况下最多保留的线程数"><a href="#corePoolSize-核心线程数目-正常情况下最多保留的线程数" class="headerlink" title="corePoolSize 核心线程数目 (正常情况下最多保留的线程数)"></a>corePoolSize 核心线程数目 (正常情况下最多保留的线程数)</h5></li></ul><p>线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。任务提交到线程池后，首先会检查当前线程数是否达到了corePoolSize，如果没有达到的话，则会创建一个新线程来处理这个任务。</p><ul><li><h5 id="maximumPoolSize-最大线程数目"><a href="#maximumPoolSize-最大线程数目" class="headerlink" title="maximumPoolSize 最大线程数目"></a>maximumPoolSize 最大线程数目</h5></li></ul><p>当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务缓存到工作队列（后面会介绍）中。如果队列也已满，则会去创建一个新线程来出来这个处理。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即maximunPoolSize指定</p><ul><li><h5 id="keepAliveTime-生存时间-针对救急线程，当没有任务一段时间会被销毁"><a href="#keepAliveTime-生存时间-针对救急线程，当没有任务一段时间会被销毁" class="headerlink" title="keepAliveTime 生存时间 - 针对救急线程，当没有任务一段时间会被销毁"></a>keepAliveTime 生存时间 - 针对救急线程，当没有任务一段时间会被销毁</h5></li></ul><p>线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 <code>corePoolSize</code> ，回收过程才会停止。</p><ul><li><h5 id="unit-时间单位-针对多余空闲线程，-救急线程存活时间单位"><a href="#unit-时间单位-针对多余空闲线程，-救急线程存活时间单位" class="headerlink" title="unit 时间单位 - 针对多余空闲线程， 救急线程存活时间单位"></a>unit 时间单位 - 针对多余空闲线程， 救急线程存活时间单位</h5></li><li><h5 id="workQueue-阻塞队列"><a href="#workQueue-阻塞队列" class="headerlink" title="workQueue 阻塞队列"></a>workQueue 阻塞队列</h5></li></ul><p>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程</p><ul><li><h5 id="threadFactory-线程工厂-可以为线程创建时起个好名字"><a href="#threadFactory-线程工厂-可以为线程创建时起个好名字" class="headerlink" title="threadFactory 线程工厂 - 可以为线程创建时起个好名字"></a>threadFactory 线程工厂 - 可以为线程创建时起个好名字</h5></li></ul><p>创建一个新线程时使用的工厂，可以用来<strong>设定线程名、是否为daemon（守护线程）线程</strong>等等</p><ul><li><h5 id="handler-拒绝策略"><a href="#handler-拒绝策略" class="headerlink" title="handler 拒绝策略"></a>handler 拒绝策略</h5></li></ul><p>当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，就会采用拒绝策略</p><h4 id="为什么线程池创建新线程需要获取全局锁？"><a href="#为什么线程池创建新线程需要获取全局锁？" class="headerlink" title="为什么线程池创建新线程需要获取全局锁？"></a>为什么线程池创建新线程需要获取全局锁？</h4><ol><li><strong>线程池的状态管理</strong>：线程池需要跟踪已创建的线程数、空闲线程数、正在运行的任务等状态信息。这些状态信息需要在多线程环境下进行更新和访问，因此需要使用全局锁来确保状态的一致性，防止多个线程同时修改状态信息导致的竞态条件。</li><li><strong>线程资源管理</strong>：线程池通常会限制创建的线程数量，以避免因为创建过多线程导致系统资源耗尽或者性能下降。因此，在创建新线程之前需要检查当前已创建的线程数量，这涉及到对线程池状态的读取和更新，需要使用全局锁来确保一致性。</li></ol><h4 id="execute源码步骤"><a href="#execute源码步骤" class="headerlink" title="execute源码步骤"></a>execute源码步骤</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-c2f64c062ff28d9ca7b37a2624367fb3_1440w.webp" alt="img"></p><p>从上图可以把execute方法主要分三个步骤：</p><ul><li>首先如果当前工作线程数小于核心线程，则调用addWorker(command, true)方法创建核心线程执行任务。</li><li>其次如果当前线程大于核心线程数则判断等待队列是否已满，如果没有满则添加任务到等待队列中去，如果工作线程数量为0则调用addWorker(null, false)方法创建非核心线程，并从等待队列中拉取任务执行。</li><li>最后如果队列已满则会调用addWorker(command, false)方法创建一个非核心线程执行任务。如果创建失败则会拒绝任务。</li></ul><p><strong>简单来说就是优先核心线程，其次等待队列，最后非核心线程。</strong></p><h5 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h5><p><strong>可以看到execute中最关键的就是addWorker方法</strong>，它接受两个参数：</p><ul><li>第一个参数是要执行的任务，如果为null那么会从等待队列中拉取任务；</li><li>第二个参数是表示是否核心线程，用来控制addWorker方法流程的；</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-757aff298fc6e148b609037749de418c_1440w.webp" alt="img"></p><p>流程中去除一些异常情况，只留了主要流程，流程中有一步验证线程数大于核心线程或者最大线程数</p><ul><li>如果传递的参数core等于true那么运行线程数量不能大于核心线程数量，</li><li>如果为false则当前线程数量不能大于最大线程数。</li></ul><p><strong>addWorker只有两个作用：增加工作线程数量、创建一个Worker并加到工作线程集合中。</strong></p><h5 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h5><p>Worker类就是线程池中执行任务的类，主要源码和解释如下图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-19a9c0570d56fb82d57680103305496d_1440w.webp" alt="img"></p><p>所以Worker本身就是一个Runnable，它有两个属性thead、firstTask；那我们就可以来梳理一下整体的运行流程了：</p><p><strong>线程池调用execute</strong>—&gt;<strong>创建Worker（设置属性thead、firstTask）</strong>—&gt;**worker.thread.start()**—&gt;**实际上调用的是worker.run()**—&gt;**线程池的runWorker(worker)**—&gt;<strong>worker.firstTask.run()</strong>(如果firstTask为null就从等待队列中拉取一个)。</p><p>转了一大圈最终调用最开始传进来的任务的run方法，不过通过等待队列可以重复利用worker与worker中的线程，变化的只是firstTask；</p><h4 id="submit和execute的区别"><a href="#submit和execute的区别" class="headerlink" title="submit和execute的区别:"></a>submit和execute的区别:</h4><p><font color = gold>execute和submit最大的区别就是execute没有返回值，submit有返回值。submit返回的是一个future ，可以通过这个future取到线程执行的结果或者异常信息。</font></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/637fd0fa146c4bb4be2e6cbaefb9bc6ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="图片"></p><p>submit不打印异常信息，而execute则会打印异常信息！，submit的方式不打印异常信息，显然在生产中，是不可行的，因为我们无法保证线程中的任务永不异常，而如果使用submit的方式出现了异常，直接如上写法，我们将无法获取到异常信息，做出对应的判断和处理，所以下一步需要知道如何获取线程池抛出的异常！</p><p><code>submit()</code>想要获取异常信息就必须使用<code>get()</code>方法！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当线程池抛出异常后 submit无提示，其他线程继续执行</span></span><br><span class="line">Future&lt;?&gt; submit = executorService.submit(<span class="keyword">new</span> <span class="title class_">task</span>());</span><br><span class="line">submit.get();</span><br></pre></td></tr></table></figure><p>submit打印异常信息如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/4cdc421e484c4468ab052ff82c500a39tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="图片"></p><p>submit源码在底层还是调用的execute方法，只不过多一层Future封装，并返回了这个Future，这也解释了为什么submit会有返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//submit()方法</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//execute内部执行这个对象内部的逻辑，然后将结果或者异常 set到这个ftask里面</span></span><br><span class="line">     RunnableFuture&lt;T&gt; ftask = newTaskFor(task); </span><br><span class="line">     <span class="comment">// 执行execute方法</span></span><br><span class="line">     execute(ftask); </span><br><span class="line">     <span class="comment">//返回这个ftask</span></span><br><span class="line">     <span class="keyword">return</span> ftask;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>如果用execute提交的任务，会被封装成了一个runable任务，然后进去 再被封装成一个worker,最后在worker的run方法里面调用runWoker方法， <code>runWoker</code>方法里面执行任务任务，如果任务出现异常，用<code>try-catch</code>捕获异常往外面抛，我们在最外层使用<code>try-catch</code>捕获到了 <code>runWoker</code>方法中抛出的异常。因此我们在execute中看到了我们的任务的异常信息。</li><li><font color = gold>submit是将任务封装成了一个<code>futureTask</code></font> ，然后这个<code>futureTask</code>被封装成worker，在woker的run方法里面，最终调用的是<code>futureTask</code>的run方法， 里面是直接吞掉了异常，并没有抛出异常，因此在worker的<code>runWorker</code>方法里面无法捕获到异常。</li></ul><p>下面来看一下<code>futureTask</code>的run方法，在try-catch中吞掉了异常，将异常放到了 <code>setException(ex);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">         !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                      <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Callable&lt;V&gt; c = callable;</span><br><span class="line">         <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">             V result;</span><br><span class="line">             <span class="type">boolean</span> ran;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 result = c.call();</span><br><span class="line">                 ran = <span class="literal">true</span>;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                 result = <span class="literal">null</span>;</span><br><span class="line">                 ran = <span class="literal">false</span>;</span><br><span class="line">                 <span class="comment">//在此方法中设置了异常信息</span></span><br><span class="line">                 setException(ex);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (ran)</span><br><span class="line">                 set(result);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//省略下文</span></span><br><span class="line">         。。。。。</span><br><span class="line">        <span class="comment">//setException(ex)`方法如下：将异常对象赋予`outcome</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setException</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">//将异常对象赋予outcome，记住这个outcome，</span></span><br><span class="line">           outcome = t;</span><br><span class="line">           UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">           finishCompletion();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>将异常对象赋予<code>outcome</code>有什么用呢？这个<code>outcome</code>是什么呢？当我们使用submit返回Future对象，并使用<code>Future.get()</code>时， 会调用内部的report方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="comment">//注意这个方法</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reoport里面实际上返回的是outcome ,刚好之前的异常就set到了这个outcome里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException &#123;</span><br><span class="line"> <span class="comment">//设置`outcome`</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">     <span class="comment">//返回`outcome`</span></span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color = gold>因此，在用submit提交的时候，runable对象被封装成了future ，future 里面的 run方法在处理异常时， <code>try-catch</code>了所有的异常，通过<code>setException(ex);</code>方法设置到了变量outcome里面， 可以通过<code>future.get</code>获取到outcome。</font></p><p><strong>在submit提交的时候，里面发生了异常， 是不会有任何抛出信息的。而通过<code>future.get（）</code>可以获取到submit抛出的异常！</strong>在submit里面，除了从返回结果里面取到异常之外, 没有其他方法。因此，在不需要返回结果的情况下，<strong>最好用execute ，这样就算没有写<code>try-catch</code>，疏漏了异常捕捉，也不至于丢掉异常信息</strong>。</p><h5 id="解决异常："><a href="#解决异常：" class="headerlink" title="解决异常："></a>解决异常：</h5><p><strong>方案一：在run()方法中使用 try -catch</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">ThreadPoolException</span> &#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个线程池</span></span><br><span class="line">        <span class="title class_">ExecutorService</span> executorService = <span class="title class_">Executors</span>.<span class="title function_">newFixedThreadPool</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当线程池抛出异常后 submit无提示，其他线程继续执行</span></span><br><span class="line">        executorService.<span class="title function_">submit</span>(<span class="keyword">new</span> <span class="title function_">task</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当线程池抛出异常后 execute抛出异常，其他线程继续执行新任务</span></span><br><span class="line">        executorService.<span class="title function_">execute</span>(<span class="keyword">new</span> <span class="title function_">task</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">task</span> implements <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;进入了task方法！！！&quot;</span>);</span><br><span class="line">            int i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) &#123;</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;使用了try -catch 捕获异常&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/52929d67d8707f0909d7b9c3125cf590.png" alt="img"></p><p>可以看到 submit 和 execute都清晰易懂的捕获到了异常，可以知道我们的任务出现了问题，而不是消失的无影无踪。</p><p><strong>实现 ThreadFactory，自定义线程工厂类（推荐）</strong></p><p>第一种方法需要我们在每个任务中手动添加 try-catch 代码块，这样做非常繁琐且不可靠。为了避免重复工作，我们可以通过自定义线程工厂类来实现。线程池创建工作线程时会使用 ThreadFactory 的实现类来创建线程，因此我们只需要实现 ThreadFactory 接口，自定义线程工厂类，并将其传递给创建线程池的构造方法中。</p><p>自定义线程工厂方法，为每一个 run 方法添加 try-catch 代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">poolNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    CustomThreadFactory() &#123;</span><br><span class="line">        namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                poolNumber.getAndIncrement() +</span><br><span class="line">                <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, namePrefix + threadNumber.getAndIncrement()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">super</span>.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;异常信息：&quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color = gold>当使用 submit 方法提交的任务出现异常时，仍然无法进行处理,因为在run()方法中出现异常被内部捕获了，但至少解决了在 execute 方法中任务出现异常的情况。对于 FutureTask 的异常，调用方需要自行处理，因为 FutureTask 设计的本意就是将结果交给调用方处理，这个结果也包含异常。</font></p><h4 id="为什么核心线程池满了后-不直接创建新的线程去执行新任务？而是先交给任务队列呢？"><a href="#为什么核心线程池满了后-不直接创建新的线程去执行新任务？而是先交给任务队列呢？" class="headerlink" title="为什么核心线程池满了后 不直接创建新的线程去执行新任务？而是先交给任务队列呢？"></a>为什么核心线程池满了后 不直接创建新的线程去执行新任务？而是先交给任务队列呢？</h4><p><strong>因为如果核心线程满了就创建新的线程去执行，达到最大线程数之后再放入队列，那么新创建线程就需要获取全局锁，对性能有很大的损耗。</strong>而且如果正在被核心线程执行的任务很快的执行完，就可以直接从任务队列中取出新的任务执行。</p><p>ThreadPoolExecutor 采取上述步 骤 的 总 体 设计 思路，是 为 了在 执 行 execute() 方法时，尽可能地避免获取全局锁 （创建新的线程需要先获取全局锁、销毁线程也需要获取全局锁mainLock）。而从阻塞队列中取任务来执行不需要获取全局锁</p><p> <img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/8477e7c513404fcfa6aa2c57dc335019.png" alt="img"></p><h4 id="阻塞队列的作用是什么"><a href="#阻塞队列的作用是什么" class="headerlink" title="阻塞队列的作用是什么"></a>阻塞队列的作用是什么</h4><ul><li>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使线程进入wait状态，释放CPU资源</li><li>阻塞队列自带阻塞和唤醒的功能，不需要额外处理，无任务执行时，线程池利用阻塞队列的take方法挂起，从而维持核心线程的存活，不至于一直占的CPU资源</li></ul><h4 id="使用阻塞队列需要注意什么"><a href="#使用阻塞队列需要注意什么" class="headerlink" title="使用阻塞队列需要注意什么"></a>使用阻塞队列需要注意什么</h4><ol><li><strong>异常处理</strong>：在使用阻塞队列时，需要注意异常处理机制。例如，在使用有界阻塞队列时，如果队列已满而无法接受新任务，可能会触发拒绝策略，需要合理处理拒绝策略以防止任务丢失。</li><li><strong>选择合适的阻塞队列类型</strong>：Java 提供了多种阻塞队列实现，如 <code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>PriorityBlockingQueue</code> 等。选择合适的队列类型需要考虑线程池的特性、任务处理情况以及性能需求。</li><li><strong>队列容量设置</strong>：阻塞队列的容量设置需要根据系统负载和任务处理速度进行合理的调整。如果任务处理速度远快于任务提交速度，可能会导致队列溢出，从而触发拒绝策略。因此，需要根据具体情况设置合适的队列容量。</li></ol><h4 id="创建多少核心线程数合适（线程池的参数怎么设计）"><a href="#创建多少核心线程数合适（线程池的参数怎么设计）" class="headerlink" title="创建多少核心线程数合适（线程池的参数怎么设计）"></a>创建多少核心线程数合适（线程池的参数怎么设计）</h4><ul><li>过小会导致程序不能充分地利用系统资源、容易导致饥饿</li><li>过大会导致更多的线程上下文切换，占用更多内存</li></ul><h5 id="CPU-密集型运算"><a href="#CPU-密集型运算" class="headerlink" title="CPU 密集型运算"></a>CPU 密集型运算</h5><p>通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p><h5 id="I-O-密集型运算"><a href="#I-O-密集型运算" class="headerlink" title="I&#x2F;O 密集型运算"></a>I&#x2F;O 密集型运算</h5><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。<br>经验公式如下</p><p>线程数 &#x3D; 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) &#x2F; CPU 计算时间</p><p>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式</p><p>4 * 100% * 100% &#x2F; 50% &#x3D; 8</p><p>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式</p><p>4 * 100% * 100% &#x2F; 10% &#x3D; 40</p><p><strong>公示也只是参考，具体还是要根据项目实际线上运行情况来动态调整</strong>，包括核心线程数、最大线程数、自定义任务队列等等</p><h4 id="假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？"><a href="#假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？" class="headerlink" title="假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？"></a>假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？</h4><ul><li>高并发低延迟业务，低延迟说明大概率是CPU密集型，高并发的情况下为了防止大量的上下文切换，核心线程数不宜设置太高，应该设置大概CPU核数 + 1个线程，</li><li>低并发高延迟业务，高延迟说明所需数据或外部资源需要较长时间等待，大概率是IO密集型，核心线程数应该设置为    CPU 核数 * 总时间(CPU计算时间+等待时间) &#x2F; CPU 计算时间</li></ul><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><h4 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h4><h5 id="LongAdder的成员变量"><a href="#LongAdder的成员变量" class="headerlink" title="LongAdder的成员变量"></a><strong>LongAdder的成员变量</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPU的数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">// Cell对象的数组，长度一般是2的指数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="comment">// 基础value值，当并发较低时，只累加该值</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"><span class="comment">// 创建或者扩容Cells数组时使用的自旋锁变量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br></pre></td></tr></table></figure><p>当并发量较少时，cell数组尚未初始化，所以只调用<code>casBase</code>函数，对base变量进行CAS累加。</p><p>并发量大时，放弃使用base变量，而是从cells数组中随机选择一个cell，CAS累加，这样就可以减少并发冲突，获取值就用base加上cells中所有元素累加获得值，遍历数组不是个原子操作，所以LongAdder取到的值不是最新值，再获取精确计数的场景，可能不适合。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240329130947920.png" alt="image-20240329130947920"></p><h4 id="CountdownLatch和CyclicBarrier的区别使用场景与具体实现"><a href="#CountdownLatch和CyclicBarrier的区别使用场景与具体实现" class="headerlink" title="CountdownLatch和CyclicBarrier的区别使用场景与具体实现"></a>CountdownLatch和CyclicBarrier的区别使用场景与具体实现</h4><p><a href="https://zhuanlan.zhihu.com/p/139020914">CountdownLatch和CyclicBarrier的区别使用场景与具体实现 - 知乎 (zhihu.com)</a></p><p><strong>CountdownLatch 使用场景</strong></p><p>顾名思义CountdownLatch可以当做一个计数器来使用,比如主线程需要等待其他几个线程都执行过某个时间节点后才能继续执行 我们来模拟一个场景,某公司一共有十个人,门卫要等十个人都来上班以后,才可以休息,代码实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//lambda中只能只用final的变量</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在赶路&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> * times);</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;到公司了&quot;</span>);</span><br><span class="line">                    <span class="comment">//调用latch的countDown方法使计数器-1</span></span><br><span class="line">                    latch.countDown();</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始工作&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;门卫等待员工上班中...&quot;</span>);</span><br><span class="line">            <span class="comment">//主线程阻塞等待计数器归零</span></span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;员工都来了,门卫去休息了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行后结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">子线程Thread-<span class="number">0</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">2</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">0</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">0</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">1</span>正在赶路</span><br><span class="line">门卫等待员工上班中...</span><br><span class="line">子线程Thread-<span class="number">4</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">9</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">5</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">6</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">7</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">8</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">3</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">1</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">1</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">2</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">2</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">3</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">3</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">4</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">4</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">5</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">5</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">6</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">6</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">7</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">7</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">8</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">8</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">9</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">9</span>开始工作</span><br><span class="line">员工都来了,门卫去休息了</span><br></pre></td></tr></table></figure><h5 id="CyclicBarrier-使用场景"><a href="#CyclicBarrier-使用场景" class="headerlink" title="CyclicBarrier 使用场景"></a>CyclicBarrier 使用场景</h5><p>我们重新模拟一个新的场景,就用已经被说烂的跑步场景吧,十名运动员各自准备比赛,需要等待所有运动员都准备好以后,裁判才能说开始然后所有运动员一起跑,代码实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">10</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有人都准备好了裁判开始了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//lambda中只能只用final的变量</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在准备&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> * times);</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备好了&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始跑了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>执行结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">子线程Thread-<span class="number">0</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">2</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">1</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">3</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">4</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">0</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">5</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">6</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">7</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">8</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">9</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">1</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">2</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">3</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">4</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">5</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">6</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">7</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">8</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">9</span>准备好了</span><br><span class="line">所有人都准备好了裁判开始了</span><br><span class="line">子线程Thread-<span class="number">9</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">0</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">2</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">1</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">7</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">6</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">5</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">4</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">3</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">8</span>开始跑了</span><br></pre></td></tr></table></figure><h5 id="CountdownLatch-底层实现"><a href="#CountdownLatch-底层实现" class="headerlink" title="CountdownLatch 底层实现"></a>CountdownLatch 底层实现</h5><p>我们先来看看CountdownLatch的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先保证了count一定要大于零,然后初始化了一个Sync对象,在看看这个Sync对象是个什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">        Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Sync是CountdownLatch的静态内部类,继承了AbstractQueuedSynchronizer(即AQS,提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的工具,回头单讲)抽象类, 在Sync的构造方法中,调用了setState方法,可以视作初始化了一个标记来记录当前计数器的数量</p><p>我们来看CountdownLatch的两个核心方法,await和countdown,先来看await</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//可以视作将线程阻塞</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>await调用的是AQS的方法,可以视作阻塞线程,具体实现在分析AQS的章节中展开 再来看看countdown方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用了sync的一个方法,再来看看这个方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再来看这个tryReleaseShared方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取标记位</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//用cas的方式更新标记位</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以看到在调用tryReleaseShared实际上是将标记位-1并且返回标记位是否为0,如果标记位为0 那么调用的doReleaseShared可以视作将阻塞的线程放行,这样整个的流程就通了</p><h5 id="CyclicBarrier-底层实现"><a href="#CyclicBarrier-底层实现" class="headerlink" title="CyclicBarrier 底层实现"></a>CyclicBarrier 底层实现</h5><p>老规矩先看构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="built_in">this</span>.parties = parties;</span><br><span class="line">        <span class="built_in">this</span>.count = parties;</span><br><span class="line">        <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这边传入了两个对象简单的记录了一下存值,我们直接查看一下关键的await方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再来看dowait的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">trip</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">/** 省略部分代码 **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">               TimeoutException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line">            <span class="comment">//判断是否被打断</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将计数器-1 即在构造方法中赋值的count</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="comment">//如果所有的线程都执行完毕即count=0时</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行传入的方法</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    ranAction = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//唤醒所有线程</span></span><br><span class="line">                    nextGeneration();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果count没有到0那么阻塞当前线程</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        trip.await();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                        <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到,CyclicBarrier是利用Lock的condition方法来进行线程的阻塞和唤醒,类似Object.wait()和notifyAll()在count不为0时阻塞,在count&#x3D;0时唤醒所有线程</p><p><strong>总结</strong></p><p>1,CountdownLatch适用于所有线程通过某一点后通知方法,而CyclicBarrier则适合让所有线程在同一点同时执行</p><p> 2,CountdownLatch利用继承AQS的共享锁来进行线程的通知,利用CAS来进行–state，当state变成0之后才放行这个调用latch.await()的线程,而CyclicBarrier则利用ReentrantLock的Condition来阻塞和通知线程，count不为0时阻塞,在count&#x3D;0时唤醒所有被阻塞线程</p><h3 id="手撕线程题"><a href="#手撕线程题" class="headerlink" title="手撕线程题"></a>手撕线程题</h3><h4 id="实现’A’、’B’、’C’循环打印ABCABC，每个线程打印时其他线程不能打印"><a href="#实现’A’、’B’、’C’循环打印ABCABC，每个线程打印时其他线程不能打印" class="headerlink" title="实现’A’、’B’、’C’循环打印ABCABC，每个线程打印时其他线程不能打印"></a>实现’A’、’B’、’C’循环打印ABCABC，每个线程打印时其他线程不能打印</h4><h5 id="使用lock"><a href="#使用lock" class="headerlink" title="使用lock"></a>使用lock</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCUsingLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times; <span class="comment">// 控制打印次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;   <span class="comment">// 当前状态值：保证三个线程之间交替打印</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintABCUsingLock</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.times = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String name, <span class="type">int</span> targetNum)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (state % <span class="number">3</span> == targetNum) &#123;</span><br><span class="line">                state++;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.print(name);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintABCUsingLock</span> <span class="variable">loopThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintABCUsingLock</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            loopThread.printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            loopThread.printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            loopThread.printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用wait-notify"><a href="#使用wait-notify" class="headerlink" title="使用wait&#x2F;notify"></a><strong>使用wait&#x2F;notify</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCUsingWaitNotify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintABCUsingWaitNotify</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.times = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintABCUsingWaitNotify</span> <span class="variable">printABC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintABCUsingWaitNotify</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printABC.printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printABC.printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printABC.printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String name, <span class="type">int</span> targetState)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">while</span> (state % <span class="number">3</span> != targetState) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                state++;</span><br><span class="line">                System.out.print(name);</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两个线程交替打印奇数和偶数"><a href="#两个线程交替打印奇数和偶数" class="headerlink" title="两个线程交替打印奇数和偶数"></a>两个线程交替打印奇数和偶数</h4><p>使用对象监视器实现，两个线程 A、B 竞争同一把锁，只要其中一个线程获取锁成功，就打印 ++i，并通知另一线程从等待集合中释放，然后自身线程加入等待集合并释放锁即可。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-9731382f3dfea5a4be6a5b4ef8ccdc87_1440w.webp" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OddEvenPrinter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    OddEvenPrinter(<span class="type">int</span> initCount, <span class="type">int</span> times) &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = initCount;</span><br><span class="line">        <span class="built_in">this</span>.limit = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">OddEvenPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OddEvenPrinter</span>(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::print, <span class="string">&quot;odd&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::print, <span class="string">&quot;even&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; limit) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;线程[%s]打印数字:%d&quot;</span>, Thread.currentThread().getName(), ++count));</span><br><span class="line">                    monitor.notifyAll();</span><br><span class="line">                    monitor.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//防止有子线程被阻塞未被唤醒，导致主线程不退出</span></span><br><span class="line">            monitor.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的思路，来解决下第 5 题：用两个线程，一个输出字母，一个输出数字，交替输出 1A2B3C4D…26Z</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumAndLetterPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printer(), <span class="string">&quot;numThread&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printer(), <span class="string">&quot;letterThread&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().getName() == <span class="string">&quot;numThread&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">//打印数字1-26</span></span><br><span class="line">                    System.out.print((i + <span class="number">1</span>));</span><br><span class="line">                    <span class="comment">// 唤醒其他在等待的线程</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 让当前线程释放锁资源，进入wait状态</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Thread.currentThread().getName() == <span class="string">&quot;letterThread&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 打印字母A-Z</span></span><br><span class="line">                    System.out.print((<span class="type">char</span>) (<span class="string">&#x27;A&#x27;</span> + i));</span><br><span class="line">                    <span class="comment">// 唤醒其他在等待的线程</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 让当前线程释放锁资源，进入wait状态</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用-Lock-Condition"><a href="#使用-Lock-Condition" class="headerlink" title="使用 Lock&#x2F;Condition"></a>使用 Lock&#x2F;Condition</h5><p>还是以第一题为例，使用 Condition 来实现，其实和 wait&#x2F;notify 的思路一样。</p><blockquote><p>Condition 中的 <code>await()</code> 方法相当于 Object 的 <code>wait()</code> 方法，Condition 中的 <code>signal()</code> 方法相当于Object 的 <code>notify()</code> 方法，Condition 中的 <code>signalAll()</code> 相当于 Object 的 <code>notifyAll()</code> 方法。<br>不同的是，Object 中的 <code>wait(),notify(),notifyAll()</code>方法是和<code>&quot;同步锁&quot;</code>(synchronized关键字)捆绑使用的；而 Condition 是需要与<code>&quot;互斥锁&quot;/&quot;共享锁&quot;</code>捆绑使用的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCUsingLockCondition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintABCUsingLockCondition</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.times = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintABCUsingLockCondition</span> <span class="variable">print</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintABCUsingLockCondition</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>, c1, c2);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>, c2, c3);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>, c3, c1);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String name, <span class="type">int</span> targetState, Condition current, Condition next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (state % <span class="number">3</span> != targetState) &#123;</span><br><span class="line">                    current.await();</span><br><span class="line">                &#125;</span><br><span class="line">                state++;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.print(name);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Lock 锁的多个 Condition 可以实现精准唤醒，所以碰到那种多个线程交替打印不同次数的题就比较容易想到，比如解决第四题：多线程按顺序调用，A-&gt;B-&gt;C，AA 打印 5 次，BB 打印10 次，CC 打印 15 次，重复 10 次</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM分区"><a href="#JVM分区" class="headerlink" title="JVM分区"></a>JVM分区</h3><h4 id="jvm堆的分区"><a href="#jvm堆的分区" class="headerlink" title="jvm堆的分区"></a>jvm堆的分区</h4><p>堆中有字符串常量池</p><p>Java堆从GC的角度可以细分为新生代YoungGeneration（Eden区、From Survivor、To Survivor，空间比例8:1:1）和老年代OldGeneration（空间比例1:2）。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-108fca6ca82b85d2d6f559d0d469c770_1440w.webp" alt="img"></p><h4 id="jvm各种区域介绍"><a href="#jvm各种区域介绍" class="headerlink" title="jvm各种区域介绍"></a>jvm各种区域介绍</h4><p><strong>Java内存区域</strong></p><p>Java的内存区域和内存模型是不一样的东西，内存区域是指 JVM 运行时将数据分区域存储，强调对内存空间的划分。</p><p>Java内存区域主要由栈、堆、方法区组成</p><p><strong>栈</strong>：每个线程有自己独立、不共享的虚拟机栈，由多个栈帧（每个方法运行时需要的内存）组成，其中存放参数、局部变量，返回地址等，每个线程只能有一个活动栈帧，对应当前正在执行的那个方法。</p><p><strong>堆</strong>：多个线程共享同一个堆，通过new关键字构建的对象都需要使用堆内存，里面存放了实例对象、字符串常量池，类对象、静态变量（存放在_java_mirror后面）等。</p><p><strong>方法区</strong>：保存在着被加载过的每一个类的信息，包括类的方法、构造器，成员方法，属性等，这些信息由<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">类加载</a>器在加载类时，从类的源文件中抽取出来；<strong>运行时常量池</strong>：当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址转换为真实地址。</p><p><strong>程序计数器：</strong>每个线程都有一个独立的程序计数器，记录下一条JVM指令的执行地址</p><p><strong>本地方法栈：</strong>调用本地方法（由C或者C++编写的底层的方法，与操作系统的底层API打交道）时给本地方法提供的内存空间</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112352559.png" alt="image-20231003112352559"></p><p><strong>直接内存：</strong>操作系统的内存，分配回收成本较高，读写性能高，不受JVM内存回收管理</p><h3 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h3><h4 id="强引用、弱引用、软引用、虚引用的区别"><a href="#强引用、弱引用、软引用、虚引用的区别" class="headerlink" title="强引用、弱引用、软引用、虚引用的区别"></a>强引用、弱引用、软引用、虚引用的区别</h4><p>在Java中提供了四个级别的引用：<strong>强引用</strong>，<strong>软引用</strong>，<strong>弱引用</strong>和<strong>虚引用</strong>。在这四个引用类型中，只有强引用FinalReference类是包内可见，其他三种引用类型均为public，可以在应用程序中直接使用。引用类型的类结构如图所示。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111728261.png" alt="image-20231003111728261"></p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a><strong>强引用</strong></h5><p>Java中默认声明的就是强引用，例如以下代码，如果M对象被回收了，会打印 finalize() 方法中的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">M</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">M</span>();  <span class="comment">//只要m还指向M对象，M对象就不会被回收</span></span><br><span class="line">        <span class="comment">// m = null;   //手动置null</span></span><br><span class="line">        System.gc();  <span class="comment">// 进行垃圾回收</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象被回收了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-e5f1836efa6748c371bcd126823414f7_1440w-1696303052906-5.webp" alt="img"></p><p>只要强引用存在，垃圾收集器将永远不会回收被引用的对象，哪怕<strong>内存不足</strong>时，JVM也会直接抛出OutOfMemoryError，<strong>不会去回收</strong>。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了。例如上面的代码，将 m &#x3D; null; 注释放开时，运行结果如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111738987.png" alt="image-20231003111738987"></p><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a><strong>软引用</strong></h5><p>软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在垃圾回收后，<strong>内存仍然不足</strong>时，系统则<strong>会回收</strong>软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出OutOfMemoryError。这种特性常常被用来实现<strong>缓存技术</strong>，比如网页缓存，图片缓存等。</p><p>在 JDK1.2 之后，用 SoftReference 类来表示软引用。下面以一个例子来进一步说明强引用和软引用的区别。</p><p>在运行下面的Java代码之前，需要先配置参数 -Xms2M -Xmx2M，将 JVM 的初始内存设为2M，最大可用内存为 2M。</p><p>首先先来测试一下强引用，在限制了 JVM 内存的前提下，下面的代码运行正常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 当 new byte为 1M 时，程序运行正常</span></span><br><span class="line">        <span class="type">byte</span>[] buff1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// byte[] buff2 = new byte[1024 * 1024 * 1];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果我们再创建一个1M大小的 byte数组时，则内存不够使用，程序直接报错。因为强引用不会被回收。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111745645.png" alt="image-20231003111745645"></p><p>接着来看一下软引用会有什么不一样，在下面的示例中先创建一个大小为 1M 的软引用对象，打印m的地址，然后进行垃圾回收，休眠500ms后打印m的地址。最后又创建了一个1M的字节数组，打印m的地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SoftReference&lt;<span class="type">byte</span>[]&gt; m = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line"> </span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        <span class="comment">// 再分配一个数组，heap将装不下，</span></span><br><span class="line">        <span class="comment">// 这时系统会进行垃圾回收，如果内存不够，会把软引用干掉</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1</span>];</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-210fffb5827e8aea4115430e5b373238_1440w-1696303070608-7.webp" alt="img"></p><p>根据运行结果，我们可以看到，在内存不足的情况下，软引用才会被回收。</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a><strong>弱引用</strong></h5><p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够</strong>，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象<strong>都会被回收</strong>。在 JDK1.2 之后，用 WeakReference 来表示弱引用。</p><p>我们以与软引用同样的方式来测试一下弱引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        WeakReference&lt;<span class="type">byte</span>[]&gt; m = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line"> </span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111756526.png" alt="image-20231003111756526"></p><p>根据运行结果，可以发现垃圾回收后被弱引用关联的对象被回收了。</p><p>在 Java 集合中有一种特殊的 Map 类型：<strong>WeakHashMap</strong>， 在这种 Map 中存放了键对象的弱引用，当一个键对象被垃圾回收，那么相应的值对象的引用会从 Map 中删除。WeakHashMap 能够节约存储空间，可用来缓存那些非必须存在的数据。</p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象。</p><p>虚引用必须要和 ReferenceQueue 引用队列一起使用，主要配合ByteBuffer使用，在引用对象被回收时，会将虚引用入队，Reference Handler线程调用虚引用相关方法释放直接内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PhantomReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Object&gt; LIST = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReferenceQueue</span> <span class="variable">QUEUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        PhantomReference&lt;M&gt; m = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">M</span>(), QUEUE);<span class="comment">//关联软引用对象和引用队列</span></span><br><span class="line"> <span class="comment">//当软引用所关联的byte数组被回收时，软引用会自己加入到queue中</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                LIST.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>]);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(m.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Reference</span> <span class="variable">poll</span> <span class="operator">=</span> QUEUE.poll();</span><br><span class="line">                <span class="keyword">if</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//获取queue中的无用的软引用对象，并移除</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;虚引用对象：&quot;</span> + poll + <span class="string">&quot; 被jvm回收了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象被回收了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-db69836fc83d1e8d39f5088bc1a4b8a9_1440w-1696303085353-9.webp" alt="img"></p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>JVM中的垃圾回收器通过可达性分析来探索所有存活的对象<br>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果找不到，则表示可以回收</p><h5 id="可以作为GC-Root的对象"><a href="#可以作为GC-Root的对象" class="headerlink" title="可以作为GC Root的对象"></a>可以作为GC Root的对象</h5><ul><li>系统类System Class（Object、String等）</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li><li>所有被同步锁（synchronized关键字）持有的对象。</li><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li></ul><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><p><strong>1.标记-清除算法</strong>：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</p><ul><li>该算法分为两个阶段，<strong>标记和清除</strong>。标记阶段标记所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。该算法最大的问题就是内存碎片严重化，后续可能发生对象不能找到利用空间的问题。</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-7389d400dc04abb145a67fa86a662e33_1440w.webp" alt="img"></p><p><strong>2.复制算法</strong>：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</p><ul><li>按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-20adb8ac4c5deb44fc27e30c8381281d_1440w.webp" alt="img"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322203226141.png" alt="image-20240322203226141"></p><p><strong>3.标记-整理算法</strong>：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</p><ul><li>标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-cc722c4e5b289434d2181451f4fd154c_1440w.webp" alt="img"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322203239717.png" alt="image-20240322203239717"></p><p><strong>4.分代算法</strong>：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</p><p>minor gc新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</p><p>full gc&#x2F;major gc 老年代的GC，Major GC 的速度一般会比 Minor GC 的慢 10 倍以上</p><p>二 minorGC过程详解<br>1 在初始阶段，新创建的对象被分配到Eden区，survivor的两块空间都为空。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>2 当Eden区满了的时候，minor garbage 被触发 。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111900766-29.png" alt="img"></p><p>3 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111908107-32.png" alt="在这里插入图片描述"></p><p>4 在下一次的Minor GC中，Eden区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到survivor区。当Eden 和 s0区空间满了，S0的所有的数据都被复制到S1，需要注意的是，在上次minor GC过程中移动到S0中的两个对象在复制到S1后其年龄要加1。此时Eden区S0区被清空，所有存活的数据都复制到了S1区，并且S1区存在着年龄不一样的对象，过程如下图所示：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111915300-35.png" alt="在这里插入图片描述"></p><p>5 再下一次MinorGC则重复这个过程，这一次survivor的两个区对换，存活的对象被复制到S0，存活的对象年龄加1，Eden区和另一个survivor区被清空。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111922409-38.png" alt="在这里插入图片描述"></p><p>6 再经过几次Minor GC之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold默认是15），就会被从年轻代Promotion到老年代。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111929062-41.png" alt="在这里插入图片描述"></p><p>7 随着MinorGC一次又一次的进行，不断会有新的对象被promote到老年代。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111935557-44.png" alt="在这里插入图片描述"></p><p>8 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记整理)。</p><ul><li><p>从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。</p></li><li><p>老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-整理算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；<strong>如果不允许，则仍然进行Full GC（</strong>这代表着如果设置-XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。</p></li></ul><p>整体描述<br>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次GC后，Eden区和”From”区已经被清空。这个时候，“From”和”To”会交换他们的角色，也就是新的”To”就是上次GC前的“From”，新的”From”就是上次GC前的”To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，**”To”区被填满之后，会将所有对象移动到年老代**中。</p><p>三 GC触发条件<br>Minor GC触发条件：Eden区满时</p><p>Full GC触发条件：<br>（1）调用System.gc时，系统建议执行Full GC，但是不必然执行<br>（2）老年代空间不足<br>（3）方法区空间不足<br>（4）通过Minor GC后进入老年代的大小大于老年代的可用内存<br>（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231004144129340.png" alt="image-20231004144129340"></p><p>新生代分为伊甸园和幸存区，幸存区由from space 与 to space 两块相等的内存区域组成。eden ：from ：to &#x3D; 8 : 1 : 1;</p><p>新生代回收之后内存足够使用的话就不会扫描老年代，否则会扫描老年代。</p><h4 id="年轻代怎么升级为老年代"><a href="#年轻代怎么升级为老年代" class="headerlink" title="年轻代怎么升级为老年代"></a>年轻代怎么升级为老年代</h4><h5 id="担保机制"><a href="#担保机制" class="headerlink" title="担保机制"></a>担保机制</h5><p>新生代内存不足的时候（当MinorGC时，如果存活对象过多，无法完全放入Survivor From区），可以通过担保分配的方式让存活对象直接分配进老年代。</p><h5 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h5><p>-XX：PretenureSizeThreshould &#x3D; 3145728，可以设置超过3M的对象直接进入老年代</p><h5 id="长期存活的对象"><a href="#长期存活的对象" class="headerlink" title="长期存活的对象"></a>长期存活的对象</h5><p>在年轻代的对象在minor GC后没有被淘汰年龄就会加1，年龄增加到一定程度就会晋升为老年代，这个晋升的年龄是可以设置的。</p><h5 id="动态年龄判断"><a href="#动态年龄判断" class="headerlink" title="动态年龄判断"></a>动态年龄判断</h5><p>当survivor空间中相同年龄所有<strong>对象的大小总和****大于</strong>survivor空间的一半，年龄大于或等于该年龄的对象就会直接进入老年代，无需等到晋升年龄。</p><h4 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h4><p><a href="https://juejin.cn/post/6974281849031884830">JVM调优——GC 调优 - 掘金 (juejin.cn)</a></p><h5 id="确定合适回收器"><a href="#确定合适回收器" class="headerlink" title="确定合适回收器"></a>确定合适回收器</h5><p>“低延迟”还是“高吞吐量”，选择合适的回收器CMS，G1，ZGC </p><h5 id="降低GC次数，最快的GC是不发生GC"><a href="#降低GC次数，最快的GC是不发生GC" class="headerlink" title="降低GC次数，最快的GC是不发生GC"></a>降低GC次数，最快的GC是不发生GC</h5><p>尽量减少堆内存的使用，减少对象大小、避免数据冗余、排查是否存在内存泄漏</p><h5 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h5><p>新生代的特点</p><ul><li>所有的new操作分配内存都是非常廉价的</li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>MInor GC 所用时间远小于Full GC</li></ul><p><strong>选择合适新生代内存大小</strong></p><ul><li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li><li>新生代内存设置为能容纳**[并发量*(请求-响应)]**的数据为宜</li><li>幸存区大到能保留【当前活跃对象+需要晋升对象】</li><li>晋升阈值配置得当，让长时间存活对象尽快晋升</li></ul><h5 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h5><p>如果fullGC频率不高，就挺适合的</p><p>如果频繁发生fullGC，可以调高老年代空间占用比率，增大堆空间</p><p>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1&#x2F;4 ~ 1&#x2F;3<br>-XX:CMSInitiatingOccupancyFraction&#x3D;percent</p><h4 id="GC调优实战"><a href="#GC调优实战" class="headerlink" title="GC调优实战"></a>GC调优实战</h4><h5 id="分析GC日志-GCEasy"><a href="#分析GC日志-GCEasy" class="headerlink" title="分析GC日志 - GCEasy"></a>分析GC日志 - GCEasy</h5><p>GCeasy是业界首款使用AI机器学习技术在线进行GC分析和诊断的工具。定位内存泄漏、GC延迟高的问题，提供JVM参数优化建议，支持在线的可视化工具图表展示。 官方网站：<a href="https://gceasy.io/">https://gceasy.io/</a> </p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1712369115106-34.png" alt="img"></p><p>使用方法：</p><p>1、选择文件，找到GC日志并上传</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1712369115050-28.png" alt="img"></p><p>2、点击Analyze分析就可以看到报告，每个账号每个月能免费上传5个GC日志。</p><p>建议部分：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1712369115050-29.png" alt="img"></p><p>内存情况：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1712369115050-30.png" alt="img"></p><p>GC关键性指标：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1712369115050-31.png" alt="img"></p><p>GC的趋势图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1712369115050-32.png" alt="img"></p><p>引发GC的原因：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1712369115050-33.png" alt="img"></p><h4 id="垃圾收集器cms和g1比较"><a href="#垃圾收集器cms和g1比较" class="headerlink" title="垃圾收集器cms和g1比较"></a>垃圾收集器cms和g1比较</h4><h5 id="CMS（仅作用于老年代，基于标记-清除算法）"><a href="#CMS（仅作用于老年代，基于标记-清除算法）" class="headerlink" title="CMS（仅作用于老年代，基于标记-清除算法）"></a>CMS（仅作用于老年代，基于标记-清除算法）</h5><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。这是因为 CMS 收集器工作时，GC 工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的。</p><ul><li>初始标记（CMS initial mark）需要 Stop-the-world，标记一下 GC Roots 能直接关联到的对象，速度很快</li><li>并发标记（CMS concurrent mark）进行 GC Roots Tracing 的过程</li><li>重新标记（CMS remark）需要 Stop-the-world，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始阶段稍长一些，但远比并发标记的时间短。</li><li>并发清除（CMS concurrent sweep）</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/59307b3ead7530e2f9fedaaf71f5608f.png" alt="img"></p><p>CMS 收集器优点：并发收集、低停顿。</p><p>CMS 收集器缺点：</p><ul><li>CMS 收集器对 CPU 资源非常敏感。</li><li>CMS 收集器无法处理浮动垃圾（Floating Garbage）（CMS在 并发标记 时是并发的，GC 线程和用户线程并发执行，这个过程当然可能会因为线程的交替执行而导致新产生的垃圾（可回收对象，即浮动垃圾）没有被标记到；而 重新标记 只是对之前 并发标记 所获得的不可达对象的更正，所以是没有办法处理 “浮动垃圾” 的。）。</li><li>CMS 收集器是基于标记-清除算法，该算法的缺点都有（内存碎片）。</li><li>停顿时间是不可预期的。</li></ul><h5 id="G1-分为年轻代回收（复制算法），混合回收（年轻代与老年代（标记整理suan’fa）都会回收）"><a href="#G1-分为年轻代回收（复制算法），混合回收（年轻代与老年代（标记整理suan’fa）都会回收）" class="headerlink" title="G1(分为年轻代回收（复制算法），混合回收（年轻代与老年代（标记整理suan’fa）都会回收）)"></a>G1(分为年轻代回收（复制算法），混合回收（年轻代与老年代（标记整理suan’fa）都会回收）)</h5><ul><li>G1 算法取消了堆中年轻代与老年代的物理划分，而是一个逻辑分代，但它仍然属于分代收集器。</li><li>G1 算法将堆划分为若干个区域，称作 Region，</li><li>同时注重**吞吐量（**Throughput）和**低延迟**（Low latency），默认的暂停目标是 200 ms</li><li>G1 采用每次只清理一部分而不是全部的 Region 的增量式清理，由此来保证每次 GC 停顿时间不会过长。</li><li>G1 算法允许通过 JVM 参数设置 Region 的大小，范围是 1～32MB，可以设置期望的最大 GC 停顿时间，根据这个停顿时间来制定回收计划，所以G1的垃圾<font color = gold>回收是可预期的</font>。</li></ul><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231011213513010.png" alt="image-20231011213513010" style="zoom: 50%;" /><p><strong>G1垃圾回收器的垃圾回收方式分为两种。</strong></p><ul><li><strong>一就是YoungGC，主要回收的是年轻代Region中的垃圾，采用<font color = gold>复制算法</font></strong></li><li><strong>第二种就是混合回收模式（Mix GC），这种回收模式会回收年轻代跟老年代中的所有垃圾，采用<font color = gold>标记-整理算法</font>。</strong></li></ul><p>G1 回收过程如下。</p><ul><li><strong>初始标记(Initial Marking)：</strong>这阶段仅仅只是<font color = gold>标记GC Roots能直接关联到的对象</font>，让下一阶段用户程序并发运行时，能在正确的可用的Region中创建新对象，这阶段需要<font color = gold>停顿线程(STW)</font>，但是<font color = gold>耗时很短</font>&gt;。而且是借用<font color = gold>进行Minor GC的时候同步完成的</font>&gt;，所以G1收集器在这个阶段实际并没有额外的停顿。</li><li><strong>并发标记(Concurrent Marking)：</strong>从GC Roots开始对堆的对象进行<font color = gold>可达性分析</font>，并进行三色标记，标记开始时创建一个快照，记录当前所有对象，递归扫描整个堆里的对象图，找出存活的对象，（在此过程中新创建的对象会直接标记为黑色），这阶段<font color = gold>耗时较长</font>，但是可以<font color = gold>与用户程序并发执行,不会STW</font>。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象，将这些对象放入STAB队列中。</li><li><strong>最终标记(Final Marking)：</strong>对<font color = gold>用户线程做另一个短暂的暂停</font>，用于标记并发阶段结束后仍遗留下来的最后那少量的 SATB队列中的对象记录。</li><li><strong>筛选回收(Live Data Counting and Evacuation)：</strong>负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，优先对可回收空间较大的 Region 进行回收，即 garbage first，这也是 G1 名称的由来，根据用户所<font color = gold>期望的停顿时间来制定回收计划</font>。可以<font color = gold>自由选择多个Region来构成回收集</font>，然后把回收的那一部分Region中的存活对象复制到空的Region中，再对那些Region进行清空。</li></ul><p>除了并发标记外，其余过程都要 STW</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/20200608151109.png" alt="img" style="zoom:50%;" /><h5 id="年轻代回收详情（复制算法）"><a href="#年轻代回收详情（复制算法）" class="headerlink" title="年轻代回收详情（复制算法）"></a>年轻代回收详情（复制算法）</h5><p>年轻代回收<strong>只扫描年轻代对象（Eden + Survivor）</strong>，所以从GC Root到年轻代的对象或者年轻代对象引用了其他年轻代的对象都很容易扫描出来。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711165442927-26.png" alt="img"></p><p>这里就存在一个问题，年轻代回收只扫描年轻代对象（Eden + Survivor），如果有老年代中的对象引用了年轻代中的对象，我们又如何知道呢？</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711165442928-27.png" alt="img"></p><p>比如上图中，E对象被对象引用了，那么显然在垃圾回收时E对象是不应该被回收的。</p><p><strong>方案1：从GC Root开始，扫描所有对象，如果年轻代对象在引用链上，就标记为存活。</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711165442928-28.png" alt="img"></p><p>重新扫描一遍GC Root关联的所有对象，包括老年代的。这个方案显然不可行，需要遍历引用链上所有对象，效率太低。</p><p><strong>方案2：维护一个详细的表，记录哪个对象被哪个老年代引用了。在年轻代中被引用的对象，不进行回收。</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711165442928-29.png" alt="img"></p><p>如上图中，通过引用详情表记录F和E对象分别被A和B对象引用了。问题：如果对象太多这张表会占用很大的内存空间。存在错标的情况</p><p>方案2的第一次优化：只记录Region被哪些对象引用了。这种引用详情表称为记忆集 RememberedSet（简称RS或RSet）：是一种记录了从非收集区域对象引用收集区域对象的这些关系的数据结构。扫描时将记忆集中的对象也加入到GC Root中，就可以根据引用链判断哪些对象需要回收了。</p><p>问题：如果区域中引用对象很多，还是占用很多内存。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711165442928-30.png" alt="img"></p><p>方案2的第二次优化：将所有区域中的内存按一定大小划分成很多个块（每个块的大小为512kb），每个块进行编号。记忆集中只记录对块的引用关系。如果一个块中有多个对象，只需要引用一次，减少了内存开销。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711165442928-31.png" alt="img"></p><p>每一个Region都拥有一个自己的卡表，如果产生了跨代引用（老年代引用年轻代），此时这个Region对应的卡表上就会将字节内容进行修改,用一个字节来代表区域内的一个512字节的块，JDK8源码中0代表被引用了称为脏卡。这样就可以标记出当前Region被老年代中的哪些部分引用了。那么要生成记忆集就比较简单了，只需要遍历整个卡表，找到所有脏卡。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711165442928-32.png" alt="img"></p><p>那么怎么样去维护这个卡表呢？或者说怎么知道A对F引用了？</p><p><strong>JVM使用写屏障（Write Barrier）技术</strong>，在执行引用关系建立的代码时，可以在代码前和代码后插入一段指令，从而维护卡表。</p><p>记忆集中不会记录新生代到新生代的引用，同一个Region中的引用也不会记录。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711165442928-33.png" alt="img"></p><p>记忆集的生成流程分为以下几个步骤：</p><p>1、通过写屏障获得引用变更的信息。</p><p>2、将引用关系记录到卡表中，并记录到一个脏卡队列中。</p><p>3、JVM中会由Refinement 线程定期从脏卡队列中获取数据，生成记忆集。不直接写入记忆集的原因是避免过多线程并发访问记忆集。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711165442928-34.png" alt="img"></p><h6 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h6><p>更详细的分析下年轻代回收的步骤，整个过程是STW的：</p><p>1、Root扫描，将所有的静态变量、局部变量扫描出来。</p><p>2、处理脏卡队列中的没有处理完的信息，更新记忆集的数据，此阶段完成后，记忆集中包含了所有老年代对当前Region的引用关系。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711165442929-35.png" alt="img"></p><p>3、标记存活对象。记忆集中的对象会加入到GC Root对象集合中，在GC Root引用链上的对象也会被标记为存活对象。</p><p>4、根据设定的最大停顿时间，选择本次收集的区域，称之为回收集合Collection Set。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711165442929-36.png" alt="img"></p><p>5、复制对象：将标记出来的对象复制到新的区中，将年龄加1，如果年龄到达15则晋升到老年代。老的区域内存直接清空。</p><p>6、处理软、弱、虚、终结器引用，以及JNI中的弱引用。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711165442929-37.png" alt="img"></p><p><strong>G1年轻代回收核心技术</strong></p><p><strong>1、卡表 Card Table</strong></p><p>每一个Region都拥有一个自己的卡表，卡表是一个字节数组，如果产生了跨代引用（老年代引用年轻代），G1会将卡表上引用对象所在的位置字节内容进行修改为0, 称为脏卡。卡表的主要作用是生成记忆集。</p><p>卡表会占用一定的内存空间，堆大小是1G时，卡表大小为1G &#x3D; 1024 MB &#x2F; 512 &#x3D; 2MB</p><p><strong>2、记忆集 RememberedSet（简称RS或RSet）</strong></p><p>每一个Region都拥有一个自己的记忆集，如果产生了跨代引用，记忆集中会记录引用对象所在的卡表位置。标记阶段将记忆集中的对象加入GC ROOT集合中一起扫描，就可以将被引用的对象标记为存活。</p><p><strong>3、写屏障 Write Barrier</strong></p><p>G1使用写屏障技术，在执行引用关系建立的代码执行后插入一段指令，完成卡表的维护工作。</p><p>会损失一部分的性能，大约在5%~10%之间。</p><h5 id="混合回收"><a href="#混合回收" class="headerlink" title="混合回收"></a>混合回收</h5><p>多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值（默认45%）时会触发混合回收MixedGC。</p><p>混合回收会由年轻代回收之后或者大对象分配之后触发，混合回收会回收 <strong>整个年轻代 + 部分老年代。</strong></p><p>老年代很多时候会有大量对象，要标记出所有存活对象耗时较长，所以整个标记过程要尽量能做到和用户线程并行执行。</p><h5 id="混合回收的步骤："><a href="#混合回收的步骤：" class="headerlink" title="混合回收的步骤："></a><strong>混合回收的步骤：</strong></h5><p>1、初始标记，STW，采用三色标记法标记从GC Root可直达的对象。</p><p>2、并发标记，并发执行，对存活对象进行标记。</p><p>3、最终标记，STW，处理SATB相关的对象标记。</p><p>4、清理，STW，如果区域中没有任何存活对象就直接清理。</p><p>5、使用标记整理算法，转移，将存活对象复制到别的区域。</p><h6 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h6><p>初始标记会暂停所有用户线程，只标记从GC Root可直达的对象，所以停顿时间不会太长。采用三色标记法进行标记，三色标记法在原有双色标记（黑也就是1代表存活，白0代表可回收）增加了一种灰色，采用队列的方式保存标记为灰色的对象。</p><p>黑色：存活，当前对象在GC Root引用链上，同时他引用的其他对象也都已经标记完成。</p><p>灰色：待处理，当前对象在GC Root引用链上，他引用的其他对象还未标记完成。</p><p>白色：可回收，不在GC Root引用链上。</p><p>初始所有对象都是默认为白色，初始值为0：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711166313048-71.png" alt="img"></p><p>三色标记中的黑色和白色是使用位图(bitmap)来实现的,比如8个字节使用1个bit来标识标记的内容，黑色为1，白色为0，灰色不会体现在位图中，会单独放入一个队列中。如果对象超过8个字节，仅仅使用第一个bit位处理。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711166313051-72.png" alt="img"></p><p>将GC Root可以直到的对象D标记，D没有其他引用对象，所以直接标记为为黑色：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711166313052-73.png" alt="img"></p><p>接下来将B对象标记，由于B关联了A和C，而A和C没有标记完成，所以B是待处理状态，将B送入灰色队列。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711166313052-74.png" alt="img"></p><h6 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h6><p>接下来进入并发标记阶段，继续进行未完成的标记任务。此阶段和用户线程并发执行。</p><p>从灰色队列中获取尚未完成标记的对象B。标记B关联的A和C对象，由于A对象并未引用其他对象，可以直接标记成黑色，而B也完成了所有引用对象的标记，也标记为黑色。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711166313053-75.png" alt="img"></p><p>最后从队列获取C对象，标记为黑色，E也标记为黑色。所以剩余对象F就是白色，可回收。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711166313053-76.png" alt="img"></p><p>三色标记存在一个比较严重的问题，由于用户线程可能同时在修改对象的引用关系，就会出现错标的情况，比如：</p><p>这个案例中正常情况下，B和C都会被标记成黑色。但是在BC标记前，用户线程执行了 B.c &#x3D; null；将B到C的引用去除了。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711166313053-77.png" alt="img"></p><p>同时执行了A.c &#x3D; c; 添加了A到C的引用。此时会出现严重问题，C是白色可回收一旦回收代码中再去使用对象会造成重大问题。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711166313053-78.png" alt="img"></p><p>如果接着处理B：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711166313054-79.png" alt="img"></p><p>B在GC引用链上，没有引用任何对象，所以B标记为黑色：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711166313054-80.png" alt="img"></p><p>这样C虽然在引用链上，但是被回收了。</p><p>G1为了解决这个问题，使用了<strong>SATB技术（Snapshot At The Beginning， 初始快照）</strong>。SATB技术是这样处理的：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711166313054-81.png" alt="img"></p><p>1、标记开始时创建一个快照，记录当前所有对象，标记过程中新生成的对象直接标记为黑色。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711166313054-82.png" alt="img"></p><p>2、采用前置写屏障技术，在引用赋值前比如B.c &#x3D; null之前，将之前引用的对象c放入SATB待处理队列中。SATB队列每个线程都有一个，最终会汇总到一个大的SATB队列中。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711166313054-83.png" alt="img"></p><p>最终队列处理完之后，C和F就可以完成标记了。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711166313055-84.png" alt="img"></p><p>SATB的缺点是在本轮清理时可能会将不存活的对象标记成存活对象，产生了一些所谓的浮动垃圾，等到下一轮清理时才能回收。比如图中的E对象。</p><h5 id="ZGC垃圾回收器"><a href="#ZGC垃圾回收器" class="headerlink" title="ZGC垃圾回收器"></a>ZGC垃圾回收器</h5><p>ZGC 是一种可扩展的低延迟垃圾回收器。ZGC 在垃圾回收过程中，STW的时间不会超过一毫秒，适合需要低延迟的应用。支持几百兆到16TB 的堆大小，堆大小对STW的时间基本没有影响。 </p><p>主要是使用了染色指针+ 读屏障来降低G1在转移对象时候的停顿时间</p><p>ZGC（Garbage Collector）是一种在JVM中实现的低停顿时间垃圾回收器。其垃圾回收流程可以概括为以下几个关键阶段：</p><ol><li><strong>初始标记阶段（Initial Mark）：</strong>与G1垃圾回收器一样，初始标记阶段是一个短暂的STW阶段，目的是标记出根对象直接引用的对象，标记的过程是并发执行的，所以这个阶段的停顿时间很短。</li><li><strong>并发标记阶段（Concurrent Mark）：</strong>在这个阶段，ZGC并发地标记出所有可达的对象，包括从根对象出发的引用链上的对象，这个过程是与应用程序的执行同时进行的，因此对停顿时间的影响很小。</li><li><strong>再标记阶段（Remark）：</strong>如果在并发标记阶段有新的对象被创建或有对象被回收，ZGC可能需要进行一次短暂的STW再标记。这个阶段的停顿时间一般不超过1毫秒。在这个阶段，ZGC会修正并发标记阶段可能由于并发引起的标记不一致。</li><li><strong>并发转移准备（Concurrent Prepare for Relocate）：</strong>在这个阶段ZGC进行整堆扫描，确定收集哪些Region，并将这些Region组成重分配集（Relocation Set）。与G1收集器不同，ZGC的重分配集扫描所有的Region，而不是计算最有价值回收的Region，由于染色指针的存在，扫描过程会很快。这个过程并不是为了计算最优的回收集，而是为了确定存活对象将被复制到其他Region。此阶段还涉及到JDK12支持的类卸载和弱引用的处理。</li><li><strong>初始转移阶段（Initial Relocation）：</strong>这是ZGC垃圾回收的核心阶段之一，ZGC并发地将重分配集中的存活对象复制到新的Region。为了记录从旧对象到新对象的转移关系，ZGC需要为重分配集中的每个Region维护一个转发表（Forward Table）。<br>ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力<br>ZGC的染色指针因为“自愈”（Self-Healing）能力，所以只有第一次访问旧对象会变慢，。 一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于新对象的分配，但是转发表还得留着不能释放掉，因为可能还有访问在使用这个转发表。</li><li><strong>并发转移阶段（Concurrent Relocation）：</strong>并发转移阶段的工作就是修正堆中指向重分配集中旧对象的所有引用，也可以直接认为就是真正进行对象引用修复的一个步骤，从这一点来看shenandoah的并发引用更新阶段是一样的。但是ZGC并不需要马上完成这个操作（因为有指针自愈的特性），ZGC把并发重映射阶段要做的工作巧妙的合并到<strong>下一次垃圾收集循环</strong>中的并发标记阶段中去完成，这样做的好处是节省遍历对象图的开销。一旦所有指针修复，新旧对象的引用关系<strong>转发表</strong>就可以释放了。</li></ol><table><thead><tr><th>优点</th><th>描述</th></tr></thead><tbody><tr><td>1. 低停顿</td><td>ZGC以低停顿为首要目标，几乎所有垃圾回收过程都是并发的，只有短暂的STW。</td></tr><tr><td>2. 高吞吐量</td><td>ZGC在吞吐量方面取得了显著进展，超越了G1，接近Parallel Scavenge。</td></tr><tr><td>3. 内存小</td><td>没有写屏障和卡表等额外的数据结构，收集过程中额外耗费的内存较小。</td></tr><tr><td>4. 局部内存分配</td><td>在多核处理器的某些架构下，优先在当前线程所处的处理器的本地内存上分配对象。</td></tr><tr><td>5. 并发停顿</td><td>并发停顿非常短暂，大部分过程都是与应用线程并发执行。</td></tr><tr><td>6. 无分代</td><td>没有引入分代的概念，简化了内存管理的复杂性。</td></tr><tr><td>7. 无内存碎片</td><td>采用并发的标记-整理算法，没有内存碎片问题。</td></tr></tbody></table><table><thead><tr><th>缺点</th><th>描述</th></tr></thead><tbody><tr><td>1. 浮动垃圾</td><td>承受的对象分配速率不会太高，产生浮动垃圾，难以及时回收。</td></tr><tr><td>2. 执行时间较长</td><td>停顿时间短，但整个垃圾回收过程的执行时间可能较长。</td></tr><tr><td>3. 无分代概念</td><td>没有分代概念，可能导致朝生夕死的对象无法及时回收。</td></tr><tr><td>4. 平台限制</td><td>目前仅在Linux&#x2F;x64上可用，可能限制了在其他平台的应用。</td></tr></tbody></table><h3 id="JVM运行、加载过程"><a href="#JVM运行、加载过程" class="headerlink" title="JVM运行、加载过程"></a>JVM运行、加载过程</h3><h4 id="静态变量的加载过程"><a href="#静态变量的加载过程" class="headerlink" title="静态变量的加载过程"></a>静态变量的加载过程</h4><p>连接的准备阶段</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231006121550663.png" alt="image-20231006121550663"></p><h4 id="Java运行一个程序的过程？"><a href="#Java运行一个程序的过程？" class="headerlink" title="Java运行一个程序的过程？"></a>Java运行一个程序的过程？</h4><ol><li><strong>编译阶段</strong></li></ol><p>Java 代码首先需要被编译器编译，Java 编译器首先检查语法和语义的错误，然后将源码转换成字节码。编译生成的字节码被存储在一个或多个 .class 文件中，这些文件可以直接在 JVM 上运行或在网络上传输。</p><ol start="2"><li><strong>运行阶段</strong></li></ol><p><strong>Java 代码的运行分为三个阶段：装载、链接和初始化。</strong></p><p>- 装载：Java 虚拟机装载字节码，通常从 ClassPath 路径中获取，并检查字节码的正确性和合法性。</p><p>- 链接：在链接阶段，Java 虚拟机将其装载的类型与所依赖的类型链接起来，生成实际的可执行代码，主要包括验证、准备、解析三个阶段：</p><ul><li>验证：Java 虚拟机对字节码进行验证，以确保其符合规范和安全标准。验证阶段检查字节码中包含的元数据和字节码是否符合规范和安全标准。</li><li>准备：Java 虚拟机为类变量分配存储空间，并将其初始化为标准初始值。</li><li>解析：Java 虚拟机在准备阶段对常量池进行了解析，以确定每个符号对应的目标，这个过程称为解析。</li></ul><p>- 初始化：在初始化阶段，Java 虚拟机按照程序设定的顺序执行类构造器，以完成类的初始化。类构造器是由编译器自动生成的，它们负责将静态变量初始化并执行静态语句块中的代码。</p><p>在初始化阶段完成后，Java 虚拟机就开始执行字节码指令了，在这个阶段，Java 虚拟机通过解释器将字节码转换为机器码，并开始执行代码逻辑，完成 Java 代码的运行和执行。</p><p>总结</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711175338351-118.png" alt="img"></p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><h5 id="类加载时JVM的区域"><a href="#类加载时JVM的区域" class="headerlink" title="类加载时JVM的区域"></a>类加载时JVM的区域</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231006115620436.png" alt="image-20231006115620436"></p><p>类对象 xxx.class放在堆中， 存放instanceKlass的镜像指针，instanceKlass的中包含类的所有信息</p><h5 id="类加载器-1"><a href="#类加载器-1" class="headerlink" title="类加载器"></a>类加载器</h5><p>1.启动类加载器（Bootstrap ClassLoader）加载核心类</p><p>2.扩展类加载器（Extension ClassLoader）加载扩展类</p><p>3.应用程序类加载器（Application ClassLoader）加载应用classpath中的类</p><p>4.自定义类加载器，重写findClass方法。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231010185648889.png" alt="image-20231010185648889"></p><h4 id="（类的加载机制）双亲委派机制是什么？怎么打破？"><a href="#（类的加载机制）双亲委派机制是什么？怎么打破？" class="headerlink" title="（类的加载机制）双亲委派机制是什么？怎么打破？"></a>（类的加载机制）双亲委派机制是什么？怎么打破？</h4><h5 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h5><p>当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。</p><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><ol><li><p>保证类加载的安全性</p><p>通过双亲委派机制，让顶层的类加载器去加载核心类，避免恶意代码替换JDK中的核心类库（比如Java.lang.String），确保核心类库的完整性和安全性。</p></li><li><p>避免重复加载</p><p>可以避免同一个类被多次记载，上层的类加载器如果记载过类，就会直接返回该类，避免重复加载造成资源浪费，</p></li></ol><h5 id="怎么打破"><a href="#怎么打破" class="headerlink" title="怎么打破"></a>怎么打破</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231010192356056.png" alt="image-20231010192356056"></p><ul><li><p>ClassLoader中包含了4个核心方法，对Java程序员来说，打破双亲委派机制的唯一方法就是实现自定义类加载器重写loadClass方法，将其中的双亲委派机制代码去掉。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711175083796-113.png" alt="img"></p></li></ul><h5 id="为什么要打破"><a href="#为什么要打破" class="headerlink" title="为什么要打破"></a>为什么要打破</h5><p><strong>用双亲委派也存在一定的局限性</strong>，</p><p>在加载核心类库时，如果需要使用用户代码，双亲委派流程就无法满足；</p><p>比如在使用JDBC时， 利用DriverManager.getConnection获取连接时，就会存在这样的问题。</p><p>DriverManager是由根类加载器Bootstrap加载的，在加载DriverManager时，会执行其静态方法，加载初始驱动程序，也就是Driver接口的实现类；但是这些实现类基本都是第三方厂商提供的，根据双亲委派原则，第三方的类应该是由ApplicationClassLoader来加载</p><h4 id="什么情况下会报ClassNotFound的异常？-1"><a href="#什么情况下会报ClassNotFound的异常？-1" class="headerlink" title="什么情况下会报ClassNotFound的异常？"></a>什么情况下会报ClassNotFound的异常？</h4><p>当应用程序运行的过程中尝试使用类加载器去加载Class文件的时候，如果没有在classpath中查找到指定的类，就会抛出ClassNotFoundException。一般情况下，当我们使用Class.forName()或者ClassLoader.loadClass以及使用ClassLoader.findSystemClass()在运行时加载类的时候，如果类没有被找到，那么就会导致JVM抛出ClassNotFoundException。</p><h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><ul><li>默认无参构造</li><li>自动拆装箱</li><li>for-each</li><li>泛型擦除（比如在list集合中put和get都把泛型当作Object）</li><li>可变参数</li><li>枚举类</li><li>重写桥接（子类重写父类方法的返回值可以是父类方法返回值的子类， 通过一个桥接方法来调用子类的重写方法）</li></ul><h4 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h4><p> 内存泄漏（memory leak）：在Java中如果不再使用一个对象，但是该对象依然在GC ROOT的引用链上，这个对象就不会被垃圾回收器回收，这种情况就称之为内存泄漏</p><p> 少量的内存泄漏可以容忍，但是如果发生持续的内存泄漏，就像滚雪球雪球越滚越大，不管有多大的内存迟早会被消耗完，最终导致的结果就是内存溢出。                </p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711161957517-1.png" alt="img"></p><p>解决内存泄漏问题总共分为四个步骤，其中前两个步骤是最核心的：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240323104729041.png" alt="image-20240323104729041"></p><h5 id="发现问题-–-堆内存状况的对比"><a href="#发现问题-–-堆内存状况的对比" class="headerlink" title="发现问题 – 堆内存状况的对比"></a>发现问题 – 堆内存状况的对比</h5><p><strong>正常情况</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711162227058-8.png" alt="img"></p><ul><li>处理业务时会出现上下起伏，业务对象频繁创建内存会升高，触发MinorGC之后内存会降下来。</li><li>手动执行FULL GC之后，内存大小会骤降，而且每次降完之后的大小是接近的。</li><li>长时间观察内存曲线应该是在一个范围内。</li></ul><p><strong>出现内存泄漏</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711162227058-9.png" alt="img"></p><ul><li>处于持续增长的情况，即使Minor GC也不能把大部分对象回收</li><li>手动FULL GC之后的内存量每一次都在增长</li><li>长时间观察内存曲线持续增长</li></ul><p>生成方式有两种</p><p>1、内存溢出时自动生成，添加生成内存快照的Java虚拟机参数：</p><p>​    -XX:+HeapDumpOnOutOfMemoryError：发生OutOfMemoryError错误时，自动生成hprof内存快照文件。</p><p>​    -XX:HeapDumpPath&#x3D;<path>：指定hprof文件的输出路径。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711162274734-14.png" alt="img"></p><p>发生oom之后，就会生成内存快照文件：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711162274735-15.png" alt="img"></p><p>2、导出运行中系统的内存快照，比较简单的方式有两种，注意只需要导出标记为存活的对象：</p><p>通过JDK自带的jmap命令导出，格式为：</p><p>​      jmap -dump:live,format&#x3D;b,file&#x3D;文件路径和文件名 进程ID</p><p>通过arthas的heapdump命令导出，格式为：</p><p>​      heapdump –live  文件路径和文件名 </p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711162274735-16.png" alt="img"></p><p>诊断 – <strong>MAT</strong>定位问题</p><p>使用MAT打开hprof文件，并选择内存泄漏检测功能，MAT会自行根据内存快照中保存的数据分析内存泄漏的根源。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711162274735-17.png" alt="img"></p><p><strong>修复问题</strong></p><p>修复内存溢出问题的要具体问题具体分析，问题总共可以分成三类：</p><ul><li>代码中的内存泄漏，由于代码的不合理写法存在隐患，导致内存泄漏</li><li>并发引起内存溢出 - 参数不当,由于参数设置不当，比如堆内存设置过小，导致并发量增加之后超过堆内存的上限。解决方案：设置合理参数</li><li>并发引起内存溢出 – 设计不当，系统的方案设计不当，比如：<ul><li>从数据库获取超大数据量的数据</li><li>线程池设计不当</li><li>生产者-消费者模型，消费者消费性能问题</li></ul></li></ul><p>​      解决方案：优化设计方案</p><h4 id="常见JVM参数"><a href="#常见JVM参数" class="headerlink" title="常见JVM参数"></a>常见JVM参数</h4><h5 id="一、堆内存相关配置"><a href="#一、堆内存相关配置" class="headerlink" title="一、堆内存相关配置"></a>一、<strong>堆内存相关配置</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">设置堆初始值</span><br><span class="line">指令<span class="number">1</span>：-Xms2g</span><br><span class="line">指令<span class="number">2</span>：-XX:InitialHeapSize=2048m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">设置堆区最大值</span><br><span class="line">指令<span class="number">1</span>：`-Xmx2g` </span><br><span class="line">指令<span class="number">2</span>： -XX:MaxHeapSize=2048m</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">新生代内存配置</span><br><span class="line">指令<span class="number">1</span>：-Xmn512m</span><br><span class="line">指令<span class="number">2</span>：-XX:MaxNewSize=512m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">缩小堆内存的时机</span><br><span class="line">-XX:MaxHeapFreeRatio=<span class="number">70</span><span class="comment">//堆内存使用率大于70时扩张堆内存，xms=xmx时该参数无效，默认值70</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">扩张堆内存的时机</span><br><span class="line">-XX:MinHeapFreeRatio=<span class="number">40</span><span class="comment">//堆内存使用率小于40时缩减堆内存，xms=xmx时该参数无效，默认值40</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>个survivor区和Eden区大小比率</span><br><span class="line">指令：-XX:SurvivorRatio=<span class="number">6</span>  <span class="comment">//S区和Eden区占新生代比率为1:6,两个S区2:6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">新生代和老年代的占比</span><br><span class="line">-XX:NewRatio=<span class="number">4</span>  <span class="comment">//表示新生代:老年代 = 1:4 即老年代占整个堆的4/5；默认值=2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h5 id="二、方法区内存配置常用参数"><a href="#二、方法区内存配置常用参数" class="headerlink" title="二、方法区内存配置常用参数"></a><strong>二、方法区内存配置常用参数</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">初始化的Metaspace大小，</span><br><span class="line">-XX:MetaspaceSize ：</span><br><span class="line"></span><br><span class="line">Metaspace最大值</span><br><span class="line">-XX:MaxMetaspaceSize</span><br><span class="line">  </span><br></pre></td></tr></table></figure><hr><h5 id="三、线程栈内存配置常用参数"><a href="#三、线程栈内存配置常用参数" class="headerlink" title="三、线程栈内存配置常用参数"></a><strong>三、线程栈内存配置</strong>常用参数</h5><p>每个线程栈最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令<span class="number">1</span>：-Xss256k</span><br><span class="line"></span><br><span class="line">指令<span class="number">2</span>：-XX:ThreadStackSize=256k</span><br></pre></td></tr></table></figure><p>注意：</p><p>栈设置太大，会导致线程创建减少。</p><p>栈设置小，会导致深入不够，深度的递归会导致栈溢出。</p><p>建议栈深度设置在3000-5000</p><h5 id="四、配置垃圾收集器"><a href="#四、配置垃圾收集器" class="headerlink" title="四、配置垃圾收集器"></a><strong>四、配置垃圾收集器</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Serial垃圾收集器（新生代）</span><br><span class="line">开启：-XX:+UseSerialGC</span><br><span class="line">关闭：-XX:-UseSerialGC</span><br><span class="line"><span class="comment">//新生代使用Serial  老年代则使用SerialOld</span></span><br><span class="line"></span><br><span class="line">ParNew垃圾收集器（新生代）</span><br><span class="line">开启 -XX:+UseParNewGC</span><br><span class="line">关闭 -XX:-UseParNewGC</span><br><span class="line"><span class="comment">//新生代使用功能ParNew 老年代则使用功能CMS</span></span><br><span class="line"></span><br><span class="line">Parallel Scavenge收集器（新生代）</span><br><span class="line">开启 -XX:+UseParallelOldGC</span><br><span class="line">关闭 -XX:-UseParallelOldGC</span><br><span class="line"><span class="comment">//新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器</span></span><br><span class="line"></span><br><span class="line">ParallelOl垃圾收集器（老年代）</span><br><span class="line">开启 -XX:+UseParallelGC</span><br><span class="line">关闭 -XX:-UseParallelGC</span><br><span class="line"><span class="comment">//新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器</span></span><br><span class="line"></span><br><span class="line">CMS垃圾收集器（老年代）</span><br><span class="line">开启 -XX:+UseConcMarkSweepGC</span><br><span class="line">关闭 -XX:-UseConcMarkSweepGC</span><br><span class="line"></span><br><span class="line">G1垃圾收集器</span><br><span class="line">开启 -XX:+UseG1GC</span><br><span class="line">关闭 -XX:-UseG1GC</span><br></pre></td></tr></table></figure><hr><h5 id="五、GC策略配置"><a href="#五、GC策略配置" class="headerlink" title="五、GC策略配置"></a><strong>五、GC策略配置</strong></h5><p><strong>GC并行执行线程数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=<span class="number">16</span></span><br></pre></td></tr></table></figure><p><strong>新生代可容纳的最大对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PretenureSizeThreshold=<span class="number">1000000</span> <span class="comment">//大于此值的对象直接会分配到老年代，设置为0则没有限制。</span></span><br><span class="line">    <span class="comment">//避免在Eden区和Survivor区发生大量的内存复制，该参数只对Serial和ParNew收集器有效，Parallel Scavenge并不认识该参数</span></span><br></pre></td></tr></table></figure><p><strong>进入老年代的GC年龄</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">进入老年代最小的GC年龄</span><br><span class="line">-XX:InitialTenuringThreshol=<span class="number">7</span> <span class="comment">//年轻代对象转换为老年代对象最小年龄值，默认值7，对象在坚持过一次Minor GC之后，年龄就加1，每个对象在坚持过一次Minor GC之后，年龄就增加1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进入老年代最大的GC年龄</span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">15</span> <span class="comment">//年轻代对象转换为老年代对象最大年龄值，默认值15</span></span><br></pre></td></tr></table></figure><hr><h5 id="六、GC日志信息配置"><a href="#六、GC日志信息配置" class="headerlink" title="六、GC日志信息配置"></a><strong>六、GC日志信息配置</strong></h5><p><strong>配置GC文件路径</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xloggc:/data/gclog/gc.log<span class="comment">//固定路径名称生成</span></span><br><span class="line">-Xloggc:/home/GCEASY/gc-%t.log <span class="comment">//根据时间生成</span></span><br></pre></td></tr></table></figure><p><strong>滚动生成日志</strong></p><p>日志文件达到一定大小后，生成另一个文件。须配置Xloggc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+UseGCLogFileRotation</span><br><span class="line">关闭 -XX:-UseGCLogFileRotation</span><br><span class="line"></span><br><span class="line">-XX:NumberOfGCLogFiles=<span class="number">4</span>   <span class="comment">//滚动GC日志文件数，默认0，不滚动</span></span><br><span class="line">-XX:GCLogFileSize=100k  <span class="comment">//GC文件滚动大小，需配置UseGCLogFileRotation，设置为0表示仅通过jcmd命令触发</span></span><br></pre></td></tr></table></figure><p><strong>打印详细的GC日志</strong></p><p>打印GC的详细日志，并且在程序运行结束是会打印出JVM的内存占用情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+PrintGCDetails</span><br><span class="line">关闭 -XX:-PrintGCDetails</span><br></pre></td></tr></table></figure><p><strong>打印应用暂停时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+PrintGCApplicationStoppedTime</span><br><span class="line">关闭 -XX:-PrintGCApplicationStoppedTime</span><br></pre></td></tr></table></figure><p><strong>每次GC完成后，打印出JVM堆内存每个区域的使用情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+PrintHeapAtGC</span><br><span class="line">关闭 -XX:-PrintHeapAtGC</span><br></pre></td></tr></table></figure><p><strong>打印存活实例年龄信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+PrintTenuringDistribution</span><br><span class="line">关闭 -XX:-PrintTenuringDistribution</span><br></pre></td></tr></table></figure><hr><h5 id="七、条件触发配置"><a href="#七、条件触发配置" class="headerlink" title="七、条件触发配置"></a><strong>七、条件触发配置</strong></h5><p><strong>OutOfMemory异常时输出文件</strong></p><p>抛出内存溢出错误时导出堆信息到指定文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">关闭 -XX:-HeapDumpOnOutOfMemoryError</span><br><span class="line"><span class="comment">//可以通过jinfo -flag [+|-]HeapDumpOnOutOfMemoryError &lt;pid&gt; 或 jinfo -flag HeapDumpOnOutOfMemoryError=&lt;value&gt; &lt;pid&gt; 来动态开启或设置值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-XX:HeapDumpPath=/data/dump/jvm.dump<span class="comment">//设置文件路径</span></span><br><span class="line"><span class="comment">//当HeapDumpOnOutOfMemoryError开启的时候，dump文件的保存路径，默认为工作目录下的</span></span><br></pre></td></tr></table></figure><p><strong>在Full GC时生成dump文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpBeforeFullGC       <span class="comment">//实现在Full GC前dump</span></span><br><span class="line">-XX:+HeapDumpAfterFullGC        <span class="comment">//实现在Full GC后dump。</span></span><br><span class="line">-XX:HeapDumpPath=e:\dump        <span class="comment">//设置Dump保存的路径</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">&quot;-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=/data/dump/jvm.dump&quot;</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><p><strong>查看JVM所有参数</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsInitial</span><br></pre></td></tr></table></figure><hr><h5 id="九、常用启动参数"><a href="#九、常用启动参数" class="headerlink" title="九、常用启动参数"></a><strong>九、常用启动参数</strong></h5><p><strong>1、设置堆内大小</strong></p><p>设置堆内存大小，Xms 最小内存，Xmx最大内存，不设置默认为物理机内存的四分之一。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms2g   -Xmx2g`     </span><br></pre></td></tr></table></figure><p><strong>2、GC日志参数</strong></p><p>生成GC滚动日志记录 ，当需要对GC排查问题时候需要对此日志分析。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+UseGCLogFileRotation  -XX:+PrintHeapAtGC -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M    -Xloggc:/opt/ard-user-gc-%t.log </span><br><span class="line">-Xloggc:/opt/app/ard-user/ard-user-gc-%t.log   设置日志目录和日志名称</span><br><span class="line">-XX:+UseGCLogFileRotation           开启滚动生成日志</span><br><span class="line">-XX:NumberOfGCLogFiles=5            滚动GC日志文件数，默认0，不滚动</span><br><span class="line">-XX:GCLogFileSize=20M               GC文件滚动大小，需开启UseGCLogFileRotation</span><br><span class="line">-XX:+PrintGCDetails                 开启记录GC日志详细信息（包括GC类型、各个操作使用的时间）,并且在程序运行结束打印出JVM的内存占用情况</span><br><span class="line">-XX:+ PrintGCDateStamps             记录系统的GC时间           </span><br><span class="line">-XX:+PrintGCCause                   产生GC的原因(默认开启)</span><br></pre></td></tr></table></figure><p><strong>3、异常时记录内存日志</strong></p><p>抛出内存溢出错误时导出堆信息到指定文件，内存溢出时需要对此日志进行分析</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=/data/dump/jvm.dump</span><br><span class="line">HeapDumpOnOutOfMemoryError  异常后打印堆内存信息</span><br><span class="line">HeapDumpPath                生成的堆内存日志的路径</span><br></pre></td></tr></table></figure><hr><h5 id="十、各种场景的参数设置方式"><a href="#十、各种场景的参数设置方式" class="headerlink" title="十、各种场景的参数设置方式"></a><strong>十、各种场景的参数设置方式</strong></h5><p><strong>Idea</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-d78c1b323328416df15ae0d49f782edd_1440w.webp" alt="img"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-542d3d81b989240197ba520b9fa9ff29_1440w.webp" alt="img"></p><h2 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="几种常见MQ的对比："><a href="#几种常见MQ的对比：" class="headerlink" title="几种常见MQ的对比："></a>几种常见MQ的对比：</h4><table><thead><tr><th></th><th>RabbitMQ</th><th>ActiveMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高（主从架构）</td><td>一般</td><td>非常高（分布式架构）</td><td>非常高（分布式架构）</td></tr><tr><td>单机吞吐量</td><td>万级</td><td>差</td><td>十万级</td><td>十万级（非常高）</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr><tr><td>功能特性</td><td>基于erlang开发，开发语言较为小众扩展性差（难以定制化开发），所以并发能力很强，性能极其好，延时很低;管理界面较丰富</td><td></td><td>MQ功能比较完备，扩展性佳</td><td>吞吐量最高，消息可靠性一般，适合用于日志转储，只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广。</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><h4 id="看你项目用了-MQ，为什么用它？"><a href="#看你项目用了-MQ，为什么用它？" class="headerlink" title="看你项目用了 MQ，为什么用它？"></a>看你项目用了 MQ，为什么用它？</h4><p>通常来说，使用消息队列能为我们的系统带来下面三点好处：</p><ol><li><strong>通过异步处理提高系统性能（减少响应所需时间）</strong></li><li><strong>削峰&#x2F;限流</strong></li><li><strong>降低系统耦合性。</strong></li></ol><p>如果在面试的时候你被面试官问到这个问题的话，一般情况是你在你的简历上涉及到消息队列这方面的内容，这个时候推荐你结合你自己的项目来回答。</p><h5 id="MQ-的解耦举个具体的场景"><a href="#MQ-的解耦举个具体的场景" class="headerlink" title="MQ 的解耦举个具体的场景"></a>MQ 的解耦举个具体的场景</h5><p>使用消息队列还可以降低系统耦合性。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。还是直接上图吧：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1711439697997-251.png" alt="图片">解耦</p><p>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。</p><p><strong>消息队列使用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="RabbitMQ对应的架构"><a href="#RabbitMQ对应的架构" class="headerlink" title="RabbitMQ对应的架构"></a>RabbitMQ对应的架构</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711265631905-158.png" alt="img"></p><p>其中包含几个概念：</p><ul><li>**<code>publisher</code>**：生产者，也就是发送消息的一方</li><li>**<code>consumer</code>**：消费者，也就是消费消息的一方</li><li>**<code>queue</code>**：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li>**<code>exchange</code>**：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li>**<code>virtual host</code>**：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue</li></ul><h4 id="如何保障MQ消息的可靠性"><a href="#如何保障MQ消息的可靠性" class="headerlink" title="如何保障MQ消息的可靠性"></a>如何保障MQ消息的可靠性</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240324155728162.png" alt="image-20240324155728162"></p><p>消息从生产者到消费者的每一步都可能导致消息丢失：</p><ul><li>发送消息时丢失：<ul><li>生产者发送消息时连接MQ失败</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code></li><li>消息到达MQ后，处理消息的进程发生异常</li></ul></li><li>MQ导致消息丢失：<ul><li>消息到达MQ，保存到队列后，尚未消费就突然宕机</li></ul></li><li>消费者处理消息时：<ul><li>消息接收后尚未处理突然宕机</li><li>消息接收后处理过程中抛出异常</li></ul></li></ul><p>综上，我们要解决消息丢失问题，保证MQ的可靠性，就必须从3个方面入手：</p><ul><li>确保生产者一定把消息发送到MQ</li><li>确保MQ不会将消息弄丢</li><li>确保消费者一定要处理消息</li></ul><h5 id="生产者可靠性"><a href="#生产者可靠性" class="headerlink" title="生产者可靠性"></a>生产者可靠性</h5><ul><li><p>消息发送时的重试机制</p><p>当<code>RabbitTemplate</code>与MQ连接超时后，多次重试。当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率不过SpringAMQP提供的重试机制是<strong>阻塞式</strong>的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。</p><p>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。</p></li><li><p>生产者消息确认机制，包括<code>Publisher Confirm</code>和<code>Publisher Return</code>两种</p></li></ul><p>开启确认机制的情况下，当生产者发送消息给MQ后，MQ会根据消息处理的情况返回不同的<strong>回执</strong>。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711270660279-161.png" alt="img"></p><p>总结如下：</p><ul><li>当消息投递到MQ，但是路由失败时，通过<strong>Publisher Return</strong>返回异常信息，同时返回ack的确认信息，代表投递成功</li><li>临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功</li><li>持久消息投递到了MQ，并且入队完成持久化，返回ACK ，告知投递成功</li><li>其它情况都会返回NACK，告知投递失败</li></ul><p>其中<code>ack</code>和<code>nack</code>属于<strong>Publisher Confirm</strong>机制，<code>ack</code>是投递成功；<code>nack</code>是投递失败。而<code>return</code>则属于<strong>Publisher Return</strong>机制。 confirmcallback是保证发送到交换机了；returncallback是保证路由到队列了</p><h5 id="MQ可靠性"><a href="#MQ可靠性" class="headerlink" title="MQ可靠性"></a>MQ可靠性</h5><p>数据持久化</p><p><strong>交换机持久化</strong></p><p>在控制台的<code>Exchanges</code>页面，添加交换机时可以配置交换机的<code>Durability</code>参数：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711270763219-164.png" alt="img"></p><p>设置为<code>Durable</code>就是持久化模式，<code>Transient</code>就是临时模式。</p><p><strong>队列持久化</strong></p><p>在控制台的Queues页面，添加队列时，同样可以配置队列的<code>Durability</code>参数：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711270763219-165.png" alt="img"></p><p><strong>消息持久化</strong></p><p>在控制台发送消息的时候，可以添加很多参数，而消息的持久化是要配置一个<code>properties</code>：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711270763220-166.png" alt="img"></p><blockquote><p><strong>说明</strong>：在开启持久化机制以后，如果同时还开启了生产者确认，那么MQ会在消息持久化以后才发送ACK回执，进一步确保消息的可靠性。</p><p>不过出于性能考虑，为了减少IO次数，发送到MQ的消息并不是逐条持久化到数据库的，而是每隔一段时间批量持久化。一般间隔在100毫秒左右，这就会导致ACK有一定的延迟，因此建议生产者确认全部采用异步方式。</p></blockquote><p><strong>LazyQueue</strong></p><p>在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。但在某些特殊情况下，这会导致消息积压，比如：</p><ul><li>消费者宕机或出现网络故障</li><li>消息发送量激增，超过了消费者处理速度</li><li>消费者处理业务发生阻塞</li></ul><p>一旦出现消息堆积问题，RabbitMQ的内存占用就会越来越高，直到触发内存预警上限。此时RabbitMQ会将内存消息刷到磁盘上，这个行为成为<code>PageOut</code>. <code>PageOut</code>会耗费一段时间，并且会阻塞队列进程。因此在这个过程中RabbitMQ不会再处理新的消息，生产者的所有请求都会被阻塞。</p><p>为了解决这个问题，从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的模式，也就是惰性队列。惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul><h5 id="消费者可靠性"><a href="#消费者可靠性" class="headerlink" title="消费者可靠性"></a>消费者可靠性</h5><p><strong>消费者确认机制</strong></p><p>当消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态。回执有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ从队列中删除该消息</li><li>nack：消息处理失败，RabbitMQ需要再次投递消息</li><li>reject：消息处理失败（一般是格式问题）并拒绝该消息，RabbitMQ从队列中删除该消息</li></ul><p>SpringAMQP帮我们实现了消息确认。并允许我们通过配置文件设置ACK处理方式，有三种模式：</p><ul><li>**<code>none</code>**：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。非常不安全，不建议使用</li><li>**<code>manual</code>**：手动模式。需要自己在业务代码中调用api，发送<code>ack</code>或<code>reject</code>，存在业务入侵，但更灵活</li><li>**<code>auto</code>**：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回<code>ack</code>.  当业务出现异常时，根据异常判断返回不同结果：<ul><li>如果是<strong>业务异常</strong>，会自动返回<code>nack</code>；</li><li>如果是<strong>消息处理或校验异常</strong>，自动返回<code>reject</code>;</li></ul></li></ul><p><strong>失败重试机制</strong></p><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止。</p><p>极端情况就是消费者一直无法执行成功，那么消息requeue就会无限循环，导致mq的消息处理飙升，带来不必要的压力：</p><p>Spring又提供了消费者失败重试机制：在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。</p><ul><li>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</li><li>重试达到最大次数后，Spring会返回reject，消息会被丢弃</li></ul><p><strong>失败处理策略</strong></p><p>本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，显然不太合适了。</p><p>因此Spring允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由<code>MessageRecovery</code>接口来定义的，它有3个不同实现：</p><ul><li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接<code>reject</code>，丢弃消息。默认就是这种方式 </li><li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回<code>nack</code>，消息重新入队 </li><li><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机</li></ul><h4 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h4><p><strong>幂等</strong>在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。例如：</p><ul><li>根据id删除数据</li><li>查询数据</li><li>新增数据</li></ul><p>在实际业务场景中，由于意外经常会出现业务被重复执行的情况，例如：</p><ul><li>页面卡顿时频繁刷新导致表单重复提交</li><li>服务间调用的重试</li><li>MQ消息的重复投递</li></ul><p>我们必须想办法保证消息处理的幂等性。这里给出两种方案：</p><ul><li>唯一消息ID</li><li>业务状态判断</li></ul><h5 id="唯一消息ID"><a href="#唯一消息ID" class="headerlink" title="唯一消息ID"></a>唯一消息ID</h5><p>这个思路非常简单：</p><ol><li>每一条消息都生成一个唯一的id，与消息一起投递给消费者。</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ol><p>我们该如何给消息添加唯一ID呢？</p><p>其实很简单，SpringAMQP的MessageConverter自带了MessageID的功能，我们只要开启这个功能即可。</p><p>以Jackson的消息转换器为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jjmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jjmc.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jjmc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="业务判断"><a href="#业务判断" class="headerlink" title="业务判断"></a>业务判断</h5><p>业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样。</p><p>例如我们当前案例中，处理消息的业务逻辑是把订单状态从未支付修改为已支付。因此我们就可以在执行业务时判断订单状态是否是未支付，如果不是则证明订单已经被处理过，无需重复处理。</p><p>相比较而言，消息ID的方案需要改造原有的数据库，所以我更推荐使用业务判断的方案。</p><p>以支付修改订单的业务为例，我们需要修改<code>OrderServiceImpl</code>中的<code>markOrderPaySuccess</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">old</span> <span class="operator">=</span> getById(orderId);</span><br><span class="line">    <span class="comment">// 2.判断订单状态</span></span><br><span class="line">    <span class="keyword">if</span> (old == <span class="literal">null</span> || old.getStatus() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 订单不存在或者订单状态不是1，放弃处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.尝试更新订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    order.setId(orderId);</span><br><span class="line">    order.setStatus(<span class="number">2</span>);</span><br><span class="line">    order.setPayTime(LocalDateTime.now());</span><br><span class="line">    updateById(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码逻辑上符合了幂等判断的需求，但是由于判断和更新是两步动作，因此在极小概率下可能存在线程安全问题。</p><p>我们可以合并上述操作为这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// UPDATE `order` SET status = ? , pay_time = ? WHERE id = ? AND status = 1</span></span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(Order::getStatus, <span class="number">2</span>)</span><br><span class="line">            .set(Order::getPayTime, LocalDateTime.now())</span><br><span class="line">            .eq(Order::getId, orderId)</span><br><span class="line">            .eq(Order::getStatus, <span class="number">1</span>)</span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看，上述代码等同于这样的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `<span class="keyword">order</span>` <span class="keyword">SET</span> status <span class="operator">=</span> ? , pay_time <span class="operator">=</span> ? <span class="keyword">WHERE</span> id <span class="operator">=</span> ? <span class="keyword">AND</span> status <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们在where条件中除了判断id以外，还加上了status必须为1的条件。如果条件不符（说明订单已支付），则SQL匹配不到数据，根本不会执行。</p><h4 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h4><p>RabbitMQ中实现延迟消息也有两种方案</p><ul><li>死信交换机+TTL</li><li>延迟消息插件</li></ul><h5 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h5><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用<code>basic.reject</code>或 <code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>如果一个队列中的消息已经成为死信，并且这个队列通过**<code>dead-letter-exchange</code><strong>属性指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机就称为</strong>死信交换机**（Dead Letter Exchange）。而此时加入有队列与死信交换机绑定，则最终死信就会被投递到这个队列中。</p><p>死信交换机有什么作用呢？</p><ol><li>收集那些因处理失败而被拒绝的消息</li><li>收集那些因队列满了而被拒绝的消息</li><li>收集因TTL（有效期）到期的消息</li></ol><p>如图，有一组绑定的交换机（<code>ttl.fanout</code>）和队列（<code>ttl.queue</code>）。但是<code>ttl.queue</code>没有消费者监听，而是设定了死信交换机<code>hmall.direct</code>，而队列<code>direct.queue1</code>则与死信交换机绑定，RoutingKey是blue：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711271696593-173.png" alt="img"></p><p>假如我们现在发送一条消息到<code>ttl.fanout</code>，RoutingKey为blue，并设置消息的<strong>有效期</strong>为5000毫秒：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711271696593-174.png" alt="img"></p><p><strong>注意</strong>：尽管这里的<code>ttl.fanout</code>不需要RoutingKey，但是当消息变为死信并投递到死信交换机时，会沿用之前的RoutingKey，这样<code>hmall.direct</code>才能正确路由消息。</p><p>消息肯定会被投递到<code>ttl.queue</code>之后，由于没有消费者，因此消息无人消费。5秒之后，消息的有效期到期，成为死信：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711271696593-175.png" alt="img"></p><p>死信被再次投递到死信交换机<code>hmall.direct</code>，并沿用之前的RoutingKey，也就是<code>blue</code>：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711271696593-176.png" alt="img"></p><p>由于<code>direct.queue1</code>与<code>hmall.direct</code>绑定的key是blue，因此最终消息被成功路由到<code>direct.queue1</code>，如果此时有消费者与<code>direct.queue1</code>绑定， 也就能成功消费消息了。但此时已经是5秒钟以后了：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711271696593-177.png" alt="img"></p><p>也就是说，publisher发送了一条消息，但最终consumer在5秒后才收到消息。我们成功实现了<strong>延迟消息</strong>。</p><h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><p><strong>注意：</strong></p><p>RabbitMQ的消息过期是基于追溯方式来实现的，也就是说当一个消息的TTL到期以后不一定会被移除或投递到死信交换机，而是在消息恰好处于队首时才会被处理。</p><p>当队列中消息堆积很多的时候，过期消息可能不会被按时处理，因此你设置的TTL时间不一定准确。</p><h5 id="DelayExchange插件"><a href="#DelayExchange插件" class="headerlink" title="DelayExchange插件"></a>DelayExchange插件</h5><p>基于死信队列虽然可以实现延迟消息，但是太麻烦了。因此RabbitMQ社区提供了一个延迟消息插件来实现相同的效果。</p><p>发送消息时需要指定为延时消息<img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1711272227552-188.png" alt="img"></p><blockquote><p>延迟消息插件内部会维护一个本地数据库表，同时使用Elang Timers功能实现计时。如果消息的延迟时间设置较长，可能会导致堆积的延迟消息非常多，会带来较大的CPU开销，同时延迟消息的时间会存在误差。</p><p>因此，<strong>不建议设置延迟时间过长的延迟消息</strong>。</p></blockquote><h2 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h2><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>倒排索引中有两个非常重要的概念：</p><ul><li>文档（<code>Document</code>）：用来搜索的数据，其中的<font color = gold>每一条数据就是一个文档</font>。例如一个网页、一个商品信息</li><li>词条（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的<font color = gold>具备含义的词语就是词条</font>。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li></ul><p><strong>创建倒排索引</strong>是对正向索引的一种特殊处理和应用，流程如下：</p><ul><li>将每一个文档的数据利用<strong>分词算法</strong>根据语义拆分，得到一个个词条</li><li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li><li>因为词条唯一性，可以给词条创建<strong>正向</strong>索引</li></ul><p>此时形成的这张以词条为索引的表，就是倒排索引表，两者对比如下：</p><p><strong>正向索引</strong></p><table><thead><tr><th align="left"><strong>id（索引）</strong></th><th align="left"><strong>title</strong></th><th align="left"><strong>price</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">小米手机</td><td align="left">3499</td></tr><tr><td align="left">2</td><td align="left">华为手机</td><td align="left">4999</td></tr><tr><td align="left">3</td><td align="left">华为小米充电器</td><td align="left">49</td></tr><tr><td align="left">4</td><td align="left">小米手环</td><td align="left">49</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr></tbody></table><p><strong>倒排索引</strong></p><table><thead><tr><th align="left"><strong>词条（索引）</strong></th><th align="left"><strong>文档id</strong></th></tr></thead><tbody><tr><td align="left">小米</td><td align="left">1，3，4</td></tr><tr><td align="left">手机</td><td align="left">1，2</td></tr><tr><td align="left">华为</td><td align="left">2，3</td></tr><tr><td align="left">充电器</td><td align="left">3</td></tr><tr><td align="left">手环</td><td align="left">4</td></tr></tbody></table><h4 id="基于倒排索引的全文检索"><a href="#基于倒排索引的全文检索" class="headerlink" title="基于倒排索引的全文检索"></a>基于倒排索引的全文检索</h4><p>倒排索引的<strong>搜索流程</strong>如下（以搜索”华为手机”为例），如图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1713335587486-15.jpeg" alt="img"></p><p>流程描述：</p><p>1）用户输入条件<code>&quot;华为手机&quot;</code>进行搜索。</p><p>2）对用户输入条件<strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code>。</p><p>3）拿着词条在倒排索引中查找（<strong>由于词条有索引，查询效率很高</strong>），即可得到包含词条的文档id：<code>1、2、3</code>。</p><p>4）拿着文档<code>id</code>到正向索引中查找具体文档即可（由于<code>id</code>也有索引，查询效率也很高）。</p><p>虽然要<font color = gold>先查询倒排索引，再查询正向索引, 倒排索引可以理解为是专门为模糊查询、全文检索而建立的特殊索引，主要目的是快速找到符合文档的id</font>，但是无论是词条、还是文档id都建立了索引，查询速度非常快！无需全表扫描。</p><h4 id="ES相关：为什么不在ES中保存完整的数据，而是只保存部分数据再查数据库呢？"><a href="#ES相关：为什么不在ES中保存完整的数据，而是只保存部分数据再查数据库呢？" class="headerlink" title="ES相关：为什么不在ES中保存完整的数据，而是只保存部分数据再查数据库呢？"></a>ES相关：为什么不在ES中保存完整的数据，而是只保存部分数据再查数据库呢？</h4><p>ES适合的场景</p><ul><li>全文检索、模糊查询。ES本身作为一个搜索引擎，用来处理检索的任务再合适不过。你可以在线上项目中直接将内容写入ES以提供检索服务，也可以把以往的数据导入ES以处理特定的需求。</li><li>统计。ES的统计也是基于检索功能的，聚合功能使得统计结果处理起来非常方便。</li></ul><p>ES不适合保存完整数据，只适合保存搜索需要的字段：</p><ul><li><p><strong>ES从添加数据到搜索有1秒的延迟</strong>(需要将更新的文档从内存reflash到内核缓冲区才能读到),查询是近实时的,</p></li><li><p><strong>同时ES是不支持事务的</strong>，数据库但是因为它的事务功能特性,可以<strong>保证不会出现脏数据</strong>.而ES并不支持事务,所以不是很适合存储原始数据.</p></li><li><p><strong>mapping不可改，不能改index属性。</strong>Elasticsearch中以定义的mapping不能修改名字和属性，无法修改名字勉强能接受，但无法需要改属性，<font color = gold>在“文档”经常变化时不方便存储。</font></p><p>官方文档中介绍了几种修改mapping的方法。一个是新建一个字段，<strong>程序中所有地方修改名字</strong>，这对于<strong>复杂的项目容易出错</strong>，而且<strong>无法保留原来的数据</strong>；另一个是利用aliaa创建一个新的索引，但是所有<strong>数据需要重新导入</strong>，这需要很长时间，操作性不强。</p></li></ul><p>所以在工作中都是两个一起使用,一方面利用MySQL保证原始数据的安全性,另一方面利用ElasticSearch来进行全文搜索.</p><h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><h4 id="切换用户（su）"><a href="#切换用户（su）" class="headerlink" title="切换用户（su）"></a>切换用户（su）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su yao               //切换为用户<span class="string">&quot;yao&quot;</span>,输入后回车需要输入该用户的密码</span><br><span class="line"><span class="built_in">exit</span>                 //退出当前用户</span><br></pre></td></tr></table></figure><h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><h5 id="切换目录（cd）"><a href="#切换目录（cd）" class="headerlink" title="切换目录（cd）"></a>切换目录（cd）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /                 //切换到根目录</span><br><span class="line"><span class="built_in">cd</span> /bin              //切换到根目录下的bin目录</span><br><span class="line"><span class="built_in">cd</span> ../               //切换到上一级目录 或者使用命令：<span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> ~                 //切换到home目录</span><br><span class="line"><span class="built_in">cd</span> -                 //切换到上次访问的目录</span><br><span class="line"><span class="built_in">cd</span> xx(文件夹名)       //切换到本目录下的名为xx的文件目录，如果目录不存在报错</span><br><span class="line"><span class="built_in">cd</span> /xxx/xx/x         //可以输入完整的路径，直接切换到目标目录，输入过程中可以使用tab键快速补全</span><br></pre></td></tr></table></figure><h5 id="查看目录（ls）"><a href="#查看目录（ls）" class="headerlink" title="查看目录（ls）"></a>查看目录（ls）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span>                   //查看当前目录下的所有目录和文件</span><br><span class="line"><span class="built_in">ls</span> -a                //查看当前目录下的所有目录和文件（包括隐藏的文件）</span><br><span class="line"><span class="built_in">ls</span> -l                //列表查看当前目录下的所有目录和文件（列表查看，显示更多信息），与命令<span class="string">&quot;ll&quot;</span>效果一样</span><br><span class="line"><span class="built_in">ls</span> /bin              //查看指定目录下的所有目录和文件 </span><br></pre></td></tr></table></figure><h5 id="创建目录（mkdir）"><a href="#创建目录（mkdir）" class="headerlink" title="创建目录（mkdir）"></a>创建目录（mkdir）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> tools          //在当前目录下创建一个名为tools的目录</span><br><span class="line"><span class="built_in">mkdir</span> /bin/tools     //在指定目录下创建一个名为tools的目录</span><br></pre></td></tr></table></figure><h5 id="删除目录与文件（rm）"><a href="#删除目录与文件（rm）" class="headerlink" title="删除目录与文件（rm）"></a>删除目录与文件（rm）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> 文件名              //删除当前目录下的文件</span><br><span class="line"><span class="built_in">rm</span> -f 文件名           //删除当前目录的的文件（不询问）</span><br><span class="line"><span class="built_in">rm</span> -r 文件夹名         //递归删除当前目录下此名的目录</span><br><span class="line"><span class="built_in">rm</span> -rf 文件夹名        //递归删除当前目录下此名的目录（不询问）</span><br><span class="line"><span class="built_in">rm</span> -rf *              //将当前目录下的所有目录和文件全部删除</span><br><span class="line"><span class="built_in">rm</span> -rf /*             //将根目录下的所有文件全部删除【慎用！相当于格式化系统】</span><br></pre></td></tr></table></figure><h5 id="修改目录（mv）"><a href="#修改目录（mv）" class="headerlink" title="修改目录（mv）"></a>修改目录（mv）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> 当前目录名 新目录名        //修改目录名，同样适用与文件操作</span><br><span class="line"><span class="built_in">mv</span> /usr/tmp/tool /opt       //将/usr/tmp目录下的tool目录剪切到 /opt目录下面</span><br><span class="line"><span class="built_in">mv</span> -r /usr/tmp/tool /opt    //递归剪切目录中所有文件和文件夹</span><br></pre></td></tr></table></figure><h5 id="拷贝目录（cp）"><a href="#拷贝目录（cp）" class="headerlink" title="拷贝目录（cp）"></a>拷贝目录（cp）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/tmp/tool /opt       //将/usr/tmp目录下的tool目录复制到 /opt目录下面</span><br><span class="line"><span class="built_in">cp</span> -r /usr/tmp/tool /opt    //递归剪复制目录中所有文件和文件夹</span><br></pre></td></tr></table></figure><h5 id="搜索目录（find）"><a href="#搜索目录（find）" class="headerlink" title="搜索目录（find）"></a>搜索目录（find）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /bin -name <span class="string">&#x27;a*&#x27;</span>        //查找/bin目录下的所有以a开头的文件或者目录</span><br></pre></td></tr></table></figure><h5 id="查看当前目录（pwd）"><a href="#查看当前目录（pwd）" class="headerlink" title="查看当前目录（pwd）"></a>查看当前目录（pwd）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span>                         //显示当前位置路径</span><br></pre></td></tr></table></figure><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><h5 id="新增文件（touch）"><a href="#新增文件（touch）" class="headerlink" title="新增文件（touch）"></a>新增文件（touch）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span>  a.txt         //在当前目录下创建名为a的txt文件（文件不存在），如果文件存在，将文件时间属性修改为当前系统时间</span><br></pre></td></tr></table></figure><h5 id="删除文件（rm）"><a href="#删除文件（rm）" class="headerlink" title="删除文件（rm）"></a>删除文件（rm）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> 文件名              //删除当前目录下的文件</span><br><span class="line"><span class="built_in">rm</span> -f 文件名           //删除当前目录的的文件（不询问）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="编辑文件（vi、vim"><a href="#编辑文件（vi、vim" class="headerlink" title="编辑文件（vi、vim)"></a>编辑文件（vi、vim)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vi 文件名              //打开需要编辑的文件</span><br><span class="line">--进入后，操作界面有三种模式：命令模式（<span class="built_in">command</span> mode）、插入模式（Insert mode）和底行模式（last line mode）</span><br><span class="line">命令模式</span><br><span class="line">-刚进入文件就是命令模式，通过方向键控制光标位置，</span><br><span class="line">-使用命令<span class="string">&quot;dd&quot;</span>删除当前整行</span><br><span class="line">-使用命令<span class="string">&quot;/字段&quot;</span>进行查找</span><br><span class="line">-按<span class="string">&quot;i&quot;</span>在光标所在字符前开始插入</span><br><span class="line">-按<span class="string">&quot;a&quot;</span>在光标所在字符后开始插入</span><br><span class="line">-按<span class="string">&quot;o&quot;</span>在光标所在行的下面另起一新行插入</span><br><span class="line">-按<span class="string">&quot;：&quot;</span>进入底行模式</span><br><span class="line">插入模式</span><br><span class="line">-此时可以对文件内容进行编辑，左下角会显示 <span class="string">&quot;-- 插入 --&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">-按&quot;</span>ESC<span class="string">&quot;进入底行模式</span></span><br><span class="line"><span class="string">底行模式</span></span><br><span class="line"><span class="string">-退出编辑：      :q</span></span><br><span class="line"><span class="string">-强制退出：      :q!</span></span><br><span class="line"><span class="string">-保存并退出：    :wq</span></span><br><span class="line"><span class="string">## 操作步骤示例 ##</span></span><br><span class="line"><span class="string">1.保存文件：按&quot;</span>ESC<span class="string">&quot; -&gt; 输入&quot;</span>:<span class="string">&quot; -&gt; 输入&quot;</span>wq<span class="string">&quot;,回车     //保存并退出编辑</span></span><br><span class="line"><span class="string">2.取消操作：按&quot;</span>ESC<span class="string">&quot; -&gt; 输入&quot;</span>:<span class="string">&quot; -&gt; 输入&quot;</span>q!<span class="string">&quot;,回车     //撤销本次修改并退出编辑</span></span><br><span class="line"><span class="string">## 补充 ##</span></span><br><span class="line"><span class="string">vim +10 filename.txt                   //打开文件并跳到第10行</span></span><br><span class="line"><span class="string">vim -R /etc/passwd                     //以只读模式打开文件</span></span><br></pre></td></tr></table></figure><h5 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> a.txt          //查看文件最后一屏内容</span><br><span class="line">less a.txt         //PgUp向上翻页，PgDn向下翻页，<span class="string">&quot;q&quot;</span>退出查看</span><br><span class="line">more a.txt         //显示百分比，回车查看下一行，空格查看下一页，<span class="string">&quot;q&quot;</span>退出查看</span><br><span class="line"><span class="built_in">tail</span> -100 a.txt    //查看文件的后100行，<span class="string">&quot;Ctrl+C&quot;</span>退出查看</span><br></pre></td></tr></table></figure><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><h5 id="权限说明"><a href="#权限说明" class="headerlink" title="权限说明"></a>权限说明</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文件权限简介：<span class="string">&#x27;r&#x27;</span> 代表可读（4），<span class="string">&#x27;w&#x27;</span> 代表可写（2），<span class="string">&#x27;x&#x27;</span> 代表执行权限（1），括号内代表<span class="string">&quot;8421法&quot;</span></span><br><span class="line"><span class="comment">##文件权限信息示例：-rwxrw-r--</span></span><br><span class="line">-第一位：<span class="string">&#x27;-&#x27;</span>就代表是文件，<span class="string">&#x27;d&#x27;</span>代表是文件夹</span><br><span class="line">-第一组三位：拥有者的权限</span><br><span class="line">-第二组三位：拥有者所在的组，组员的权限</span><br><span class="line">-第三组三位：代表的是其他用户的权限</span><br></pre></td></tr></table></figure><h5 id="文件权限-1"><a href="#文件权限-1" class="headerlink" title="文件权限"></a>文件权限</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">普通授权    <span class="built_in">chmod</span> +x a.txt    </span><br><span class="line">8421法     <span class="built_in">chmod</span> 777 a.txt     //1+2+4=7，<span class="string">&quot;7&quot;</span>说明授予所有权限</span><br></pre></td></tr></table></figure><h4 id="打包与解压"><a href="#打包与解压" class="headerlink" title="打包与解压"></a>打包与解压</h4><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.zip、.rar        //windows系统中压缩文件的扩展名</span><br><span class="line">.tar              //Linux中打包文件的扩展名</span><br><span class="line">.gz               //Linux中压缩文件的扩展名</span><br><span class="line">.tar.gz           //Linux中打包并压缩文件的扩展名</span><br></pre></td></tr></table></figure><h5 id="打包文件"><a href="#打包文件" class="headerlink" title="打包文件"></a>打包文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf 打包压缩后的文件名 要打包的文件</span><br><span class="line">参数说明：z：调用gzip压缩命令进行压缩; c：打包文件; v：显示运行过程; f：指定文件名;</span><br><span class="line">示例：</span><br><span class="line">tar -zcvf a.tar file1 file2,...      //多个文件压缩打包</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf a.tar                      //解包至当前目录</span><br><span class="line">tar -zxvf a.tar -C /usr------        //指定解压的位置</span><br><span class="line">unzip test.zip             //解压*.zip文件 </span><br><span class="line">unzip -l test.zip          //查看*.zip文件的内容 </span><br><span class="line">z ：表示 tar 包是被 gzip 压缩过的 (后缀是.tar.gz)，所以解压时需要用 gunzip 解压 (.tar不需要)</span><br><span class="line">x ：表示 从 tar 包中把文件提取出来</span><br><span class="line">v ：表示 显示打包过程详细信息</span><br><span class="line">f ：指定被处理的文件是什么</span><br></pre></td></tr></table></figure><h4 id="Linux查看内存情况"><a href="#Linux查看内存情况" class="headerlink" title="Linux查看内存情况"></a>Linux查看内存情况</h4><h5 id="ps指令"><a href="#ps指令" class="headerlink" title="ps指令"></a>ps指令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@web3_u ~]<span class="comment"># ps -e -o &#x27;pid,comm,args,pcpu,rsz,vsz,stime,user&#x27; | sort -k5nr</span></span><br><span class="line">23946 php-cgi         /usr/local/php/bin/php-cgi   0.0 129540 440000 Oct06 nobody</span><br><span class="line">24418 php-cgi         /usr/local/php/bin/php-cgi   0.0 129336 437684 Oct06 nobody</span><br><span class="line">18973 php-cgi         /usr/local/php/bin/php-cgi   0.0 129268 440176 Oct06 nobody</span><br><span class="line">17219 php-cgi         /usr/local/php/bin/php-cgi   0.0 126588 439840 Oct06 nobody</span><br><span class="line"> 6996 php-cgi         /usr/local/php/bin/php-cgi   0.0 125056 438104 Oct09 nobody</span><br><span class="line">23850 php-cgi         /usr/local/php/bin/php-cgi   0.0 122984 440036 Oct09 nobody</span><br></pre></td></tr></table></figure><ul><li>-e 显示所有进程</li><li>-o 定制显示信息</li><li>pid 进程ID</li><li>comm 进程名</li><li>args 启动命令</li><li>pcpu 占用CPU 百分比</li><li>rsz 占用物理内存大小</li><li>vsz 占用虚拟内存大小</li><li>stime 进程启动时间</li><li>user 启动用户</li></ul><p><strong>查看进程按照内存排序</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e -o <span class="string">&#x27;pid,comm,args,pcpu,rsz,vsz,stime,user,uid&#x27;</span> | <span class="built_in">sort</span> -rsz</span><br></pre></td></tr></table></figure><h5 id="top指令"><a href="#top指令" class="headerlink" title="top指令"></a>top指令</h5><p>top命令默认是以CPU排序输出的，按字母「M」，可以按内存占用大小进行排序显示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    <span class="selector-tag">TIME</span>+  COMMAND</span><br><span class="line"><span class="number">23946</span> nobody    <span class="number">20</span>   <span class="number">0</span>  <span class="number">429</span>m <span class="number">126</span>m <span class="number">107</span>m S  <span class="number">0.0</span>  <span class="number">2.2</span>   <span class="number">1</span>:<span class="number">15.01</span> php-cgi</span><br><span class="line"><span class="number">24418</span> nobody    <span class="number">20</span>   <span class="number">0</span>  <span class="number">427</span>m <span class="number">126</span>m <span class="number">109</span>m S  <span class="number">0.0</span>  <span class="number">2.2</span>   <span class="number">1</span>:<span class="number">19.56</span> php-cgi</span><br><span class="line"><span class="number">18973</span> nobody    <span class="number">20</span>   <span class="number">0</span>  <span class="number">429</span>m <span class="number">126</span>m <span class="number">107</span>m S  <span class="number">0.0</span>  <span class="number">2.2</span>   <span class="number">1</span>:<span class="number">20.18</span> php-cgi</span><br><span class="line"><span class="number">17219</span> nobody    <span class="number">20</span>   <span class="number">0</span>  <span class="number">429</span>m <span class="number">123</span>m <span class="number">104</span>m S  <span class="number">0.0</span>  <span class="number">2.1</span>   <span class="number">1</span>:<span class="number">23.60</span> php-cgi</span><br><span class="line"><span class="number">6996</span> nobody    <span class="number">20</span>   <span class="number">0</span>  <span class="number">427</span>m <span class="number">122</span>m <span class="number">105</span>m S  <span class="number">0.0</span>  <span class="number">2.1</span>   <span class="number">1</span>:<span class="number">05.27</span> php-cgi</span><br><span class="line"><span class="number">23850</span> nobody    <span class="number">20</span>   <span class="number">0</span>  <span class="number">429</span>m <span class="number">120</span>m <span class="number">101</span>m S  <span class="number">0.0</span>  <span class="number">2.1</span>   <span class="number">1</span>:<span class="number">02.43</span> php-cgi</span><br></pre></td></tr></table></figure><p>输出参数介绍</p><ul><li>PID：进程的ID</li><li>USER：进程所有者</li><li>VIRT：进程占用的虚拟内存</li><li>RES：进程占用的物理内存</li><li>SHR：进程使用的共享内存</li><li>S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数</li><li>%CPU：进程占用CPU的使用率</li><li>%MEM：进程使用的物理内存和总内存的百分比</li><li>TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。</li></ul><h4 id="linux服务器的负载如何查看"><a href="#linux服务器的负载如何查看" class="headerlink" title="linux服务器的负载如何查看"></a>linux服务器的负载如何查看</h4><p><strong>top命令查看linux负载</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-f7c19d6321dd5cbff27584e8ebe5fd70_1440w.webp" alt="img"></p><p><strong>第一行解释：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">top - 11:03:08 up 1 days, 04:01, 3 user, load average: 0.05, 0.05, 0.01</span><br><span class="line">11:03:08：系统当前时间</span><br><span class="line">up 1 days, 04:01：系统开机到现在经过了1天</span><br><span class="line">3 users：当前3用户在线</span><br><span class="line">load average:0.05, 0.05, 0.01：系统1分钟、5分钟、15分钟的CPU负载信息.</span><br><span class="line">备注：load average后面三个数值的含义是最近1分钟、最近5分钟、最近15分钟系统的负载值。这个值的意义是，单位时间段内CPU活动进程数。如果你的机器为单核，那么只要这几个值均&lt;1，代表系统就没有负载压力，如果你的机器为N核，那么必须是这几个值均＜N才可认为系统没有负载压力。</span><br></pre></td></tr></table></figure><p><strong>第二行解释：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tasks: 176 total, 1 running, 175 sleeping, 0 stopped, 0 zombie</span><br><span class="line">176 total：当前有176个任务</span><br><span class="line">1 running：1个任务正在运行</span><br><span class="line">175 sleeping：175个进程处于睡眠状态</span><br><span class="line">0 stopped：停止的进程数</span><br><span class="line">0 zombie：僵死的进程数</span><br></pre></td></tr></table></figure><p><strong>第三行解释：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%Cpu(s): 0.1 us, 0.2 sy, 0.2 ni, 99.4 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</span><br><span class="line">0.1%us：用户态进程占用CPU时间百分比</span><br><span class="line">0.2%sy：内核占用CPU时间百分比</span><br><span class="line">0.2%ni：renice值为负的任务的用户态进程的CPU时间百分比。nice是优先级的意思</span><br><span class="line">99.4%id：空闲CPU时间百分比</span><br><span class="line">0.0%wa：等待I/O的CPU时间百分比</span><br><span class="line">0.0%hi：CPU硬中断时间百分比</span><br><span class="line">0.0%si：CPU软中断时间百分比</span><br></pre></td></tr></table></figure><p><strong>第四行解释：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KiB Mem : 3882172 total, 1079980 free, 1684652 used, 1117540 buff/cache</span><br><span class="line">3882172 k total：物理内存总数</span><br><span class="line">1684652k used： 使用的物理内存</span><br><span class="line">1079980k free：空闲的物理内存</span><br><span class="line">1117540k cached：用作缓存的内存</span><br></pre></td></tr></table></figure><p><strong>第五行解释：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KiB Swap: 0 total, 0 free, 0 used. 1871412 avail Mem</span><br><span class="line">0k total：交换空间的总量</span><br><span class="line">0k used： 使用的交换空间</span><br><span class="line">0k free：空闲的交换空间</span><br><span class="line">1871412k cached：缓存的交换空间</span><br></pre></td></tr></table></figure><p><strong>最后一行：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND</span><br><span class="line">PID：进程ID</span><br><span class="line">USER：进程的所有者</span><br><span class="line">PR：进程的优先级</span><br><span class="line">NI：nice值</span><br><span class="line">VIRT：占用的虚拟内存</span><br><span class="line">RES：占用的物理内存</span><br><span class="line">SHR：使用的共享内存</span><br><span class="line">S：进行状态 S：休眠 R运行 Z僵尸进程 N nice值为负</span><br><span class="line">%CPU：占用的CPU</span><br><span class="line">%MEM：占用内存</span><br><span class="line">TIME+： 占用CPU的时间的累加值</span><br><span class="line">COMMAND：启动命令</span><br></pre></td></tr></table></figure><h4 id="Linux如何查看所有的Java进程"><a href="#Linux如何查看所有的Java进程" class="headerlink" title="Linux如何查看所有的Java进程"></a>Linux如何查看所有的Java进程</h4><p><code>ps</code>命令是用于查看当前系统进程状态的工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java</span><br></pre></td></tr></table></figure><p><strong>使用<code>pgrep</code>命令</strong>：<code>pgrep</code>命令是一个可以根据名称查找进程的工具。如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgrep -a java</span><br></pre></td></tr></table></figure><p><code>-a</code>选项会显示每个匹配进程的完整命令行，而不仅仅是PID。这样，你可以看到每个Java进程的详细信息。</p><p>统计一个文件中重复行和重复次数</p><p><strong>使用cat+uniq命令</strong></p><ul><li><h3 id="其实就是统计每行重复多少次"><a href="#其实就是统计每行重复多少次" class="headerlink" title="其实就是统计每行重复多少次"></a>其实就是统计每行重复多少次</h3><ul><li>格式：uniq [options] [file1[files2]]</li></ul></li><li><h3 id="uniq-c-file"><a href="#uniq-c-file" class="headerlink" title="uniq  -c  file"></a>uniq  -c  file</h3><ul><li>file中的重复行输出一次，并在每行前显示重复次数</li></ul></li><li><h3 id="uniq-d-file"><a href="#uniq-d-file" class="headerlink" title="uniq  -d  file"></a>uniq  -d  file</h3><ul><li>file中的重复行输出一次，但不输出唯一的行</li></ul></li><li><h3 id="uniq-u-file"><a href="#uniq-u-file" class="headerlink" title="uniq  -u  file"></a>uniq  -u  file</h3><ul><li>只输出file中的唯一行</li></ul></li><li><h3 id="uniq-file1-file2"><a href="#uniq-file1-file2" class="headerlink" title="uniq  file1  file2"></a>uniq  file1  file2</h3><ul><li>把file1中的重复的相邻行删除，并把每行的一个拷贝送到file2</li></ul></li><li><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> a.txt</span><br><span class="line">1,2,3,3</span><br><span class="line">4,4,4,1</span><br><span class="line">4,4,4,1</span><br><span class="line">2,4,4,1</span><br><span class="line"><span class="built_in">cat</span> a.txt|<span class="built_in">uniq</span> -c</span><br><span class="line">1 1,2,3,3</span><br><span class="line">2 4,4,4,1</span><br><span class="line">1 2,4,4,1</span><br><span class="line">$ <span class="built_in">uniq</span> -c a.txt</span><br><span class="line">1 1,2,3,3</span><br><span class="line">2 4,4,4,1</span><br><span class="line">1 2,4,4,1</span><br></pre></td></tr></table></figure><h4 id="linux使用grep获取两个文件相同的行或不同的行"><a href="#linux使用grep获取两个文件相同的行或不同的行" class="headerlink" title="linux使用grep获取两个文件相同的行或不同的行"></a>linux使用grep获取两个文件相同的行或不同的行</h4><p>**grep进行文件内容匹配工作是用到的参数主要有两个，分别是</p><ol><li><p>取出两个文件中的相同部分内容“-wf”参数.</p></li><li><p>取出两个文件中的不同部分内容“-wvf”参数**</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat aaa.txt</span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br><span class="line">ddd</span><br><span class="line">fff</span><br><span class="line">asda</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat bbb.txt</span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">233</span><br><span class="line">ccc</span><br><span class="line">ddd</span><br><span class="line">fff</span><br><span class="line">asda</span><br></pre></td></tr></table></figure><p>取出两文件相同行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grep -wf aaa.txt bbb.txt</span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">ddd</span><br><span class="line">fff</span><br><span class="line">asda</span><br></pre></td></tr></table></figure><p>取出两个文件中不同的行(bbb.txt文件中存在而aaa.txt文件中没有的内容)</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -wvf aaa.txt bbb.txt</span><br><span class="line">233</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h4 id="LRUcache的内部数据结构"><a href="#LRUcache的内部数据结构" class="headerlink" title="LRUcache的内部数据结构"></a>LRUcache的内部数据结构</h4><p>实现LRU Cache的方法和思路很多，但是要保持高效实现O(1)的put和get，那么使用双向链表和哈希表的搭配是最高效和经典的。</p><p>使用双向链表是因为双向链表可以实现任意位置O(1)的插入和删除，双向链表用于记录数据对象的访问顺序，每当一个数据对象被访问时，就将其移动到链表的头部。这样，链表头部的数据对象就是最近被访问的数据，而链表尾部的数据对象则是最久未被访问的数据。同时，使用哈希表能够以 O(1) 的时间复杂度进行数据对象的查找。</p><p>当缓存空间达到上限时，需要淘汰最久未被访问的数据对象。这时只需从链表尾部删除相应的数据对象，并在哈希表中删除对应的索引即可。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h4 id="ACM模式输入输出"><a href="#ACM模式输入输出" class="headerlink" title="ACM模式输入输出"></a>ACM模式输入输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种 数字中间用逗号隔开，用的String后转成int类型（不限制输入数组的长度）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入几个数并用逗号隔开：&quot;</span>);</span><br><span class="line">  <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">  <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine().toString();</span><br><span class="line">  String[] arr  = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;b.length;j++) &#123;</span><br><span class="line">   b[j] = Integer.parseInt(arr[j]);</span><br><span class="line">   System.out.println(b[j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//数字中间用空格隔开 输入时注意要用nextLine()方法，用next方法只能接收到数组第一位</span></span><br><span class="line"> <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine().toString();</span><br><span class="line">        String[] arr=str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span>[] b=<span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)&#123;</span><br><span class="line">            b[i]=Integer.parseInt(arr[i]);</span><br><span class="line">            System.out.println(b[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用层序遍历数组构建树</span></span><br><span class="line"><span class="keyword">private</span> TreeNode&lt;T&gt; <span class="title function_">getTree</span><span class="params">(T[] value)</span>&#123;</span><br><span class="line">        TreeNode&lt;T&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(value[<span class="number">0</span>]);</span><br><span class="line">        TreeNode&lt;T&gt; q = p;</span><br><span class="line">        Queue&lt;TreeNode&lt;T&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&lt;T&gt;&gt;();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;value.length)&#123;</span><br><span class="line">                p.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(value[<span class="number">2</span>*i+<span class="number">1</span>]);</span><br><span class="line">                queue.add(p.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span>*i+<span class="number">2</span>&lt;value.length)&#123;</span><br><span class="line">                 p.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(value[<span class="number">2</span>*i+<span class="number">2</span>]);</span><br><span class="line">                queue.add(p.right);</span><br><span class="line">            &#125;</span><br><span class="line">            p = queue.poll();</span><br><span class="line">            i+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>常用排序算法</p><p><a href="https://blog.csdn.net/wlddhj/article/details/131482951?ops_request_misc=%7B%22request_id%22:%22170886399616800182765281%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170886399616800182765281&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-6-131482951-null-null.142%5Ev99%5Epc_search_result_base8&utm_term=Java%E5%AE%9E%E7%8E%B0%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F&spm=1018.2226.3001.4187">详解Java常用排序算法（10种，含演示动画）_java排序算法-CSDN博客</a></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240225203119687.png" alt="image-20240225203119687"></p><h4 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1. 冒泡排序（Bubble Sort）"></a>1. 冒泡排序（Bubble Sort）</h4><p>冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就交换位置。这个过程持续对数列的末尾进行，直到整个数列都排序完成。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/2b36116b631b4dd8b2ee2dc4632b2b15.gif" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换arr[j+1]和arr[j]</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2. 选择排序（Selection Sort）"></a>2. 选择排序（Selection Sort）</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/5439855d3b4b4326aaf1da321b98a168.gif" alt="img"></p><p>选择排序是一种简单的排序算法，它的基本思想是每次从待排序的元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的元素排完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Selection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换arr[i]和arr[minIndex]</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3. 插入排序（Insertion Sort）"></a>3. 插入排序（Insertion Sort）</h4><p>插入排序是一种简单的排序算法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/df34d7e7050443bc8deb405c3d135a96.gif" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="comment">// 外部循环从第二个元素开始，</span></span><br><span class="line">        <span class="comment">// 因为我们将第一个元素视为已排序部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 将当前值key和前面的值进行比较，</span></span><br><span class="line">            <span class="comment">// 如果前面的值&gt;key 则将值往后移1位</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在不小当前值key的位置，插入当前值key</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>内部循环中，我们将要插入的元素与已排序部分的元素进行比较，如果要插入的元素小于已排序部分的元素，则将已排序部分的元素向右移动一位，以便为要插入的元素腾出空间。在内部循环结束后，我们将要插入的元素插入到正确的位置。在每次外部循环迭代后，我们可以确保前i个元素已经被排序。</p><h4 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4. 希尔排序（Shell Sort）"></a>4. 希尔排序（Shell Sort）</h4><p>希尔排序是一种改进的插入排序算法，它的基本思想是将待排序的数组按照一定的间隔进行分组，对每组使用插入排序算法进行排序，然后缩小间隔，再对分组进行排序，直到间隔为1为止。</p><p>逐渐减小间隔大小的方法有助于提高排序过程的效率，可以减少比较和交换的次数。这是希尔排序算法的一个关键特点。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/7ab8dcaf458d4545b4f122ea1c54fae5.gif" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">       <span class="comment">// 初始化间隔（gap）的值，它决定了每次迭代中子数组的大小</span></span><br><span class="line">       <span class="comment">// 从数组长度的一半开始作为初始间隔值，gap就是分割的子数组数量</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="comment">// 循环从间隔值开始，遍历数组直到数组的末尾；代表循环所有的子数组</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; n; i++) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">               <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">               <span class="comment">// 将当前元素 arr[j] 的值替换为前一个元素 arr[j - gap] 的值。</span></span><br><span class="line">               <span class="comment">// 通过这个操作，将较大的元素向后移动，为当前元素腾出位置</span></span><br><span class="line">               <span class="keyword">while</span> (j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp) &#123;</span><br><span class="line">                   arr[j] = arr[j - gap];</span><br><span class="line">                   j -= gap;</span><br><span class="line">               &#125;</span><br><span class="line">               arr[j] = temp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中， shellSort 函数接受一个整数数组作为输入，并使用希尔排序算法对其进行排序。外部循环使用一个间隔变量 gap ，初始值为数组长度的一半，每次循环将 gap 除以2，直到 gap 为1。内部循环从第 gap 个元素开始，将要插入的元素与已排序部分的元素进行比较，如果要插入的元素小于已排序部分的元素，则将已排序部分的元素向右移动 gap 个位置，以便为要插入的元素腾出空间。在内部循环结束后，我们将要插入的元素插入到正确的位置。在每次外部循环迭代后，我们可以确保数组的前 gap 个元素已经被排序。</p><h4 id="5-快速排序（Quick-Sort）"><a href="#5-快速排序（Quick-Sort）" class="headerlink" title="5. 快速排序（Quick Sort）"></a>5. 快速排序（Quick Sort）</h4><p>快速排序是一种分治思想的排序算法，它的基本思想是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后再分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/cbc80136b7ec4c1d895984962c75e53f.gif" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">      <span class="comment">// 取最后一个元素作为中心元素</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> array[high];</span><br><span class="line">      <span class="comment">// 定义指向比中心元素大的指针，首先指向第一个元素</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">pointer</span> <span class="operator">=</span> low;</span><br><span class="line">      <span class="comment">// 遍历数组中的所有元素，将比中心元素大的放在右边，比中心元素小的放在左边</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; i &lt; high; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (array[i] &lt;= pivot) &#123;</span><br><span class="line">              <span class="comment">// 将比中心元素小的元素和指针指向的元素交换位置</span></span><br><span class="line">              <span class="comment">// 如果第一个元素比中心元素小，这里就是自己和自己交换位置，指针和索引都向下一位移动</span></span><br><span class="line">              <span class="comment">// 如果元素比中心元素大，索引向下移动，指针指向这个较大的元素，直到找到比中心元素小的元素，并交换位置，指针向下移动</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">              array[i] = array[pointer];</span><br><span class="line">              array[pointer] = temp;</span><br><span class="line">              pointer++;</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(Arrays.toString(array));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将中心元素和指针指向的元素交换位置</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[pointer];</span><br><span class="line">      array[pointer] = array[high];</span><br><span class="line">      array[high] = temp;</span><br><span class="line">      <span class="keyword">return</span> pointer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">          <span class="comment">// 获取划分子数组的位置</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> partition(array, low, high);</span><br><span class="line">          <span class="comment">// 左子数组递归调用</span></span><br><span class="line">          quickSort(array, low, position -<span class="number">1</span>);</span><br><span class="line">          <span class="comment">// 右子数组递归调用</span></span><br><span class="line">          quickSort(array, position + <span class="number">1</span>, high);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中， quickSort 函数接受一个整数数组、一个低索引和一个高索引作为输入，并使用快速排序算法对指定范围内的数组元素进行排序。该函数使用递归将数组分成两个子数组，然后对它们进行排序，并最后将它们合并成一个有序数组。 partition 函数用于将数组分成两个子数组。它选择数组中的最后一个元素作为基准元素，然后将小于基准元素的元素放在左边，将大于基准元素的元素放在右边，并返回基准元素的索引。 swap 函数用于交换数组中的两个元素。</p><p>快速排序的时间复杂度为O(nlogn)，它的性能比冒泡排序和插入排序要好得多，特别是在大型列表上。</p><h4 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/e9778f2e042746818efc6450bfa57e9c.gif" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;<span class="comment">//直到left = right时，即只有一个节点时</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            mergeSort(arr, left, mid);</span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">            merge(arr, left, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 子数组 L 的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> mid - left + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 右子数组 R 的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> right - mid;</span><br><span class="line">        <span class="comment">// 创建两个临时数组 L 和 R ，分别用来存储左子数组和右子数组的元素</span></span><br><span class="line">        <span class="type">int</span>[] L = <span class="keyword">new</span> <span class="title class_">int</span>[n1];</span><br><span class="line">        <span class="type">int</span>[] R = <span class="keyword">new</span> <span class="title class_">int</span>[n2];</span><br><span class="line">        <span class="comment">// 使用 for 循环将原始数组 arr 中的元素复制到临时数组 L 和 R 中，分别从 left 和 mid + 1 开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">            L[i] = arr[left + i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n2; j++) &#123;</span><br><span class="line">            R[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化三个变量 i、j和k，分别指向数组 L 、R 和原始数组 arr 的起始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line">        <span class="comment">// 使用 while 循环，比较 L 和 R 的元素，并将较小的元素放回原始数组 arr 中</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;</span><br><span class="line">                arr[k] = L[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[k] = R[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 L 或 R 中的元素用完时，将剩余的元素依次放回原始数组 arr 中</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">            arr[k] = L[i];</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">            arr[k] = R[j];</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// merge 方法执行完毕后，两个子数组范围内的元素已经按照从小到大的顺序合并到了原始数组 arr 中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的代码中， mergeSort 函数接受一个整数数组、一个左索引和一个右索引作为输入，并使用归并排序算法对指定范围内的数组元素进行排序。该函数使用递归将数组分成两个子数组，然后对它们进行排序，并最后将它们合并成一个有序数组。 merge 函数用于将两个有序数组合并成一个有序数组。它创建两个临时数组 L 和 R ，将左子数组的元素存储在 L 中，将右子数组的元素存储在 R 中，然后将它们合并成一个有序数组并存储在原始数组中。</p><p>归并排序的时间复杂度为O(nlogn)，而且是稳定的，它的性能比冒泡排序和插入排序要好得多，特别是在大型列表上。</p><h4 id="手写堆排序"><a href="#手写堆排序" class="headerlink" title="手写堆排序"></a>手写堆排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.SortedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">heapSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] target = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">heapSort</span> <span class="variable">heap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">heapSort</span>();</span><br><span class="line">        <span class="type">int</span>[] nums = heap.sort(target);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="comment">// 复制原数组，避免改变原始数据</span></span><br><span class="line">        <span class="type">int</span> arr[] = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="comment">// 构建最大堆</span></span><br><span class="line">        buildMaxHeap(arr, len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        <span class="comment">// 每次将最大值与最后一个数交换位置，也就是将当前堆最大元素移动到数组后方，并从根节点开始调整大根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, i); <span class="comment">// 将当前最大值（根节点）与未排序部分的最后一个元素交换</span></span><br><span class="line">            len--; <span class="comment">// 缩小堆的范围</span></span><br><span class="line">            heapify(arr, <span class="number">0</span>, len); <span class="comment">// 调整堆，使其满足堆的性质</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整堆，使其满足堆的性质</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// 左子节点索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// 右子节点索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i; <span class="comment">// 最大值的索引，默认为当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左子节点存在且大于当前节点，更新最大值索引为左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果右子节点存在且大于当前节点，更新最大值索引为右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果最大值不是当前节点，则交换并递归调整（向上或者向下调整）</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(arr, i, largest);</span><br><span class="line">            heapify(arr, largest, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建最大堆</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="comment">// 从最后一个非叶子节点开始向上，逐渐建立一颗大根堆的树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换数组中的两个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工具包"><a href="#工具包" class="headerlink" title="工具包"></a>工具包</h2><h3 id="hutool工具包"><a href="#hutool工具包" class="headerlink" title="hutool工具包"></a>hutool工具包</h3><h4 id="join方法："><a href="#join方法：" class="headerlink" title="join方法："></a>join方法：</h4><p>将一个集合的全部元素，通过指定的字符来连接成一个字符串，返回值为该字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CollUtil.join(itemIds, <span class="string">&quot;,&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty():"></a>isEmpty():</h4><p>判断一个集合是否为空，返回值为Boolean值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用法</span></span><br><span class="line">CollUtil.isEmpty(instances)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(Collection&lt;?&gt; collection)</span></span><br></pre></td></tr></table></figure><h4 id="RandomUtil-randomInt"><a href="#RandomUtil-randomInt" class="headerlink" title="RandomUtil.randomInt()"></a>RandomUtil.randomInt()</h4><p>返回一个从0 ~ （limit - 1）的随机数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static int randomInt(int limit) </span><br></pre></td></tr></table></figure><h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><h4 id="如何实现订单超时"><a href="#如何实现订单超时" class="headerlink" title="如何实现订单超时"></a>如何实现订单超时</h4><p><strong>1.使用rocketMQ延时队列</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240309115614353.png" alt="image-20240309115614353"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240309115745610.png" alt="image-20240309115745610"></p><p><strong>2.Redis过期监听</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240309115853600.png" alt="image-20240309115853600"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240309115911237.png" alt="image-20240309115911237"></p><p><strong>3.定时任务中间件</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240309120040161.png" alt="image-20240309120040161"></p><p><strong>优点</strong></p><p>定时批处理，减轻数据库压力</p><p>成本低，不需要单独存储超时消息，而是定时查询超时的消息，不会占用很多服务器资源</p><p><strong>缺点</strong></p><p>实时性查，定时任务不精确</p><h4 id="如何解决接口幂等性"><a href="#如何解决接口幂等性" class="headerlink" title="如何解决接口幂等性"></a>如何解决接口幂等性</h4><p><strong>实现幂等性的关键步骤分为以下三个：</strong> 一锁 二判 三更新</p><ul><li>每个请求操作必须有唯一的 ID（幂等字段），而这个 ID 就是用来表示此业务是否被执行过的关键凭证，例如，订单支付业务的请求，就要使用订单的 ID 作为幂等性验证的 Key；</li><li>每次执行业务之前必须要先判断此业务是否已经被处理过；</li><li>第一次业务处理完成之后，要把此业务处理的状态进行保存，比如存储到 Redis 中或者是数据库中，这样才能防止业务被重复处理。</li></ul><h5 id="前端拦截"><a href="#前端拦截" class="headerlink" title="前端拦截"></a><strong>前端拦截</strong></h5><p>前端拦截是指通过 Web 站点的页面进行请求拦截，比如在用户点击完“提交”按钮后，我们可以把按钮设置为不可用或者隐藏状态，避免用户重复点击。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/es511m1kme.gif" alt="img"></p><p>前端拦截有一个致命的问题，如果是懂行的程序员或者黑客可以直接绕过页面的 JS 执行，直接模拟请求后端的接口。</p><h5 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a><strong>分布式锁实现</strong></h5><p>分布式锁实现幂等性的逻辑是，在每次执行方法之前先判断是否可以获取到分布式锁，避免多个并发请求同时做并发操作，如果获取锁成功，则表示为第一次执行方法，否则直接舍弃请求即可，执行流程如下图所示：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/dv8pez35ep.png" alt="img"></p><p>需要注意的是分布式锁的 key 必须为业务的唯一标识，如果使用 Redis 的话，则用 set nx命令来创建和获取分布式锁。</p><p><font color = gold><strong>同时，也需要在数据库添加唯一性约束，做一个兜底策略，避免赃数据的产生。</strong></font></p><h5 id="数据库唯一索引"><a href="#数据库唯一索引" class="headerlink" title="数据库唯一索引"></a>数据库唯一索引</h5><p>创建一个唯一索引的表来实现幂等性，在每次执行业务之前，先执行插入操作，因为唯一字段就是业务的 ID，因此如果重复插入的话会触发唯一约束而导致插入失败 + 事务回滚。在这种情况下（插入失败）我们就可以判定它为重复提交的请求。</p><p>唯一索引表的创建示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">CREATE</span> <span class="variable constant_">TABLE</span> <span class="string">`table_name`</span> (</span><br><span class="line">  <span class="string">`id`</span> int <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span> <span class="variable constant_">AUTO_INCREMENT</span>,</span><br><span class="line">  <span class="string">`orderid`</span> <span class="title function_">varchar</span>(<span class="number">32</span>) <span class="variable constant_">NOT</span> <span class="variable constant_">NULL</span> <span class="variable constant_">DEFAULT</span> <span class="string">&#x27;&#x27;</span> <span class="variable constant_">COMMENT</span> <span class="string">&#x27;唯一id&#x27;</span>,</span><br><span class="line">  <span class="variable constant_">PRIMARY</span> <span class="variable constant_">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="variable constant_">UNIQUE</span> <span class="variable constant_">KEY</span> <span class="string">`uq_orderid`</span> (<span class="string">`orderid`</span>) <span class="variable constant_">COMMENT</span> <span class="string">&#x27;唯一约束&#x27;</span></span><br><span class="line">) <span class="variable constant_">ENGINE</span>=<span class="title class_">InnoDB</span>;</span><br></pre></td></tr></table></figure><p><strong>悲观锁</strong></p><p>使用悲观锁实现幂等性，一般是配合事务一起来实现，在没有使用悲观锁时，我们通常的执行过程是这样的，首先来判断数据的状态，执行 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> status <span class="keyword">from</span> table_name <span class="keyword">where</span> ;</span><br></pre></td></tr></table></figure><p>然后再进行添加操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name (id) <span class="keyword">values</span> (<span class="string">&#x27;xxx&#x27;</span>);</span><br></pre></td></tr></table></figure><p>最后再进行状态的修改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> table_name <span class="keyword">set</span> status<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>;</span><br></pre></td></tr></table></figure><p>但这种情况因为是非原子操作，所以在高并发环境下可能会造成一个业务被执行两次的问题，当一个程序在执行中时，而另一个程序也开始状态判断的操作。因为第一个程序还未来得及更改状态，所以第二个程序也能执行成功，这就导致一个业务被执行了两次。</p><p>在这种情况下我们就可以使用悲观锁 + 来避免问题的产生，实现 SQL 如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;  # <span class="number">1.</span>开始事务</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">for</span> <span class="keyword">update</span>; # <span class="number">2.</span>查询状态</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name (id) <span class="keyword">values</span> (<span class="string">&#x27;xxx&#x27;</span>); # <span class="number">3.</span>添加操作</span><br><span class="line"><span class="keyword">update</span> table_name <span class="keyword">set</span> status<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>; # <span class="number">4.</span>更改操作</span><br><span class="line"><span class="keyword">commit</span>; # <span class="number">5.</span>提交事务</span><br></pre></td></tr></table></figure><blockquote><p>两个问题：</p><p>如果使用的是 <a href="https://cloud.tencent.com/product/cdb?from_column=20065&from=20065">MySQL 数据库</a>，必须选用 innodb 存储引擎，因为 innodb 支持事务；</p><p>id 字段一定要是主键或者是唯一索引，不然会锁表，影响其他业务执行。</p></blockquote><h4 id="场景题：微信扫码登录如何设计"><a href="#场景题：微信扫码登录如何设计" class="headerlink" title="场景题：微信扫码登录如何设计"></a>场景题：微信扫码登录如何设计</h4><p><a href="https://www.cnblogs.com/huanshilang/p/12365376.html">扫码登录功能如何实现？一文搞懂主流的扫码登录技术原理 - 闲人鹤 - 博客园 (cnblogs.com)</a></p><p><strong>扫码登录功能的完整技术逻辑</strong></p><p>　　<strong>1）网页端与服务器的配合逻辑：</strong></p><p>　　接下来就是对于这个服务的详细实现。</p><p>　　首先用户打开网站的登录页面的时候，向浏览器的服务器发送获取登录二维码的请求。服务器收到请求后，随机生成一个uuid，将这个id作为key值存入redis服务器，同时设置一个过期时间，再过期后，用户登录二维码需要进行刷新重新获取。</p><p>　　同时，将这个key值和本公司的验证字符串合在一起，通过二维码生成接口，生成一个二维码的图片（二维码生成，网上有很多现成的接口和源码，这里不再介绍）。然后，将二维码图片和uuid一起返回给用户浏览器。</p><p>　　浏览器拿到二维码和uuid后，会每隔一秒向服务器发送一次，登录是否成功的请求。请求中携带有uuid作为当前页面的标识符。这里有的同学就会奇怪了，服务器只存了个uuid在redis中作为key值，怎么会有用户的id信息呢？</p><p>　　这里确实会有用户的id信息，这个id信息是由手机服务器存入redis中的。具体请继续阅读“手机端与服务器的配合逻辑”。</p><p>　　<strong>2）手机端与服务器的配合逻辑：</strong></p><p>　　话说，浏览器拿到二维码后，将二维码展示到网页上，并给用户一个提示：请掏出您的手机，打开扫一扫进行登录。</p><p>　　用户拿出手机扫描二维码，就可以得到一个验证信息和一个uuid（扫描二维码获取字符串的功能在网上同样有很多demo，这里就不详细介绍了）。</p><p>　　由于手机端已经进行过了登录，在访问手机端的服务器的时候，参数中都回携带一个用户的token，手机端服务器可以从中解析到用户的userId（这里从token中取值而不是手机端直接传userid是为了安全，直接传userid可能会被截获和修改，token是加密的，被修改的风险会小很多）。手机端将解析到的数据和用户token一起作为参数，向服务器发送验证登录请求（这里的服务器是手机服务器，手机端的服务器跟网页端服务器不是同一台服务器）。</p><p>　　服务器收到请求后，首先对比参数中的验证信息，确定是否为用户登录请求接口。如果是，返回一个确认信息给手机端。</p><p>　　手机端收到返回后，将登录确认框显示给用户（防止用户误操作，同时使登录更加人性化）。用户确认是进行的登录操作后，手机再次发送请求。服务器拿到uuId和userId后，将用户的userid作为value值存入redis中以uuid作为key的键值对中。</p><p>　　<strong>3）登录成功时的逻辑：</strong></p><p>　　然后，浏览器再次发送请求的时候，浏览器端的服务器就可以得到一个用户Id，并调用登录的方法，声成一个浏览器端的token，再浏览器再次发送请求的时候，将用户信息返回给浏览器，登录成功。这里存储用户id而不是直接存储用户信息是因为，手机端的用户信息，不一定是和浏览器端的用户信息完全一致。</p><p>　　<strong>4）详细的技术原理总结如下图所示：</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1643577-20200226094531549-13062519.png" alt="img"></p><h4 id="大文件中找前100个高频词"><a href="#大文件中找前100个高频词" class="headerlink" title="大文件中找前100个高频词"></a>大文件中找前100个高频词</h4><p>假如有一个<strong>1G</strong>大小的文件，文件里每一行是一个词，每个词的大小不超过<strong>16byte</strong>，要求返回出现频率最高的100个词。内存大小限制是<strong>10M</strong></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>由于内存限制，我们无法直接将大文件的所有词一次性读到内存中。</p><p>可以采用<strong>分治策略</strong>，把一个大文件分解成多个小文件，保证每个文件的大小小于10M，进而直接将单个小文件读取到内存中进行处理。</p><p><strong>第一步</strong>，首先遍历大文件，对遍历到的每个词x，执行 <code>hash(x) % 500</code>，将结果为i的词存放到文件f(i)中，遍历结束后，可以得到500个小文件，每个小文件的大小为2M左右；</p><p><strong>第二步</strong>，接着统计每个小文件中出现频数最高的100个词。可以使用HashMap来实现，其中key为词，value为该词出现的频率。</p><p>对于遍历到的词x，如果在map中不存在，则执行 <code>map.put(x, 1)。</code></p><p>若存在，则执行 <code>map.put(x, map.get(x)+1)</code>，将该词出现的次数加1。</p><p><strong>第三步</strong>，在第二步中找出了每个文件出现频率最高的100个词之后，通过维护一个<strong>小顶堆</strong>来找出所有小文件中出现频率最高的100个词。</p><p>具体方法是，遍历第一个文件，把第一个文件中出现频率最高的100个词构建成一个小顶堆。</p><p>如果第一个文件中词的个数小于100，可以继续遍历第二个文件，直到构建好有100个结点的小顶堆为止。</p><p>继续遍历其他小文件，如果遍历到的词的出现次数大于堆顶上词的出现次数，可以用新遍历到的词替换堆顶的词，然后重新调整这个堆为小顶堆。</p><p>当遍历完所有小文件后，这个小顶堆中的词就是出现频率最高的100个词。</p><p>总结一下，这种解法的主要思路如下：</p><ol><li>采用<strong>分治</strong>的思想，进行哈希取余</li><li>使用<strong>HashMap</strong>统计每个小文件单词出现的次数</li><li>使用<strong>小顶堆</strong>，遍历步骤2中的小文件，找出词频top100的单词</li></ol><h4 id="线上oom怎么处理"><a href="#线上oom怎么处理" class="headerlink" title="线上oom怎么处理"></a><strong>线上oom怎么处理</strong></h4><p><a href="https://blog.csdn.net/o9109003234/article/details/121917786">某团面试：如果线上遇到了OOM，你该如何排查？如何解决？哪些方案？-CSDN博客</a></p><h5 id="为什么会-OOM"><a href="#为什么会-OOM" class="headerlink" title="为什么会 OOM"></a>为什么会 OOM</h5><p>OOM 全称 “Out Of Memory”，表示内存耗尽。当 JVM 因为没有足够的内存来为对象分配空间，并且垃圾回收器也已经没有空间可回收时，就会抛出这个错误</p><p>为什么会出现 OOM，一般由这些问题引起</p><ol><li>分配过少：JVM 初始化内存小，业务使用了大量内存；或者不同 JVM 区域分配内存不合理</li><li>代码漏洞：某一个对象被频繁申请，不用了之后却没有被释放，导致内存耗尽</li></ol><p><strong>内存泄漏</strong>：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了。因为申请者不用了，而又不能被虚拟机分配给别人用</p><p><strong>内存溢出</strong>：申请的内存超出了 JVM 能提供的内存大小，此时称之为溢出</p><p>内存泄漏持续存在，最后一定会溢出，两者是因果关系</p><p>Dump <strong>文件分析</strong></p><p>Dump 文件是 Java 进程的内存镜像，其中主要包括 <strong>系统信息</strong>、<strong>虚拟机属性</strong>、<strong>完整的线程 Dump</strong>、<strong>所有类和对象的状态</strong> 等信息</p><p>当程序发生内存溢出或 GC 异常情况时，怀疑 JVM 发生了 <strong>内存泄漏</strong>，这时我们就可以导出 Dump 文件分析</p><p>JVM 启动参数配置添加以下参数</p><ul><li>-XX:+HeapDumpOnOutOfMemoryError</li><li>-XX:HeapDumpPath&#x3D;.&#x2F;（参数为 Dump 文件生成路径）</li></ul><blockquote><p>当 JVM 发生 OOM 异常自动导出 Dump 文件，文件名称默认格式：<code>java_pid&#123;pid&#125;.hprof</code></p></blockquote><p>上面配置是在应用抛出 OOM 后自动导出 Dump，或者可以在 JVM 运行时导出 Dump 文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:file=[文件路径] [pid]</span><br><span class="line"># 示例</span><br><span class="line">jmap -dump:file=./jvmdump.hprof <span class="number">15162</span></span><br></pre></td></tr></table></figure><p>在本地写一个测试代码，验证下 OOM 以及分析 Dump 文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">设置 VM 参数：-Xms3m -Xmx3m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Object&gt; oomList = Lists.newArrayList();</span><br><span class="line">   <span class="comment">// 无限循环创建对象</span></span><br><span class="line">    while (<span class="literal">true</span>) &#123;</span><br><span class="line">        oomList.add(<span class="built_in">new</span> Object());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过报错信息得知，<code>java heap space</code> 表示 OOM 发生在堆区，并生成了 hprof 二进制文件在当前文件夹下</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/0265f74e1fd0e98c885edcc2214c57f1.png" alt="0265f74e1fd0e98c885edcc2214c57f1.png"></p><p><strong>JvisualVM 分析</strong></p><p>Dump 分析工具有很多，相对而言 <strong>JvisualVM</strong>、<strong>JProfiler</strong>、<strong>Eclipse Mat</strong>，使用人群更多一些。下面以 JvisualVM 举例分析 Dump 文件</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/ae7e3690c2148f94318e852a29f38479.png" alt="ae7e3690c2148f94318e852a29f38479.png"></p><p>列举两个常用的功能，第一个是能看到触发 OOM 的线程堆栈，清晰得知程序溢出的原因</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/1d072a2c87a3477e9ac329d09e21170b.png" alt="1d072a2c87a3477e9ac329d09e21170b.png"></p><p>第二个就是可以查看 JVM 内存里保留大小最大的对象，可以自由选择排查个数</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/2e140a908558b54627b872604547123f.png" alt="2e140a908558b54627b872604547123f.png"></p><p>点击对象还可以跳转具体的对象引用详情页面</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/95a0922d88d1efc4de9f16caa8afae86.png" alt="95a0922d88d1efc4de9f16caa8afae86.png"></p><p>文中 Dump 文件较为简单，而正式环境出错的原因五花八门，所以不对该 Dump 文件做深度解析</p><p><strong>注意</strong>：JvisualVM 如果分析大 Dump 文件，可能会因为内存不足打不开，需要调整默认的内存</p><p><strong>总结回顾</strong></p><p>线上如遇到 JVM 内存溢出，可以分以下几步排查</p><ol><li><code>jmap -heap</code> 查看是否内存分配过小</li><li><code>jmap -histo</code> 查看是否有明显的对象分配过多且没有释放情况</li><li><strong>在JVM启动时添加-XX:+HeapDumpOnOutOfMemoryError     -XX:HeapDumpPath&#x3D;.&#x2F;（参数为 Dump 文件生成路径）等参数使得发生OOM时能保存内存快照并指定hprof文件的存放位置，或者使用<code>jmap -dump</code> 导出 JVM 当前内存快照，使用 JDK 自带或 MAT 等工具分析快照，分析发生内存溢出的线程、保存最大的对象、对象的引用详情</strong></li></ol><h4 id="可能会产生OOM的区域，以及各种区域产生OOM的原因"><a href="#可能会产生OOM的区域，以及各种区域产生OOM的原因" class="headerlink" title="可能会产生OOM的区域，以及各种区域产生OOM的原因"></a>可能会产生OOM的区域，以及各种区域产生OOM的原因</h4><h5 id="堆溢出的可能原因"><a href="#堆溢出的可能原因" class="headerlink" title="堆溢出的可能原因"></a>堆溢出的可能原因</h5><p><strong>溢出的原因一般由于 JVM 堆内存设置不合理或者内存泄漏导致</strong></p><ul><li>如果是内存泄漏，可以通过工具查看泄漏对象到 GC Roots 的引用链。掌握了泄漏对象的类型信息以及 GC Roots 引用链信息，就可以精准地定位出泄漏代码的位置</li><li>如果不存在内存泄漏，就是内存中的对象确实都还必须存活着，那就应该检查虚拟机的堆参数（-Xmx 与 -Xms），查看是否可以将虚拟机的内存调大些</li></ul><p>一）是否App中的类中和引用变量过多使用了Static修饰 如public staitc Student s；在类中的属性中使用 static修饰的最好只用基本类型或字符串。如public static int i &#x3D; 0; &#x2F;&#x2F;public static String str;<br>二）是否App中使用了大量的递归或无限递归（递归中用到了大量的建新的对象）<br>三）是否App中使用了大量循环或死循环（循环中用到了大量的新建的对象）<br>四）检查App中是否使用了向数据库查询所有记录的方法。即一次性全部查询的方法，如果数据量超过10万多条了，就可能会造成内存溢出。所以在查询时应采用“分页查询”。<br>五）检查是否有数组，List，Map中存放的是对象的引用而不是对象，因为这些引用会让对应的对象不能被释放。会大量存储在内存中。<br>六）检查是否使用了“非字面量字符串进行+”的操作。因为String类的内容是不可变的，每次运行”+”就会产生新的对象，如果过多会造成新String对象过多，从而导致JVM没有及时回收而出现内存溢出。<br>七）使用 DDMS工具进行查找内存溢出的大概位置</p><h5 id="栈溢出的可能原因"><a href="#栈溢出的可能原因" class="headerlink" title="栈溢出的可能原因"></a>栈溢出的可能原因</h5><ul><li>一般是由于程序中存在 <strong>死循环或者深度递归调用</strong> 造成的。如果栈大小设置过小也会出现溢出，可以通过 <code>-Xss</code> 设置栈的大小</li><li>虚拟机抛出栈溢出错误，可以在日志中定位到错误的类、方法</li></ul><p>函数地址、函数参数、局部变量等信息存储于栈内存</p><p>一）是否有递归调用<br>二）是否有大量循环或死循环创建过多局部变量<br>三）局部变量是否过多</p><p>五）使用DDMS工具进行查找大概出现栈溢出的位置</p><h4 id="Java程序占用-CPU-过高怎么排查"><a href="#Java程序占用-CPU-过高怎么排查" class="headerlink" title="Java程序占用 CPU 过高怎么排查"></a>Java程序占用 CPU 过高怎么排查</h4><p>cpu占用过高说明有密集型耗费cpu的运算，原因是while循环，死循环了，一直占有cpu。</p><h5 id="第一步，使用-top-找到占用-CPU-最高的-Java-进程"><a href="#第一步，使用-top-找到占用-CPU-最高的-Java-进程" class="headerlink" title="第一步，使用 top 找到占用 CPU 最高的 Java 进程"></a>第一步，使用 top 找到占用 CPU 最高的 Java 进程</h5><p>在真实环境中，首先要确认是不是 Java 程序造成的，如果有系统监控工具，可能会直接在预警信息里告诉你是有哪个进程造成的，但也有可能不知道，需要我们手动排查。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-38f5640906c245788aeb6ead74d54007_1440w.webp" alt="img"></p><p>使用 <code>top</code>命令发现占用 CPU 99.7% 的线程是 Java 进程，进程 PID 为 <code>13731</code>。</p><h5 id="第二步，用-top-Hp-命令查看占用-CPU-最高的线程"><a href="#第二步，用-top-Hp-命令查看占用-CPU-最高的线程" class="headerlink" title="第二步，用 top -Hp 命令查看占用 CPU 最高的线程"></a>第二步，用 <code>top -Hp</code> 命令查看占用 CPU 最高的线程</h5><p>上一步用 <code>top</code>命令找到了那个 Java 进程。那一个进程中有那么多线程，不可能所有线程都一直占着 CPU 不放，这一步要做的就是揪出这个罪魁祸首，当然有可能不止一个。</p><p>执行<code>top -Hp pid</code>命令，pid 就是前面的 Java 进程，我这个例子中就是 <code>13731</code> ，完整命令为：</p><p><code>top -Hp 13731</code>，执行之后的效果如下</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-6265125e88645d40b99ac10a577fc8ef_1440w.webp" alt="img"></p><p>可以看到占用 CPU 最高的那个线程 PID 为 <code>13756</code>。</p><p>然后将 <code>13756</code>转换为 16 进制的，后面会用到，可以用在线进制转换的网站直接转换，转换结果为 <code>0x35bc</code></p><h5 id="第三步，保存线程栈信息"><a href="#第三步，保存线程栈信息" class="headerlink" title="第三步，保存线程栈信息"></a>第三步，保存线程栈信息</h5><p>当前 Java 程序的所有线程信息都可以通过 <code>jstack</code>命令查看，我们用<code>jstack</code>命令将第一步找到的 Java 进程的线程栈保存下来。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 13731 &gt; thread_stack.log</span><br></pre></td></tr></table></figure><h5 id="第四步，在线程栈中查找最贵祸首的线程"><a href="#第四步，在线程栈中查找最贵祸首的线程" class="headerlink" title="第四步，在线程栈中查找最贵祸首的线程"></a>第四步，在线程栈中查找最贵祸首的线程</h5><p>第二步已经找到了这个罪魁祸首的线程 PID，并把它转换成了 16 进制的，第三步保存下来的线程栈中有所有线程的 PID 16 进制信息，我们在线程栈中查找这个16进制的线程 id （<code>0x35bc</code>）。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-866c85eec23d68be6bf7659e93565d10_1440w.webp" alt="img"></p><h4 id="如何在亿级数据库中快速查询到uid-4的数据，同时有多个uid为4的数据"><a href="#如何在亿级数据库中快速查询到uid-4的数据，同时有多个uid为4的数据" class="headerlink" title="如何在亿级数据库中快速查询到uid &#x3D; 4的数据，同时有多个uid为4的数据"></a>如何在亿级数据库中快速查询到uid &#x3D; 4的数据，同时有多个uid为4的数据</h4><p>在亿级的数据量下，同时还有大量uid 为4的数据，即使使用索引，查询效率也会受到影响。</p><ul><li>分库分表，可以通过uid对数据进行一致性Hash取模运算，把数据分配到不同的库和表中，降低单表数据量，提高查询效率</li><li>使用ES，可以将uid同步到搜索引擎中，在大数据量下，搜索引擎可以提供更加高效的查询</li></ul><h4 id="秒杀系统设计"><a href="#秒杀系统设计" class="headerlink" title="秒杀系统设计"></a>秒杀系统设计</h4><p><a href="https://mp.weixin.qq.com/s/l05_28xe6O4vZUQEmnu2Ug">高并发下秒杀商品，你必须知道的9个细节 (qq.com)</a></p><p><strong>秒杀的特点</strong></p><p>大量用户抢少量商品的场景，必定会出现<code>狼多肉少</code>的情况，绝大部分用户秒杀会失败，只有极少部分用户能够成功。</p><p>一般在<code>秒杀时间点</code>（比如：12点）前几分钟，用户并发量才真正突增，达到秒杀时间点时，并发量会达到顶峰。在秒杀结束后，用户并发量会急剧下降</p><p><img src="/./../../../../../../%25E4%25B8%25AA%25E4%25BA%25BA%25E5%258D%259A%25E5%25AE%25A2/hexo/blog/source/imgs/Java%25E7%259F%25A5%25E8%25AF%2586%25E7%2582%25B9%25E6%2580%25BB%25E7%25BB%2593/640.webp" alt="图片"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1712993375685-30.webp" alt="图片"></p><h5 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h5><p>活动页面是用户流量的第一入口，所以是并发量最大的地方。</p><p>如果这些流量都能直接访问服务端，恐怕服务端会因为承受不住这么大的压力，而直接挂掉。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1712993323236-21.webp" alt="图片">活动页面绝大多数内容是固定的，比如：商品名称、商品描述、图片等。为了减少不必要的服务端请求，通常情况下，会对活动页面做<code>静态化</code>处理。用户浏览商品等常规操作，并不会请求到服务端。只有到了秒杀时间点，并且用户主动点了秒杀按钮才允许访问服务端。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1712993323239-22.webp" alt="图片">这样能过滤大部分无效请求。</p><p>但只做页面静态化还不够，因为用户分布在全国各地，有些人在北京，有些人在成都，有些人在深圳，地域相差很远，网速各不相同。</p><p>如何才能让用户最快访问到活动页面呢？</p><p>这就需要使用CDN，它的全称是Content Delivery Network，即内容分发网络。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1712993323241-23.webp" alt="图片">使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p><h5 id="将秒杀按钮置灰，添加定时器"><a href="#将秒杀按钮置灰，添加定时器" class="headerlink" title="将秒杀按钮置灰，添加定时器"></a>将秒杀按钮置灰，添加定时器</h5><p>大部分用户怕错过<code>秒杀时间点</code>，一般会提前进入活动页面。此时看到的<code>秒杀按钮</code>是置灰，不可点击的。只有到了秒杀时间点那一时刻，秒杀按钮才会自动点亮，变成可点击的。</p><p>但此时很多用户已经迫不及待了，通过不停刷新页面，争取在第一时间看到秒杀按钮的点亮。</p><p>前端还可以加一个<strong>定时器</strong>，控制比如：3秒之内，只允许发起一次请求。如果用户点击了一次秒杀按钮，则在3秒之内置灰，不允许再次点击，等到过了时间限制，又允许重新点击该按钮。</p><h5 id="使用Redis缓存保存商品"><a href="#使用Redis缓存保存商品" class="headerlink" title="使用Redis缓存保存商品"></a>使用Redis缓存保存商品</h5><p>我们需要在redis中保存商品信息，里面包含：商品id、商品名称、规格属性、库存等信息，同时数据库中也要有相关信息，毕竟缓存并不完全可靠。</p><p>用户在点击秒杀按钮，请求秒杀接口的过程中，需要传入的商品id参数，然后服务端需要校验该商品是否合法。</p><p>大致流程如下图所示：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1712994746156-33.webp" alt="图片"></p><p>根据商品id，先从缓存中查询商品，如果商品存在，则参与秒杀。如果不存在，则需要从数据库中查询商品，如果存在，则将商品信息放入缓存，然后参与秒杀。如果商品不存在，则直接提示失败。</p><p>这个过程表面上看起来是OK的，但是如果深入分析一下会发现一些问题。</p><h6 id="缓存击穿-1"><a href="#缓存击穿-1" class="headerlink" title="缓存击穿"></a>缓存击穿</h6><p>比如商品A第一次秒杀时，缓存中是没有数据的，但数据库中有。虽说上面有如果从数据库中查到数据，则放入缓存的逻辑。</p><p>然而，在高并发下，同一时刻会有大量的请求，都在秒杀同一件商品，这些请求同时去查缓存中没有数据，然后又同时访问数据库。结果悲剧了，数据库可能扛不住压力，直接挂掉。</p><p>这就需要加锁，最好使用分布式锁。</p><ul><li>使用redis的分布式锁，setNx&#96;命令（ set key value  5 min NX），并给分布式锁添加过期时间(原子性操作)</li><li>使用Lua脚本保证释放锁时，判断锁是否属于本线程和释放锁两个操作的原子性</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span> </span><br><span class="line"> <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]) </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>使用redis分布式锁，还有锁竞争问题、续期问题、锁重入问题、多个redis实例加锁问题等，可以使用redisson。</p><p>它能保证查询锁是否存在和删除锁是原子操作。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1712994782723-36.webp" alt="图片">当然，针对这种情况，最好在项目启动之前，<strong>先把缓存进行<code>预热</code><strong>。即事先</strong>把所有的商品，同步到缓存中</strong>，这样商品基本都能直接从缓存中获取到，就不会出现缓存击穿的问题了。</p><p>缓存预热后也可以添加获取分布式锁的逻辑，如果缓存中设置的过期时间不对，缓存提前过期了，或者缓存被不小心删除了，如果不加锁同样可能出现缓存击穿。其实这里加锁，相当于一个兜底方案。</p><h6 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h6><p>如果有大量的请求传入的商品id，在缓存中和数据库中都不存在，这些请求不就每次都会穿透过缓存，而直接访问数据库了。</p><p>由于前面已经加了锁，所以即使这里的并发量很大，也不会导致数据库直接挂掉。</p><p><strong>使用布隆过滤器</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1712994963384-39.webp" alt="图片"></p><p>需要预先将商品的id同步添加到布隆过滤器中，系统根据商品id，先从布隆过滤器中查询该id是否存在，如果存在则允许从缓存中查询数据，如果不存在，则直接返回失败。</p><h5 id="预扣库存"><a href="#预扣库存" class="headerlink" title="预扣库存"></a>预扣库存</h5><p>预扣库存的主要流程如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1712995196863-45.webp" alt="图片"></p><p>扣减库存中除了上面说到的<code>预扣库存</code>和<code>回退库存</code>之外，还需要特别注意的是库存不足和库存超卖问题。</p><h6 id="使用数据库扣减库存（不推荐）"><a href="#使用数据库扣减库存（不推荐）" class="headerlink" title="使用数据库扣减库存（不推荐）"></a>使用数据库扣减库存（不推荐）</h6><p>使用数据库扣减库存，是最简单的实现方案了，这就需要在update之前，使用乐观锁先查一下库存是否足够了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> product <span class="keyword">set</span> stock<span class="operator">=</span>stock<span class="number">-1</span> <span class="keyword">where</span> id<span class="operator">=</span>product <span class="keyword">and</span> stock <span class="operator">&gt;</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>但需要频繁访问数据库，我们都知道数据库连接是非常昂贵的资源。在高并发的场景下，可能会造成系统雪崩。而且，容易出现多个请求，同时竞争行锁的情况，造成相互等待，从而出现死锁的问题。</p><h6 id="redis扣减库存"><a href="#redis扣减库存" class="headerlink" title="redis扣减库存"></a>redis扣减库存</h6><p>如果在高并发下，有多个请求同时查询库存，当时都大于0。由于查询库存和更新库存非原则操作，则会出现库存为负数的情况，即<code>库存超卖</code>。</p><p><strong>lua脚本扣库存</strong></p><p>lua脚本保证原子性，它跟redis一起配合使用，能够完美解决上面的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">lua</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">lua.append(<span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 1) then&quot;</span>);</span><br><span class="line">lua.append(<span class="string">&quot;    local stock = tonumber(redis.call(&#x27;get&#x27;, KEYS[1]));&quot;</span>);</span><br><span class="line">lua.append(<span class="string">&quot;    if (stock == -1) then&quot;</span>);</span><br><span class="line">lua.append(<span class="string">&quot;        return 1;&quot;</span>);</span><br><span class="line">lua.append(<span class="string">&quot;    end;&quot;</span>);</span><br><span class="line">lua.append(<span class="string">&quot;    if (stock &gt; 0) then&quot;</span>);</span><br><span class="line">lua.append(<span class="string">&quot;        redis.call(&#x27;incrby&#x27;, KEYS[1], -1);&quot;</span>);</span><br><span class="line">lua.append(<span class="string">&quot;        return stock;&quot;</span>);</span><br><span class="line">lua.append(<span class="string">&quot;    end;&quot;</span>);</span><br><span class="line">lua.append(<span class="string">&quot;    return 0;&quot;</span>);</span><br><span class="line">lua.append(<span class="string">&quot;end;&quot;</span>);</span><br><span class="line">lua.append(<span class="string">&quot;return -1;&quot;</span>);</span><br></pre></td></tr></table></figure><p>该代码的主要流程如下：</p><ol><li>先判断商品id是否存在，如果不存在则直接返回。</li><li>获取该商品id的库存，判断库存如果是-1，则直接返回，表示不限制库存。</li><li>如果库存大于0，则扣减库存。</li><li>如果库存等于0，是直接返回，表示库存不足。</li></ol><h5 id="mq异步处理"><a href="#mq异步处理" class="headerlink" title="mq异步处理"></a>mq异步处理</h5><p>我们都知道在真实的秒杀场景中，有三个核心流程：<img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1712996087820-48.webp" alt="图片"></p><p>而这三个核心流程中，真正并发量大的是秒杀功能，下单和支付功能实际并发量很小。所以，我们在设计秒杀系统时，有必要把下单和支付功能从秒杀的主流程中拆分出来，特别是下单功能要做成mq异步处理的。而支付功能，比如支付宝支付，是业务场景本身保证的异步。</p><p>于是，秒杀后下单的流程变成如下：<img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1712996087821-49.webp" alt="图片"></p><p>秒杀成功了，往mq发送下单消息的时候，有可能会失败。原因有很多，比如：网络问题、broker挂了、mq服务端磁盘问题等。这些情况，都可能会造成消息丢失。</p><p>如何防止消息丢失呢？</p><p>答：加一张消息发送表。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1712996167623-54.webp" alt="图片"></p><p>在生产者发送mq消息之前，先把该条消息写入消息发送表，初始状态是待处理，然后再发送mq消息。消费者消费消息时，处理完业务逻辑之后，再回调生产者的一个接口，修改消息状态为已处理。</p><p>如果生产者把消息写入消息发送表之后，再发送mq消息到mq服务端的过程中失败了，造成了消息丢失。</p><p>这时候，要如何处理呢？</p><p>答：使用job，增加重试机制。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1712996167627-55.webp" alt="图片">用job每隔一段时间去查询消息发送表中状态为待处理的数据，然后重新发送mq消息。</p><p><strong>重复消费问题（下单的幂等性）</strong></p><p>本来消费者消费消息时，在ack应答的时候，如果网络超时，本身就可能会消费重复的消息。但由于消息发送者增加了重试机制，会导致消费者重复消息的概率增大。</p><p><strong>分布式锁实现下单的幂等性</strong></p><p>分布式锁实现幂等性的逻辑是，在每次执行方法之前先判断是否可以获取到分布式锁，避免多个并发请求同时做并发操作，如果获取锁成功，则表示为第一次执行方法，否则直接舍弃请求即可，执行流程如下图所示：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/dv8pez35ep.png" alt="img"></p><p>需要注意的是分布式锁的 key 必须为业务的唯一标识，如果使用 Redis 的话，则用 set nx命令来创建和获取分布式锁。</p><p><font color = gold><strong>同时，也需要在数据库添加唯一性约束，做一个兜底策略，避免赃数据的产生。</strong></font></p><p><strong>延迟消费问题</strong></p><p>用户秒杀成功了，下单之后，在15分钟之内还未完成支付的话，该订单会被自动取消，回退库存。</p><p>使用延迟队列，我们都知道rocketmq，自带了延迟队列的功能。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1712996416947-63.webp" alt="图片">下单时消息生产者会先生成订单，此时状态为待支付，然后会向延迟队列中发一条消息。达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。如果是待支付状态，则会更新订单状态为取消状态。如果不是待支付状态，说明该订单已经支付过了，则直接返回。</p><p>还有个关键点，用户完成支付之后，会修改订单状态为已支付。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1712996416947-64.webp" alt="图片"></p><h5 id="限流的实现"><a href="#限流的实现" class="headerlink" title="限流的实现"></a>限流的实现</h5><p>有人会在自己的服务器上，运行脚本，模拟正常用户登录系统，跳过秒杀页面，直接调用秒杀接口。</p><p>如果是我们手动操作，一般情况下，一秒钟只能点击一次秒杀按钮。<img src="/./../../../../../../%25E4%25B8%25AA%25E4%25BA%25BA%25E5%258D%259A%25E5%25AE%25A2/hexo/blog/source/imgs/Java%25E7%259F%25A5%25E8%25AF%2586%25E7%2582%25B9%25E6%2580%25BB%25E7%25BB%2593/640-1712996543555-69.webp" alt="图片">但是如果是服务器，一秒钟可以请求成上千接口。<img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1712996543556-70.webp" alt="图片">这种差距实在太明显了，如果不做任何限制，绝大部分商品可能是被机器抢到，而非正常的用户，有点不太公平。</p><p><strong>对同一用户限流</strong></p><p>为了防止某个用户，请求接口次数过于频繁，可以只针对该用户做限制。<img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1712996595135-75.webp" alt="图片"></p><p>限制同一个用户id，比如每分钟只能请求5次接口。</p><p><strong>对同一ip限流</strong></p><p>有时候只对某个用户限流是不够的，有些高手可以模拟多个用户请求，这种nginx就没法识别了。</p><p>。<img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1712996620236-78.webp" alt="图片"></p><p>这时需要加同一ip限流功能限制同一个ip，比如每分钟只能请求5次接口。</p><p>但这种限流方式可能会有误杀的情况，比如同一个公司或网吧的出口ip是相同的，如果里面有多个正常用户同时发起请求，有些用户可能会被限制住。</p><h2 id="未总结八股"><a href="#未总结八股" class="headerlink" title="未总结八股"></a>未总结八股</h2><p>[EX seconds]: </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/2024/04/19/JUC/"/>
      <url>/2024/04/19/JUC/</url>
      
        <content type="html"><![CDATA[<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>进程作为资源分配的基本单位,线程作为调度的基本单位。</p><ul><li>进程可看做是正在执行的程序,每个进程都有独立的代码和数据空间，所以进程间的切换会有较大的开销。一个进程在其执行的过程中可以产生多个线程。</li><li>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器（</strong>线程切换后能恢复到正确的执行位置<strong>）</strong>、<strong>虚拟机栈（</strong>保证线程中的局部变量不被别的线程访问到<strong>）</strong>和<strong>本地方法栈</strong>（包含局部变量，本地方法），所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul><p>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响,因为它们共享了堆和方法区资源。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231016143302701.png" alt="image-20231016143302701"></p><ul><li>堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存）</li><li>方法区保存在着被加载过的每一个类的信息，包括类的方法、构造器，成员方法，属性等，这些信息由<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">类加载</a>器在加载类时，从类的源文件中抽取出来；<strong>运行时常量池</strong>：当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址转换为真实地址。</li></ul><h4 id="线程创建方法"><a href="#线程创建方法" class="headerlink" title="线程创建方法"></a>线程创建方法</h4><ol><li>继承Thread类并重写run方法</li></ol><ul><li><p>d定义Thread类的子类，并重写该类的run()方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。</p></li><li><p>创建Thread子类的实例，也就是创建了线程对象</p></li><li><p>启动线程，即调用线程的start()方法，本质上调用的是runable接口中的run方法</p></li></ul><p>代码实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;<span class="comment">//继承Thread类</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">new</span> <span class="title class_">MyThread</span>().start();<span class="comment">//创建并启动线程</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过实现Runnable接口并重写run方法</li></ol><ul><li><p>定义Runnable接口的实现类，一样要重写run()方法，这个run（）方法和Thread中的run()方法一样是线程的执行体</p></li><li><p>创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象</p></li><li><p>第三部依然是通过调用线程对象的start()方法来启动线程</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;<span class="comment">//实现Runnable接口</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　　<span class="comment">//创建并启动线程</span></span><br><span class="line">　　　　MyThread2 myThread=<span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">　　　　Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">　　　　thread().start();</span><br><span class="line">　　　　<span class="comment">//或者    new Thread(new MyThread2()).start();</span></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>实现Callable接口并实现call()方法</li></ol><ul><li><p>创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。</p></li><li><p>使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值</p></li><li><p>使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）</p></li><li><p>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread3</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">　　　MyThread3 th=<span class="keyword">new</span> <span class="title class_">MyThread3</span>();</span><br><span class="line">      th.start();</span><br><span class="line">　　　<span class="comment">//也可以直接使用Lambda表达式创建Callable对象</span></span><br><span class="line">　　   <span class="comment">//使用FutureTask类来包装Callable对象</span></span><br><span class="line">　　　FutureTask&lt;Integer&gt; future=<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(</span><br><span class="line">　　　　(Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　  );</span><br><span class="line"></span><br><span class="line">　　　<span class="keyword">new</span> <span class="title class_">Thread</span>(future,<span class="string">&quot;有返回值的线程&quot;</span>).start();<span class="comment">//实质上还是以Callable对象来创建并启动线程</span></span><br><span class="line">　　  <span class="keyword">try</span> &#123;</span><br><span class="line">　　　　System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span>+future.get());<span class="comment">//get()方法会阻塞，直到子线程执行结束才返回</span></span><br><span class="line"> 　　 &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">　　　　ex.printStackTrace();</span><br><span class="line">　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用线程池来创建线程</li></ol><h4 id="Future-类有什么用？"><a href="#Future-类有什么用？" class="headerlink" title="Future 类有什么用？"></a>Future 类有什么用？</h4><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p><p>这其实就是多线程中经典的 <strong>Future 模式</strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p><p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li>取消任务；</li><li>判断任务是否被取消;</li><li>判断任务是否已经执行完成;</li><li>获取任务执行结果。</li></ul><h4 id="Java内存区域，内存模型？"><a href="#Java内存区域，内存模型？" class="headerlink" title="Java内存区域，内存模型？"></a>Java内存区域，内存模型？</h4><p><strong>Java内存模型（JMM）</strong></p><p>可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112214089.png" alt="image-20231003112214089"></p><p>在当前的 Java 内存模型下，线程可以把变量保存 <strong>本地内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p><p><strong>Java内存区域</strong></p><p>Java的内存区域和内存模型是不一样的东西，内存区域是指 JVM 运行时将数据分区域存储，强调对内存空间的划分。</p><p>Java内存区域主要由栈、堆、方法区组成</p><p><strong>栈</strong>：每个线程有自己独立、不共享的虚拟机栈，由多个栈帧（每个方法运行时需要的内存）组成，其中存放参数、局部变量，返回地址等，每个线程只能有一个活动栈帧，对应当前正在执行的那个方法。</p><p><strong>堆</strong>：多个线程共享同一个堆，通过new关键字构建的对象都需要使用堆内存，里面存放了实例对象、字符串常量池，静态变量等。</p><p><strong>方法区</strong>：保存在着被加载过的每一个类的信息，包括类的方法、构造器，成员方法，属性等，这些信息由<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">类加载</a>器在加载类时，从类的源文件中抽取出来；<strong>运行时常量池</strong>：当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址转换为真实地址。</p><p><strong>程序计数器：</strong>每个线程都有一个独立的程序计数器，记录下一条JVM指令的执行地址</p><p><strong>本地方法栈：</strong>调用本地方法（由C或者C++编写的底层的方法，与操作系统的底层API打交道）时给本地方法提供的内存空间</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112225692.png" alt="image-20231003112225692"></p><h4 id="线程的上下文切换是什么"><a href="#线程的上下文切换是什么" class="headerlink" title="线程的上下文切换是什么"></a>线程的上下文切换是什么</h4><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 CPU 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行，CPU被抢占</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li><li>主动让出CPU调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li></ul><p>线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念<br>就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><p>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等<br>Context Switch 频繁发生会影响性能</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112229884.png" alt="image-20231003112229884"></p><h4 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h4><p>多个线程同时被阻塞，处于相互等待的状态，如果没有外界干预，线程会被无限期地阻塞，因此程序不可能正常终止</p><h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><p>互斥条件：该资源任意一个时刻只由一个线程占用。</p><p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p><p>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系</p><h5 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h5><p><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</p><p><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><ul><li><h4 id="同步、异步、阻塞、非阻塞的理解"><a href="#同步、异步、阻塞、非阻塞的理解" class="headerlink" title="同步、异步、阻塞、非阻塞的理解"></a>同步、异步、阻塞、非阻塞的理解</h4><p>同步与异步关注的是<strong>消息通信机制</strong>（synchronous communication&#x2F; asynchronous communication）关注的<strong>是在发出调用后需不需要等待调用结果再返回调用</strong>。</p><p>阻塞和非阻塞关注的是<strong>程序在等待调用结果</strong>（消息，返回值）时的状态，关注的<strong>是等待调用结果时线程能否处理其他事情</strong>。</p><p><strong>阻塞</strong>调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<strong>非阻塞</strong>调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p><strong>(1)阻塞(blocking)、非阻塞（non-blocking）：</strong>可以简单理解为需要做一件事能不能立即得到返回应答，如果不能立即获得返回，需要等待，那就阻塞了(进程或线程就阻塞在那了，不能做其它事情)，否则就可以理解为非阻塞(在等待的过程中可以做其它事情)。</p><p><strong>(2)同步(synchronous)、异步(asynchronous)：</strong> 总是做完一件再去做另一件，不管是否需要时间等待，这就是同步(在发出一个功能调用时，在没有得到结果之前，该调用就不返回,即此时不能做下一件事情)；异步则反之，可以同时做几件事，并非一定需要一件事做完再做另一件事(当一个异步过程调用发出后，调用者不能立刻得到结果,此时可以接着做其它事情)。</p><p>同步简单理解成一问一答同步进行，异步可以简单理解为不必等一个问题有了答案再去问另一个问题，尽管问，有答了再通知你。</p></li></ul><h4 id="start和-run方法的区别"><a href="#start和-run方法的区别" class="headerlink" title="start和 run方法的区别"></a>start和 run方法的区别</h4><ul><li><p>直接调用 run 是在主线程中执行了 run，没有启动新的线程</p></li><li><p>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</p></li></ul><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p><h4 id="java里面线程有几种状态？"><a href="#java里面线程有几种状态？" class="headerlink" title="java里面线程有几种状态？"></a>java里面线程有几种状态？</h4><h5 id="操作系统-层面来描述"><a href="#操作系统-层面来描述" class="headerlink" title="操作系统 层面来描述"></a>操作系统 层面来描述</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112235300.png" alt="image-20231003112235300"></p><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li><li>【运行状态】指获取了 CPU 时间片运行中的状态 ：当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li><li>【阻塞状态】：如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】：等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】，阻塞状态与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h5 id="Java-API-层面来描述"><a href="#Java-API-层面来描述" class="headerlink" title="Java API 层面来描述"></a>Java API 层面来描述</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112238774.png" alt="image-20231003112238774"></p><ul><li><p>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code>。</p><p>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</p><p>BLOCKED：阻塞状态，需要等待锁释放。</p><p>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</p><p>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</p><p>TERMINATED：终止状态，表示该线程已经运行完毕.</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112242092.png" alt="image-20231003112242092"></p></li></ul><h4 id="阻塞和等待有什么区别？"><a href="#阻塞和等待有什么区别？" class="headerlink" title="阻塞和等待有什么区别？"></a>阻塞和等待有什么区别？</h4><p>造成原因不同：线程因为对共享资源竞争失败进入阻塞，而等待是因为api调用而进入等待</p><p>我们说一个操作是”阻塞”的，我们的意思是这个操作会<strong>停止线程的执行</strong>，直到某个条件得到满足。例如，在传统的同步I&#x2F;O中，一个读操作会阻塞线程，直到数据可用为止。<strong>在阻塞期间，线程不能做任何其他的事情，它只是停在那里，等待读操作完成。</strong></p><p>当我们说一个操作是”等待”的，我们的意思是这个操作会<strong>让出线程的控制权</strong>，直到某个条件得到满足。例如，在异步I&#x2F;O中，一个读操作（如ReadAsync）会立即返回一个任务，代表这个操作的完成情况。<strong>在等待这个任务时，线程可以去做其他的事情。这就是所谓的”非阻塞”行为。</strong></p><h4 id="什么情况下会让线程进入-block-状态"><a href="#什么情况下会让线程进入-block-状态" class="headerlink" title="什么情况下会让线程进入 block 状态"></a>什么情况下会让线程进入 block 状态</h4><ul><li>t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED</li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED</li></ul><h4 id="线程调用sleep方法，sleep-10s-，结束后，调用sleep的线程处于什么状态？"><a href="#线程调用sleep方法，sleep-10s-，结束后，调用sleep的线程处于什么状态？" class="headerlink" title="线程调用sleep方法，sleep(10s)，结束后，调用sleep的线程处于什么状态？"></a>线程调用sleep方法，sleep(10s)，结束后，调用sleep的线程处于什么状态？</h4><p><strong>Runable状态</strong></p><p>在sleep的时间内，线程不会释放临界资源，在sleep结束之后，线程正常运行，sleep一般是模拟一些业务，之后unlock就释放了临界资源，比如锁</p><h4 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h4><p><strong>使用位置不同</strong>：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用</p><p><strong>释放资源不同</strong>：调用wait方法时，该线程必须持有锁资源，<strong>wait 方法会主动的释放锁，而 sleep 方法则不会</strong></p><p><strong>源头不同</strong>：wait 方法属于 Object 类的方法，而 sleep 属于 Thread 类的方法</p><p>sleep 方法必须要传递一个超时时间的参数，且过了超时时间之后，线程会自动唤醒。而 wait 方法可以不传递任何参数，不传递任何参数时表示永久休眠，直到另一个线程调用了 notify 或 notifyAll 之后，休眠的线程才能被唤醒。也就是说 <strong>sleep 方法具有主动唤醒功能，而不传递任何参数的 wait 方法只能被动的被唤醒</strong>。<strong>调用 sleep 方法线程会进入 TIMED_WAITING 有时限等待状态，而调用无参数的 wait 方法，线程会进入 WAITING 无时限等待状态</strong></p><h4 id="为什么wait和notify方法要写在synchronized同步代码块中？"><a href="#为什么wait和notify方法要写在synchronized同步代码块中？" class="headerlink" title="为什么wait和notify方法要写在synchronized同步代码块中？"></a>为什么wait和notify方法要写在synchronized同步代码块中？</h4><p>这是Java设计者为了避免使用者出现lost wake up(可能导致线程陷入永久等待)问题而搞出来的。</p><p>列举下面永久等待的场景：</p><p>所以需要synchronized这样的同步机制来避免多线程并发修改这个共享变量，造成永久等待的问题</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112303623.png" alt="image-20231003112303623"></p><p>问题的根源在于，消费者在检查count到调用wait()之间，count就可能被改掉了。</p><p>常见的解决方式是加锁</p><p> wait 和 notify 用来实现多线程之间的协调，wait 表示让线程进入到阻塞状态，notify 表示让阻塞的线程唤醒。</p><p>wait 和 notify 必然是成对出现的，如果一个线程被 wait()方法阻塞，那么必然需要另外一个线程通过 notify()方法来唤醒这个被阻塞的线程，从而实现多线程之间的通信。</p><p>在多线程里面，要实现多个线程之间的通信，除了管道流以外，只能通过共享变量的方法来实现，也就是线程 t1 修改共享变量 s，线程 t2 获取修改后的共享变量 s，从而完成数据通信。</p><p>但是多线程本身具有并行执行的特性，也就是在同一时刻，多个线程可以同时执行。在这种情况下，线程 t2 在访问共享变量 s 之前，必须要知道线程 t1 已经修改过了共享变量 s，否则就需要等待。<br>同时，线程 t1 修改过了共享变量 S 之后，还需要通知在等待中的线程 t2。所以要在这种特性下要去实现线程之间的通信，就必须要有一个竞争条件控制线程在什么条件下等待，什么条件下唤醒。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231015195346379.png" alt="image-20231015195346379"></p><p>而 Synchronized 同步关键字就可以实现这样一个互斥条件，也就是在通过共享变量来实现多个线程通信的场景里面，参与通信的线程必须要竞争到这个共享变量的锁资源，才有资格对共享变量做修改，修改完成后就释放锁，那么其他的线程就可以再次来竞争同一个共享变量的锁来获取修改后的数据，从而完成线程之前的通信。</p><p>所以这也是为什么 wait&#x2F;notify 需要放在 Synchronized 同步代码块中的原因，有了 Synchronized 同步锁，就可以实现对多个通信线程之间的互斥，实现条件等待和条件唤醒。</p><h3 id="关键字与锁"><a href="#关键字与锁" class="headerlink" title="关键字与锁"></a>关键字与锁</h3><h4 id="类锁与对象锁的区别："><a href="#类锁与对象锁的区别：" class="headerlink" title="类锁与对象锁的区别："></a>类锁与对象锁的区别：</h4><h5 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a><strong>类锁</strong></h5><p>用synchronized修饰静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> method（）</span><br></pre></td></tr></table></figure><p>作用在代码块上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> method（）&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(object.class)&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类锁是加载类上的，而类信息是存在 JVM 方法区的，并且整个 JVM 只有一份，方法区又是所有线程共享的，所以类锁是所有线程共享的，所以同一时刻，只能有一个线程使用加了类锁的方法或方法体，不管是不是同一个实例。</p><h5 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h5><p>作用在实例方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> method（）&#123;&#125;</span><br></pre></td></tr></table></figure><p>作用在代码块上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> method（）&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">   <span class="comment">//这里是需要同步的部分</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用对象锁的情况，只有使用同一实例的线程才会受对象锁的影响，多个实例调用同一方法也不会受影响。</p><p><strong>类锁和对象锁不存在冲突</strong>，<strong>对象锁和类锁互不影响</strong>，可同时申请一个类的类锁、和该类某实例的对象锁</p><h4 id="说一下synchronized关键字底层原理"><a href="#说一下synchronized关键字底层原理" class="headerlink" title="说一下synchronized关键字底层原理"></a>说一下synchronized关键字底层原理</h4><p>synchronized的底层是通过monitor对象来实现的。</p><p>Java对象在内存中的布局大致可以分为三部分：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>填充对齐</strong>。因为<code>synchronized</code>用的锁是存在对象头里的，这里我们需要重点了解对象头。如果对象头是数组类型，则对象头由<strong>Mark Word</strong>、<strong>Class MetadataAddress</strong>和<strong>Array length</strong>组成，如果对象头非数组类型，对象头则由<strong>Mark Word</strong>和<strong>Class MetadataAddress</strong>组成。</p><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112246654.png" alt="image-20231003112246654"></p><p>monitor对象中有owner用来指示拥有锁的线程，entrylist来存放阻塞的线程（竞争失败的线程），waitSet来存放wating的线程（wait()方法），初始时，Monitor中的Owner为null，当第一个竞争锁的线程获得锁，其他的竞争这个锁的线程就会被放入EntryList等待，当获得锁的线程执行完同步代码块中的内容，就会唤醒EntryList中等待的线程，发生非公平竞争这个锁。<br>注意：<br>synchronized 必须是进入同一个对象的 monitor 才有上述的效果</p><p><strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p><p>上面的字节码中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 **对象监视器 <code>monitor</code>**（每个Java对象都可以关联一个monitor对象） 的持有权。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由[ObjectMonitoropen in new window](https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp)实现的。每个对象中都内置了一个 `ObjectMonitor`对象。</span><br><span class="line"></span><br><span class="line">另外，`wait/notify`等方法也依赖于`monitor`对象，这就是为什么只有在同步的块或者方法中才能调用`wait/notify`等方法，否则会抛出`java.lang.IllegalMonitorStateException`的异常的原因。</span><br></pre></td></tr></table></figure><p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112249933.png" alt="image-20231003112249933"></p><p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112256314.png" alt="image-20231003112256314"></p><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><h5 id="synchronized-修饰方法的的情况"><a href="#synchronized-修饰方法的的情况" class="headerlink" title="synchronized 修饰方法的的情况"></a>synchronized 修饰方法的的情况</h5><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p><p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p><h4 id="讲一讲AQS"><a href="#讲一讲AQS" class="headerlink" title="讲一讲AQS"></a>讲一讲AQS</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p><code>AbstractQueuedSynchronizer(AQS)</code>提供了一套可用于实现锁同步机制和其他同步组件的框架。<code>AQS通过一个</code>FIFO<code>队列维护线程同步状态，实现类只需要继承该类，并重写指定方法即可实现一套线程同步机制</code>。在JUC<code>中，诸如</code>ReentrantLock<code>、</code>CountDownLatch<code>等都基于</code>AQS&#96;实现。</p><p><code>AQS</code>根据资源互斥级别提供了<strong>独占和共享</strong>两种资源访问模式；同时其定义<code>Condition</code>结构提供了<code>wait/signal</code>等待唤醒机制。</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><code>AQS</code>维护了一个<code>volatile int state</code>变量（state &#x3D; 0 表示锁可用， state &#x3D;&gt; 1 表示锁已被占用）用来记录锁竞争的状态。</p><ul><li>一个线程来获得锁资源的时候首先会判断state是否等于0，如果是就把state更新为1，表示获得这个锁，为了防止多个线程同时更新state，AQS使用CAS保障state互斥变量更新的原子性。</li><li>未获得到锁的线程会阻塞，并按照先进先出的原则加入到双向链表中。</li></ul><p>当获得锁资源的线程释放锁后会从双向链表唤醒阻塞的线程。 </p><ul><li>AQS获取锁有公平竞争和非公平竞争，公平竞争就是在获取锁的时候，需要判断双向链表是否有阻塞的线程，如果有就需要去排队等待。 </li><li>非公平锁不管双向链表是否存在阻塞的线程，都会直接尝试更改state去获取锁。对于双向队列中阻塞的线程是不公平的</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112335241.png" alt="image-20231003112335241"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/e22dfb7003ee44afb6f80ddfbce68a93tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-1696303417939-13.webp" alt="img"></p><p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul><p><strong><code>Node</code>主要包含5个核心字段：</strong></p><ul><li><p>waitStatus</p><p>：当前节点状态，该字段共有5种取值：</p><ul><li><code>CANCELLED = 1</code>。节点引用线程由于等待超时或被打断时的状态。</li><li><code>SIGNAL = -1</code>。后继节点线程需要被唤醒时的当前节点状态。当队列中加入后继节点被挂起<code>(block)</code>时，其前驱节点会被设置为<code>SIGNAL</code>状态，表示该节点需要被唤醒。</li><li><code>CONDITION = -2</code>。当节点线程进入<code>condition</code>队列时的状态。(见<code>ConditionObject</code>)</li><li><code>PROPAGATE = -3</code>。仅在释放共享锁<code>releaseShared</code>时对头节点使用。(见共享锁分析)</li><li><code>0</code>。节点初始化时的状态。</li></ul></li><li><p><code>prev</code>：前驱节点。</p></li><li><p><code>next</code>：后继节点。</p></li><li><p><code>thread</code>：引用线程，头节点不包含线程。</p></li><li><p><code>nextWaiter</code>：<code>condition</code>条件队列。(见<code>ConditionObject</code>)</p></li></ul><h4 id="jdk1-7对synchorinzed的优化？"><a href="#jdk1-7对synchorinzed的优化？" class="headerlink" title="jdk1.7对synchorinzed的优化？"></a>jdk1.7对synchorinzed的优化？</h4><p>JDK1.6为了减少获得锁和释放锁所带来的性能消耗，引入了<strong>“偏向锁”</strong>和<strong>“轻量级锁”</strong>，所以在JDK1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。<strong>锁可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率</p><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁，顾名思义，它会偏向于第一个访问锁的线程</p><p>如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。线程第二次到达同步代码块时，会判断此时持有锁的线程是否就是自己，如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。<br>如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。<br>级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致<code>STW(stop the word)</code>操作</p><ul><li><h6 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h6><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象<br>的 Thread ID<br>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程</p></li><li><h6 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h6><p>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p></li></ul><h5 id="轻量级锁（还未关联monitor对象）"><a href="#轻量级锁（还未关联monitor对象）" class="headerlink" title="轻量级锁（还未关联monitor对象）"></a>轻量级锁（还未关联monitor对象）</h5><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以<br>使用轻量级锁来优化。当存在竞争时，锁膨胀升级为重量级锁来互斥访问。</p><p>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164622798.png" alt="image-20240322164622798"></p><p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164644569.png" alt="image-20240322164644569"></p><p>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164712066.png" alt="image-20240322164712066"></p><p>如果 cas 失败，有两种情况</p><ol><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li><li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li></ol><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164748554.png" alt="image-20240322164748554"></p><p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164814658.png" alt="image-20240322164814658"></p><p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</p><ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164905678.png" alt="image-20240322164905678"></p><p>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<strong>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</strong><br>然后自己进入 Monitor 的 EntryList BLOCKED</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240322164942030.png" alt="image-20240322164942030"></p><p>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁<br>流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</p><h5 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h5><p>重量级锁竞争的时候，如果竞争锁失败，该线程不会马上阻塞，使用自旋重试来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p><h4 id="Reentrantlock-与-synchronized-的区别"><a href="#Reentrantlock-与-synchronized-的区别" class="headerlink" title="Reentrantlock 与 synchronized 的区别"></a>Reentrantlock 与 synchronized 的区别</h4><p>Synchronized 可以通过两种方式来控制锁的粒度</p><ul><li>一种是把 synchronized 关键字修饰在方法层面，</li><li>另一种是修饰在代码块上，并且我们可以通过 Synchronized 加锁对象的声明周期来控制锁的作用范围，比如锁对象是静态对象或者类对象，那么这个锁就是全局锁。如果锁对象是普通实例对象，那这个锁的范围取决于这个实例的声明周期。</li></ul><p>Lock 锁的粒度是通过它里面提供的 lock()和 unlock()方法决定的（贴图），包裹在这两个方法之间的代码能够保证线程安全性。而锁的作用域取决于 Lock 实例的生命周期</p><p>相对于 synchronized 它具备如下特点</p><ul><li><strong>可以设置超时时间</strong>， Lock 还提供了非阻塞的竞争锁方法 tryLock(int time)方法，在规定时间获取不到锁会返回false</li><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li><li><strong>可实现选择性通知（支持多个条件变量）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul><p>与 synchronized 一样，都支持可重入</p><h4 id="公平锁与非公平锁？底层实现是什么"><a href="#公平锁与非公平锁？底层实现是什么" class="headerlink" title="公平锁与非公平锁？底层实现是什么"></a>公平锁与非公平锁？底层实现是什么</h4><p>底层都是AQS，默认一般使用<strong>非公平锁</strong>，它的效率和吞吐量都比公平锁高的多。由于公平锁需要关心队列的情况，得按照队列里的先后顺序来获取锁(会造成大量的线程上下文切换)，而非公平锁则没有这个限制。所以也就能解释非公平锁的效率会被公平锁更高。</p><p><strong>公平锁</strong>：</p><p>线程在tryAcquire（arg）尝试获得锁之前会利用 hasQueuedPredecessors() 方法来判断 AQS 的队列中中是否有其他线程，如果有则不会尝试获取锁(<strong>这是公平锁特有的情况</strong>)。</p><p>如果队列中没有线程就利用 CAS 来将 AQS 中的 state 修改为1，也就是获取锁，获取成功则将当前线程置为获得锁的独占线程(setExclusiveOwnerThread(current))。</p><p>如果 state 大于 0 时，说明锁已经被获取了，则需要判断获取锁的线程是否为当前线程(ReentrantLock 支持重入)，是则需要将 state + 1，并将值更新。</p><p>如果tryAcquire(arg) 获取锁失败，则需要用 addWaiter(Node.EXCLUSIVE) 将当前线程写入队列中。</p><p>写入之前需要将当前线程包装为一个 Node 对象(addWaiter(Node.EXCLUSIVE))，通过自旋加上 CAS 保证一定能写入队列。</p><p><strong>非公平锁</strong>：尝试获取锁时tryAcquire(arg)，非公平锁是不需要判断队列中是否还有其他线程，也是直接尝试获取锁：</p><h4 id="可中断锁和不可中断锁有什么区别？"><a href="#可中断锁和不可中断锁有什么区别？" class="headerlink" title="可中断锁和不可中断锁有什么区别？"></a>可中断锁和不可中断锁有什么区别？</h4><ul><li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li><li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁</li></ul><h4 id="volatile关键字的原理？怎么用？是否保证原子性？"><a href="#volatile关键字的原理？怎么用？是否保证原子性？" class="headerlink" title="volatile关键字的原理？怎么用？是否保证原子性？"></a>volatile关键字的原理？怎么用？是否保证原子性？</h4><p>由于JVM缓存优化，线程读变量值时，可能会到自己的工作缓存去读而不是到内存，所以当一个线程对变量执行写操作到内存，可能其他线程无法读到最新的变量值。</p><p>用法：在多线程读，一线程写的情况下，用来修饰成员变量和静态成员变量，这就指示 JVM，这个变量是共享且不稳定的，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。</p><h5 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112310433.png" alt="image-20231003112310433"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112313979.png" alt="image-20231003112313979"></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112317775.png" alt="image-20231003112317775"></p><p>Volatile关键字底层实现主要是<strong>通过汇编lock指令</strong>，当某个CPU修改了缓存里面的数据，该数据会马上通过总线同步回主存，（lock指令开启其他CPU的总线嗅探机制）其他CPU通过一个<strong>总线嗅探机制</strong>来感知数据的变化从而将自己缓存里面的数据失效，需要使用这个数据，必须重新去内存中获取最新的数据，来保证数据的可见性。</p><h5 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h5><p>当对volatile修饰变量赋值，会加上写屏障，写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当对volatile修饰变量取值，会加上读屏障，读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不能解决指令交错（无法保证原子性）："><a href="#不能解决指令交错（无法保证原子性）：" class="headerlink" title="不能解决指令交错（无法保证原子性）："></a>不能解决指令交错（无法保证原子性）：</h5><p>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去<br>而有序性的保证也只是保证了本线程内相关代码不被重排序</p><h4 id="synchronized关键字保证可见性和有序性"><a href="#synchronized关键字保证可见性和有序性" class="headerlink" title="synchronized关键字保证可见性和有序性"></a>synchronized关键字保证可见性和有序性</h4><p>我们都知道sychronized底层是通过monitorenter的指令来进行加锁的、通过monitorexit指令来释放锁的。</p><p>但是很多人都不知道的一点是，monitorenter指令其实还具有Load屏障的作用。</p><p>也就是通过monitorenter指令之后，synchronized内部的共享变量，每次读取数据的时候被强制从主内存读取最新的数据。</p><p>同样的道理monitorexit指令也具有Store屏障的作用，也就是让synchronized代码块内的共享变量，如果数据有变更的，强制刷新回主内存。</p><p>这样通过这种方式，数据修改之后立即刷新回主内存，其他线程进入synchronized代码块后，使用共享变量的时候强制读取主内存的数据，上一个线程对共享变量的变更操作，它就能立即看到了。</p><p>同时synchronized加的内存屏障也能保证内部代码的有序性</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112322766.png" alt="image-20231003112322766"></p><h4 id="为什么单线程不需要这个volatile关键字多线程需要"><a href="#为什么单线程不需要这个volatile关键字多线程需要" class="headerlink" title="为什么单线程不需要这个volatile关键字多线程需要"></a>为什么单线程不需要这个volatile关键字多线程需要</h4><p>因为在单线程的环境下，只有一个线程会使用修改的变量，变量不存在可见性问题。同时，单线程下，JVM的指令重排序也不会改变执行结果。</p><h4 id="为什么会出现指令重排序："><a href="#为什么会出现指令重排序：" class="headerlink" title="为什么会出现指令重排序："></a>为什么会出现指令重排序：</h4><p>指令还可以再划分成一个个更小的阶段，在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行，从而提高CPU的吞吐率。</p><h4 id="讲一下CAS"><a href="#讲一下CAS" class="headerlink" title="讲一下CAS"></a>讲一下CAS</h4><p>CAS（Compare And Swap）是一种无锁同步机制，基于乐观锁的思想，但是它底层还是有用到锁的，使用总线锁锁住总线，确保在比较替换的过程中没有其他线程对该值进行修改，保障比较并替换的原子性。</p><p><strong>CAS 必须借助 volatile</strong> 才能读取到共享变量的最新值来实现【比较并交换】的效果</p><p>CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。</p><p>CAS指令执行时，通过发送一个lock指令锁住总线，确保整个比较并替换的操作是一个原子操作。<strong>当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则放弃对数据的操作。</strong></p><p>cas可以不用自旋重试机制，失败也可以直接返回false。只是一般应用场景下，cas都会带有重试机制（while和for实现空转，不断尝试）</p><h5 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h5><ul><li>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、竞争较少，多核 CPU 的场景下。</li><li>CAS 是基于乐观锁的思想：最乐观的估计，预计很少出现并发问题，当出现后，再重试。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，当一个线程上了锁，其他线程只能阻塞等待解锁。使得线程只能串行访问同步代码块，效率较低。</li><li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思</li><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到CAS自旋重试必然频繁发生，反而效率会受影响</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p><strong>CAS长时间自旋开销很大：</strong>我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</p><p><strong>只能保证一个共享变量的原子操作：</strong>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p><p><strong>ABA*问题</strong>：<strong>通过版本号法解决。</strong>Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p><h5 id="用处："><a href="#用处：" class="headerlink" title="用处："></a>用处：</h5><p>Automic原子类，多线程的互斥同步等</p><h4 id="乐观锁和悲观锁的区别？"><a href="#乐观锁和悲观锁的区别？" class="headerlink" title="乐观锁和悲观锁的区别？"></a>乐观锁和悲观锁的区别？</h4><h5 id="什么悲观锁？"><a href="#什么悲观锁？" class="headerlink" title="什么悲观锁？"></a><strong>什么悲观锁？</strong></h5><p>悲观锁是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;</p><p>特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p><h5 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a><strong>什么是乐观锁？</strong></h5><p>乐观锁是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);</p><p>特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。</p><h5 id="理论上来说："><a href="#理论上来说：" class="headerlink" title="理论上来说："></a>理论上来说：</h5><ul><li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li><li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li></ul><h4 id="ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？"><a href="#ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？" class="headerlink" title="ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？"></a>ThreadLocal是什么？怎么用？内存泄漏？在项目中的运用？</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112342131.png" alt="image-20231003112342131"></p><p>threadLocal 是一个用来解决线程安全性问题的工具。它相当于让每个线程都开辟一块内存空间，用来存储共享变量的副本。<br>然后每个线程只需要访问和操作自己的共享变量副本即可，从而避免多线程竞争同一个共享资源。<br>它的工作原理很简单（如图）</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112345346.png" alt="image-20231003112345346"></p><p>每个线程里面有一个成员变量 ThreadLocalMap,<br>当线程访问用 ThreadLocal 修饰的共享数据的时候<br>这个线程就会在自己成员变量 ThreadLocalMap 里面保存一份数据副本。<br>key 指向 ThreadLocal 这个引用，并且是弱引用关系，而 value 保存的是共享数据的副本。<br>因为每个线程都持有一个副本，所以就解决了线程安全性问题。</p><p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用<strong>弱引用</strong>的ThreadLocal实例，value为线程变量的副本。这些对象之间的引用关系如下,</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112348542.png" alt="image-20231003112348542"></p><blockquote><p>实心箭头表示强引用，空心箭头表示弱引用</p></blockquote><h5 id="ThreadLocal-内存泄漏的原因"><a href="#ThreadLocal-内存泄漏的原因" class="headerlink" title="ThreadLocal 内存泄漏的原因"></a>ThreadLocal 内存泄漏的原因</h5><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>由于Thread中包含变量ThreadLocalMap，因此ThreadLocalMap与Thread的生命周期是一样长，如果都没有手动删除对应key，都会导致内存泄漏。</p><p>但是使用<strong>弱引用</strong>可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set(),get(),remove()的时候会被清除。</p><p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p><h5 id="ThreadLocal正确的使用方法"><a href="#ThreadLocal正确的使用方法" class="headerlink" title="ThreadLocal正确的使用方法"></a>ThreadLocal正确的使用方法</h5><ul><li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li><li>(将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 )</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="单核-CPU-上运行多个线程效率一定会高吗？"><a href="#单核-CPU-上运行多个线程效率一定会高吗？" class="headerlink" title="单核 CPU 上运行多个线程效率一定会高吗？"></a>单核 CPU 上运行多个线程效率一定会高吗？</h4><p>单核CPU同时运行多个线程的效率是否会高，取决于线程的类型和任务的性质。两种类型的线程：CPU密集型和IO密集型。</p><ul><li>CPU密集型的线程主要进行计算和逻辑处理，需要占用大量的CPU资源。</li><li>IO密集型的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待IO设备的响应，而不占用太多的CPU资源。</li></ul><p>在单核CPU上，同一时刻只能有一个线程在运行，其他线程需要等待CPU的时间片分配。如果线程是CPU密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。</p><p>如果线程是IO密集型的，那么多个线程同时运行可以利用CPU在等待IO时的空闲时间，提高了效率。</p><p>因此，对于单核CPU来说，如果任务是CPU密集型的，那么开很多线程会影响效率；如果任务是IO密集型的，那么开很多线程会提高效率。当然，这里的“很多”也要适度，不能超过系统能够承受的上限。</p><h4 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h4 id="线程池的缺点"><a href="#线程池的缺点" class="headerlink" title="线程池的缺点"></a>线程池的缺点</h4><ul><li>可能引发死锁：在使用线程池时，如果任务之间存在依赖关系，或者线程因为资源的竞争，可能会引发死锁问题，需要额外的注意和处理。</li><li>不能对于线程池中任务设置优先级，只能按照先来先服务的策略</li><li><strong>难以调试</strong>: 线程池中的线程是由线程池管理的，因此在出现问题时，很难追踪和调试特定的线程。这可能会增加故障排除的难度。</li></ul><h4 id="线程池的拒绝策略有哪些？"><a href="#线程池的拒绝策略有哪些？" class="headerlink" title="线程池的拒绝策略有哪些？"></a>线程池的拒绝策略有哪些？</h4><p>若线程池中的核心线程数被用完且阻塞队列已排满，则此时线程池的资源已耗尽，线程池将没有足够的线程资源执行新的任务。为了保证操作系统的安全，线程池将通过拒绝策略处理新添加的线程任务。</p><h5 id="1-AbortPolicy（默认策略）"><a href="#1-AbortPolicy（默认策略）" class="headerlink" title="1. AbortPolicy（默认策略）"></a><strong>1. AbortPolicy</strong>（默认策略）</h5><p>第一种拒绝策略是 <code>AbortPolicy</code>，这种拒绝策略在拒绝任务时，会直接抛出一个类型为 RejectedExecutionException的RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。</p><h5 id="2-DiscardPolicy"><a href="#2-DiscardPolicy" class="headerlink" title="2.DiscardPolicy"></a><strong>2.DiscardPolicy</strong></h5><p>第2种拒绝策略是 <code>DiscardPolicy</code>，这种拒绝策略正如它的名字所描述的一样，当新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失。</p><h5 id="3-DiscardOldestPolicy"><a href="#3-DiscardOldestPolicy" class="headerlink" title="3.DiscardOldestPolicy"></a><strong>3.DiscardOldestPolicy</strong></h5><p>第3种拒绝策略是 <code>DiscardOldestPolicy</code>，如果线程池没被关闭且没有能力执行，则会丢弃任务队列中的头结点，通常是存活时间最长的任务，这种策略与第二种不同之处在于它丢弃的不是最新提交的，而是队列中存活时间最长的，这样就可以腾出空间给新提交的任务，但同理它也存在一定的数据丢失风险。</p><h5 id="4-CallerRunsPolicy"><a href="#4-CallerRunsPolicy" class="headerlink" title="4.CallerRunsPolicy"></a><strong>4.CallerRunsPolicy</strong></h5><p>第4种拒绝策略是 CallerRunsPolicy，相对而言它就比较完善了，当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。这样做主要有两点好处。</p><ol><li>第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。</li><li>第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。</li></ol><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>本文中我们学习线程池中的4 种默认的拒绝策略。线程池会在以下两种情况下会拒绝新提交的任务。</p><ul><li>第一种情况是当我们调用 shutdown 等方法关闭线程池后，即便此时可能线程池内部依然有没执行完的任务正在执行，但是由于线程池已经关闭，此时如果再向线程池内提交任务，就会遭到拒绝。</li><li>第二种情况是线程池没有能力继续处理新提交的任务，也就是工作已经非常饱和的时候。</li></ul><p>线程池状态</p><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003112330381.png" alt="image-20231003112330381"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c 为旧值， ctlOf 返回结果为新值</span></span><br><span class="line">ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));</span><br><span class="line"><span class="comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><h4 id="Excetors工具类提供了哪些线程池？有什么问题吗？"><a href="#Excetors工具类提供了哪些线程池？有什么问题吗？" class="headerlink" title="Excetors工具类提供了哪些线程池？有什么问题吗？"></a>Excetors工具类提供了哪些线程池？有什么问题吗？</h4><p>四种阻塞队列</p><p>*<strong>基于数组的先进先出队列，有界</strong></p><ul><li>new ArrayBlockingQueue&lt;&gt;(10)</li></ul><p>生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行</p><p><strong>由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列</strong></p><ul><li>new LinkedBlockingQueue&lt;&gt;()</li></ul><p>生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p><p><strong>无缓冲的等待队列，无界</strong></p><ul><li>new SynchronousQueue&lt;&gt;()</li></ul><p>不存储元素的阻塞队列，也即单个元素的队列。</p><p><strong>使用优先级队列实现的延迟无界阻塞队列。</strong></p><p>new DelayQueue&lt;&gt;()<br>DelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p><p>Executors中创建线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Executors</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建固定数量线程的线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这是最后一个参数--阻塞队列调用的方法，长度是Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     * public LinkedBlockingQueue() &#123;</span></span><br><span class="line"><span class="comment">     *    this(Integer.MAX_VALUE);</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建只有一个线程的线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这是最后一个参数--阻塞队列调用的方法，长度也是Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     * public LinkedBlockingQueue() &#123;</span></span><br><span class="line"><span class="comment">     *    this(Integer.MAX_VALUE);</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created single-threaded Executor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *创建一个缓冲线程池 </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这是最后一个参数--阻塞队列调用的方法</span></span><br><span class="line"><span class="comment">     * public SynchronousQueue() &#123;</span></span><br><span class="line"><span class="comment">     *    this(false);</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 它的第二个参数，maximumPoolSize 为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a thread pool that can schedule commands to run after a</span></span><br><span class="line"><span class="comment">     * given delay, or to execute periodically.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 创建一个可以在给定延迟后再执行或定期执行命令的线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ScheduledThreadPoolExecutor 是 ThreadPoolExecutor 的子类，代码如下：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor</span></span><br><span class="line"><span class="comment">        implements ScheduledExecutorService &#123;</span></span><br><span class="line"><span class="comment">            //这是下面调用的构造方法，其实是调用了父类的构造方法,这些参数都是下面分析的参数</span></span><br><span class="line"><span class="comment">            public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span></span><br><span class="line"><span class="comment">               super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span></span><br><span class="line"><span class="comment">               new DelayedWorkQueue());</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FixedThreadPool 和 SingleThreadExecutor 传入的最后一个参数阻塞队列 ”workQueue“，默认的长度是INTEGER.MAX_VALUE，而它们允许的最大线程数量又是有限的，所以当请求线程的任务过多线程不够用时，它们会在队列中等待，又因为队列的长度特别长，所以可能会堆积大量的请求，导致OOM。</p><p>CachedThreadPool 和 ScheduledThreadPool 它们的阻塞队列长度有限，但是传入的第二个参数maximumPoolSize 为Integer.MAX_VALUE，这就意味着当请求线程的任务过多线程不够而且队列也满了的时候，线程池就会创建新的线程，因为它允许的最大线程数量是相当大的，所以可能会创建大量线程，导致OOM。</p><p>Executors类中封装好的创建线程池的方法使用方便，但是也有其局限性和风险性，所以我们可以使用 ThreadPoolExecutor 类中的构造方法手动创建线程池的实例， 从而可以根据我们的使用情况来指定参数，满足使用的同时又能规避风险。<br>所以，说白了，使用Executors类创建线程池与使用ThreadPoolExecutor类的区别就是使用ThreadPoolExecutor类可以自定义传入我们设置的线程池的参数，更加灵活。</p><h4 id="线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列"><a href="#线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列" class="headerlink" title="线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列"></a>线程池七大参数，向线程池提交任务，为什么核心线程池已满后要加入到等待队列</h4><ul><li><h5 id="corePoolSize-核心线程数目-正常情况下最多保留的线程数"><a href="#corePoolSize-核心线程数目-正常情况下最多保留的线程数" class="headerlink" title="corePoolSize 核心线程数目 (正常情况下最多保留的线程数)"></a>corePoolSize 核心线程数目 (正常情况下最多保留的线程数)</h5></li></ul><p>线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。任务提交到线程池后，首先会检查当前线程数是否达到了corePoolSize，如果没有达到的话，则会创建一个新线程来处理这个任务。</p><ul><li><h5 id="maximumPoolSize-最大线程数目"><a href="#maximumPoolSize-最大线程数目" class="headerlink" title="maximumPoolSize 最大线程数目"></a>maximumPoolSize 最大线程数目</h5></li></ul><p>当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务缓存到工作队列（后面会介绍）中。如果队列也已满，则会去创建一个新线程来出来这个处理。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即maximunPoolSize指定</p><ul><li><h5 id="keepAliveTime-生存时间-针对救急线程，当没有任务一段时间会被销毁"><a href="#keepAliveTime-生存时间-针对救急线程，当没有任务一段时间会被销毁" class="headerlink" title="keepAliveTime 生存时间 - 针对救急线程，当没有任务一段时间会被销毁"></a>keepAliveTime 生存时间 - 针对救急线程，当没有任务一段时间会被销毁</h5></li></ul><p>线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 <code>corePoolSize</code> ，回收过程才会停止。</p><ul><li><h5 id="unit-时间单位-针对多余空闲线程，-救急线程存活时间单位"><a href="#unit-时间单位-针对多余空闲线程，-救急线程存活时间单位" class="headerlink" title="unit 时间单位 - 针对多余空闲线程， 救急线程存活时间单位"></a>unit 时间单位 - 针对多余空闲线程， 救急线程存活时间单位</h5></li><li><h5 id="workQueue-阻塞队列"><a href="#workQueue-阻塞队列" class="headerlink" title="workQueue 阻塞队列"></a>workQueue 阻塞队列</h5></li></ul><p>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程</p><ul><li><h5 id="threadFactory-线程工厂-可以为线程创建时起个好名字"><a href="#threadFactory-线程工厂-可以为线程创建时起个好名字" class="headerlink" title="threadFactory 线程工厂 - 可以为线程创建时起个好名字"></a>threadFactory 线程工厂 - 可以为线程创建时起个好名字</h5></li></ul><p>创建一个新线程时使用的工厂，可以用来<strong>设定线程名、是否为daemon（守护线程）线程</strong>等等</p><ul><li><h5 id="handler-拒绝策略"><a href="#handler-拒绝策略" class="headerlink" title="handler 拒绝策略"></a>handler 拒绝策略</h5></li></ul><p>当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，就会采用拒绝策略</p><h4 id="为什么线程池创建新线程需要获取全局锁？"><a href="#为什么线程池创建新线程需要获取全局锁？" class="headerlink" title="为什么线程池创建新线程需要获取全局锁？"></a>为什么线程池创建新线程需要获取全局锁？</h4><ol><li><strong>线程池的状态管理</strong>：线程池需要跟踪已创建的线程数、空闲线程数、正在运行的任务等状态信息。这些状态信息需要在多线程环境下进行更新和访问，因此需要使用全局锁来确保状态的一致性，防止多个线程同时修改状态信息导致的竞态条件。</li><li><strong>线程资源管理</strong>：线程池通常会限制创建的线程数量，以避免因为创建过多线程导致系统资源耗尽或者性能下降。因此，在创建新线程之前需要检查当前已创建的线程数量，这涉及到对线程池状态的读取和更新，需要使用全局锁来确保一致性。</li></ol><h4 id="execute源码步骤"><a href="#execute源码步骤" class="headerlink" title="execute源码步骤"></a>execute源码步骤</h4><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-c2f64c062ff28d9ca7b37a2624367fb3_1440w.webp" alt="img"></p><p>从上图可以把execute方法主要分三个步骤：</p><ul><li>首先如果当前工作线程数小于核心线程，则调用addWorker(command, true)方法创建核心线程执行任务。</li><li>其次如果当前线程大于核心线程数则判断等待队列是否已满，如果没有满则添加任务到等待队列中去，如果工作线程数量为0则调用addWorker(null, false)方法创建非核心线程，并从等待队列中拉取任务执行。</li><li>最后如果队列已满则会调用addWorker(command, false)方法创建一个非核心线程执行任务。如果创建失败则会拒绝任务。</li></ul><p><strong>简单来说就是优先核心线程，其次等待队列，最后非核心线程。</strong></p><h5 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h5><p><strong>可以看到execute中最关键的就是addWorker方法</strong>，它接受两个参数：</p><ul><li>第一个参数是要执行的任务，如果为null那么会从等待队列中拉取任务；</li><li>第二个参数是表示是否核心线程，用来控制addWorker方法流程的；</li></ul><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-757aff298fc6e148b609037749de418c_1440w.webp" alt="img"></p><p>流程中去除一些异常情况，只留了主要流程，流程中有一步验证线程数大于核心线程或者最大线程数</p><ul><li>如果传递的参数core等于true那么运行线程数量不能大于核心线程数量，</li><li>如果为false则当前线程数量不能大于最大线程数。</li></ul><p><strong>addWorker只有两个作用：增加工作线程数量、创建一个Worker并加到工作线程集合中。</strong></p><h5 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h5><p>Worker类就是线程池中执行任务的类，主要源码和解释如下图：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-19a9c0570d56fb82d57680103305496d_1440w.webp" alt="img"></p><p>所以Worker本身就是一个Runnable，它有两个属性thead、firstTask；那我们就可以来梳理一下整体的运行流程了：</p><p><strong>线程池调用execute</strong>—&gt;<strong>创建Worker（设置属性thead、firstTask）</strong>—&gt;**worker.thread.start()**—&gt;**实际上调用的是worker.run()**—&gt;**线程池的runWorker(worker)**—&gt;<strong>worker.firstTask.run()</strong>(如果firstTask为null就从等待队列中拉取一个)。</p><p>转了一大圈最终调用最开始传进来的任务的run方法，不过通过等待队列可以重复利用worker与worker中的线程，变化的只是firstTask；</p><h4 id="submit和execute的区别"><a href="#submit和execute的区别" class="headerlink" title="submit和execute的区别:"></a>submit和execute的区别:</h4><p><font color = gold>execute和submit最大的区别就是execute没有返回值，submit有返回值。submit返回的是一个future ，可以通过这个future取到线程执行的结果或者异常信息。</font></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/637fd0fa146c4bb4be2e6cbaefb9bc6ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="图片"></p><p>submit不打印异常信息，而execute则会打印异常信息！，submit的方式不打印异常信息，显然在生产中，是不可行的，因为我们无法保证线程中的任务永不异常，而如果使用submit的方式出现了异常，直接如上写法，我们将无法获取到异常信息，做出对应的判断和处理，所以下一步需要知道如何获取线程池抛出的异常！</p><p><code>submit()</code>想要获取异常信息就必须使用<code>get()</code>方法！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当线程池抛出异常后 submit无提示，其他线程继续执行</span></span><br><span class="line">Future&lt;?&gt; submit = executorService.submit(<span class="keyword">new</span> <span class="title class_">task</span>());</span><br><span class="line">submit.get();</span><br></pre></td></tr></table></figure><p>submit打印异常信息如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/4cdc421e484c4468ab052ff82c500a39tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="图片"></p><p>submit源码在底层还是调用的execute方法，只不过多一层Future封装，并返回了这个Future，这也解释了为什么submit会有返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//submit()方法</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//execute内部执行这个对象内部的逻辑，然后将结果或者异常 set到这个ftask里面</span></span><br><span class="line">     RunnableFuture&lt;T&gt; ftask = newTaskFor(task); </span><br><span class="line">     <span class="comment">// 执行execute方法</span></span><br><span class="line">     execute(ftask); </span><br><span class="line">     <span class="comment">//返回这个ftask</span></span><br><span class="line">     <span class="keyword">return</span> ftask;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>如果用execute提交的任务，会被封装成了一个runable任务，然后进去 再被封装成一个worker,最后在worker的run方法里面调用runWoker方法， <code>runWoker</code>方法里面执行任务任务，如果任务出现异常，用<code>try-catch</code>捕获异常往外面抛，我们在最外层使用<code>try-catch</code>捕获到了 <code>runWoker</code>方法中抛出的异常。因此我们在execute中看到了我们的任务的异常信息。</li><li><font color = gold>submit是将任务封装成了一个<code>futureTask</code></font> ，然后这个<code>futureTask</code>被封装成worker，在woker的run方法里面，最终调用的是<code>futureTask</code>的run方法， 里面是直接吞掉了异常，并没有抛出异常，因此在worker的<code>runWorker</code>方法里面无法捕获到异常。</li></ul><p>下面来看一下<code>futureTask</code>的run方法，在try-catch中吞掉了异常，将异常放到了 <code>setException(ex);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">         !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                      <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Callable&lt;V&gt; c = callable;</span><br><span class="line">         <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">             V result;</span><br><span class="line">             <span class="type">boolean</span> ran;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 result = c.call();</span><br><span class="line">                 ran = <span class="literal">true</span>;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                 result = <span class="literal">null</span>;</span><br><span class="line">                 ran = <span class="literal">false</span>;</span><br><span class="line">                 <span class="comment">//在此方法中设置了异常信息</span></span><br><span class="line">                 setException(ex);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (ran)</span><br><span class="line">                 set(result);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//省略下文</span></span><br><span class="line">         。。。。。</span><br><span class="line">        <span class="comment">//setException(ex)`方法如下：将异常对象赋予`outcome</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setException</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">//将异常对象赋予outcome，记住这个outcome，</span></span><br><span class="line">           outcome = t;</span><br><span class="line">           UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">           finishCompletion();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>将异常对象赋予<code>outcome</code>有什么用呢？这个<code>outcome</code>是什么呢？当我们使用submit返回Future对象，并使用<code>Future.get()</code>时， 会调用内部的report方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="comment">//注意这个方法</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reoport里面实际上返回的是outcome ,刚好之前的异常就set到了这个outcome里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException &#123;</span><br><span class="line"> <span class="comment">//设置`outcome`</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">     <span class="comment">//返回`outcome`</span></span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color = gold>因此，在用submit提交的时候，runable对象被封装成了future ，future 里面的 run方法在处理异常时， <code>try-catch</code>了所有的异常，通过<code>setException(ex);</code>方法设置到了变量outcome里面， 可以通过<code>future.get</code>获取到outcome。</font></p><p><strong>在submit提交的时候，里面发生了异常， 是不会有任何抛出信息的。而通过<code>future.get（）</code>可以获取到submit抛出的异常！</strong>在submit里面，除了从返回结果里面取到异常之外, 没有其他方法。因此，在不需要返回结果的情况下，<strong>最好用execute ，这样就算没有写<code>try-catch</code>，疏漏了异常捕捉，也不至于丢掉异常信息</strong>。</p><h5 id="解决异常："><a href="#解决异常：" class="headerlink" title="解决异常："></a>解决异常：</h5><p><strong>方案一：在run()方法中使用 try -catch</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">ThreadPoolException</span> &#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个线程池</span></span><br><span class="line">        <span class="title class_">ExecutorService</span> executorService = <span class="title class_">Executors</span>.<span class="title function_">newFixedThreadPool</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当线程池抛出异常后 submit无提示，其他线程继续执行</span></span><br><span class="line">        executorService.<span class="title function_">submit</span>(<span class="keyword">new</span> <span class="title function_">task</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当线程池抛出异常后 execute抛出异常，其他线程继续执行新任务</span></span><br><span class="line">        executorService.<span class="title function_">execute</span>(<span class="keyword">new</span> <span class="title function_">task</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">task</span> implements <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    @<span class="title class_">Override</span></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;进入了task方法！！！&quot;</span>);</span><br><span class="line">            int i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) &#123;</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;使用了try -catch 捕获异常&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/52929d67d8707f0909d7b9c3125cf590.png" alt="img"></p><p>可以看到 submit 和 execute都清晰易懂的捕获到了异常，可以知道我们的任务出现了问题，而不是消失的无影无踪。</p><p><strong>实现 ThreadFactory，自定义线程工厂类（推荐）</strong></p><p>第一种方法需要我们在每个任务中手动添加 try-catch 代码块，这样做非常繁琐且不可靠。为了避免重复工作，我们可以通过自定义线程工厂类来实现。线程池创建工作线程时会使用 ThreadFactory 的实现类来创建线程，因此我们只需要实现 ThreadFactory 接口，自定义线程工厂类，并将其传递给创建线程池的构造方法中。</p><p>自定义线程工厂方法，为每一个 run 方法添加 try-catch 代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">poolNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    CustomThreadFactory() &#123;</span><br><span class="line">        namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                poolNumber.getAndIncrement() +</span><br><span class="line">                <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, namePrefix + threadNumber.getAndIncrement()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">super</span>.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;异常信息：&quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color = gold>当使用 submit 方法提交的任务出现异常时，仍然无法进行处理,因为在run()方法中出现异常被内部捕获了，但至少解决了在 execute 方法中任务出现异常的情况。对于 FutureTask 的异常，调用方需要自行处理，因为 FutureTask 设计的本意就是将结果交给调用方处理，这个结果也包含异常。</font></p><h4 id="为什么核心线程池满了后-不直接创建新的线程去执行新任务？而是先交给任务队列呢？"><a href="#为什么核心线程池满了后-不直接创建新的线程去执行新任务？而是先交给任务队列呢？" class="headerlink" title="为什么核心线程池满了后 不直接创建新的线程去执行新任务？而是先交给任务队列呢？"></a>为什么核心线程池满了后 不直接创建新的线程去执行新任务？而是先交给任务队列呢？</h4><p><strong>因为如果核心线程满了就创建新的线程去执行，达到最大线程数之后再放入队列，那么新创建线程就需要获取全局锁，对性能有很大的损耗。</strong>而且如果正在被核心线程执行的任务很快的执行完，就可以直接从任务队列中取出新的任务执行。</p><p>ThreadPoolExecutor 采取上述步 骤 的 总 体 设计 思路，是 为 了在 执 行 execute() 方法时，尽可能地避免获取全局锁 （创建新的线程需要先获取全局锁、销毁线程也需要获取全局锁mainLock）。而从阻塞队列中取任务来执行不需要获取全局锁</p><p> <img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/8477e7c513404fcfa6aa2c57dc335019.png" alt="img"></p><h4 id="阻塞队列的作用是什么"><a href="#阻塞队列的作用是什么" class="headerlink" title="阻塞队列的作用是什么"></a>阻塞队列的作用是什么</h4><ul><li>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使线程进入wait状态，释放CPU资源</li><li>阻塞队列自带阻塞和唤醒的功能，不需要额外处理，无任务执行时，线程池利用阻塞队列的take方法挂起，从而维持核心线程的存活，不至于一直占的CPU资源</li></ul><h4 id="使用阻塞队列需要注意什么"><a href="#使用阻塞队列需要注意什么" class="headerlink" title="使用阻塞队列需要注意什么"></a>使用阻塞队列需要注意什么</h4><ol><li><strong>异常处理</strong>：在使用阻塞队列时，需要注意异常处理机制。例如，在使用有界阻塞队列时，如果队列已满而无法接受新任务，可能会触发拒绝策略，需要合理处理拒绝策略以防止任务丢失。</li><li><strong>选择合适的阻塞队列类型</strong>：Java 提供了多种阻塞队列实现，如 <code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>PriorityBlockingQueue</code> 等。选择合适的队列类型需要考虑线程池的特性、任务处理情况以及性能需求。</li><li><strong>队列容量设置</strong>：阻塞队列的容量设置需要根据系统负载和任务处理速度进行合理的调整。如果任务处理速度远快于任务提交速度，可能会导致队列溢出，从而触发拒绝策略。因此，需要根据具体情况设置合适的队列容量。</li></ol><h4 id="创建多少核心线程数合适（线程池的参数怎么设计）"><a href="#创建多少核心线程数合适（线程池的参数怎么设计）" class="headerlink" title="创建多少核心线程数合适（线程池的参数怎么设计）"></a>创建多少核心线程数合适（线程池的参数怎么设计）</h4><ul><li>过小会导致程序不能充分地利用系统资源、容易导致饥饿</li><li>过大会导致更多的线程上下文切换，占用更多内存</li></ul><h5 id="CPU-密集型运算"><a href="#CPU-密集型运算" class="headerlink" title="CPU 密集型运算"></a>CPU 密集型运算</h5><p>通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p><h5 id="I-O-密集型运算"><a href="#I-O-密集型运算" class="headerlink" title="I&#x2F;O 密集型运算"></a>I&#x2F;O 密集型运算</h5><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。<br>经验公式如下</p><p>线程数 &#x3D; 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) &#x2F; CPU 计算时间</p><p>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式</p><p>4 * 100% * 100% &#x2F; 50% &#x3D; 8</p><p>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式</p><p>4 * 100% * 100% &#x2F; 10% &#x3D; 40</p><p><strong>公示也只是参考，具体还是要根据项目实际线上运行情况来动态调整</strong>，包括核心线程数、最大线程数、自定义任务队列等等</p><h4 id="假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？"><a href="#假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？" class="headerlink" title="假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？"></a>假如有一个高并发低延迟的业务和一个低并发高延迟的业务，应该核心线程的数量应该怎么设置？</h4><ul><li>高并发低延迟业务，低延迟说明大概率是CPU密集型，高并发的情况下为了防止大量的上下文切换，核心线程数不宜设置太高，应该设置大概CPU核数 + 1个线程，</li><li>低并发高延迟业务，高延迟说明所需数据或外部资源需要较长时间等待，大概率是IO密集型，核心线程数应该设置为    CPU 核数 * 总时间(CPU计算时间+等待时间) &#x2F; CPU 计算时间</li></ul><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><h4 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h4><h5 id="LongAdder的成员变量"><a href="#LongAdder的成员变量" class="headerlink" title="LongAdder的成员变量"></a><strong>LongAdder的成员变量</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPU的数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">// Cell对象的数组，长度一般是2的指数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="comment">// 基础value值，当并发较低时，只累加该值</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"><span class="comment">// 创建或者扩容Cells数组时使用的自旋锁变量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br></pre></td></tr></table></figure><p>当并发量较少时，cell数组尚未初始化，所以只调用<code>casBase</code>函数，对base变量进行CAS累加。</p><p>并发量大时，放弃使用base变量，而是从cells数组中随机选择一个cell，CAS累加，这样就可以减少并发冲突，获取值就用base加上cells中所有元素累加获得值，遍历数组不是个原子操作，所以LongAdder取到的值不是最新值，再获取精确计数的场景，可能不适合。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20240329130947920.png" alt="image-20240329130947920"></p><h4 id="CountdownLatch和CyclicBarrier的区别使用场景与具体实现"><a href="#CountdownLatch和CyclicBarrier的区别使用场景与具体实现" class="headerlink" title="CountdownLatch和CyclicBarrier的区别使用场景与具体实现"></a>CountdownLatch和CyclicBarrier的区别使用场景与具体实现</h4><p><a href="https://zhuanlan.zhihu.com/p/139020914">CountdownLatch和CyclicBarrier的区别使用场景与具体实现 - 知乎 (zhihu.com)</a></p><p><strong>CountdownLatch 使用场景</strong></p><p>顾名思义CountdownLatch可以当做一个计数器来使用,比如主线程需要等待其他几个线程都执行过某个时间节点后才能继续执行 我们来模拟一个场景,某公司一共有十个人,门卫要等十个人都来上班以后,才可以休息,代码实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//lambda中只能只用final的变量</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在赶路&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> * times);</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;到公司了&quot;</span>);</span><br><span class="line">                    <span class="comment">//调用latch的countDown方法使计数器-1</span></span><br><span class="line">                    latch.countDown();</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始工作&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;门卫等待员工上班中...&quot;</span>);</span><br><span class="line">            <span class="comment">//主线程阻塞等待计数器归零</span></span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;员工都来了,门卫去休息了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行后结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">子线程Thread-<span class="number">0</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">2</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">0</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">0</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">1</span>正在赶路</span><br><span class="line">门卫等待员工上班中...</span><br><span class="line">子线程Thread-<span class="number">4</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">9</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">5</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">6</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">7</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">8</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">3</span>正在赶路</span><br><span class="line">子线程Thread-<span class="number">1</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">1</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">2</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">2</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">3</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">3</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">4</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">4</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">5</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">5</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">6</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">6</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">7</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">7</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">8</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">8</span>开始工作</span><br><span class="line">子线程Thread-<span class="number">9</span>到公司了</span><br><span class="line">子线程Thread-<span class="number">9</span>开始工作</span><br><span class="line">员工都来了,门卫去休息了</span><br></pre></td></tr></table></figure><h5 id="CyclicBarrier-使用场景"><a href="#CyclicBarrier-使用场景" class="headerlink" title="CyclicBarrier 使用场景"></a>CyclicBarrier 使用场景</h5><p>我们重新模拟一个新的场景,就用已经被说烂的跑步场景吧,十名运动员各自准备比赛,需要等待所有运动员都准备好以后,裁判才能说开始然后所有运动员一起跑,代码实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">10</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有人都准备好了裁判开始了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//lambda中只能只用final的变量</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在准备&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> * times);</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备好了&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始跑了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>执行结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">子线程Thread-<span class="number">0</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">2</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">1</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">3</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">4</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">0</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">5</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">6</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">7</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">8</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">9</span>正在准备</span><br><span class="line">子线程Thread-<span class="number">1</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">2</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">3</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">4</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">5</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">6</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">7</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">8</span>准备好了</span><br><span class="line">子线程Thread-<span class="number">9</span>准备好了</span><br><span class="line">所有人都准备好了裁判开始了</span><br><span class="line">子线程Thread-<span class="number">9</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">0</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">2</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">1</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">7</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">6</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">5</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">4</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">3</span>开始跑了</span><br><span class="line">子线程Thread-<span class="number">8</span>开始跑了</span><br></pre></td></tr></table></figure><h5 id="CountdownLatch-底层实现"><a href="#CountdownLatch-底层实现" class="headerlink" title="CountdownLatch 底层实现"></a>CountdownLatch 底层实现</h5><p>我们先来看看CountdownLatch的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先保证了count一定要大于零,然后初始化了一个Sync对象,在看看这个Sync对象是个什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">        Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Sync是CountdownLatch的静态内部类,继承了AbstractQueuedSynchronizer(即AQS,提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的工具,回头单讲)抽象类, 在Sync的构造方法中,调用了setState方法,可以视作初始化了一个标记来记录当前计数器的数量</p><p>我们来看CountdownLatch的两个核心方法,await和countdown,先来看await</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//可以视作将线程阻塞</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>await调用的是AQS的方法,可以视作阻塞线程,具体实现在分析AQS的章节中展开 再来看看countdown方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用了sync的一个方法,再来看看这个方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再来看这个tryReleaseShared方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取标记位</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//用cas的方式更新标记位</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以看到在调用tryReleaseShared实际上是将标记位-1并且返回标记位是否为0,如果标记位为0 那么调用的doReleaseShared可以视作将阻塞的线程放行,这样整个的流程就通了</p><h5 id="CyclicBarrier-底层实现"><a href="#CyclicBarrier-底层实现" class="headerlink" title="CyclicBarrier 底层实现"></a>CyclicBarrier 底层实现</h5><p>老规矩先看构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="built_in">this</span>.parties = parties;</span><br><span class="line">        <span class="built_in">this</span>.count = parties;</span><br><span class="line">        <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这边传入了两个对象简单的记录了一下存值,我们直接查看一下关键的await方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再来看dowait的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">trip</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">/** 省略部分代码 **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">               TimeoutException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line">            <span class="comment">//判断是否被打断</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将计数器-1 即在构造方法中赋值的count</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="comment">//如果所有的线程都执行完毕即count=0时</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行传入的方法</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    ranAction = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//唤醒所有线程</span></span><br><span class="line">                    nextGeneration();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果count没有到0那么阻塞当前线程</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        trip.await();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                        <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到,CyclicBarrier是利用Lock的condition方法来进行线程的阻塞和唤醒,类似Object.wait()和notifyAll()在count不为0时阻塞,在count&#x3D;0时唤醒所有线程</p><p><strong>总结</strong></p><p>1,CountdownLatch适用于所有线程通过某一点后通知方法,而CyclicBarrier则适合让所有线程在同一点同时执行</p><p> 2,CountdownLatch利用继承AQS的共享锁来进行线程的通知,利用CAS来进行–state，当state变成0之后才放行这个调用latch.await()的线程,而CyclicBarrier则利用ReentrantLock的Condition来阻塞和通知线程，count不为0时阻塞,在count&#x3D;0时唤醒所有被阻塞线程</p><h3 id="手撕线程题"><a href="#手撕线程题" class="headerlink" title="手撕线程题"></a>手撕线程题</h3><h4 id="实现’A’、’B’、’C’循环打印ABCABC，每个线程打印时其他线程不能打印"><a href="#实现’A’、’B’、’C’循环打印ABCABC，每个线程打印时其他线程不能打印" class="headerlink" title="实现’A’、’B’、’C’循环打印ABCABC，每个线程打印时其他线程不能打印"></a>实现’A’、’B’、’C’循环打印ABCABC，每个线程打印时其他线程不能打印</h4><h5 id="使用lock"><a href="#使用lock" class="headerlink" title="使用lock"></a>使用lock</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCUsingLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times; <span class="comment">// 控制打印次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;   <span class="comment">// 当前状态值：保证三个线程之间交替打印</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintABCUsingLock</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.times = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String name, <span class="type">int</span> targetNum)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (state % <span class="number">3</span> == targetNum) &#123;</span><br><span class="line">                state++;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.print(name);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintABCUsingLock</span> <span class="variable">loopThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintABCUsingLock</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            loopThread.printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            loopThread.printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            loopThread.printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用wait-notify"><a href="#使用wait-notify" class="headerlink" title="使用wait&#x2F;notify"></a><strong>使用wait&#x2F;notify</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCUsingWaitNotify</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintABCUsingWaitNotify</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.times = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintABCUsingWaitNotify</span> <span class="variable">printABC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintABCUsingWaitNotify</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printABC.printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printABC.printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printABC.printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String name, <span class="type">int</span> targetState)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">while</span> (state % <span class="number">3</span> != targetState) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        LOCK.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                state++;</span><br><span class="line">                System.out.print(name);</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两个线程交替打印奇数和偶数"><a href="#两个线程交替打印奇数和偶数" class="headerlink" title="两个线程交替打印奇数和偶数"></a>两个线程交替打印奇数和偶数</h4><p>使用对象监视器实现，两个线程 A、B 竞争同一把锁，只要其中一个线程获取锁成功，就打印 ++i，并通知另一线程从等待集合中释放，然后自身线程加入等待集合并释放锁即可。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-9731382f3dfea5a4be6a5b4ef8ccdc87_1440w.webp" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OddEvenPrinter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    OddEvenPrinter(<span class="type">int</span> initCount, <span class="type">int</span> times) &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = initCount;</span><br><span class="line">        <span class="built_in">this</span>.limit = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">OddEvenPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OddEvenPrinter</span>(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::print, <span class="string">&quot;odd&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(printer::print, <span class="string">&quot;even&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; limit) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;线程[%s]打印数字:%d&quot;</span>, Thread.currentThread().getName(), ++count));</span><br><span class="line">                    monitor.notifyAll();</span><br><span class="line">                    monitor.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//防止有子线程被阻塞未被唤醒，导致主线程不退出</span></span><br><span class="line">            monitor.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的思路，来解决下第 5 题：用两个线程，一个输出字母，一个输出数字，交替输出 1A2B3C4D…26Z</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumAndLetterPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printer(), <span class="string">&quot;numThread&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printer(), <span class="string">&quot;letterThread&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().getName() == <span class="string">&quot;numThread&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">//打印数字1-26</span></span><br><span class="line">                    System.out.print((i + <span class="number">1</span>));</span><br><span class="line">                    <span class="comment">// 唤醒其他在等待的线程</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 让当前线程释放锁资源，进入wait状态</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Thread.currentThread().getName() == <span class="string">&quot;letterThread&quot;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 打印字母A-Z</span></span><br><span class="line">                    System.out.print((<span class="type">char</span>) (<span class="string">&#x27;A&#x27;</span> + i));</span><br><span class="line">                    <span class="comment">// 唤醒其他在等待的线程</span></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 让当前线程释放锁资源，进入wait状态</span></span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用-Lock-Condition"><a href="#使用-Lock-Condition" class="headerlink" title="使用 Lock&#x2F;Condition"></a>使用 Lock&#x2F;Condition</h5><p>还是以第一题为例，使用 Condition 来实现，其实和 wait&#x2F;notify 的思路一样。</p><blockquote><p>Condition 中的 <code>await()</code> 方法相当于 Object 的 <code>wait()</code> 方法，Condition 中的 <code>signal()</code> 方法相当于Object 的 <code>notify()</code> 方法，Condition 中的 <code>signalAll()</code> 相当于 Object 的 <code>notifyAll()</code> 方法。<br>不同的是，Object 中的 <code>wait(),notify(),notifyAll()</code>方法是和<code>&quot;同步锁&quot;</code>(synchronized关键字)捆绑使用的；而 Condition 是需要与<code>&quot;互斥锁&quot;/&quot;共享锁&quot;</code>捆绑使用的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintABCUsingLockCondition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> times;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintABCUsingLockCondition</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.times = times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintABCUsingLockCondition</span> <span class="variable">print</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintABCUsingLockCondition</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printLetter(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>, c1, c2);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printLetter(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>, c2, c3);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printLetter(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>, c3, c1);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printLetter</span><span class="params">(String name, <span class="type">int</span> targetState, Condition current, Condition next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (state % <span class="number">3</span> != targetState) &#123;</span><br><span class="line">                    current.await();</span><br><span class="line">                &#125;</span><br><span class="line">                state++;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.print(name);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Lock 锁的多个 Condition 可以实现精准唤醒，所以碰到那种多个线程交替打印不同次数的题就比较容易想到，比如解决第四题：多线程按顺序调用，A-&gt;B-&gt;C，AA 打印 5 次，BB 打印10 次，CC 打印 15 次，重复 10 次</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2024/04/19/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/04/19/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="基本数据类型与权限"><a href="#基本数据类型与权限" class="headerlink" title="基本数据类型与权限"></a>基本数据类型与权限</h3><h4 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a><strong>基本类型和包装类型的区别</strong></h4><h5 id="1-基本类型有初始值，而包装类型的默认值是null"><a href="#1-基本类型有初始值，而包装类型的默认值是null" class="headerlink" title="1.基本类型有初始值，而包装类型的默认值是null"></a>1.基本类型有初始值，而包装类型的默认值是null</h5><h5 id="2-包装类型可以为-null，而基本类型不可以"><a href="#2-包装类型可以为-null，而基本类型不可以" class="headerlink" title="2.包装类型可以为 null，而基本类型不可以"></a>2.包装类型可以为 null，而基本类型不可以</h5><p>数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有<a href="https://so.csdn.net/so/search?q=NPE&spm=1001.2101.3001.7020">NPE</a>（NullPointerException）风险。</p><h5 id="3-存储位置有所区别：基本类型是成员变量就存储在堆内存里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用"><a href="#3-存储位置有所区别：基本类型是成员变量就存储在堆内存里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用" class="headerlink" title="3.存储位置有所区别：基本类型是成员变量就存储在堆内存里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用"></a>3.存储位置有所区别：基本类型是成员变量就存储在<a href="https://so.csdn.net/so/search?q=%E5%A0%86%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">堆内存</a>里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用</h5><h5 id="4-包装类型可用于泛型，而基本类型不可以"><a href="#4-包装类型可用于泛型，而基本类型不可以" class="headerlink" title="4.包装类型可用于泛型，而基本类型不可以"></a>4.包装类型可用于泛型，而基本类型不可以</h5><p>如果我们这么写<br>List<int> a &#x3D; new ArrayList&lt;&gt;();<br>编译器会报错：Type argument cannot be of primitive type(类型参数不能为基本类型)<br>这是为什么呢？因为泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类。</p><h5 id="5-在使用“-”进行判断的时候的不同"><a href="#5-在使用“-”进行判断的时候的不同" class="headerlink" title="5.在使用“&#x3D;&#x3D;”进行判断的时候的不同"></a>5.在使用“&#x3D;&#x3D;”进行判断的时候的不同</h5><p>基本数据类型会直接比较值是否相同，而包装数据类型用“&#x3D;&#x3D;”判断比较的是地址值（在-128 – 127之间会共用内部类的cache），真正判断是否相等需要用equals()。</p><p><strong>6.自动装箱和自动拆箱</strong><br>把基本类型转换成包装类型的过程叫做装箱（boxing）。反之，把包装类型转换成基本类型的过程叫做拆箱（unboxing）。</p><p>1）基本类型和包装类型进行 &#x3D;&#x3D; 比较，包装类型会自动拆箱，直接和基本类型比较值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">System.out.println(a == b);</span><br></pre></td></tr></table></figure><p>上述代码的结果为 true。</p><p>2）当需要进行自动装箱时，如果数字在 -128 至 127 之间，会直接使用缓存中的对象，而不是重新创建一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">199</span>;  </span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> A;  </span><br></pre></td></tr></table></figure><p>执行第一句代码的时候，系统为我们执行了：<br>Integer A &#x3D; Integer.valueOf(199);<br>执行第二句代码的时候，系统为我们执行了：<br>int a &#x3D; A.intValue();</p><h4 id="java的访问权限有哪些"><a href="#java的访问权限有哪些" class="headerlink" title="java的访问权限有哪些"></a>java的访问权限有哪些</h4><h5 id="类的成员变量和方法访问权限"><a href="#类的成员变量和方法访问权限" class="headerlink" title="类的成员变量和方法访问权限"></a>类的成员变量和方法访问权限</h5><table><thead><tr><th>修饰符</th><th>类内部</th><th>同包（package）</th><th>子类</th><th>任何地方</th></tr></thead><tbody><tr><td>public</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>protected</td><td>Yes</td><td>Yes</td><td>Yes</td><td></td></tr><tr><td>缺省</td><td>Yes</td><td>Yes</td><td></td><td></td></tr><tr><td>private</td><td>Yes</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th align="left">权限修饰符</th><th align="left">类</th><th align="left">变量&#x2F;方法</th></tr></thead><tbody><tr><td align="left">public</td><td align="left">包内外的类都可以访问</td><td align="left">包内外的类都可以访问</td></tr><tr><td align="left">protected</td><td align="left">类不可以声明为protected</td><td align="left">本包内的类和子类可以访问</td></tr><tr><td align="left">不写</td><td align="left">本包中的类可以访问</td><td align="left">本包中的类可以访问</td></tr><tr><td align="left">private</td><td align="left">类不可以声明为private</td><td align="left">只允许本类访问</td></tr></tbody></table><h5 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h5><p>类的访问权限仅有<strong>public</strong>和<strong>default</strong>， 如果一个类声明的时候用了<strong>public</strong>，则该类的类名必须与文件名一致，包括大小写，如果不匹配，会有编译错误</p><h4 id="Java的基本类型存储位置"><a href="#Java的基本类型存储位置" class="headerlink" title="Java的基本类型存储位置"></a><strong>Java的基本类型存储位置</strong></h4><ul><li><p><strong>第一种</strong>: 在方法中声明的变量，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因</p><p>（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中</p><p>（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。</p></li><li><p><strong>第二种</strong> 在类中声明的变量是类的成员变量(全局变量),放在堆中</p><ol><li>声明的是基本类型的变量,其变量名及其值放在堆内存中</li><li>声明的是引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中。但与对象中的普通成员变量（局部变量）不同的是，它们的生命周期是在对象销毁时才结束的</li></ol></li><li><p><strong>第三种</strong> 静态变量：</p><p>​静态变量随着类的加载而存在，是存储在方法区（Method Area）中的，而不是存储在栈或堆上，所以它的生命周期与程序的生命周期一样长。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjcxMjE2,size_16,color_FFFFFF,t_70.png" alt="img"></p></li></ul><h4 id="包装类的缓存"><a href="#包装类的缓存" class="headerlink" title="包装类的缓存"></a>包装类的缓存</h4><p>1、前提：发生自动装箱的过程（基本类型–&gt;包装类型）<br>创建一个包装类对象有两种方法：<br>（1）构造器方法（就是new出来）；<br>（2）自动装箱（就是编译器自动调用包装类的valueOf方法）；</p><h5 id="两种方法的区别："><a href="#两种方法的区别：" class="headerlink" title="两种方法的区别："></a>两种方法的区别：</h5><p>构造器方法：不论值的大小，返回的将都会是一个新对象；<br>自动装箱会先经过判断，再决定返回的是一个新对象还是常量池中已存在的对象。</p><p>2、机制：当通过自动装箱机制创建包装类对象时，首先会判断数值是否在缓存范围内，如果满足条件，则会从  该包装类中的静态内部类xxCache包装类（例如IntegerCache类）类型数组（例如static final Integer cache[]）（放在方法区的常量池）中寻找指定数值，并返回缓存的对象，否则创建一个新的对象返回。</p><p>3、原理：<br>（1）当包装类加载时，该包装类中的静态内部类xxCache会初始化一个静态包装类类型数组，最小值（固定值）为-128,而最大值（默认值）为127【可修改】，是所有线程共享的。</p><h5 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h5><p>在缓存值范围内的对象可以直接在常量池中取出，不用创建新的对象；<br>当需要频繁的使用同一对象的时候，如果有缓存，则可以避免重复创建同一对象，节省空间开销和时间消耗，提升了性能。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111615708.png" alt="image-20231003111615708"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h4><ol><li>重写必须依赖于继承(父子关系) 将父类的的方法给完善。而重载不需要依赖继承关系，在自己的类中就可以实现。</li><li>重写的方法名和参数列表必须和父类相同，如果父类没有这个方法，那么就不算重写。重载是在自身类中创建多个方法名相同但是参数类型或者个数不同的方法。</li><li>重写的参数不能修改，而重载的参数必须修改。</li></ol><h4 id="object中的hashcode-方法是做什么用的"><a href="#object中的hashcode-方法是做什么用的" class="headerlink" title="object中的hashcode()方法是做什么用的"></a>object中的hashcode()方法是做什么用的</h4><p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p><p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><h5 id="那为什么不只提供-hashCode-方法呢？"><a href="#那为什么不只提供-hashCode-方法呢？" class="headerlink" title="那为什么不只提供 hashCode() 方法呢？"></a><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></h5><p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p><h5 id="那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？"><a href="#那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？" class="headerlink" title="那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？"></a><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></h5><p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><h4 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h4><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p>再map集合中，如果只重写equals方法，那么两个相同对象hashcode可能不同，会存在多个key相同的情况。</p><h4 id="object类中的常用方法的用处："><a href="#object类中的常用方法的用处：" class="headerlink" title="object类中的常用方法的用处："></a>object类中的常用方法的用处：</h4><p>1、 getClass()：获取类的class对象。<br>2、 hashCode():获取对象的hashCode值<br>3、 equals():比较对象是否相等，先比较存储地址再比较对象，子类可重写以自定义。<br>4、 clone()：浅拷贝一个新的对象。<br>5、 toString():如果没有重写，应用对象将打印的是地址值。<br>6、 notify():随机选择一个在该对象上调用wait方法的线程，解除其阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>7、 notifyall():解除所有那些在该对象上调用wait方法的线程的阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>8、 wait():导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在同步方法中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。<br>9、 finalize()：对象回收时调用</p><h4 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h4><ol><li><p>final修饰符（关键字）。被<strong>final修饰的类</strong>，就意味着<strong>不能再派生出新的子类</strong>，不能作为父类而被子类继承。因此一个类不能既被abstract声明，又被final声明。将<strong>变量或方法声明为final</strong>，可以保证他们在<strong>使用的过程中不被修改</strong>。被声明为final的变量必须在声明时<strong>给出变量的初始值</strong>，而在以后的引用中只能读取。被final声明的方法也同样只能使用，即不能方法重写。</p></li><li><p>finally是在<strong>异常处理时提供finally块来执行任何清除操作</strong>。不管有没有异常被抛出、捕获，finally块都会被执行。try块中的内容是在无异常时执行到结束。catch块中的内容，是在try块内容发生catch所声明的异常时，跳转到catch块中执行。<strong>finally块则是无论异常是否发生，都会执行finally块的内容，所以在代码逻辑中有需要无论发生什么都必须执行的代码，就可以放在finally块中</strong>。</p></li><li><p>finalize是方法名。java技术允许使用finalize（）方法<strong>在垃圾收集器将对象从内存中清除出去之前做必要的清理工作</strong>。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在object类中定义的，因此所有的类都继承了它。子类覆盖finalize（）方法以整理系统资源或者被执行其他清理工作。<strong>finalize（）方法是在垃圾收集器删除对象之前对这个对象调用的。</strong></p></li></ol><h4 id="Return与finally的使用顺序"><a href="#Return与finally的使用顺序" class="headerlink" title="Return与finally的使用顺序"></a>Return与finally的使用顺序</h4><p><strong>如果程序是从try代码块或者catch代码块中返回时，finally中的代码总会执行。而且finally语句在return语句执行之后return返回之前执行的。可以使用编译器的Debug功能查看详细过程。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally模块被执行&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">//结果 finally模块被执行 1</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>/<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally模块被执行&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//结果： finally模块被执行 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>/<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally模块被执行&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">//结果 finally模块被执行 0；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally模块被执行&quot;</span>);</span><br><span class="line">          result = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//结果 finally模块被执行 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>*<strong>如果try和catch的return是一个变量时且函数的是从其中一个返回时，后面finally中语句即使有对返回的变量进行赋值的操作时，也不会影响返回的值，因为返回值已经被保存到局部变量表中，赋值操作无法修改到返回值。*</strong></p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String为什么不可变"><a href="#String为什么不可变" class="headerlink" title="String为什么不可变"></a>String为什么不可变</h4><ul><li>将 class 自身声明为 final，这样别人就不能通过扩展来绕过限制了。</li><li>将所有成员变量定义为 private 和 final（使得byte[]引用不可变），并且没有实现 setter 方法来修改byte[]（使得byte[]值不可变）。</li><li>通过构造对象时，成员变量使用深拷贝来初始化，而不是直接赋值，这是一种防御措施，因为该输入对象被其他变量引用，你无法确定输入对象不被其他人修改。</li></ul><p>可以通过反射修改String的值，相当于使用set方法修改byte[];</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString3</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">strObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;反射执行前字符串：&quot;</span> + strObj);</span><br><span class="line">    System.out.println(<span class="string">&quot;反射执行前的hash值：&quot;</span> + strObj.hashCode());</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> strObj.getClass().getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">char</span>[] value = (<span class="type">char</span>[]) field.get(strObj);</span><br><span class="line">    value[<span class="number">2</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;反射执行后字符串：&quot;</span> + strObj);</span><br><span class="line">    System.out.println(<span class="string">&quot;反射执行后的hash值：&quot;</span> + strObj.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1的内存地址：<span class="number">1922154895</span></span><br><span class="line">执行+=后str1的内存地址：<span class="number">883049899</span></span><br><span class="line">拼接之后str1的值：helloworld</span><br><span class="line">str3的值：<span class="number">123</span></span><br><span class="line">str4的值：<span class="number">123456</span></span><br><span class="line">str5的值：ABC</span><br><span class="line">str6的值：BBC</span><br></pre></td></tr></table></figure><h4 id="String-类设计成不可变的原因及好处？"><a href="#String-类设计成不可变的原因及好处？" class="headerlink" title="String 类设计成不可变的原因及好处？"></a><strong>String 类设计成不可变的原因及好处？</strong></h4><p>其实好处就是原因，String 设计成不可变，主要是从性能和安全两方面考虑。</p><h5 id="1、常量池的需要"><a href="#1、常量池的需要" class="headerlink" title="1、常量池的需要"></a><strong>1、常量池的需要</strong></h5><p>这个方面很好理解，Java 中的字符串常量池的存在就是为了性能优化。</p><p>字符串常量池（String pool）是 Java 堆内存中一个特殊的存储区域，当创建一个 String 对象时，假如此字符串已经存在于常量池中，则不会创建新的对象，而是直接引用已经存在的对象。这样做能够减少 JVM 的内存开销，提高效率。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span> s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="title class_">String</span> s2 = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><p>比如引用 s1和 s2 都是指向常量池的同一个对象 “abc”，如果 String 是可变类，引用 s1 对 String 对象的修改，会直接导致引用 s2 获取错误的值。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/43vmfn3rmu.png" alt="img"></p><p>所以，如果字符串是可变的，那么常量池就没有存在的意义了。</p><h5 id="2、hashcode-缓存的需要"><a href="#2、hashcode-缓存的需要" class="headerlink" title="2、hashcode 缓存的需要"></a><strong>2、hashcode 缓存的需要</strong></h5><p>String有一个属性用来缓存hash值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p>因为字符串不可变，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就使得字符串很适合作为 HashMap 中的 key，效率大大提高。</p><h5 id="3、多线程安全"><a href="#3、多线程安全" class="headerlink" title="3、多线程安全"></a><strong>3、多线程安全</strong></h5><p>多线程中，可变对象的值很可能被其他线程改变，造成不可预期的结果。而不可变的 String 可以自由在多个线程之间共享，不需要同步处理。</p><h4 id="String-、StringBuffer和StringBuilder的区别"><a href="#String-、StringBuffer和StringBuilder的区别" class="headerlink" title="String 、StringBuffer和StringBuilder的区别"></a>String 、StringBuffer和StringBuilder的区别</h4><h5 id="1-可变性"><a href="#1-可变性" class="headerlink" title="1.可变性"></a>1.可变性</h5><p>​String 内部的 value 值是 final 修饰的，所以它是不可变类。所以每次修改 String 的值，都会产生一个新的对象。<br>​StringBuffer 和 StringBuilder 是可变类，字符串的变更不会产生新的对象。</p><h5 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="2.线程安全性"></a>2.线程安全性</h5><p>​String 是不可变类，所以它是线程安全的。<br>​StringBuffer 是线程安全的，因为它每个操作方法都加了 synchronized 同步关键字。<br>​StringBuilder 不是线程安全的。所以在多线程环境下对字符串进行操作，应该使用 StringBuffer，否则使用StringBuilder</p><h5 id="3-性能方面。"><a href="#3-性能方面。" class="headerlink" title="3.性能方面。"></a>3.性能方面。</h5><p>​String 的性能是最低的，因为不可变意味着在做字符串拼接和修改的时候，需要重新创建新的对象以及分配内存。<br>​其次是 StringBuffer 要比 String 性能高，因为它的可变性使得字符串可以直接被修改<br>​最后是 StringBuilder，它比 StringBuffer 的性能高，因为 StringBuffer 加了同步锁。</p><h5 id="4-存储方面。"><a href="#4-存储方面。" class="headerlink" title="4.存储方面。"></a>4.存储方面。</h5><p>​String 存储在字符串常量池里面<br>​StringBuffer 和 StringBuilder 存储在堆内存空间。</p><h4 id="StringBuffer、StringBuilder的扩容原理"><a href="#StringBuffer、StringBuilder的扩容原理" class="headerlink" title="StringBuffer、StringBuilder的扩容原理"></a>StringBuffer、StringBuilder的扩容原理</h4><p>扩容原理：</p><p><code>StringBuffer</code>的底层数组结构用的是<code>char</code>类型的数组如果没有指定大小，默认大小为16，指定了大小，默认大小为（16 + 指定大小）。</p><p>所以，当我们使用<code>StringBuffer</code>对象的<code>append(...)</code>方法追加数据时，</p><ul><li>如果数组长度可以容纳追加的数据，就直接追加到数组</li><li>如果char类型数组的长度无法容纳我们追加的数据，<code>StringBuffer</code>就会进行扩容。</li><li>扩容时会用到<code>Arrays</code>类中的<code>copyOf(...)</code>方法，每次扩容的容量大小是原来的容量的2倍（通过无符号左移）加2。</li></ul><h4 id="String-str-“abc”-和String-str-new-String-“abc”-的区别"><a href="#String-str-“abc”-和String-str-new-String-“abc”-的区别" class="headerlink" title="String str &#x3D; “abc” 和String str &#x3D; new String(“abc”)的区别"></a><strong>String str &#x3D; “abc” 和String str &#x3D; new String(“abc”)的区别</strong></h4><p><code>String str =&quot;abc&quot;</code>的原理，采用字面值的方式创建时，<code>JVM</code>会先去字符串常量池中去查找是否存在”abc”这个对象，如果不存在就创建这个字符串，并把地址返回给<code>str</code>。如果存在则直接把”abc”这个字符串的地址返回给<code>str</code>。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/16e1f7c1f13d9561tplv-t2oaga2asx-jj-mark3024000q75-1696302993864-1.webp" alt="img"></p><p><code>String str = new String(&quot;abc&quot;)</code>采用<code>new</code>关键字的方式创建，能被看成”abc”和new String()，<code>JVM</code>也会去字符串常量池中查找有没有这个字符串，如果没有的话，就先在字符串常量池里创建”abc”这个字符串，然后再复制一份放在堆里并把地址返回给<code>str</code>。如果字符串常量池里存在该字符串，那么就直接复制一份放在堆里并把地址返回给<code>str</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = original.value;</span><br><span class="line">        <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">    &#125;<span class="comment">//浅拷贝</span></span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/16e1f8c6aa324edetplv-t2oaga2asx-jj-mark3024000q75-1696303002110-3.webp" alt="img"></p><h4 id="（String的）equals-的底层代码是什么"><a href="#（String的）equals-的底层代码是什么" class="headerlink" title="（String的）equals 的底层代码是什么?"></a>（String的）equals 的底层代码是什么?</h4><ol><li>先使用&#x3D;&#x3D; 进行地址值的判断  </li><li>判断equals()中的值是否为字符串  instanceof()方法</li><li>判断字符串的长度是否相同  </li><li>循环遍历进行判断两个字符串是否相同</li></ol><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="集合顶层是什么，各个接口实现类有哪些"><a href="#集合顶层是什么，各个接口实现类有哪些" class="headerlink" title="集合顶层是什么，各个接口实现类有哪些"></a>集合顶层是什么，各个接口实现类有哪些</h4><p><strong>Java 集合框架架构图如下图所示</strong>：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640-1711439392899-248.png" alt="图片"></p><p><code>List</code> 接口实现类：</p><ul><li><code>ArrayList</code>: 底层基于可调节大小的数组实现。</li><li><code>LinkedList</code>: 底层基于双向链表实现，链表实现类。</li><li><code>Vector</code>: 和<code>ArrayList</code>类似，但线程安全。</li><li><code>Stack</code>: 继承自 <code>Vector</code>，栈实现类。</li></ul><p><code>Set</code> 接口实现类：</p><ul><li><code>HashSet</code>: 底层基于哈希表实现，没有排序保证。</li><li><code>LinkedHashSet</code>: 底层基于哈希表和链表实现，元素的插入和取出顺序满足 FIFO</li><li><code>TreeSet</code>: 底层基于红黑树实现，元素是有序的，排序的方式有自然排序和定制排序。</li></ul><p><code>Map</code> 接口实现类：</p><ul><li><code>HashMap</code>: 仅用于存储键值对，JDK1.8 之前 <code>HashMap</code> 底层基于数组和链表实现，JDK1.8 之前基于数组和红黑树。</li><li><code>LinkedHashMap</code>: 继承自 <code>HashMap</code>，并在 <code>HashMap</code> 基础上维护一条双向链表，支持遍历时会按照插入顺序有序进行迭代，支持按照元素访问顺序排序，迭代效率比<code>HashMap</code>更高。</li><li><code>TreeMap</code>: 相比于 <code>HashMap</code> 来说，<code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</li><li><code>Hashtable</code>: 与 <code>HashMap</code> 类似，但线程安全。</li></ul><p><code>Queue</code> 接口实现类：</p><ul><li><code>LinkedList</code>: 同时实现了 <code>List</code> 和 <code>Queue</code> 接口。</li><li><code>PriorityQueue</code>：元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</li><li><code>ArrayDeque</code> ：底层基于可变长的数组和双指针实现，允许我们在队列的两端进行元素的插入和移除操作。</li></ul><h4 id="数组和链表的不同"><a href="#数组和链表的不同" class="headerlink" title="数组和链表的不同"></a>数组和链表的不同</h4><table><thead><tr><th></th><th>数组</th><th>链表</th></tr></thead><tbody><tr><td>逻辑结构</td><td>（1）数组在内存中连续； (2)使用数组之前，必须事先固定数组长度，不支持动态改变数组大小；(3) 数组元素增加时，有可能会数组越界；(4) 数组元素减少时，会造成内存浪费；（5）数组增删时需要移动其它元素</td><td>（1）链表采用动态内存分配的方式，在内存中不连续 (2)支持动态增加或者删除元素</td></tr><tr><td>访问效率</td><td>数组在内存中顺序存储，可通过下标访问，访问效率高</td><td>链表访问效率低，如果想要访问某个元素，需要从头遍历</td></tr><tr><td>越界问题</td><td>数组的大小是固定的，所以存在访问越界的风险</td><td>只要可以申请得到链表空间，链表就无越界风险</td></tr><tr><td>使用场景</td><td>存储的大小变化不大，且可以事先确定大小，主要是进行查找，很少插入和删除时</td><td>长度变化较大时，事先无法估量数据规模，当线性表要求频繁插入和删除时</td></tr></tbody></table><h4 id="说说ArrayList"><a href="#说说ArrayList" class="headerlink" title="说说ArrayList"></a>说说ArrayList</h4><p>ArrayList 是一个数组结构的存储容器，所以ArrayList是支持随机存取的，默认情况下，数组的长度是 10.也可以在构建 ArrayList 对象的时候自己指定初始长度。随着在程序里面不断的往 ArrayList 中添加数据，当添加的数据达到 10 个的时候，ArrayList 就没有多余容量可以存储后续的数据。这个时候 ArrayList 会自动触发扩容。扩容的具体流程很简单：</p><ol><li>首先，创建一个新的数组，这个新数组的长度是原来数组长度的 1.5 倍。</li><li>然后使用 Arrays.copyOf 方法把老数组里面的数据拷贝到新的数组里面。<br>扩容完成后再把当前要添加的元素加入到新的数组里面，从而完成动态扩容的过程。</li></ol><h4 id="常见的树"><a href="#常见的树" class="headerlink" title="常见的树"></a>常见的树</h4><p><a href="https://zhuanlan.zhihu.com/p/531299726#%E5%89%8D%E8%A8%80">为什么红黑树的效率比较高 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/361961175">红黑树 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/91960960">一文带你彻底读懂红黑树（附详细图解） - 知乎 (zhihu.com)</a></p><h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><strong>平衡二叉树</strong></h5><p>特点：<strong>任意节点的左子树和右子树高度差不能超过1</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-db8cdc6ff692f73cb4984ff80e45ef34_720w.webp" alt="img"></p><h5 id="非平衡二叉树"><a href="#非平衡二叉树" class="headerlink" title="非平衡二叉树"></a><strong>非平衡二叉树</strong></h5><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-07b3c6b4c4d2d524555fb739bf599981_720w.webp" alt="img"></p><p>高度差已经大于1 了。平衡树解决的问题就是 能够最大限度的增加访问的每个节点的的平均性。保证每个节点被访问的次数平衡。</p><h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a><strong>完全二叉树</strong></h5><p>除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-db8cdc6ff692f73cb4984ff80e45ef34_720w.webp" alt="img"></p><p>堆排序 结构其实就是一个完全二叉树的结构，倒序和正序就是用的 大根堆 小根堆的原理。</p><h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a><strong>满二叉树</strong></h5><p>每个节点是叶节点或者度为2.</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-c24507d5ab42fa1a9de508aea129bacc_720w.webp" alt="img"></p><h5 id="二叉搜索树（Binary-Search-Tree）"><a href="#二叉搜索树（Binary-Search-Tree）" class="headerlink" title="二叉搜索树（Binary Search Tree）"></a><strong>二叉搜索树（Binary Search Tree）</strong></h5><p>特点是每个根节点大于左子树上的任意一个节点，小于等于右子树上的任意一个节点。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-bc1985e7abdd4871d0d0709f02a64725_720w.webp" alt="img"></p><p>可以利用二叉搜索树的大小关系，有点类似于二分查找。二叉搜索树查询的时间复杂度为O(logn)，因为每次查找都能将范围缩小一半。</p><p><strong>二叉搜索树的不足：</strong></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-b43c0ec9893114064c891d5b3b2ee383_720w.webp" alt="img"></p><p>极端的二叉搜索树：如果二叉搜索树每个节点都只有左节点或者都只有右节点，那么这颗树就会降级为链表结构，使得时间复杂度为O(n),所以引出了平衡排序树(AVL树).</p><h5 id="平衡二叉搜索树（AVL树）"><a href="#平衡二叉搜索树（AVL树）" class="headerlink" title="平衡二叉搜索树（AVL树）"></a>平衡二叉搜索树（AVL树）</h5><p><strong>特点</strong></p><ul><li>任意节点的左右子树的高度差都小于等于1</li><li>常见的平衡树包括B树（MySQL中的索引），AVL树等</li></ul><p><strong>平衡二叉搜索树能同时满足平衡树和二叉搜索树的特点：</strong></p><ul><li>优点：AVL树可以有效减少二叉树的深度，从而提升查询的效率。</li><li>缺点：AVL树为了达到平衡（任意节点的左右子树的高度差都小于等于1，这属于<strong>绝对平衡</strong>，维持起来并不容易），需要付出额外代价。在插入和删除操作时，AVL树都需要进行再平衡。</li></ul><p>所以AVL树还有待改进——红黑树。</p><table><thead><tr><th>平衡二叉树类型</th><th>平衡度</th><th>调整频率</th><th>适用场景</th></tr></thead><tbody><tr><td>AVL树</td><td>高</td><td>高</td><td>查询多，增&#x2F;删少</td></tr><tr><td>红黑树</td><td>低</td><td>低</td><td>增&#x2F;删频繁</td></tr></tbody></table><hr><h5 id="红黑树（R-B树）"><a href="#红黑树（R-B树）" class="headerlink" title="红黑树（R-B树）"></a>红黑树（R-B树）</h5><p>红黑树是一种特化的AVL树，查询与AVL树基本相同，在插入和删除时通过特定操作保持二叉搜索树的<strong>相对平衡</strong>（红黑树与AVL树不同，AVL是绝对平衡）， 因为这种相对平衡的条件，红黑树在插入和删除时，对于树的调整的频率低于AVL树，对于树的旋转的次数也比AVL树少，从而获得较高的性能。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-d5a84583be75cd748b2a979e27a911ec_720w.webp" alt="img"></p><p><strong>由图可以看出红黑树不是严格的AVL树，只是黑色平衡</strong></p><p><strong>红黑树的特点</strong>：</p><ol><li><strong>首先必须满足二叉搜索树</strong></li><li><strong>节点非黑即红</strong></li><li><strong>根节点是黑色的，叶子节点是黑色的（都是空节点，为了简单起见，红黑树一般会省略叶子结点）</strong></li><li><strong>相邻父子节点不能同为红色，每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。</strong>）</li><li><strong>从一个节点到该节点的叶子结点的所有路径上包含的黑节点数量相等（这是平衡关键）</strong></li></ol><p><strong>红黑树特点总结成一句口诀：黑根黑叶红不邻，通祖等高只数黑</strong></p><p><strong>红黑树相关定理</strong></p><ol><li>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</li></ol><p>要满足从根节点到叶节点每条路径的黑色节点数量一致。最短路径：全是黑色 最长路径：黑红相间</p><p>对于给定的黑色高度为n的红黑树，从根结点到叶结点的简单路径的最短长度为n-1，最大长度为2(n-1)，从这一点我们可以看出红黑树是 大致平衡的。(当然比平衡二叉树要差一些，AVL的平衡因子最多为1)</p><ol start="2"><li>红黑树的树高(h)不大于两倍的红黑树的黑深度(bd)，即h&lt;&#x3D;2bd</li></ol><p>根据定理1，我们不难说明这一点。bd是红黑树的最短路径长度。而可能的最长路径长度(树高的最大值)就是红黑相间的路径，等于2bd。因此h&lt;&#x3D;2bd。</p><ol start="3"><li>一棵拥有n个内部结点(不包括叶子结点)的红黑树的树高h&lt;&#x3D;2log(n+1)</li></ol><p>下面我们首先证明一颗有n个内部结点的红黑树满足n&gt;&#x3D;2^bd-1。这可以用数学归纳法证明，施归纳于树高h。当h&#x3D;0时，这相当于是一个叶结点，黑高度bd为0，而内部结点数量n为0，此时0&gt;&#x3D;2^0-1成立。假设树高h&lt;&#x3D;t时，n&gt;&#x3D;2^bd-1成立，我们记一颗树高 为t+1的红黑树的根结点的左子树的内部结点数量为nl，右子树的内部结点数量为nr，记这两颗子树的黑高度为bd’（注意这两颗子树的黑高度必然一 样），显然这两颗子树的树高&lt;&#x3D;t，于是有nl&gt;&#x3D;2^bd’-1以及nr&gt;&#x3D;2^bd’-1，将这两个不等式相加有nl+nr&gt;&#x3D;2^(bd’+1)-2，将该不等式左右加1，得到n&gt;&#x3D;2^(bd’+1)-1，很显然bd’+1&gt;&#x3D;bd，于是前面的不等式可以 变为n&gt;&#x3D;2^bd-1，这样就证明了一颗有n个内部结点的红黑树满足n&gt;&#x3D;2^bd-1。</p><p>在根据定理2，h&lt;&#x3D;2bd。即n&gt;&#x3D;2^(h&#x2F;2)-1，那么h&lt;&#x3D;2log(n+1)</p><p>从这里我们能够看出，红黑树的查找长度最多不超过2log(n+1)，因此其查找时间复杂度也是O(log N)级别的。</p><p><strong>红黑树的复杂度分析</strong></p><ul><li><p>一棵含有n个节点（内部节点，不包含空的叶子节点）的红黑树的高度至多为2log(n+1)</p></li><li><p>查找时间复杂度为O(logn),红黑树上的查找操作与普通二叉查找树上的查找操作相同</p></li><li><p>插入时间复杂度为O(1)+O(logn)</p></li><li><p>删除时间复杂度为O(1)+O(logn)</p></li></ul><p><strong>AVL vs 红黑树</strong></p><ul><li>插入：AVL和红黑树都是最多两次旋转实现复衡，旋转的量级是O(1)，恢复红黑树的属性需要O(log n)的颜色变更</li><li>删除：AVL旋转的量级是O(logn)，红黑树最多旋转3次实现复衡只要O(1)</li><li>红黑树插入和删除效率更高，AVL的查找效率更高.</li><li>红黑树成本较低，AVL成本较高</li></ul><p><strong>两者没有谁好谁坏，关键看使用场景</strong></p><p><strong>红黑树的实际应用</strong></p><ul><li><strong>Java中的HashMap、TreeMap、TreeSet等</strong></li></ul><p><strong>红黑树的基本操作</strong></p><p><strong>查找节点（二叉搜索树一样的查找）</strong></p><ol><li>选择根节点作为当前节点</li><li>按照二叉搜索树特点进行循环查找（若值与当前节点值相等，则返回该节点；若值小于当前节点，左节点作为当前节点；否则，右节点作为当前节点）</li><li>未找到，为null</li></ol><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-f90edcb09cc58e310e2047ba8d6af772_720w.webp" alt="img"></p><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>[B+ 树搜索时间复杂度到底是什么：mlogmN &#x2F; logN？ - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/402951">https://zhuanlan.zhihu.com/p/402951</a></p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231023104558443.png" alt="image-20231023104558443"></p><p>第一种，按照B+树数据结构来算，要访问节点数 * 节点内的搜索时间复杂度，其中节点内搜索时间有线性查找、二分查找两种</p><p>第二种：</p><p>说一个结论：非叶子节点的大小 &#x3D; 页大小。下面是证明</p><blockquote><p>B+ 树在搜索过程中，需要从磁盘IO来读取节点的数据。我们知道磁盘IO一次读取的数据大小为一页。</p><ul><li>非叶子节点的大小 &gt; 页大小：那么意味着搜索过程中，为了获取一个完整节点来查找数据，我们需要多次IO来获取这个节点，这显然非常消耗时间。所以非叶子节点的大小不能超过一页。</li><li>非叶子节点的体积非常小：这就意味着B+树的分叉就少，B+树的总节点数会变多、深度变大。B+树利用指针构成的树形结构，意味着每个节点在磁盘上是不连续的，B+树的深度变大了，意味着搜索时访问的节点数量变多，IO次数也变多了。</li><li>因此，非叶子节点过大、过小，都会导致IO次数增加。所以最合适的非叶子节点大小 &#x3D; 页大小。</li></ul></blockquote><p>因为</p><p>1 B+树的节点，即非叶子节点大小 &#x3D; 页大小</p><p>2 读取一页需要一次IO</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231023105000623.png" alt="image-20231023105000623"></p><h4 id="有哪些线程安全的容器？"><a href="#有哪些线程安全的容器？" class="headerlink" title="有哪些线程安全的容器？"></a>有哪些线程安全的容器？</h4><h5 id="不可变类："><a href="#不可变类：" class="headerlink" title="不可变类："></a>不可变类：</h5><ul><li>String：String的各个substring、replace、reverse 等方法都是重新new一个String对象，不会改变源对象，而且用final修饰，不会有子类覆盖String的方法，不会出现线程安全问题</li><li>Integer 类似String</li><li>Random 类似String</li></ul><h5 id="遗留的线程安全集合"><a href="#遗留的线程安全集合" class="headerlink" title="遗留的线程安全集合"></a>遗留的线程安全集合</h5><ul><li>StringBuﬀer 对方法加上了synchronized锁，保证线程安全，但是效率比StringBuilder低一些</li><li>Vector 每个方法都加上了synchronized 关键字，串行化执行，效率低下。而且多线程下组合调用这些方法还是会出现线程不安全。</li><li>Hashtable： 每个方法都加上了synchronized 关键字，串行化执行，效率低下。而且多线程下组合调用这些方法还是会出现线程不安全。</li></ul><h5 id="经过修饰的线程安全的集合"><a href="#经过修饰的线程安全的集合" class="headerlink" title="经过修饰的线程安全的集合"></a>经过修饰的线程安全的集合</h5><ul><li>synchronizedList 、synchronizedMap 、 synchronizedSet等等， 把不安全的list、map、set等作为构造的参数， 其方法使用synchronized(mutex) {map.get();} 使用的还是原本集合中的方法，但是通过synchronized和信号量来实现同步</li></ul><h5 id="java-util-concurrent-包下的类"><a href="#java-util-concurrent-包下的类" class="headerlink" title="java.util.concurrent 包下的类"></a>java.util.concurrent 包下的类</h5><ul><li><p>concurrentHashMap。</p></li><li><p>BlockingQueue的实现类:阻塞队列（<code>BlockingQueue</code>）被广泛使用在“生产者-消费者”问题中，其原因是 <code>BlockingQueue</code> 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p></li><li><p>copyOnWriteArrayList: <code>CopyOnWriteArrayList</code> 中的读取操作是完全无需加锁的。更加厉害的是，写入操作也不会阻塞读取操作，只有写写才会互斥。这样一来，读操作的性能就可以大幅度提升。</p></li></ul><p>线程安全的类不一定能保证线程安全，只能保证单个方法执行是线程安全的，但是多个方法的组合还是会出现不安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">concurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.get(str);</span><br><span class="line"><span class="comment">//在此处时间片结束，线程不安全</span></span><br><span class="line">map.put(str,count == <span class="number">0</span> : <span class="number">1</span> ? count + <span class="number">1</span>);;</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="CopyOnWriteArrayList详情"><a href="#CopyOnWriteArrayList详情" class="headerlink" title="CopyOnWriteArrayList详情"></a>CopyOnWriteArrayList详情</h4><p><code>CopyOnWriteArrayList</code> 线程安全的核心在于其采用了 <strong>写时复制（Copy-On-Write）</strong> 的策略，<strong>采用读写分离的思想</strong></p><p>当需要修改（ <code>add</code>，<code>set</code>、<code>remove</code> 等操作） <code>CopyOnWriteArrayList</code> 的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将原容器的引用指向新的容器，这样就可以保证写操作不会影响读操作了。</p><ul><li>在修改数组时(add、remove、set),需要先获取锁，实现多线程写同步</li><li>读的时候不需要加锁，如果读的时候多个线程正在修改数据，读操作还是会读到旧的数据，因为在读的那一刻就已经确定了读的对象是旧对象。</li></ul><p><strong>适用于读多写少的并发场景</strong>：如白名单、黑名单、商品类目的访问和变更等</p><p><strong>缺点</strong></p><p><strong>内存占用问题</strong>。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p><p>　　针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如<a href="http://ifeve.com/concurrenthashmap/">ConcurrentHashMap</a>。</p><p>　　<strong>数据一致性问题</strong>。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p><h4 id="线程不安全的集合"><a href="#线程不安全的集合" class="headerlink" title="线程不安全的集合"></a>线程不安全的集合</h4><ul><li>HashMap</li><li>HashSet</li><li>ArrayList:put方法中，elementData[size++] &#x3D; e，不是一个原子操作</li><li>LinkedList:add方法可能出现指针指向错误节点</li></ul><h4 id="List、Map、Set能不能存NULL？"><a href="#List、Map、Set能不能存NULL？" class="headerlink" title="List、Map、Set能不能存NULL？"></a>List、Map、Set能不能存NULL？</h4><h5 id="List-——-允许为null"><a href="#List-——-允许为null" class="headerlink" title="List —— 允许为null"></a><strong>List —— 允许为null</strong></h5><ul><li>ArrayList底层是数组，可以添加null</li><li>LinkedList底层是双向链表，可以node.value &#x3D; null</li><li>Vector底层是数组，可以存储NULL</li></ul><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h5><ul><li>HashMap只允许有一个key为null的节点，因为Map的key相同，后面节点会替换相同key的节点，可以有多个value为null的节点，当key为null，计算出的hash值为0，放在第一个桶中。可以有多个value为null的节点，这是因为 HashMap 的设计是给单线程使用的，所以如果查询到了 null 值，我们可以通过 hashMap.containsKey(key) 的方法来区分这个 null 值到底是存入的 null？还是压根不存在的 null？这样二义性问题就得到了解决，所以 HashMap 不怕二义性问题。</li><li>TreeMap会调用compareTo方法，当对象为null，会报空指针</li><li>HashTable底层为散列表，需要对value进行判空，会调用key.hashCode()来计算桶的位置，key和value都不能为空。</li></ul><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h5><ul><li>HashSet底层是HashMap，可以有一个key为NULL的元素。</li><li>LinkedHashSet底层也是HashMap，允许一个key为NULL</li><li>TreeSet底层是TreeMap，底层是红黑树，需要对节点的value进行比对排序，不能有key为null的元素</li></ul><h4 id="ConcurrentHashMap为什么key和value都不能存入null？"><a href="#ConcurrentHashMap为什么key和value都不能存入null？" class="headerlink" title="ConcurrentHashMap为什么key和value都不能存入null？"></a>ConcurrentHashMap为什么key和value都不能存入null？</h4><p>从代码层面来看：ConcurrentHashMap在put方法的起始位置就判断Key和Value是否为空，如果是就抛出空指针异常。</p><p><code>ConcurrentHashMap</code> 的 key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，表示没有对象或没有引用。（如果你用 null 作为键，那么你就无法区分这个键是否存在于 <code>ConcurrentHashMap</code> 中，还是根本没有这个键。）同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储<code>ConcurrentHashMap</code> 中的，还是因为找不到对应的键而返回的。</p><p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p><ul><li>值没有在集合中 ；</li><li>值本身就是 null。</li></ul><p>这也就是二义性的由来。</p><p>多线程环境下，存在一个线程操作该 <code>ConcurrentHashMap</code> 时，其他的线程将该 <code>ConcurrentHashMap</code> 修改的情况，所以无法通过 <code>containsKey(key)</code> 来判断否存在这个键值对，也就没办法解决二义性问题了。</p><p>与此形成对比的是，<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入 null 作为参数，就会返回 hash 值为 0 的位置的值。HashMap 的设计是给单线程使用的，所以如果取到 null（空） 值，我们可以通过HashMap 的 containsKey(key)方 法来区分这个 null（空） 值到底是插入值是 null（空），还是本就没有才返回的 null（空） 值。单线程环境下，不存在一个线程操作该 HashMap 时，其他的线程将该 <code>HashMap</code> 修改的情况，所以可以通过 <code>contains(key)</code>来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。</p><p>也就是说，多线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。</p><p>如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>举个例子，现在有线程 T1 调用了 ConcurrentHashMap 的 containsKey(key) 方法，<br>我们期望返回的结果是 false，也就是说，T1 并没有往 ConcurrentHashMap 中 put null（空）值。<br>但是，恰恰出了个意外，在线程 T1 还没有得到返回结果之前，线程 T2 又调用了<br>ConcurrentHashMap 的 put() 方法，插入了一个 Key，并且存入的 Value 是 null（空） 值。那么，线程 T1 最终得到的返回结果就变成 true 了。</p><h4 id="Map的遍历方式"><a href="#Map的遍历方式" class="headerlink" title="Map的遍历方式"></a>Map的遍历方式</h4><p>1）在 for 循环中使用 entries 实现 Map 的遍历（最常见和最常用的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;Java入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;C语言入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapKey</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapValue</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        System.out.println(mapKey + <span class="string">&quot;：&quot;</span> + mapValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）使用 for-each 循环遍历 key 或者 values，一般适用于只需要 Map 中的 key 或者 value 时使用。性能上比 entrySet 较好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Java入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;C语言入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line"><span class="comment">// 打印键集合</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印值集合</span></span><br><span class="line"><span class="keyword">for</span> (String value : map.values()) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）使用迭代器（Iterator）遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Java入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;C语言入门教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;    </span><br><span class="line">    Entry&lt;String, String&gt; entry = entries.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;:&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）通过键找值遍历，这种方式的效率比较低，因为本身从键取值是耗时的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hash怎么扩容有了解吗？"><a href="#hash怎么扩容有了解吗？" class="headerlink" title="hash怎么扩容有了解吗？"></a>hash怎么扩容有了解吗？</h4><ul><li>HashMap的底层是采用数组来存储数据，当 HashMap 中元素个数超过（大于）临界值时会自动触发扩容，这个临界值有一个计算公式。</li><li>threashold&#x3D;loadFactor*capacity。loadFactor 的默认值是 0.75，capacity 的默认值是 16。当元素个数超过临界值就会触发Hash扩容（resize函数），默认扩容的大小是原来数组长度的 2 倍，HashMap 的最大容量是Integer.MAX_VALUE，也就是 2 的 31 次方-1。</li><li>然后会进行数据迁移，会伴随着一次重新 hash 分配（reHash),是非常耗时的，并且会遍历 hash 表中所有的元素，HasMap让容量为2的幂次方，就是方便数据迁移，元素的位置是  元素的hash&amp;（n - 1），此时n是全为1的二进制数，那么元素根据hash值的的位置要么不变，要么加上原来的长度, 底层的行为都是给 table 赋值一个两倍长度的新数组。</li></ul><h4 id="为什么扩容因子是-0-75？"><a href="#为什么扩容因子是-0-75？" class="headerlink" title="为什么扩容因子是 0.75？"></a>为什么扩容因子是 0.75？</h4><p>扩容因子表示 Hash 表中元素的填充程度，扩容因子的值越大，那么触发扩容的元素个数更多，<br>虽然空间利用率比较高，但是 hash 冲突的概率会增加。<br>扩容因子的值越小，触发扩容的元素个数就越少，也意味着 hash 冲突的概率减少，<br>但是对内存空间的浪费就比较多，而且还会增加扩容的频率。<br>因此，扩容因子的值的设置，本质上就是在 冲突的概率 以及 空间利用率之间的平衡。<br>0.75 这个值的来源，和统计学里面的泊松分布有关。</p><p>当扩容因子在 0.75 的时候，链表长度达到 8 的可能性几乎为 0，也就是比较好的达到了空间成本和时间成本的平衡。</p><h4 id="HashMap的Hash值如何计算"><a href="#HashMap的Hash值如何计算" class="headerlink" title="HashMap的Hash值如何计算"></a>HashMap的Hash值如何计算</h4><p> <strong>h &#x3D; (key.hashCode ()) ^ (key.hashCode()&gt;&gt;16)</strong>,让hashCode的高16位和低16位进行异或，这样可以让hash值得散列度更高，尽可能区减少hash冲突的情况，从而去提升数据查找性能。</p><h4 id="HashMap为什么一定大小要是2的幂次方？"><a href="#HashMap为什么一定大小要是2的幂次方？" class="headerlink" title="HashMap为什么一定大小要是2的幂次方？"></a>HashMap为什么一定大小要是2的幂次方？</h4><p>HashMap为了提高存取效率，减少hash冲突，就是要尽量把数据分配均匀，使得每个链表长度大致相同，就可以通过hash值 % 数组长度 来实现。<br>但直接取模运算的效率不如位运算&amp;，当容量为2的n次方时，hash &amp; (capacity - 1) &#x3D;&#x3D; hash % capacity，通过 hash &amp; (capacity - 1) 来替代取模运算，而前提就是容量必须为2的n次方。</p><h4 id="HashMap怎么解决hash冲突的"><a href="#HashMap怎么解决hash冲突的" class="headerlink" title="HashMap怎么解决hash冲突的"></a>HashMap怎么解决hash冲突的</h4><p>hash 冲突问题 : 也就是两个不同 hash 值的 key，最终&amp;运算会落到同一个数组下标。所以 HashMap 引入了链式寻址法来解决 hash 冲突问题， 对于存在冲突的key，HashMap 把这些 key 组成一个单向链表。然后采用尾插法把这个 key 保存到链表的尾部。另外，为了避免链表过长的问题，当链表长度大于 8 并且数组长度大于等于 64 的时候，HashMap 会把链表转化为红黑树,从而减少链表数据查询的时间复杂度问题，提升查询性能</p><p>解决 hash 冲突问题的方法有很多，比如</p><ul><li>再 hash 法，就是如果某个 hash 函数产生了冲突，再用另外一个 hash 进行计算，</li><li>开放寻址法，就是直接从冲突的数组位置往下寻找一个空的数组下标进行数据存储，(这个在 ThreadLocal 里面有使用到)。</li><li>建立公共溢出区，也就是把存在冲突的 key 统一放在一个公共溢出区里面。</li></ul><h4 id="为什么HashMap将链表转化为红黑树的阈值是8？"><a href="#为什么HashMap将链表转化为红黑树的阈值是8？" class="headerlink" title="为什么HashMap将链表转化为红黑树的阈值是8？"></a>为什么HashMap将链表转化为红黑树的阈值是8？</h4><p>这是因为在实践中，当链表中的元素数量达到8时，使用红黑树进行查找的效率会超过链表。具体来说，当链表中的元素数量为8时，平均查找长度为8&#x2F;2&#x3D;4。而红黑树的平均查找长度为log(8)，大约是3。因此，将链表转换为红黑树可以提高查找效率。</p><p>然而，红黑树并不是在所有情况下都比链表更优。当红黑树中的元素数量较少时，树结构的维护成本会变得相对较高。这是因为每次插入或删除元素，都可能需要调整树的平衡。因此，当红黑树中的元素数量减少到一定程度时，HashMap会将其转换回链表。在JDK 1.8的实现中，这个阈值是6。</p><p>为何选择6作为红黑树转换回链表的阈值呢？这是因为在实践中，当红黑树中的元素数量小于等于6时，使用链表进行查找的效率会超过红黑树。具体来说，当红黑树中的元素数量为6时，平均查找长度为log(6)，大约是2.58。而链表的平均查找长度为6&#x2F;2&#x3D;3。因此，将红黑树转换回链表可以提高效率。 同时，选择6相比于7和8能避免频繁发生链表和红黑树的转换，造成大量性能消耗</p><h4 id="HashMap在多线程情况下会产生哪些问题？会产生死锁吗？"><a href="#HashMap在多线程情况下会产生哪些问题？会产生死锁吗？" class="headerlink" title="HashMap在多线程情况下会产生哪些问题？会产生死锁吗？"></a>HashMap在多线程情况下会产生哪些问题？会产生死锁吗？</h4><ul><li>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</li><li>为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题。并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</li></ul><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><ul><li><p>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。</p><p>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。</p><p>随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</p></li><li><p>还有一种情况是这两个线程同时 <code>put</code> 操作导致 <code>size</code> 的值不正确，进而导致数据覆盖的问题：</p><ol><li>线程 1 执行 <code>if(++size &gt; threshold)</code> 判断时，假设获得 <code>size</code> 的值为 10，由于时间片耗尽挂起。</li><li>线程 2 也执行 <code>if(++size &gt; threshold)</code> 判断，获得 <code>size</code> 的值也为 10，并将元素插入到该桶位中，并将 <code>size</code> 的值更新为 11。</li><li>随后，线程 1 获得时间片，它也将元素放入桶位中，并将 size 的值更新为 11。</li><li>线程 1、2 都执行了一次 <code>put</code> 操作，但是 <code>size</code> 的值只增加了 1，也就导致实际上只有一个元素被添加到了 <code>HashMap</code> 中。</li></ol></li></ul><h4 id="说一说HashMap-get元素的完整流程"><a href="#说一说HashMap-get元素的完整流程" class="headerlink" title="说一说HashMap get元素的完整流程"></a>说一说HashMap get元素的完整流程</h4><p>先计算key的hashcode值，然后计算key的hash值，通过（n - 1） &amp; hash 找到对应的桶的位置。</p><ul><li><p>如果位置上没有结点，直接返回null。</p></li><li><p>有结点，判断头结点的hash值是否等于key的hash值</p><ul><li><p>hash值相等，继续用 “&#x3D;&#x3D;” 和equals（）判断key是否相等，相等就返回</p></li><li><p>hash值不相等，遍历整个链表或者红黑树结点，还是判断hash值和key是否相等</p></li><li><p>头结点hash值 &lt; 0, 说明map正在扩容，需要到新的table中用一个 find() 方法去查找</p></li></ul></li></ul><h4 id="说一说HashMap-put元素的完整流程"><a href="#说一说HashMap-put元素的完整流程" class="headerlink" title="说一说HashMap put元素的完整流程"></a>说一说HashMap put元素的完整流程</h4><ol><li>根据key的hashcode 获得hash值（hashcode ^ (hashcode  &gt;&gt;&gt; 16)),也就是高十六位与低十六位进行异或运算</li><li>通过hash &amp; (n - 1) 找到对应桶的位置</li><li>如果桶为空，就直接put</li><li>如果桶不为空就遍历桶中所有元素，通过比较hashcode –&gt; “&#x3D;&#x3D;”判断 –&gt;equals 判断是否已存在，存在就更新value值， 不存在，就插入，size++     </li><li>判断是否需要转化为红黑树，是否需要扩容</li></ol><h4 id="ConcurrentHashMap为什么能保证线程安全？"><a href="#ConcurrentHashMap为什么能保证线程安全？" class="headerlink" title="ConcurrentHashMap为什么能保证线程安全？"></a>ConcurrentHashMap为什么能保证线程安全？</h4><p>添加元素时首先会判断容器是否为空，</p><ul><li><p>如果为空则使用 volatile 加 CAS 来初始化，防止多个线程同时初始化，造成并发问题，</p></li><li><p>如果容器不为空，则根据存储的元素计算该位置是否为空。</p><ul><li><p>如果根据存储的元素计算结果桶为空，则利用 CAS 设置该节点，避免并发冲突；</p></li><li><p>如果根据存储的元素计算桶为空不为空，则使用 synchronized 锁住这个桶链表的头结点，然后，遍历桶中的数据，根据hash值与key，更新或新增节点到桶中，</p></li><li><p>如果桶中头结点的hash值为 MOVED（-1），就说明map正在进行扩容，此时会锁住这个桶中的链表来帮助扩容，避免扩容的并发问题，等待扩容完成再put入新的table</p></li><li><p>最后再判断是否需要转为红黑树。这样就能保证并发访问时的线程安全了。</p></li></ul></li></ul><p>设置多个累加单元来计算size()的值，防止并发下计数错误。</p><ul><li>当线程竞争不激烈时，直接采用 CAS 对baseCount操作实现元素个数的原子递增。</li><li>如果线程竞争激烈，使用一个数组来维护元素个数，如果要增加总的元素个数，则直接从数组中随机选择一个，再通过 CAS 实现原子递增，之后遍历数组中所有的值与baseCount累加。它的核心思想是引入了数组来实现对并发更新的负载。</li></ul><p>总结： ConcurrentHashMap 通过<strong>对数组头结点加锁</strong>和<strong>加CAS的初始化</strong>来保证线程安全的。</p><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p><strong>特点</strong></p><ul><li>PriorityQueue 的底层是堆，堆的底层是数组</li><li>PriorityQueue中放置的元素必须要能够比较大小 （只有实现了 Comparable 和 Comparator 接口的类才能比较大小），不能插入无法比较大小的对象，否则会抛出 ClassCastException 异常</li><li>不能插入 null 对象，否则会抛出 NullPointerException 异常</li><li>没有容量限制，可以插入任意多个元素，其内部可以自动扩容</li><li>插入和删除元素的时间复杂度均为 O(log2N)</li><li>PriorityQueue底层使用了堆数据结构</li></ul><p>插入&#x2F;删除&#x2F;获取优先级最高的元素</p><table><thead><tr><th align="left">函数名</th><th>功能介绍</th></tr></thead><tbody><tr><td align="left">boolean offer(E e)&#x2F;add()</td><td>插入元素 e，插入成功返回 true，如果 e 对象为空，抛出 NullPointerException 异常，时间复杂度为 O(log2N) ，注意：空间不够时会自动扩容</td></tr><tr><td align="left">E peek()&#x2F;element()</td><td>获取优先级最高的元素，如果优先级队列为空，返回 null</td></tr><tr><td align="left">E poll()&#x2F;remove()</td><td>移除优先级最高的元素并返回，如果优先级队列为空，返回 null</td></tr><tr><td align="left">int size()</td><td>获取有效元素的个数</td></tr><tr><td align="left">void clean()</td><td>清空</td></tr><tr><td align="left">boolean isEmpty()</td><td>检测优先级队列是否为空，空返回 true</td></tr></tbody></table><h4 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h4><p>前提知识：二叉树的顺序存储<br>使用数组存储二叉树的方式，就是将二叉树按照层序遍历放入数组<br>一般只适合完全二叉树，因为非完全二叉树会有空间的浪费<br>这种方式的主要用法就是堆的表示</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知双亲(parent)的下标</span><br><span class="line">左孩子(left)下标 = 2 * parent + 1;</span><br><span class="line">右孩子(right)下标 = 2 * parent + 2;</span><br><span class="line">已知孩子（不区分左右）(child)下标</span><br><span class="line">双亲(parent)下标 = (child - 1) / 2;</span><br></pre></td></tr></table></figure><p><strong>1、概念</strong><br>概括：堆就是一颗顺序存储的完全二叉树，底层是一个数组</p><p>堆逻辑上是一颗完全二叉树</p><p>堆物理上是保存在数组中</p><p>堆满足任意结点的值都大于其子树中结点的值，也就是所有根节点 &gt; 其左右孩子结点，叫做大堆，或者大根堆、最大堆</p><p>反之则是小堆，或者小根堆、最小堆</p><p>堆的基本作用是快速找到集合中的最值</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70-1710494617676-3.png" alt="img"></p><p><strong>2、性质</strong></p><ul><li>堆中某个节点的值总是不大于或不小于其父结点的值</li><li>堆总是一颗完全二叉树</li></ul><p><strong>3、向下调整</strong></p><p>找左右孩子最大值，然后和父亲结点进行交换</p><p><strong>4、建堆</strong></p><p>这里我们从倒数的第一个非叶子节点的子树开始调整，一直调整到根节点的树，就可以调整成堆。</p><p>具体做法就是，从最后一个非叶子结点子树开始，比较左右孩子结点，较大的孩子结点和父亲结点比较，比父亲结点大的话就进行交换，直到这棵子树已经成了一个堆<br>    <img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70-1710494806954-6.jpeg" alt="img"></p><p><strong>插入一个元素</strong></p><ul><li><strong>过程（以大堆为例）：</strong></li></ul><ol><li>首先按尾插方式放入数组（空间不够时需要扩容）</li><li>比较其和其双亲的值的大小，如果双亲的值大，则满足堆的性质，插入结束</li><li>否则，交换其和双亲位置的值，重新进行 2、3 步骤（2、3就是向上调整的过程）</li><li>直到根结点</li></ol><ul><li><p><strong>图示</strong><br><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70-1710494847608-9.jpeg" alt="在这里插入图片描述"><br>是一个向上调整的过程</p><p><strong>删除一个元素</strong></p><p>为了防止破坏堆的结构，删除时并不是直接将堆顶元素删除，而是</p><ol><li>用数组的最后一个元素替换堆顶元素 ，usedSize–</li><li>然后从堆顶<strong>0号位置</strong>下标的元素开始，通过<strong>向下调整</strong>方式重新调整成堆<br><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpbGxpZUZhbg==,size_16,color_FFFFFF,t_70-1710494869532-12.jpeg" alt="在这里插入图片描述"></li></ol></li></ul><p>​</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h4><p>面向过程：把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。</p><p>面向对象：将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p><p>好处：</p><p><strong>易扩展</strong>：由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，增加或修改业务时，只需要改变小部分代码，使得系统更灵活、更容易扩展，而且成本较低。</p><p><strong>代码复用率高</strong>：可重用现有的已被测试过的类使系统满足业务需求并具有较高的质量。</p><p><strong>效率高</strong>：根据设计的需要对现实世界的事物进行抽象，产生类。使用这样的方法解决问题，接近于日常生活和自然的思考方式，势必提高软件开发的效率和质量。</p><h4 id="Java-基础有哪些核心模块"><a href="#Java-基础有哪些核心模块" class="headerlink" title="Java 基础有哪些核心模块"></a>Java 基础有哪些核心模块</h4><p>这里简单对我觉得 Java 基础比较核心的模块做一下总结：</p><ul><li><strong>异常</strong>：定义了 Java 运行中可能出现的异常，提供了异常处理手段。</li><li><strong>泛型</strong>：使用泛型参数，可以增强代码的可读性以及稳定性。</li><li><strong>反射</strong>：赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</li><li><strong>注解</strong>：可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</li><li><strong>集合</strong>：Java 集合，也叫作容器，可以用于保存数据，主要分为 List, Set, Queue, Map 四大类，这四类分别由不同的用途。</li><li><strong>IO 流</strong>：用于处理输入和输出，比如文件读写。</li><li><strong>多线程</strong>：除了 <code>Thread</code> 类和 <code>Runnable</code> 接口这些基础外，最重要的就是 JUC 了，这个包中包含并发编程中很常用的实用工具类，包括线程池、异步 IO、各种锁等等。</li></ul><h4 id="Java三大特性"><a href="#Java三大特性" class="headerlink" title="Java三大特性"></a>Java三大特性</h4><p><strong>封装</strong></p><blockquote><p>封装指的是属性和方法私有化，根据需要提供setter和getter方法来访问属性。即隐藏具体属性和实现细节，仅对外开放接口，控制程序中属性的访问级别。</p><p>封装目的：增强安全性和简化编程，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员与方法。</p></blockquote><p><strong>继承</strong></p><blockquote><p>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，使用extends关键字实现继承；子类中可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。</p><p>• 继承的出现减少了代码冗余，提高了代码的复用性。<br>• 继承的出现，更有利于功能的扩展。<br>• 继承的出现让类与类之间产生了的关系，为多态的使用提供了前提。</p></blockquote><p><strong>多态</strong></p><blockquote><p>多态就是在声明时使用父类，在实现或调用时使用具体的子类；即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态。</p><p>在 Java 中的体现：父类的引用指向子类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure><p><strong>多态的条件：</strong></p><p><strong>继承</strong>: 在多态中必须存在有继承关系的子类和父类。</p><p><strong>方法重写</strong>: 子类对父类中某些方法进行重新定义,在调用这些方法时就会调用子类的方法。</p><p><strong>向上转型</strong>: 在多态中需要将子类的引用赋给父类对象,只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p></blockquote><blockquote><p>好处：父类变量引用的子类对象不同，执行的方法就不同，实现动态绑定。代码编写更灵活、功能更强大，可维护性和扩展性更好了。<br>弊端：一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法（父类中没有的属性和方法）。</p></blockquote><h4 id="抽象类接口什么不同"><a href="#抽象类接口什么不同" class="headerlink" title="抽象类接口什么不同"></a>抽象类接口什么不同</h4><p><strong>抽象类</strong>：在Java中被abstract关键字修饰的类称为抽象类，被abstract关键字修饰的方法称为抽象方法，抽象方法只有方法的声明，没有方法体。抽象类的特点：</p><p>a、抽象类不能被实例化只能被继承；</p><p>b、包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法，抽象类中可以包含普通方法；</p><p>c、抽象类中的抽象方法的修饰符只能为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），默认为public；</p><p>d、一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类；</p><p>e、抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。</p><p>*<strong>接口*：</strong>Java中接口使用interface关键字修饰，特点为:</p><p>a、接口可以包含变量、方法；变量被隐式指定为public static final，方法被隐式指定为public abstract（JDK1.8之前）；</p><p>b、接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题；</p><p>c、一个类可以实现多个接口；</p><h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a><strong>相同点</strong></h5><p>（1）都不能被实例化 （2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。</p><h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a><strong>不同点</strong></h5><p>（1）接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现（普通方法），方法可在抽象类中实现。</p><p>（2）实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</p><p>（3）接口强调特定功能的实现，而抽象类强调所属关系。</p><h4 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h4><p>深拷贝和浅拷贝是只针对引用数据类型的</p><p><strong>引用拷贝</strong>: 引用拷贝就是直接赋值，只在栈中创建一个新的引用，拷贝引用的地址，所以指向的是堆中同一个对象。</p><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），这个对象有着原始对象属性值的一份精确拷贝。如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。深拷贝会递归拷贝对象所有层级的对象属性和数组元素。深拷贝相比于浅拷贝速度较慢并且花销较大。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111716166.png" alt="image-20231003111716166"></p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111721557.png" alt="image-20231003111721557" style="zoom:150%;" /><h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><p>序列化核心目的是为了解决网络通信之间的对象传输问题。<br>也就是说，如何把当前 JVM 进程里面的一个对象，跨网络传输到另外一个 JVM进程里面。<br>序列化：把内存里面的<strong>对象转化为字节流</strong>，以便用来<strong>实现存储或者传输</strong>。<br>反序列化：根据从<strong>文件或者网络上获取到的对象的字节流</strong>，根据字节流里面保存的<strong>对象描述信息和状态</strong>，重新构建一个新的对象。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111810871.png" alt="image-20231003111810871"></p><p>其次呢，序列化的前提是保证通信双方对于对象的可识别性，所以很多时候，我们会把对象先转化为通用的解析格式，比如 json、xml 等。然后再把他们转化为字节流进行网络传输，从而实现跨平台和跨语言的可识别性。</p><h4 id="Java反射有了解吗？举几个Java反射的应用案例"><a href="#Java反射有了解吗？举几个Java反射的应用案例" class="headerlink" title="Java反射有了解吗？举几个Java反射的应用案例"></a>Java反射有了解吗？举几个Java反射的应用案例</h4><p>反射是java语言的一个特性，<strong>反射功能通常用于检查或修改Java虚拟机运行中（runtime）的应用程序的行为</strong>,它允程序在运行时（注意不是编译的时候），获取任意一个类的成员变量、成员方法和属性,调用任意一个对象的方法和属性,，这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p><ul><li>获取任意类的名称、package信息、所有属性、方法、注解、类型、类加载器等</li><li>获取任意对象的属性，并且能改变对象的属性</li><li>调用任意对象的方法</li><li>判断任意一个对象所属的类</li><li>实例化任意一个类的对象</li><li>通过反射我们可以实现动态装配，降低代码的耦合度,动态代理等。</li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>可以增加程序的灵活性，在运行过程中可以动态对类进行修改和操作</li><li>提高代码复用率，比如动态代理</li><li>可以在运行时轻松获取任意一个类的方法、属性、并且还能通过反射进行动态调用</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>使用反射后，可读性较差</li><li>反射可以绕过一些限制访问的属性和方法，可能会导致一些安全性问题</li><li>反射会涉及动态类型的解析，所以JVM无法对这些代码进行优化，导致性能要比非反射调用更低</li></ul><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>AOP动态代理的场景中，使用动态生成的代理类来提升代码复用性。</li><li>IOC：组件扫描后，用反射来实例化bean对象等</li></ul><h5 id="反射的原理"><a href="#反射的原理" class="headerlink" title="反射的原理"></a>反射的原理</h5><p>通常，java在编译之后，会将Java代码生成为class源文件，JVM启动时，将会载入所有的源文件，并将类信息存放到方法区中；将所有对象实例存放在Java堆中，同时也会保存指向类型信息的指针。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rad5bGx6YGT5aOr,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>以下分两种情况来分析，直接使用类和使用反射的区别，以此理解反射的实现原理。</p><p><strong>直接使用类</strong><br>正常流程下，我们要创建一个类的实例，是一定确定这个类的类型信息的，我们知道这个类的名字、方法、属性等等。我们可以很容易的创建实例，也可以通过实例很容易的获取属性、调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br></pre></td></tr></table></figure><p><strong>使用反射</strong><br>在一个方法中，如果我们不知道在实际运行（runtime）时，它将要处理的对象是谁，它的类型信息是怎么样的，那我们如何访问这个对象或为这个对象创建一个新的实例呢？</p><p>与直接使用类相反，我们需要<strong>先获取到对象在方法区的类型信息</strong>（通过实例对象的getClass方法、全限定类名等限定条件），获取到类型信息后，我们就知道这个类的构造器、属性、方法、注解、子类、父类等等信息了，这个时候，<strong>我们就可以通过这些类型信息来回调处理对象，来完成自己想要的操作了。</strong></p><p><strong>反射在运行时，通过读取方法区中的字节码，来动态的找到其反射的类以及类的方法和属性等（实际上就是在运行时，根据全类型名、对象的getClass()等，在方法区找对应的类）</strong>，用这些类型信息完成对该类实例的操作，其实就是直接使用类的一个逆向使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">void</span> <span class="title function_">reflectMethod</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理这个无法明确类型的实例对象</span></span><br><span class="line">        <span class="comment">// 获取类型信息</span></span><br><span class="line">        Class&lt;?&gt; aClass = obj.getClass();</span><br><span class="line">        Field[] fields = aClass.getFields();</span><br><span class="line">        Method[] methods = aClass.getMethods();</span><br><span class="line">        Annotation[] annotations = aClass.getAnnotations();</span><br><span class="line">        Constructor&lt;?&gt;[] constructors = aClass.getConstructors();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = aClass.getInterfaces();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 操作属性或方法</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> fields[<span class="number">0</span>];</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> field.get(obj); <span class="comment">// 获取obj的属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在实际开发过程会遇到很多这种情况，譬如常用到的Bean属性工具类org.springframework.beans.BeanUtils.copyProperties(Object source, Object target)，在复制对象属性前，它是并不知道source、target这两个对象有什么属性的，那么这个工具类是如何完成属性复制呢？这里其实就用到了反射功能。可以简单了解下流程：</p><ul><li><p>获取target的类型</p></li><li><p>获取target类中属性、getter和setter方法</p></li><li><p>遍历target中的属性，查询source中是否有属性名相同且支持getter和setter的属性</p></li><li><p>通过source.getter.invoke方法读取值</p></li><li><p>最后通过target.setter.invoke(source.getter.invoke) 设置刚刚从source读取的值</p></li><li><p>循环遍历target所有属性后，就完成了整个属性的复制</p></li><li><p>这里只是一个简单的反射运用，感兴趣的可以看看源码</p></li></ul></blockquote><p><strong>总结</strong></p><ul><li><p>直接使用是在运行前就明确类型信息，然后在运行时根据这个类来操作对象；</p></li><li><p>而反射是运行时先拿到对象，根据对象得到方法区中的类型信息后，<strong>再根据属性、方法来操作该对象。</strong></p></li></ul><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p><strong>什么是代理模式</strong></p><p>定义：为其他对象提供一种代理以控制对这个对象的访问。</p><p>如果<strong>根据字节码的创建时机</strong>来分类，可以分为静态代理和动态代理：</p><ul><li>所谓<strong>静态</strong>也就是在<strong>程序运行前</strong>就已经存在代理类的<strong>字节码文件</strong>，代理类和真实主题角色的关系在运行前就确定了。</li><li>而动态代理的源码是在程序运行期间由<strong>JVM</strong>根据<strong>反射</strong>等机制<strong>动态的生成</strong>，所以在运行前并不存在代理类的字节码文件</li></ul><p><strong>静态代理</strong></p><p>我们先通过实例来学习静态代理，然后理解静态代理的缺点，再来学习本文的主角：动态代理</p><p>编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span>;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;查询 selectById&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新 update&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将通过静态代理对 UserServiceImpl 进行功能增强，在调用<code>select</code>和<code>update</code>之前记录一些日志。写一个代理类 UserServiceProxy，代理类需要实现 UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceProxy</span><span class="params">(UserService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        target.select();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        target.update();    <span class="comment">// 这里才实际调用真实主题角色的方法</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;     <span class="comment">// 在执行方法之前执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log start time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;      <span class="comment">// 在执行方法之后执行</span></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log end time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userServiceImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceProxy</span>(userServiceImpl);</span><br><span class="line"></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">查询 selectById</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">log start time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br><span class="line">更新 update</span><br><span class="line">log end time [Thu Dec <span class="number">20</span> <span class="number">14</span>:<span class="number">13</span>:<span class="number">25</span> CST <span class="number">2018</span>] </span><br></pre></td></tr></table></figure><p>通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。</p><p>静态代理的缺点<br>虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。</p><p>1、 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</p><ul><li>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致<strong>代理类过于庞大</strong>,方法过多</li><li>新建多个代理类，每个目标对象对应一个代理类，但是这样会<strong>产生过多的代理类</strong></li></ul><p>2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，<strong>不易维护。</strong></p><p><strong>动态代理就是让代理类动态的生成，最常见的就是使用反射实现</strong>，使用反射（依据被代理类、被代理类的所有接口、被代理类的ClassLoader）来加载代理类</p><p>&#x2F;&#x2F;动态代理：使⽤JDK提供的api（InvocationHandler、Proxy实现），此种⽅式实现，要求被代理类必须实现接⼝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayServiceJDKInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"><span class="comment">//⽬标对象即就是被代理对象</span></span><br><span class="line"><span class="keyword">private</span> Object target;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PayServiceJDKInvocationHandler</span><span class="params">( Object target)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//proxy代理对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"> <span class="comment">//1.安全检查</span></span><br><span class="line"> System.out.println(<span class="string">&quot;安全检查&quot;</span>);</span><br><span class="line"> <span class="comment">//2.记录⽇志</span></span><br><span class="line"> System.out.println(<span class="string">&quot;记录⽇志&quot;</span>);</span><br><span class="line"><span class="comment">//3.时间统计开始</span></span><br><span class="line">System.out.println(<span class="string">&quot;记录开始时间&quot;</span>);</span><br><span class="line"><span class="comment">//通过反射调⽤被代理类的⽅法</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"><span class="comment">//4.时间统计结束</span></span><br><span class="line">System.out.println(<span class="string">&quot;记录结束时间&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">PayService target= <span class="keyword">new</span> <span class="title class_">AliPayService</span>();</span><br><span class="line"><span class="comment">//⽅法调⽤处理器</span></span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PayServiceJDKInvocationHandler</span>(target);</span><br><span class="line"><span class="comment">//创建⼀个代理类：通过被代理类、被代理实现的接⼝、⽅法调⽤处理器来创建</span></span><br><span class="line"><span class="type">PayService</span> <span class="variable">proxy</span> <span class="operator">=</span> (PayService) Proxy.newProxyInstance(</span><br><span class="line">target.getClass().getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;PayService.class&#125;,handler);</span><br><span class="line">proxy.pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK动态代理</strong></p><p>从 UserServiceProxy 的代码中我们可以发现：</p><ul><li>UserServiceProxy 继承了 Proxy 类，并且实现了被代理的所有接口，以及equals、hashCode、toString等方法</li><li>由于 UserServiceProxy 继承了 Proxy 类，所以每个代理类都会关联一个 InvocationHandler 方法调用处理器</li><li>类和所有方法都被 <code>public final</code> 修饰，所以代理类只可被使用，不可以再被继承</li><li>每个方法都有一个 Method 对象来描述，Method 对象在static静态代码块中创建，以 <code>m + 数字</code> 的格式命名</li><li>调用方法的时候通过 <code>super.h.invoke(this, m1, args)</code> 调用，其中的 <code>super.h.invoke</code> 实际上是在创建代理的时候传递给 <code>Proxy.newProxyInstance</code> 的 xxxHandler 对象，它继承 InvocationHandler 类，负责实际的调用处理逻辑</li></ul><p>而 LogHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，<strong>然后通过反射让被代理的对象 target 执行方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    before();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);       <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">    after();</span><br><span class="line">    <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以车站卖票的例子来看</strong></p><pre><code>1. 通过代理对象调用sell()方法2. 根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法3. 代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法，传入调用的方法以及参数4. invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法</code></pre><p>JDK动态代理执行方法调用的过程简图如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-776369e13e295f3c8e33489251bd4927_1440w.webp" alt="img"></p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="Error与Exception的区别"><a href="#Error与Exception的区别" class="headerlink" title="Error与Exception的区别"></a>Error与Exception的区别</h4><p>(1)Error类和Exception类都是继承Throwable类<br>(2)Error（错误）<strong>是系统中的错误</strong>，程序员是不能改变的和处理的，是在<strong>程序编译时出现的错误</strong>，只能通过修改程序才能修正。一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。<br>(3)Exception（异常）表示程序可以处理的异常，<strong>可以捕获且可能恢复</strong>。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。<br><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY5ODU2MQ==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><h4 id="异常顶层是什么，有哪些接口实现类"><a href="#异常顶层是什么，有哪些接口实现类" class="headerlink" title="异常顶层是什么，有哪些接口实现类"></a>异常顶层是什么，有哪些接口实现类</h4><p><strong>Java 异常类层次结构图概览</strong>：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/640.png" alt="图片"></p><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong><code>Exception</code></strong>: 程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。</li><li>分为 Checked Exception 非运行时异常（编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义unchecked异常。通俗的话说，就是在写代码时出现红线，需要try catch或者throws时出现的异常。</li><li>Unchecked Exception(运行时异常)，都是RuntimeException类及其子类异常，就是我们在开发中测试功能时程序终止，控制台出现的异常，比如：<br>NullPointerException(空指针异常)<br>IndexOutOfBoundsException(下标越界异常)<br>ClassCastException(类转换异常)<br>ArrayStoreException(数据存储异常，操作数组时类型不一致)<br>IO操作的BufferOverflowException异常</li><li><strong><code>Error</code></strong>: <code>Error</code> 属于程序无法处理的错误 ，不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h4 id="全局异常处理器如何实现？"><a href="#全局异常处理器如何实现？" class="headerlink" title="全局异常处理器如何实现？"></a>全局异常处理器如何实现？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用ControllerAdvice注解标识该类为异常处理类</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常处理，指定该方法处理的异常类型为Exception</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="comment">//将返回的Result转化为Json格式，在controller中已经包含此注解</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">error</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.build(<span class="literal">null</span> , <span class="number">201</span>,<span class="string">&quot;出现了异常&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常处理，指定该方法处理的异常类型为GuiguException</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = GuiguException.class)</span><span class="comment">// 处理自定义异常</span></span><br><span class="line">    <span class="comment">//将返回的Result转化为Json格式，在controller中已经包含此注解</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">error</span><span class="params">(GuiguException exception)</span> &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.build(<span class="literal">null</span> , exception.getResultCodeEnum()) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么情况下会报ClassNotFound的异常？"><a href="#什么情况下会报ClassNotFound的异常？" class="headerlink" title="什么情况下会报ClassNotFound的异常？"></a>什么情况下会报ClassNotFound的异常？</h4><p>当应用程序运行的过程中尝试使用类加载器去加载Class文件的时候，如果没有在classpath中查找到指定的类，就会抛出ClassNotFoundException。一般情况下，当我们使用Class.forName()或者ClassLoader.loadClass以及使用ClassLoader.findSystemClass()在运行时加载类的时候，如果类没有被找到，那么就会导致JVM抛出ClassNotFoundException。</p><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><h4 id="字符流与字节流"><a href="#字符流与字节流" class="headerlink" title="字符流与字节流"></a>字符流与字节流</h4><p><strong>流</strong><br>流是一个抽象的概念，可以看作是一连串的数据，在程序中所有的数据都是以流的方式进行传输或保存的，程序需要数据的时候要使用输入流读取数据，而当程序需要将一些数据保存起来的时候，就要使用输出流完成。程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。</p><p>Java中的流是对字节序列的抽象，我们可以想象有一个水管，只不过现在流动在水管中的不再是水，而是字节序列。和水流一样，Java中的流也具有一个“流动的方向”，通常可以从中读入一个字节序列的对象被称为输入流；能够向其写入一个字节序列的对象被称为输出流。</p><blockquote><p>知识补充1：<br>计算机能存储的唯一东西就是 bytes,为了在计算机中存储东西,我们首先得将其编码(encode),例如将其转化为 bytes。<br>比如：要想保存音乐(以字节形式保存),我们首先得用 MP3, WAV 等将其编码；要想保存图片,我们首先得用 PNG, JPEG 等将其编码；要想保存文本,我们首先得用 ASCII, UTF-8 等将其编码.<br>知识补充2:<br>Unicode 是字符集,不是字符编码。Unicode 把全世界的字符都搜集并且编号了,但是没有规定具体的编码规则。编码规则有 UTF-8、GBK等。</p></blockquote><p><strong>字节流</strong><br>Java中的字节流处理的最基本单位为单个字节，它通常用来处理二进制数据。Java中最基本的两个字节流类是InputStream和OutputStream，它们分别代表了最基本的输入字节流和输出字节流。InputStream是所有字节输入流的祖先，而OutputStream是所有字节输出流的祖先，它们都是抽象类。</p><p><strong>字节流在默认情况下是不支持缓存的，字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，这意味着每调用一次read方法都会请求操作系统来读取一个字节，这往往会伴随着一次磁盘IO</strong>，因此效率会比较低。要使用内存缓冲区以提高读取的效率，我们应该使用BufferedInputStream。</p><p>需注意，使用BufferedOutputStream输出数据时如果没有关闭流，数据也是不会输出到文件当中的，即并不是所有字节流都不用到缓冲区，输入缓冲字节流BufferedInputStream和输出缓冲字节流BufferedOutputStream还是要用到缓冲区的。</p><p><strong>字符流</strong></p><p><strong>为什么要有字符流？</strong></p><p>Java中字符是采用Unicode标准，Unicode 编码中，一个英文为一个字节，一个中文为两个字节。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-bc6b06e4cf29ecb425f56eb3e72d6e40_1440w.webp" alt="img"></p><p>而在UTF-8编码中，一个中文字符是3个字节。例如下面图中，“云深不知处”5个中文对应的是15个字节：-28-70-111-26-73-79-28-72-115-25-97-91-27-92-124</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-d10f2fb7a759d08a233fb04dd7ca7b95_1440w.webp" alt="img"></p><p>那么问题来了，如果使用字节流处理中文，如果一次读写一个字符对应的字节数就不会有问题，一旦将一个字符对应的字节分裂开来，就会出现乱码了。为了更方便地处理中文这些字符，Java就推出了字符流。</p><p>Java中的字符流处理的最基本的单元是Unicode码元（大小2字节），它通常<strong>用来处理文本数据</strong>，例如字符、字符数组或字符串。Java中的String类型默认就把字符以Unicode规则编码而后存储在内存中。存储在磁盘上的数据通常有着各种各样的编码方式，不同的编码方式最终输出的字节内容是不同的，所以，字节流的读取和写入都要<strong>设置相应的编码方式。</strong></p><p>由于<strong>字符流在输出前</strong>实际上是要完成<strong>Unicode码元序列</strong>到相应编码方式的<strong>字节序列的转换</strong>，所以它会使用<strong>内存缓冲区</strong>来存放转换后得到的<strong>字节序列</strong>，等待都转换完毕再一同写入磁盘文件中。</p><p>所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列。</p><p>字符流与字节流的区别：</p><ul><li><p>字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元（通常为两个字节）。<br>字节流默认不使用缓冲区；字符流使用缓冲区(用于保存由字符转化为的字节)。</p></li><li><p>字节流在操作的时候本身是不会用到缓冲区的，是与文件本身直接操作的，所以字节流在操作文件时，即使不关闭资源，文件也能输出；字符流在操作的时候是使用到缓冲区的。如果字符流不调用close或flush方法，则不会输出任何内容。</p></li><li><p>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</p></li><li><p>字节流按字节读数据,而字节不需要编码、解码,只有字节与字符之间转换时才需要编码、解码！</p></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="单例模式（重要）"><a href="#单例模式（重要）" class="headerlink" title="单例模式（重要）"></a>单例模式（重要）</h4><p><strong>何为单例模式</strong><br>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。<br><strong>实现思路</strong><br>如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将 类的构造器的访问权限设置为 private ，这样，就不能用 new 操作符在类的外部产生类的对<br>象了，但在类内部仍可以产生该类的对象。</p><p>因为在类的外部开始还无法得到类的对象， 只能调用该类的某个静态方法 以返回类内部创建的对象，</p><p>静态方法只能访问类中的静态成员变量，所以，指向类内部产生的 该类对象的变量也必须定义成静态的 。</p><h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 私有化构造器，防止使用构造器new对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 内部提供一个当前类的实例</span></span><br><span class="line">    <span class="comment">// 4. 此实例也必须静态化，才能让静态方法返回该实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 3. 提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="懒汉式-多线程环境下多个线程同时初始化对象会出现线程安全问题，需要加上类锁"><a href="#懒汉式-多线程环境下多个线程同时初始化对象会出现线程安全问题，需要加上类锁" class="headerlink" title="懒汉式(多线程环境下多个线程同时初始化对象会出现线程安全问题，需要加上类锁)"></a>懒汉式(多线程环境下多个线程同时初始化对象会出现线程安全问题，需要加上类锁)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyOne</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyOne instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyOne</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方式 1 ：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazyOne <span class="title function_">getInstance1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式 2 ：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title function_">getInstance2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazyOne.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式 3 ：存在线程安全问题，当线程1获得锁，new instance并不是一个原子操作</span></span><br><span class="line"><span class="comment">//线程2判断instance不为空可能返回未初始化完成的instance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title function_">getInstance2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyOne.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">                    <span class="comment">//分配空间</span></span><br><span class="line">                    <span class="comment">//初始化</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要解决双重检查锁模式带来空指针异常的问题，只需要使用 `volatile` 关键字, `volatile` 关键字可以保证可见性和有序性。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过静态内部类实现懒汉式单例模式，不需要加锁，较为推荐</strong></p><p>静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder</p><p>并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p><h5 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h5><p>使用<strong>序列化与反序列化</strong>可以生成多个实例对象，会破坏单例设计模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//往文件中写对象</span></span><br><span class="line">        <span class="comment">//writeObject2File();</span></span><br><span class="line">        <span class="comment">//从文件中读取对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断两个反序列化后的对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title function_">readObjectFromFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建对象输入流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//第一个读取Singleton对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeObject2File</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的对象</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="comment">//创建对象输出流</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//将instance对象写出到文件中</span></span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决</strong>：在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面是为了解决序列化反序列化破解单例模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：反射能够调用private的构造方法，破坏单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的字节码对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Singleton.class;</span><br><span class="line">        <span class="comment">//获取Singleton类的私有无参构造方法对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//取消访问检查</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Singleton类的对象s1</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line">        <span class="comment">//创建Singleton类的对象s2</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断通过反射创建的两个Singleton对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决</strong>：在构造器中添加判断逻辑，如果instance不为空，就抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           反射破解单例模式需要添加的代码</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>饿汉式</strong>：</p><ul><li><strong>特点</strong>： 立即加载 ，即在使用类的时候已经将对象创建完毕。</li><li><strong>优点</strong>：实现起来 简单 ；没有多线程安全问题。</li><li><strong>缺点</strong>：当类被加载的时候，会初始化 static 的实例，静态变量被创建并分配内存空间，从这以后，这个 static 的实例便一直占着这块内存，直到类被卸载时，静态变量被摧毁，并释放所占有的内存。因此在某些特定条件下会 耗费内存 。</li></ul><p><strong>懒汉式</strong>：</p><ul><li><strong>特点</strong>： 延迟加载 ，即在调用静态方法时实例才被创建。</li><li><strong>优点</strong>：实现起来比较简单；当类被加载的时候，static 的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会节约内存 。</li><li><strong>缺点</strong>：在多线程环境中，这种实现方法是完全错误的， 线程不安全 ，需要加锁保证单例的唯一性。</li></ul><p><strong>单例模式的优点及应用场景</strong><br>由于单例模式只生成一个实例，减少了 系统性能开销 ，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时，直接产生一个单例对象，然后永久驻留内存的方式来解决。</p><h4 id="Strategy策略模式"><a href="#Strategy策略模式" class="headerlink" title="Strategy策略模式"></a><strong>Strategy策略模式</strong></h4><p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们之间可以相互替换，策略模式可以在不影响客户端的情况下发生变化。 策略模式是处理算法不同变体的一种成熟模式，策略模式通过接口或抽象类封装算法的标识，即在接口中定义一个抽象方法，实现该接口的类将实现接口中的抽象方法。策略模式把针对一个算法标识的一系列具体算法分别封装在不同的类中，使得各个类给出的具体算法可以相互替换。</p><p>策略模式的结构：</p><ul><li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li></ul><p>【例】促销活动</p><p>一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p>代码如下：</p><p>定义百货公司所有促销活动的共同接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为春节准备的促销活动A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买一送一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为中秋准备的促销活动B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满200元减50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为圣诞准备的促销活动C</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalesMan</span> &#123;                        </span><br><span class="line">    <span class="comment">//持有抽象策略角色的引用                              </span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;                 </span><br><span class="line">                                               </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SalesMan</span><span class="params">(Strategy strategy)</span> &#123;       </span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;              </span><br><span class="line">    &#125;                                          </span><br><span class="line">                                               </span><br><span class="line">    <span class="comment">//向客户展示促销活动                                </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">salesManShow</span><span class="params">()</span>&#123;                </span><br><span class="line">        strategy.show();                       </span><br><span class="line">    &#125;                                          </span><br><span class="line">&#125;                                              </span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p><strong>1，优点：</strong></p><ul><li><p>策略类之间可以自由切换</p><p>由于策略类都实现同一个接口，所以使它们之间可以自由切换。</p></li><li><p>易于扩展</p><p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“</p></li><li><p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想。</p></li></ul><p><strong>2，缺点：</strong></p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li></ul><p><strong>使用场景</strong></p><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li></ul><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><strong>工厂模式</strong></h4><p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。现在在以一个具体的例子来简单简化下工厂模式。假如我现在去餐馆吃饭，餐馆有回锅肉，有鱼，有烤鸭可供我选择，然后我点餐餐馆为我做出具体的菜。</p><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>首先我们来创建一个餐馆的接口,因为这里只要有做菜就行，所以写一个cook的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Resaurant</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来写三个实现类，分别是做回锅肉的，做鱼的，做烤鸭的，用这三个实现类去实现餐馆的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> <span class="keyword">implements</span> <span class="title class_">Resaurant</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来一份烤鸭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">implements</span> <span class="title class_">Resaurant</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来一份红烧鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Meet</span> <span class="keyword">implements</span> <span class="title class_">Resaurant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来一份回锅肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在餐馆已经具备了做回锅肉，做鱼，做烤鸭的功能，但是客人来了并不知道餐馆有这些菜，这时候就需要我们来给餐馆做一个菜单，客人来了就可以根据菜单点餐；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wait</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MEAN_MEET</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MEAN_FISH</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MEAN_DUCK</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Resaurant <span class="title function_">getMean</span><span class="params">(<span class="type">int</span> meantype)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (meantype)&#123;</span><br><span class="line">            <span class="keyword">case</span> MEAN_MEET :</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Meet</span>();</span><br><span class="line">            <span class="keyword">case</span> MEAN_FISH :</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">            <span class="keyword">case</span> MEAN_DUCK :</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>菜单也有了，现在客人来了可以点餐了，假如客人根据菜单点了一份烤鸭，那餐馆就可以直接给客人制作一份美味的烤鸭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//简单工厂模式</span></span><br><span class="line">        <span class="type">Resaurant</span> <span class="variable">resaurant</span> <span class="operator">=</span> Wait.getMean(Wait.MEAN_DUCK);</span><br><span class="line">        resaurant.cook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看执行结果</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-fdb9586dea3ad2f16c5e3ba1289117c1_1440w.webp" alt="img"></p><h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>工厂模式除了简单工厂模式还有工厂方法模式和抽象工厂模式，下面我再已餐馆这个例子给大家扩展一下工厂方法模式。工厂方法模式就是把简单工厂中具体的工厂类，划分成两层：抽象工厂层+具体的工厂子类层。</p><p>首先我们来创建一个抽象工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CookFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Resaurant <span class="title function_">createRestaurant</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建两个具体需要的产品实现类去继承上面这个抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DuckFactory</span> <span class="keyword">extends</span> <span class="title class_">CookFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Resaurant <span class="title function_">createRestaurant</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FishFactory</span> <span class="keyword">extends</span> <span class="title class_">CookFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Resaurant <span class="title function_">createRestaurant</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>烤鸭和鱼都做好了，开始享用吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cook</span> &#123;</span><br><span class="line">    <span class="comment">//工厂方法模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Resaurant</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DuckFactory</span>().createRestaurant();</span><br><span class="line">        duck.cook();</span><br><span class="line">        <span class="type">Resaurant</span> <span class="variable">fish</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FishFactory</span>().createRestaurant();</span><br><span class="line">        fish.cook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下执行结果</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/v2-6f3165566e6db1dc7ac0a40aabd93d9e_1440w.webp" alt="img"></p><p><strong>优点和缺点</strong></p><p>优点：</p><ul><li><strong>一个调用者想创建一个对象，只要知道其名称就可以了。</strong></li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li><li>屏蔽产品的具体实现，调用者只关心产品的接口。</li></ul><p>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p><strong>概述</strong>：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p><p><strong>结构</strong>：原型模式包含如下角色：</p><ul><li>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ul><p>接口类图如下：</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png"></p><p><strong>用原型模式生成“三好学生”奖状</strong></p><p>同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。</p><p>类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F1.png" style="zoom:80%;" /><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奖状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试访问类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        c1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制奖状</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> c1.clone();</span><br><span class="line">        <span class="comment">//将奖状的名字修改李四</span></span><br><span class="line">        c2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>对象的创建非常复杂，可以使用原型模式快捷的创建对象。</li><li>性能和安全要求比较高。</li></ul><h5 id="扩展（深克隆）"><a href="#扩展（深克隆）" class="headerlink" title="扩展（深克隆）"></a>扩展（深克隆）</h5><p>将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奖状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStu</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stu = stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(stu.getName() + <span class="string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line">        c1.setStu(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制奖状</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> c1.clone();</span><br><span class="line">        <span class="comment">//获取c2奖状所属学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> c2.getStu();</span><br><span class="line">        stu1.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断stu对象和stu1对象是否是同一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F2.png" style="zoom:80%;" /><p><font color="red">说明：</font></p><p>​stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，</p><p>可以重写clone方法实现。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// constructors, getters and setters</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) <span class="built_in">super</span>.clone();</span><br><span class="line">        user.setAddress(<span class="built_in">this</span>.address.clone());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用序列化实现深拷贝</p><p>Java提供了序列化的能力，我们可以先将源对象进行序列化，再反序列化生成拷贝对象。但是，使用序列化的前提是拷贝的类（包括其成员变量）需要实现Serializable接口。Apache Commons Lang包对Java序列化进行了封装，我们可以直接使用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String country;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// constructors, getters and setters</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// constructors, getters and setters</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serializableCopy</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;杭州&quot;</span>, <span class="string">&quot;中国&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;大山&quot;</span>, address);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 使用Apache Commons Lang序列化进行深拷贝</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">copyUser</span> <span class="operator">=</span> (User) SerializationUtils.clone(user);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 修改源对象的值</span></span><br><span class="line">    user.getAddress().setCity(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 检查两个对象的值不同</span></span><br><span class="line">    assertNotSame(user.getAddress().getCity(), copyUser.getAddress().getCity());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="序列化为JSON"><a href="#序列化为JSON" class="headerlink" title="序列化为JSON"></a>序列化为JSON</h5><p>Gson可以将对象序列化成JSON，也可以将JSON反序列化成对象，所以我们可以用它进行深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gsonCopy</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;杭州&quot;</span>, <span class="string">&quot;中国&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;大山&quot;</span>, address);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 使用Gson序列化进行深拷贝</span></span><br><span class="line">    <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    <span class="type">User</span> <span class="variable">copyUser</span> <span class="operator">=</span> gson.fromJson(gson.toJson(user), User.class);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 修改源对象的值</span></span><br><span class="line">    user.getAddress().setCity(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 检查两个对象的值不同</span></span><br><span class="line">    assertNotSame(user.getAddress().getCity(), copyUser.getAddress().getCity());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p><strong>定义：</strong></p><p>​运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p><p>【例】俄罗斯方块</p><p>下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97.jpeg" style="zoom:60%;" /><p><strong>先来看类图：</strong></p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p><strong>代码如下：</strong></p><p>俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getShape</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方块形状：&quot;</span> + <span class="built_in">this</span>.getShape() + <span class="string">&quot; 颜色：&quot;</span> + color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;L&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, AbstractBox&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BoxFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, AbstractBox&gt;();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">iBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">lBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">oBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OBox</span>();</span><br><span class="line">        map.put(<span class="string">&quot;I&quot;</span>, iBox);</span><br><span class="line">        map.put(<span class="string">&quot;L&quot;</span>, lBox);</span><br><span class="line">        map.put(<span class="string">&quot;O&quot;</span>, oBox);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BoxFactory <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BoxFactory</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BoxFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AbstractBox <span class="title function_">getBox</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优缺点和使用场景"><a href="#优缺点和使用场景" class="headerlink" title="优缺点和使用场景"></a>优缺点和使用场景</h5><p><strong>优点</strong></p><ul><li>极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</li></ul><p><strong>使用场景：</strong></p><ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li></ul><h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p><strong>定义：</strong></p><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p><p>【例】炒菜</p><p>炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">cookProcess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//第一步：倒油</span></span><br><span class="line">        <span class="built_in">this</span>.pourOil();</span><br><span class="line">        <span class="comment">//第二步：热油</span></span><br><span class="line">        <span class="built_in">this</span>.heatOil();</span><br><span class="line">        <span class="comment">//第三步：倒蔬菜</span></span><br><span class="line">        <span class="built_in">this</span>.pourVegetable();</span><br><span class="line">        <span class="comment">//第四步：倒调味料</span></span><br><span class="line">        <span class="built_in">this</span>.pourSauce();</span><br><span class="line">        <span class="comment">//第五步：翻炒</span></span><br><span class="line">        <span class="built_in">this</span>.fry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;倒油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：热油是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heatOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;热油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：倒调味料是不一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五步：翻炒是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;炒啊炒啊炒到熟啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_BaoCai</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是包菜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是辣椒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_CaiXin</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是菜心&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是蒜蓉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//炒手撕包菜</span></span><br><span class="line">        <span class="type">ConcreteClass_BaoCai</span> <span class="variable">baoCai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass_BaoCai</span>();</span><br><span class="line">        baoCai.cookProcess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//炒蒜蓉菜心</span></span><br><span class="line">        <span class="type">ConcreteClass_CaiXin</span> <span class="variable">caiXin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass_CaiXin</span>();</span><br><span class="line">        caiXin.cookProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：为防止恶意操作，一般模板方法都加上 final 关键词。</p></blockquote><p><strong>优点：</strong></p><ul><li><p>提高代码复用性</p><p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p></li><li><p>实现了反向控制</p><p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。</p></li></ul><p><strong>缺点：</strong></p><ul><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li></ul><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><p><strong>定义：</strong></p><p>​指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p><p><strong>例子</strong></p><p>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。</p><p>使用继承的方式存在的问题：</p><ul><li><p>扩展性不好</p><p>如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。</p></li><li><p>产生过多的子类</p></li></ul><p>我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.png" style="zoom:75%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快餐接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> price;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">(<span class="type">float</span> price, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">float</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDesc</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span>;  <span class="comment">//获取价格</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒饭</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRice</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedRice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">10</span>, <span class="string">&quot;炒饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedNoodles</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedNoodles</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">12</span>, <span class="string">&quot;炒面&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配料类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Garnish</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FastFood fastFood;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FastFood <span class="title function_">getFastFood</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFastFood</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Garnish</span><span class="params">(FastFood fastFood, <span class="type">float</span> price, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(price,desc);</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鸡蛋配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Egg</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Egg</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(fastFood,<span class="number">1</span>,<span class="string">&quot;鸡蛋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//培根配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bacon</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bacon</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(fastFood,<span class="number">2</span>,<span class="string">&quot;培根&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//点一份炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">&quot; &quot;</span> + food.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加鸡蛋的炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line"></span><br><span class="line">        food1 = <span class="keyword">new</span> <span class="title class_">Egg</span>(food1);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food1.getDesc() + <span class="string">&quot; &quot;</span> + food1.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加培根的炒面</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedNoodles</span>();</span><br><span class="line">        food2 = <span class="keyword">new</span> <span class="title class_">Bacon</span>(food2);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food2.getDesc() + <span class="string">&quot; &quot;</span> + food2.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>好处：</strong></p><ul><li><p>装饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</p></li><li><p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p></li></ul><p><strong>使用场景</strong></p><ul><li><p>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</p><p>不能采用继承的情况主要有两类：</p><ul><li>第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；</li><li>第二类是因为类定义不能继承（如final类）</li></ul></li><li><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p></li><li><p>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</p></li></ul><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p><strong>定义</strong>：又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p>【例】现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。</p><p>类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请假条</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//请假天数</span></span><br><span class="line">    <span class="keyword">private</span> String content;<span class="comment">//请假内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeaveRequest</span><span class="params">(String name, <span class="type">int</span> num, String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理者抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_ONE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_THREE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_SEVEN</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该领导处理的请假天数区间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//领导上面还有领导</span></span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围 上不封顶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart, <span class="type">int</span> numEnd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">        <span class="built_in">this</span>.numEnd = numEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置上级领导</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(Handler nextHandler)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交请假条</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(LeaveRequest leave)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">this</span>.numStart)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果请假天数达到该领导者的处理要求</span></span><br><span class="line">        <span class="keyword">if</span>(leave.getNum() &gt;= <span class="built_in">this</span>.numStart)&#123;</span><br><span class="line">            <span class="built_in">this</span>.handleLeave(leave);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果还有上级 并且请假天数超过了当前领导的处理范围</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> != <span class="built_in">this</span>.nextHandler &amp;&amp; leave.getNum() &gt; numEnd)&#123;</span><br><span class="line">                <span class="built_in">this</span>.nextHandler.submit(leave);<span class="comment">//继续提交</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;流程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各级领导处理请假条方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小组长</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupLeader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//小组长处理1-3天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_ONE, Handler.NUM_THREE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小组长审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//部门经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理3-7天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_THREE, Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;部门经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GeneralManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理7天以上的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//请假条来一张</span></span><br><span class="line">        <span class="type">LeaveRequest</span> <span class="variable">leave</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="string">&quot;小花&quot;</span>,<span class="number">5</span>,<span class="string">&quot;身体不适&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//各位领导</span></span><br><span class="line">        <span class="type">GroupLeader</span> <span class="variable">groupLeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>();</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        <span class="type">GeneralManager</span> <span class="variable">generalManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralManager</span>();</span><br><span class="line"></span><br><span class="line">        groupLeader.setNextHandler(manager);<span class="comment">//小组长的领导是部门经理</span></span><br><span class="line">        manager.setNextHandler(generalManager);<span class="comment">//部门经理的领导是总经理</span></span><br><span class="line">        <span class="comment">//之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交申请</span></span><br><span class="line">        groupLeader.submit(leave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p><strong>优点：</strong></p><ul><li><p>降低了对象之间的耦合度</p><p>该模式降低了请求发送者和接收者的耦合度。</p></li><li><p>增强了系统的可扩展性</p><p>可以根据需要增加新的请求处理类，满足开闭原则。</p></li><li><p>增强了给对象指派职责的灵活性</p><p>当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。</p></li><li><p>责任链简化了对象之间的连接</p><p>一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</p></li><li><p>责任分担</p><p>每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</p></li></ul><p><strong>缺点：</strong></p><ul><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li></ul><p>使用案例：Filter的链式调用</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p><strong>定义：</strong></p><p>又被称为发布-订阅（Publish&#x2F;Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><p><strong>结构</strong></p><ul><li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li><li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li><li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li><li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li></ul><p>【例】微信公众号</p><p>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。</p><p>类图如下：</p><img src="./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" style="zoom:80%;" /><p>代码如下：</p><p>定义抽象观察者类，里面定义一个更新的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体观察者类，微信用户是观察者，里面实现了更新的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeixinUser</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 微信用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeixinUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象主题类，提供了attach、detach、notify三个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//增加订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通知订阅者更新消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//储存订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; weixinUserlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserlist.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserlist.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : weixinUserlist) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SubscriptionSubject mSubscriptionSubject=<span class="keyword">new</span> <span class="title class_">SubscriptionSubject</span>();</span><br><span class="line">        <span class="comment">//创建微信用户</span></span><br><span class="line">        WeixinUser user1=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;孙悟空&quot;</span>);</span><br><span class="line">        WeixinUser user2=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;猪悟能&quot;</span>);</span><br><span class="line">        WeixinUser user3=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;沙悟净&quot;</span>);</span><br><span class="line">        <span class="comment">//订阅公众号</span></span><br><span class="line">        mSubscriptionSubject.attach(user1);</span><br><span class="line">        mSubscriptionSubject.attach(user2);</span><br><span class="line">        mSubscriptionSubject.attach(user3);</span><br><span class="line">        <span class="comment">//公众号更新发出消息给订阅的微信用户</span></span><br><span class="line">        mSubscriptionSubject.notify(<span class="string">&quot;传智黑马的专栏更新了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p><strong>优点：</strong></p><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】</li></ul><p><strong>缺点：</strong></p><ul><li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时</li><li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</li></ul><p><strong>使用场景</strong></p><ul><li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。</li></ul><h3 id="JDK新特性"><a href="#JDK新特性" class="headerlink" title="JDK新特性"></a>JDK新特性</h3><h5 id="JDK1-8的新特性"><a href="#JDK1-8的新特性" class="headerlink" title="JDK1.8的新特性:"></a><strong>JDK1.8的新特性:</strong></h5><ol><li><p>stream流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;gkh&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="comment">//返回符合条件的stream</span></span><br><span class="line">    Stream&lt;String&gt; stringStream = strings.stream().filter(s -&gt; <span class="string">&quot;abc&quot;</span>.equals(s));</span><br><span class="line">    <span class="comment">//计算流符合条件的流的数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringStream.count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//forEach遍历-&gt;打印元素</span></span><br><span class="line">    strings.stream().forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>2、Lambda 表达式<br>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、函数式接口</p><p>Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p><p>4、方法与构造函数引用</p><p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">converter = something::startsWith;</span><br><span class="line"><span class="type">String</span> <span class="variable">converted</span> <span class="operator">=</span> converter.convert(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">System.out.println(converted);</span><br></pre></td></tr></table></figure><ol start="5"><li>日期 Date-timeAPI</li></ol><ul><li>增强了时区处理</li><li>增强各种格式化、和时间计算</li></ul><h5 id="JDK9新特性"><a href="#JDK9新特性" class="headerlink" title="JDK9新特性"></a>JDK9新特性</h5><ol><li><p>JShell，为 Java 提供了类似于 Python 的实时命令行交互工具。</p><p><img src="/./../../imgs/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/image-20231003111847441.png" alt="image-20231003111847441"></p></li><li><p>String 改为用byte[]存储。</p></li></ol><h5 id="jdk10新特性"><a href="#jdk10新特性" class="headerlink" title="jdk10新特性"></a>jdk10新特性</h5><p><strong>局部变量类型推断(var)</strong>***</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">id</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">codefx</span> <span class="operator">=</span>newURL(<span class="string">&quot;https://mp.weixin.qq.com/&quot;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span>newArrayList&lt;&gt;();</span><br><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span>List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h5 id="JDK11新特性"><a href="#JDK11新特性" class="headerlink" title="JDK11新特性"></a>JDK11新特性</h5><h5 id="String增强"><a href="#String增强" class="headerlink" title="String增强"></a>String增强</h5><p>增加了一系列的字符串处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断字符串是否为空</span></span><br><span class="line"><span class="string">&quot; &quot;</span>.isBlank();<span class="comment">//true</span></span><br><span class="line"><span class="comment">//去除字符串首尾空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.strip();<span class="comment">// &quot;Java&quot;</span></span><br><span class="line"><span class="comment">//去除字符串首部空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.stripLeading();   <span class="comment">// &quot;Java &quot;</span></span><br><span class="line"><span class="comment">//去除字符串尾部空格</span></span><br><span class="line"><span class="string">&quot; Java &quot;</span>.stripTrailing();  <span class="comment">// &quot; Java&quot;</span></span><br><span class="line"><span class="comment">//重复字符串多少次</span></span><br><span class="line"><span class="string">&quot;Java&quot;</span>.repeat(<span class="number">3</span>);             <span class="comment">// &quot;JavaJavaJava&quot;</span></span><br><span class="line"><span class="comment">//返回由行终止符分隔的字符串集合。</span></span><br><span class="line"><span class="string">&quot;A\nB\nC&quot;</span>.lines().count();    <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;A\nB\nC&quot;</span>.lines().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2024/04/19/JVM/"/>
      <url>/2024/04/19/JVM/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM分区"><a href="#JVM分区" class="headerlink" title="JVM分区"></a>JVM分区</h3><h4 id="jvm堆的分区"><a href="#jvm堆的分区" class="headerlink" title="jvm堆的分区"></a>jvm堆的分区</h4><p>堆中有字符串常量池</p><p>Java堆从GC的角度可以细分为新生代YoungGeneration（Eden区、From Survivor、To Survivor，空间比例8:1:1）和老年代OldGeneration（空间比例1:2）。</p><p><img src="/./../imgs/JVM/v2-108fca6ca82b85d2d6f559d0d469c770_1440w.webp" alt="img"></p><h4 id="jvm各种区域介绍"><a href="#jvm各种区域介绍" class="headerlink" title="jvm各种区域介绍"></a>jvm各种区域介绍</h4><p><strong>Java内存区域</strong></p><p>Java的内存区域和内存模型是不一样的东西，内存区域是指 JVM 运行时将数据分区域存储，强调对内存空间的划分。</p><p>Java内存区域主要由栈、堆、方法区组成</p><p><strong>栈</strong>：每个线程有自己独立、不共享的虚拟机栈，由多个栈帧（每个方法运行时需要的内存）组成，其中存放参数、局部变量，返回地址等，每个线程只能有一个活动栈帧，对应当前正在执行的那个方法。</p><p><strong>堆</strong>：多个线程共享同一个堆，通过new关键字构建的对象都需要使用堆内存，里面存放了实例对象、字符串常量池，类对象、静态变量（存放在_java_mirror后面）等。</p><p><strong>方法区</strong>：保存在着被加载过的每一个类的信息，包括类的方法、构造器，成员方法，属性等，这些信息由<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">类加载</a>器在加载类时，从类的源文件中抽取出来；<strong>运行时常量池</strong>：当该类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址转换为真实地址。</p><p><strong>程序计数器：</strong>每个线程都有一个独立的程序计数器，记录下一条JVM指令的执行地址</p><p><strong>本地方法栈：</strong>调用本地方法（由C或者C++编写的底层的方法，与操作系统的底层API打交道）时给本地方法提供的内存空间</p><p><img src="/./../imgs/JVM/image-20231003112352559.png" alt="image-20231003112352559"></p><p><strong>直接内存：</strong>操作系统的内存，分配回收成本较高，读写性能高，不受JVM内存回收管理</p><h3 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h3><h4 id="强引用、弱引用、软引用、虚引用的区别"><a href="#强引用、弱引用、软引用、虚引用的区别" class="headerlink" title="强引用、弱引用、软引用、虚引用的区别"></a>强引用、弱引用、软引用、虚引用的区别</h4><p>在Java中提供了四个级别的引用：<strong>强引用</strong>，<strong>软引用</strong>，<strong>弱引用</strong>和<strong>虚引用</strong>。在这四个引用类型中，只有强引用FinalReference类是包内可见，其他三种引用类型均为public，可以在应用程序中直接使用。引用类型的类结构如图所示。</p><p><img src="/./../imgs/JVM/image-20231003111728261.png" alt="image-20231003111728261"></p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a><strong>强引用</strong></h5><p>Java中默认声明的就是强引用，例如以下代码，如果M对象被回收了，会打印 finalize() 方法中的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">M</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">M</span>();  <span class="comment">//只要m还指向M对象，M对象就不会被回收</span></span><br><span class="line">        <span class="comment">// m = null;   //手动置null</span></span><br><span class="line">        System.gc();  <span class="comment">// 进行垃圾回收</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象被回收了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/./../imgs/JVM/v2-e5f1836efa6748c371bcd126823414f7_1440w-1696303052906-5.webp" alt="img"></p><p>只要强引用存在，垃圾收集器将永远不会回收被引用的对象，哪怕<strong>内存不足</strong>时，JVM也会直接抛出OutOfMemoryError，<strong>不会去回收</strong>。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了。例如上面的代码，将 m &#x3D; null; 注释放开时，运行结果如下：</p><p><img src="/./../imgs/JVM/image-20231003111738987.png" alt="image-20231003111738987"></p><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a><strong>软引用</strong></h5><p>软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在垃圾回收后，<strong>内存仍然不足</strong>时，系统则<strong>会回收</strong>软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出OutOfMemoryError。这种特性常常被用来实现<strong>缓存技术</strong>，比如网页缓存，图片缓存等。</p><p>在 JDK1.2 之后，用 SoftReference 类来表示软引用。下面以一个例子来进一步说明强引用和软引用的区别。</p><p>在运行下面的Java代码之前，需要先配置参数 -Xms2M -Xmx2M，将 JVM 的初始内存设为2M，最大可用内存为 2M。</p><p>首先先来测试一下强引用，在限制了 JVM 内存的前提下，下面的代码运行正常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 当 new byte为 1M 时，程序运行正常</span></span><br><span class="line">        <span class="type">byte</span>[] buff1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// byte[] buff2 = new byte[1024 * 1024 * 1];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果我们再创建一个1M大小的 byte数组时，则内存不够使用，程序直接报错。因为强引用不会被回收。</p><p><img src="/./../imgs/JVM/image-20231003111745645.png" alt="image-20231003111745645"></p><p>接着来看一下软引用会有什么不一样，在下面的示例中先创建一个大小为 1M 的软引用对象，打印m的地址，然后进行垃圾回收，休眠500ms后打印m的地址。最后又创建了一个1M的字节数组，打印m的地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SoftReference&lt;<span class="type">byte</span>[]&gt; m = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line"> </span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        <span class="comment">// 再分配一个数组，heap将装不下，</span></span><br><span class="line">        <span class="comment">// 这时系统会进行垃圾回收，如果内存不够，会把软引用干掉</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1</span>];</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/./../imgs/JVM/v2-210fffb5827e8aea4115430e5b373238_1440w-1696303070608-7.webp" alt="img"></p><p>根据运行结果，我们可以看到，在内存不足的情况下，软引用才会被回收。</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a><strong>弱引用</strong></h5><p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够</strong>，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象<strong>都会被回收</strong>。在 JDK1.2 之后，用 WeakReference 来表示弱引用。</p><p>我们以与软引用同样的方式来测试一下弱引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        WeakReference&lt;<span class="type">byte</span>[]&gt; m = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line"> </span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/./../imgs/JVM/image-20231003111756526.png" alt="image-20231003111756526"></p><p>根据运行结果，可以发现垃圾回收后被弱引用关联的对象被回收了。</p><p>在 Java 集合中有一种特殊的 Map 类型：<strong>WeakHashMap</strong>， 在这种 Map 中存放了键对象的弱引用，当一个键对象被垃圾回收，那么相应的值对象的引用会从 Map 中删除。WeakHashMap 能够节约存储空间，可用来缓存那些非必须存在的数据。</p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象。</p><p>虚引用必须要和 ReferenceQueue 引用队列一起使用，主要配合ByteBuffer使用，在引用对象被回收时，会将虚引用入队，Reference Handler线程调用虚引用相关方法释放直接内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PhantomReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Object&gt; LIST = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReferenceQueue</span> <span class="variable">QUEUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        PhantomReference&lt;M&gt; m = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">M</span>(), QUEUE);<span class="comment">//关联软引用对象和引用队列</span></span><br><span class="line"> <span class="comment">//当软引用所关联的byte数组被回收时，软引用会自己加入到queue中</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                LIST.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>]);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(m.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Reference</span> <span class="variable">poll</span> <span class="operator">=</span> QUEUE.poll();</span><br><span class="line">                <span class="keyword">if</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//获取queue中的无用的软引用对象，并移除</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;虚引用对象：&quot;</span> + poll + <span class="string">&quot; 被jvm回收了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象被回收了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/./../imgs/JVM/v2-db69836fc83d1e8d39f5088bc1a4b8a9_1440w-1696303085353-9.webp" alt="img"></p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>JVM中的垃圾回收器通过可达性分析来探索所有存活的对象<br>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果找不到，则表示可以回收</p><h5 id="可以作为GC-Root的对象"><a href="#可以作为GC-Root的对象" class="headerlink" title="可以作为GC Root的对象"></a>可以作为GC Root的对象</h5><ul><li>系统类System Class（Object、String等）</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li><li>所有被同步锁（synchronized关键字）持有的对象。</li><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li></ul><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><p><strong>1.标记-清除算法</strong>：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</p><ul><li>该算法分为两个阶段，<strong>标记和清除</strong>。标记阶段标记所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。该算法最大的问题就是内存碎片严重化，后续可能发生对象不能找到利用空间的问题。</li></ul><p><img src="/./../imgs/JVM/v2-7389d400dc04abb145a67fa86a662e33_1440w.webp" alt="img"></p><p><strong>2.复制算法</strong>：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</p><ul><li>按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。</li></ul><p><img src="/./../imgs/JVM/v2-20adb8ac4c5deb44fc27e30c8381281d_1440w.webp" alt="img"></p><p><img src="/./../imgs/JVM/image-20240322203226141.png" alt="image-20240322203226141"></p><p><strong>3.标记-整理算法</strong>：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</p><ul><li>标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。</li></ul><p><img src="/./../imgs/JVM/v2-cc722c4e5b289434d2181451f4fd154c_1440w.webp" alt="img"></p><p><img src="/./../imgs/JVM/image-20240322203239717.png" alt="image-20240322203239717"></p><p><strong>4.分代算法</strong>：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</p><p>minor gc新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</p><p>full gc&#x2F;major gc 老年代的GC，Major GC 的速度一般会比 Minor GC 的慢 10 倍以上</p><p>二 minorGC过程详解<br>1 在初始阶段，新创建的对象被分配到Eden区，survivor的两块空间都为空。</p><p><img src="/./../imgs/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>2 当Eden区满了的时候，minor garbage 被触发 。</p><p><img src="/./../imgs/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111900766-29.png" alt="img"></p><p>3 经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收， 并且存活的对象年龄都增大一岁。</p><p><img src="/./../imgs/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111908107-32.png" alt="在这里插入图片描述"></p><p>4 在下一次的Minor GC中，Eden区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到survivor区。当Eden 和 s0区空间满了，S0的所有的数据都被复制到S1，需要注意的是，在上次minor GC过程中移动到S0中的两个对象在复制到S1后其年龄要加1。此时Eden区S0区被清空，所有存活的数据都复制到了S1区，并且S1区存在着年龄不一样的对象，过程如下图所示：</p><p><img src="/./../imgs/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111915300-35.png" alt="在这里插入图片描述"></p><p>5 再下一次MinorGC则重复这个过程，这一次survivor的两个区对换，存活的对象被复制到S0，存活的对象年龄加1，Eden区和另一个survivor区被清空。</p><p><img src="/./../imgs/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111922409-38.png" alt="在这里插入图片描述"></p><p>6 再经过几次Minor GC之后，当存活对象的年龄达到一个阈值之后（-XX：MaxTenuringThreshold默认是15），就会被从年轻代Promotion到老年代。</p><p><img src="/./../imgs/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111929062-41.png" alt="在这里插入图片描述"></p><p>7 随着MinorGC一次又一次的进行，不断会有新的对象被promote到老年代。</p><p><img src="/./../imgs/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYxNTA2OA==,size_16,color_FFFFFF,t_70-1711111935557-44.png" alt="在这里插入图片描述"></p><p>8 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩(标记-清除或者标记整理)。</p><ul><li><p>从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。</p></li><li><p>老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-整理算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；<strong>如果不允许，则仍然进行Full GC（</strong>这代表着如果设置-XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。</p></li></ul><p>整体描述<br>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。经过这次GC后，Eden区和”From”区已经被清空。这个时候，“From”和”To”会交换他们的角色，也就是新的”To”就是上次GC前的“From”，新的”From”就是上次GC前的”To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，**”To”区被填满之后，会将所有对象移动到年老代**中。</p><p>三 GC触发条件<br>Minor GC触发条件：Eden区满时</p><p>Full GC触发条件：<br>（1）调用System.gc时，系统建议执行Full GC，但是不必然执行<br>（2）老年代空间不足<br>（3）方法区空间不足<br>（4）通过Minor GC后进入老年代的大小大于老年代的可用内存<br>（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</p><p><img src="/./../imgs/JVM/image-20231004144129340.png" alt="image-20231004144129340"></p><p>新生代分为伊甸园和幸存区，幸存区由from space 与 to space 两块相等的内存区域组成。eden ：from ：to &#x3D; 8 : 1 : 1;</p><p>新生代回收之后内存足够使用的话就不会扫描老年代，否则会扫描老年代。</p><h4 id="年轻代怎么升级为老年代"><a href="#年轻代怎么升级为老年代" class="headerlink" title="年轻代怎么升级为老年代"></a>年轻代怎么升级为老年代</h4><h5 id="担保机制"><a href="#担保机制" class="headerlink" title="担保机制"></a>担保机制</h5><p>新生代内存不足的时候（当MinorGC时，如果存活对象过多，无法完全放入Survivor From区），可以通过担保分配的方式让存活对象直接分配进老年代。</p><h5 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h5><p>-XX：PretenureSizeThreshould &#x3D; 3145728，可以设置超过3M的对象直接进入老年代</p><h5 id="长期存活的对象"><a href="#长期存活的对象" class="headerlink" title="长期存活的对象"></a>长期存活的对象</h5><p>在年轻代的对象在minor GC后没有被淘汰年龄就会加1，年龄增加到一定程度就会晋升为老年代，这个晋升的年龄是可以设置的。</p><h5 id="动态年龄判断"><a href="#动态年龄判断" class="headerlink" title="动态年龄判断"></a>动态年龄判断</h5><p>当survivor空间中相同年龄所有<strong>对象的大小总和****大于</strong>survivor空间的一半，年龄大于或等于该年龄的对象就会直接进入老年代，无需等到晋升年龄。</p><h4 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h4><p><a href="https://juejin.cn/post/6974281849031884830">JVM调优——GC 调优 - 掘金 (juejin.cn)</a></p><h5 id="确定合适回收器"><a href="#确定合适回收器" class="headerlink" title="确定合适回收器"></a>确定合适回收器</h5><p>“低延迟”还是“高吞吐量”，选择合适的回收器CMS，G1，ZGC </p><h5 id="降低GC次数，最快的GC是不发生GC"><a href="#降低GC次数，最快的GC是不发生GC" class="headerlink" title="降低GC次数，最快的GC是不发生GC"></a>降低GC次数，最快的GC是不发生GC</h5><p>尽量减少堆内存的使用，减少对象大小、避免数据冗余、排查是否存在内存泄漏</p><h5 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h5><p>新生代的特点</p><ul><li>所有的new操作分配内存都是非常廉价的</li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>MInor GC 所用时间远小于Full GC</li></ul><p><strong>选择合适新生代内存大小</strong></p><ul><li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li><li>新生代内存设置为能容纳**[并发量*(请求-响应)]**的数据为宜</li><li>幸存区大到能保留【当前活跃对象+需要晋升对象】</li><li>晋升阈值配置得当，让长时间存活对象尽快晋升</li></ul><h5 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h5><p>如果fullGC频率不高，就挺适合的</p><p>如果频繁发生fullGC，可以调高老年代空间占用比率，增大堆空间</p><p>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1&#x2F;4 ~ 1&#x2F;3<br>-XX:CMSInitiatingOccupancyFraction&#x3D;percent</p><h4 id="GC调优实战"><a href="#GC调优实战" class="headerlink" title="GC调优实战"></a>GC调优实战</h4><h5 id="分析GC日志-GCEasy"><a href="#分析GC日志-GCEasy" class="headerlink" title="分析GC日志 - GCEasy"></a>分析GC日志 - GCEasy</h5><p>GCeasy是业界首款使用AI机器学习技术在线进行GC分析和诊断的工具。定位内存泄漏、GC延迟高的问题，提供JVM参数优化建议，支持在线的可视化工具图表展示。 官方网站：<a href="https://gceasy.io/">https://gceasy.io/</a> </p><p><img src="/./../imgs/JVM/1712369115106-34.png" alt="img"></p><p>使用方法：</p><p>1、选择文件，找到GC日志并上传</p><p><img src="/./../imgs/JVM/1712369115050-28.png" alt="img"></p><p>2、点击Analyze分析就可以看到报告，每个账号每个月能免费上传5个GC日志。</p><p>建议部分：</p><p><img src="/./../imgs/JVM/1712369115050-29.png" alt="img"></p><p>内存情况：</p><p><img src="/./../imgs/JVM/1712369115050-30.png" alt="img"></p><p>GC关键性指标：</p><p><img src="/./../imgs/JVM/1712369115050-31.png" alt="img"></p><p>GC的趋势图：</p><p><img src="/./../imgs/JVM/1712369115050-32.png" alt="img"></p><p>引发GC的原因：</p><p><img src="/./../imgs/JVM/1712369115050-33.png" alt="img"></p><h4 id="垃圾收集器cms和g1比较"><a href="#垃圾收集器cms和g1比较" class="headerlink" title="垃圾收集器cms和g1比较"></a>垃圾收集器cms和g1比较</h4><h5 id="CMS（仅作用于老年代，基于标记-清除算法）"><a href="#CMS（仅作用于老年代，基于标记-清除算法）" class="headerlink" title="CMS（仅作用于老年代，基于标记-清除算法）"></a>CMS（仅作用于老年代，基于标记-清除算法）</h5><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。这是因为 CMS 收集器工作时，GC 工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的。</p><ul><li>初始标记（CMS initial mark）需要 Stop-the-world，标记一下 GC Roots 能直接关联到的对象，速度很快</li><li>并发标记（CMS concurrent mark）进行 GC Roots Tracing 的过程</li><li>重新标记（CMS remark）需要 Stop-the-world，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始阶段稍长一些，但远比并发标记的时间短。</li><li>并发清除（CMS concurrent sweep）</li></ul><p><img src="/./../imgs/JVM/59307b3ead7530e2f9fedaaf71f5608f.png" alt="img"></p><p>CMS 收集器优点：并发收集、低停顿。</p><p>CMS 收集器缺点：</p><ul><li>CMS 收集器对 CPU 资源非常敏感。</li><li>CMS 收集器无法处理浮动垃圾（Floating Garbage）（CMS在 并发标记 时是并发的，GC 线程和用户线程并发执行，这个过程当然可能会因为线程的交替执行而导致新产生的垃圾（可回收对象，即浮动垃圾）没有被标记到；而 重新标记 只是对之前 并发标记 所获得的不可达对象的更正，所以是没有办法处理 “浮动垃圾” 的。）。</li><li>CMS 收集器是基于标记-清除算法，该算法的缺点都有（内存碎片）。</li><li>停顿时间是不可预期的。</li></ul><h5 id="G1-分为年轻代回收（复制算法），混合回收（年轻代与老年代（标记整理suan’fa）都会回收）"><a href="#G1-分为年轻代回收（复制算法），混合回收（年轻代与老年代（标记整理suan’fa）都会回收）" class="headerlink" title="G1(分为年轻代回收（复制算法），混合回收（年轻代与老年代（标记整理suan’fa）都会回收）)"></a>G1(分为年轻代回收（复制算法），混合回收（年轻代与老年代（标记整理suan’fa）都会回收）)</h5><ul><li>G1 算法取消了堆中年轻代与老年代的物理划分，而是一个逻辑分代，但它仍然属于分代收集器。</li><li>G1 算法将堆划分为若干个区域，称作 Region，</li><li>同时注重**吞吐量（**Throughput）和**低延迟**（Low latency），默认的暂停目标是 200 ms</li><li>G1 采用每次只清理一部分而不是全部的 Region 的增量式清理，由此来保证每次 GC 停顿时间不会过长。</li><li>G1 算法允许通过 JVM 参数设置 Region 的大小，范围是 1～32MB，可以设置期望的最大 GC 停顿时间，根据这个停顿时间来制定回收计划，所以G1的垃圾<font color = gold>回收是可预期的</font>。</li></ul><img src="./../imgs/JVM/image-20231011213513010.png" alt="image-20231011213513010" style="zoom: 50%;" /><p><strong>G1垃圾回收器的垃圾回收方式分为两种。</strong></p><ul><li><strong>一就是YoungGC，主要回收的是年轻代Region中的垃圾，采用<font color = gold>复制算法</font></strong></li><li><strong>第二种就是混合回收模式（Mix GC），这种回收模式会回收年轻代跟老年代中的所有垃圾，采用<font color = gold>标记-整理算法</font>。</strong></li></ul><p>G1 回收过程如下。</p><ul><li><strong>初始标记(Initial Marking)：</strong>这阶段仅仅只是<font color = gold>标记GC Roots能直接关联到的对象</font>，让下一阶段用户程序并发运行时，能在正确的可用的Region中创建新对象，这阶段需要<font color = gold>停顿线程(STW)</font>，但是<font color = gold>耗时很短</font>&gt;。而且是借用<font color = gold>进行Minor GC的时候同步完成的</font>&gt;，所以G1收集器在这个阶段实际并没有额外的停顿。</li><li><strong>并发标记(Concurrent Marking)：</strong>从GC Roots开始对堆的对象进行<font color = gold>可达性分析</font>，并进行三色标记，标记开始时创建一个快照，记录当前所有对象，递归扫描整个堆里的对象图，找出存活的对象，（在此过程中新创建的对象会直接标记为黑色），这阶段<font color = gold>耗时较长</font>，但是可以<font color = gold>与用户程序并发执行,不会STW</font>。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象，将这些对象放入STAB队列中。</li><li><strong>最终标记(Final Marking)：</strong>对<font color = gold>用户线程做另一个短暂的暂停</font>，用于标记并发阶段结束后仍遗留下来的最后那少量的 SATB队列中的对象记录。</li><li><strong>筛选回收(Live Data Counting and Evacuation)：</strong>负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，优先对可回收空间较大的 Region 进行回收，即 garbage first，这也是 G1 名称的由来，根据用户所<font color = gold>期望的停顿时间来制定回收计划</font>。可以<font color = gold>自由选择多个Region来构成回收集</font>，然后把回收的那一部分Region中的存活对象复制到空的Region中，再对那些Region进行清空。</li></ul><p>除了并发标记外，其余过程都要 STW</p><img src="./../imgs/JVM/20200608151109.png" alt="img" style="zoom:50%;" /><h5 id="年轻代回收详情（复制算法）"><a href="#年轻代回收详情（复制算法）" class="headerlink" title="年轻代回收详情（复制算法）"></a>年轻代回收详情（复制算法）</h5><p>年轻代回收<strong>只扫描年轻代对象（Eden + Survivor）</strong>，所以从GC Root到年轻代的对象或者年轻代对象引用了其他年轻代的对象都很容易扫描出来。</p><p><img src="/./../imgs/JVM/1711165442927-26.png" alt="img"></p><p>这里就存在一个问题，年轻代回收只扫描年轻代对象（Eden + Survivor），如果有老年代中的对象引用了年轻代中的对象，我们又如何知道呢？</p><p><img src="/./../imgs/JVM/1711165442928-27.png" alt="img"></p><p>比如上图中，E对象被对象引用了，那么显然在垃圾回收时E对象是不应该被回收的。</p><p><strong>方案1：从GC Root开始，扫描所有对象，如果年轻代对象在引用链上，就标记为存活。</strong></p><p><img src="/./../imgs/JVM/1711165442928-28.png" alt="img"></p><p>重新扫描一遍GC Root关联的所有对象，包括老年代的。这个方案显然不可行，需要遍历引用链上所有对象，效率太低。</p><p><strong>方案2：维护一个详细的表，记录哪个对象被哪个老年代引用了。在年轻代中被引用的对象，不进行回收。</strong></p><p><img src="/./../imgs/JVM/1711165442928-29.png" alt="img"></p><p>如上图中，通过引用详情表记录F和E对象分别被A和B对象引用了。问题：如果对象太多这张表会占用很大的内存空间。存在错标的情况</p><p>方案2的第一次优化：只记录Region被哪些对象引用了。这种引用详情表称为记忆集 RememberedSet（简称RS或RSet）：是一种记录了从非收集区域对象引用收集区域对象的这些关系的数据结构。扫描时将记忆集中的对象也加入到GC Root中，就可以根据引用链判断哪些对象需要回收了。</p><p>问题：如果区域中引用对象很多，还是占用很多内存。</p><p><img src="/./../imgs/JVM/1711165442928-30.png" alt="img"></p><p>方案2的第二次优化：将所有区域中的内存按一定大小划分成很多个块（每个块的大小为512kb），每个块进行编号。记忆集中只记录对块的引用关系。如果一个块中有多个对象，只需要引用一次，减少了内存开销。</p><p><img src="/./../imgs/JVM/1711165442928-31.png" alt="img"></p><p>每一个Region都拥有一个自己的卡表，如果产生了跨代引用（老年代引用年轻代），此时这个Region对应的卡表上就会将字节内容进行修改,用一个字节来代表区域内的一个512字节的块，JDK8源码中0代表被引用了称为脏卡。这样就可以标记出当前Region被老年代中的哪些部分引用了。那么要生成记忆集就比较简单了，只需要遍历整个卡表，找到所有脏卡。</p><p><img src="/./../imgs/JVM/1711165442928-32.png" alt="img"></p><p>那么怎么样去维护这个卡表呢？或者说怎么知道A对F引用了？</p><p><strong>JVM使用写屏障（Write Barrier）技术</strong>，在执行引用关系建立的代码时，可以在代码前和代码后插入一段指令，从而维护卡表。</p><p>记忆集中不会记录新生代到新生代的引用，同一个Region中的引用也不会记录。</p><p><img src="/./../imgs/JVM/1711165442928-33.png" alt="img"></p><p>记忆集的生成流程分为以下几个步骤：</p><p>1、通过写屏障获得引用变更的信息。</p><p>2、将引用关系记录到卡表中，并记录到一个脏卡队列中。</p><p>3、JVM中会由Refinement 线程定期从脏卡队列中获取数据，生成记忆集。不直接写入记忆集的原因是避免过多线程并发访问记忆集。</p><p><img src="/./../imgs/JVM/1711165442928-34.png" alt="img"></p><h6 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h6><p>更详细的分析下年轻代回收的步骤，整个过程是STW的：</p><p>1、Root扫描，将所有的静态变量、局部变量扫描出来。</p><p>2、处理脏卡队列中的没有处理完的信息，更新记忆集的数据，此阶段完成后，记忆集中包含了所有老年代对当前Region的引用关系。</p><p><img src="/./../imgs/JVM/1711165442929-35.png" alt="img"></p><p>3、标记存活对象。记忆集中的对象会加入到GC Root对象集合中，在GC Root引用链上的对象也会被标记为存活对象。</p><p>4、根据设定的最大停顿时间，选择本次收集的区域，称之为回收集合Collection Set。</p><p><img src="/./../imgs/JVM/1711165442929-36.png" alt="img"></p><p>5、复制对象：将标记出来的对象复制到新的区中，将年龄加1，如果年龄到达15则晋升到老年代。老的区域内存直接清空。</p><p>6、处理软、弱、虚、终结器引用，以及JNI中的弱引用。</p><p><img src="/./../imgs/JVM/1711165442929-37.png" alt="img"></p><p><strong>G1年轻代回收核心技术</strong></p><p><strong>1、卡表 Card Table</strong></p><p>每一个Region都拥有一个自己的卡表，卡表是一个字节数组，如果产生了跨代引用（老年代引用年轻代），G1会将卡表上引用对象所在的位置字节内容进行修改为0, 称为脏卡。卡表的主要作用是生成记忆集。</p><p>卡表会占用一定的内存空间，堆大小是1G时，卡表大小为1G &#x3D; 1024 MB &#x2F; 512 &#x3D; 2MB</p><p><strong>2、记忆集 RememberedSet（简称RS或RSet）</strong></p><p>每一个Region都拥有一个自己的记忆集，如果产生了跨代引用，记忆集中会记录引用对象所在的卡表位置。标记阶段将记忆集中的对象加入GC ROOT集合中一起扫描，就可以将被引用的对象标记为存活。</p><p><strong>3、写屏障 Write Barrier</strong></p><p>G1使用写屏障技术，在执行引用关系建立的代码执行后插入一段指令，完成卡表的维护工作。</p><p>会损失一部分的性能，大约在5%~10%之间。</p><h5 id="混合回收"><a href="#混合回收" class="headerlink" title="混合回收"></a>混合回收</h5><p>多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值（默认45%）时会触发混合回收MixedGC。</p><p>混合回收会由年轻代回收之后或者大对象分配之后触发，混合回收会回收 <strong>整个年轻代 + 部分老年代。</strong></p><p>老年代很多时候会有大量对象，要标记出所有存活对象耗时较长，所以整个标记过程要尽量能做到和用户线程并行执行。</p><h5 id="混合回收的步骤："><a href="#混合回收的步骤：" class="headerlink" title="混合回收的步骤："></a><strong>混合回收的步骤：</strong></h5><p>1、初始标记，STW，采用三色标记法标记从GC Root可直达的对象。</p><p>2、并发标记，并发执行，对存活对象进行标记。</p><p>3、最终标记，STW，处理SATB相关的对象标记。</p><p>4、清理，STW，如果区域中没有任何存活对象就直接清理。</p><p>5、使用标记整理算法，转移，将存活对象复制到别的区域。</p><h6 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h6><p>初始标记会暂停所有用户线程，只标记从GC Root可直达的对象，所以停顿时间不会太长。采用三色标记法进行标记，三色标记法在原有双色标记（黑也就是1代表存活，白0代表可回收）增加了一种灰色，采用队列的方式保存标记为灰色的对象。</p><p>黑色：存活，当前对象在GC Root引用链上，同时他引用的其他对象也都已经标记完成。</p><p>灰色：待处理，当前对象在GC Root引用链上，他引用的其他对象还未标记完成。</p><p>白色：可回收，不在GC Root引用链上。</p><p>初始所有对象都是默认为白色，初始值为0：</p><p><img src="/./../imgs/JVM/1711166313048-71.png" alt="img"></p><p>三色标记中的黑色和白色是使用位图(bitmap)来实现的,比如8个字节使用1个bit来标识标记的内容，黑色为1，白色为0，灰色不会体现在位图中，会单独放入一个队列中。如果对象超过8个字节，仅仅使用第一个bit位处理。</p><p><img src="/./../imgs/JVM/1711166313051-72.png" alt="img"></p><p>将GC Root可以直到的对象D标记，D没有其他引用对象，所以直接标记为为黑色：</p><p><img src="/./../imgs/JVM/1711166313052-73.png" alt="img"></p><p>接下来将B对象标记，由于B关联了A和C，而A和C没有标记完成，所以B是待处理状态，将B送入灰色队列。</p><p><img src="/./../imgs/JVM/1711166313052-74.png" alt="img"></p><h6 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h6><p>接下来进入并发标记阶段，继续进行未完成的标记任务。此阶段和用户线程并发执行。</p><p>从灰色队列中获取尚未完成标记的对象B。标记B关联的A和C对象，由于A对象并未引用其他对象，可以直接标记成黑色，而B也完成了所有引用对象的标记，也标记为黑色。</p><p><img src="/./../imgs/JVM/1711166313053-75.png" alt="img"></p><p>最后从队列获取C对象，标记为黑色，E也标记为黑色。所以剩余对象F就是白色，可回收。</p><p><img src="/./../imgs/JVM/1711166313053-76.png" alt="img"></p><p>三色标记存在一个比较严重的问题，由于用户线程可能同时在修改对象的引用关系，就会出现错标的情况，比如：</p><p>这个案例中正常情况下，B和C都会被标记成黑色。但是在BC标记前，用户线程执行了 B.c &#x3D; null；将B到C的引用去除了。</p><p><img src="/./../imgs/JVM/1711166313053-77.png" alt="img"></p><p>同时执行了A.c &#x3D; c; 添加了A到C的引用。此时会出现严重问题，C是白色可回收一旦回收代码中再去使用对象会造成重大问题。</p><p><img src="/./../imgs/JVM/1711166313053-78.png" alt="img"></p><p>如果接着处理B：</p><p><img src="/./../imgs/JVM/1711166313054-79.png" alt="img"></p><p>B在GC引用链上，没有引用任何对象，所以B标记为黑色：</p><p><img src="/./../imgs/JVM/1711166313054-80.png" alt="img"></p><p>这样C虽然在引用链上，但是被回收了。</p><p>G1为了解决这个问题，使用了<strong>SATB技术（Snapshot At The Beginning， 初始快照）</strong>。SATB技术是这样处理的：</p><p><img src="/./../imgs/JVM/1711166313054-81.png" alt="img"></p><p>1、标记开始时创建一个快照，记录当前所有对象，标记过程中新生成的对象直接标记为黑色。</p><p><img src="/./../imgs/JVM/1711166313054-82.png" alt="img"></p><p>2、采用前置写屏障技术，在引用赋值前比如B.c &#x3D; null之前，将之前引用的对象c放入SATB待处理队列中。SATB队列每个线程都有一个，最终会汇总到一个大的SATB队列中。</p><p><img src="/./../imgs/JVM/1711166313054-83.png" alt="img"></p><p>最终队列处理完之后，C和F就可以完成标记了。</p><p><img src="/./../imgs/JVM/1711166313055-84.png" alt="img"></p><p>SATB的缺点是在本轮清理时可能会将不存活的对象标记成存活对象，产生了一些所谓的浮动垃圾，等到下一轮清理时才能回收。比如图中的E对象。</p><h5 id="ZGC垃圾回收器"><a href="#ZGC垃圾回收器" class="headerlink" title="ZGC垃圾回收器"></a>ZGC垃圾回收器</h5><p>ZGC 是一种可扩展的低延迟垃圾回收器。ZGC 在垃圾回收过程中，STW的时间不会超过一毫秒，适合需要低延迟的应用。支持几百兆到16TB 的堆大小，堆大小对STW的时间基本没有影响。 </p><p>主要是使用了染色指针+ 读屏障来降低G1在转移对象时候的停顿时间</p><p>ZGC（Garbage Collector）是一种在JVM中实现的低停顿时间垃圾回收器。其垃圾回收流程可以概括为以下几个关键阶段：</p><ol><li><strong>初始标记阶段（Initial Mark）：</strong>与G1垃圾回收器一样，初始标记阶段是一个短暂的STW阶段，目的是标记出根对象直接引用的对象，标记的过程是并发执行的，所以这个阶段的停顿时间很短。</li><li><strong>并发标记阶段（Concurrent Mark）：</strong>在这个阶段，ZGC并发地标记出所有可达的对象，包括从根对象出发的引用链上的对象，这个过程是与应用程序的执行同时进行的，因此对停顿时间的影响很小。</li><li><strong>再标记阶段（Remark）：</strong>如果在并发标记阶段有新的对象被创建或有对象被回收，ZGC可能需要进行一次短暂的STW再标记。这个阶段的停顿时间一般不超过1毫秒。在这个阶段，ZGC会修正并发标记阶段可能由于并发引起的标记不一致。</li><li><strong>并发转移准备（Concurrent Prepare for Relocate）：</strong>在这个阶段ZGC进行整堆扫描，确定收集哪些Region，并将这些Region组成重分配集（Relocation Set）。与G1收集器不同，ZGC的重分配集扫描所有的Region，而不是计算最有价值回收的Region，由于染色指针的存在，扫描过程会很快。这个过程并不是为了计算最优的回收集，而是为了确定存活对象将被复制到其他Region。此阶段还涉及到JDK12支持的类卸载和弱引用的处理。</li><li><strong>初始转移阶段（Initial Relocation）：</strong>这是ZGC垃圾回收的核心阶段之一，ZGC并发地将重分配集中的存活对象复制到新的Region。为了记录从旧对象到新对象的转移关系，ZGC需要为重分配集中的每个Region维护一个转发表（Forward Table）。<br>ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力<br>ZGC的染色指针因为“自愈”（Self-Healing）能力，所以只有第一次访问旧对象会变慢，。 一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于新对象的分配，但是转发表还得留着不能释放掉，因为可能还有访问在使用这个转发表。</li><li><strong>并发转移阶段（Concurrent Relocation）：</strong>并发转移阶段的工作就是修正堆中指向重分配集中旧对象的所有引用，也可以直接认为就是真正进行对象引用修复的一个步骤，从这一点来看shenandoah的并发引用更新阶段是一样的。但是ZGC并不需要马上完成这个操作（因为有指针自愈的特性），ZGC把并发重映射阶段要做的工作巧妙的合并到<strong>下一次垃圾收集循环</strong>中的并发标记阶段中去完成，这样做的好处是节省遍历对象图的开销。一旦所有指针修复，新旧对象的引用关系<strong>转发表</strong>就可以释放了。</li></ol><table><thead><tr><th>优点</th><th>描述</th></tr></thead><tbody><tr><td>1. 低停顿</td><td>ZGC以低停顿为首要目标，几乎所有垃圾回收过程都是并发的，只有短暂的STW。</td></tr><tr><td>2. 高吞吐量</td><td>ZGC在吞吐量方面取得了显著进展，超越了G1，接近Parallel Scavenge。</td></tr><tr><td>3. 内存小</td><td>没有写屏障和卡表等额外的数据结构，收集过程中额外耗费的内存较小。</td></tr><tr><td>4. 局部内存分配</td><td>在多核处理器的某些架构下，优先在当前线程所处的处理器的本地内存上分配对象。</td></tr><tr><td>5. 并发停顿</td><td>并发停顿非常短暂，大部分过程都是与应用线程并发执行。</td></tr><tr><td>6. 无分代</td><td>没有引入分代的概念，简化了内存管理的复杂性。</td></tr><tr><td>7. 无内存碎片</td><td>采用并发的标记-整理算法，没有内存碎片问题。</td></tr></tbody></table><table><thead><tr><th>缺点</th><th>描述</th></tr></thead><tbody><tr><td>1. 浮动垃圾</td><td>承受的对象分配速率不会太高，产生浮动垃圾，难以及时回收。</td></tr><tr><td>2. 执行时间较长</td><td>停顿时间短，但整个垃圾回收过程的执行时间可能较长。</td></tr><tr><td>3. 无分代概念</td><td>没有分代概念，可能导致朝生夕死的对象无法及时回收。</td></tr><tr><td>4. 平台限制</td><td>目前仅在Linux&#x2F;x64上可用，可能限制了在其他平台的应用。</td></tr></tbody></table><h3 id="JVM运行、加载过程"><a href="#JVM运行、加载过程" class="headerlink" title="JVM运行、加载过程"></a>JVM运行、加载过程</h3><h4 id="静态变量的加载过程"><a href="#静态变量的加载过程" class="headerlink" title="静态变量的加载过程"></a>静态变量的加载过程</h4><p>连接的准备阶段</p><p><img src="/./../imgs/JVM/image-20231006121550663.png" alt="image-20231006121550663"></p><h4 id="Java运行一个程序的过程？"><a href="#Java运行一个程序的过程？" class="headerlink" title="Java运行一个程序的过程？"></a>Java运行一个程序的过程？</h4><ol><li><strong>编译阶段</strong></li></ol><p>Java 代码首先需要被编译器编译，Java 编译器首先检查语法和语义的错误，然后将源码转换成字节码。编译生成的字节码被存储在一个或多个 .class 文件中，这些文件可以直接在 JVM 上运行或在网络上传输。</p><ol start="2"><li><strong>运行阶段</strong></li></ol><p><strong>Java 代码的运行分为三个阶段：装载、链接和初始化。</strong></p><p>- 装载：Java 虚拟机装载字节码，通常从 ClassPath 路径中获取，并检查字节码的正确性和合法性。</p><p>- 链接：在链接阶段，Java 虚拟机将其装载的类型与所依赖的类型链接起来，生成实际的可执行代码，主要包括验证、准备、解析三个阶段：</p><ul><li>验证：Java 虚拟机对字节码进行验证，以确保其符合规范和安全标准。验证阶段检查字节码中包含的元数据和字节码是否符合规范和安全标准。</li><li>准备：Java 虚拟机为类变量分配存储空间，并将其初始化为标准初始值。</li><li>解析：Java 虚拟机在准备阶段对常量池进行了解析，以确定每个符号对应的目标，这个过程称为解析。</li></ul><p>- 初始化：在初始化阶段，Java 虚拟机按照程序设定的顺序执行类构造器，以完成类的初始化。类构造器是由编译器自动生成的，它们负责将静态变量初始化并执行静态语句块中的代码。</p><p>在初始化阶段完成后，Java 虚拟机就开始执行字节码指令了，在这个阶段，Java 虚拟机通过解释器将字节码转换为机器码，并开始执行代码逻辑，完成 Java 代码的运行和执行。</p><p>总结</p><p><img src="/./../imgs/JVM/1711175338351-118.png" alt="img"></p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><h5 id="类加载时JVM的区域"><a href="#类加载时JVM的区域" class="headerlink" title="类加载时JVM的区域"></a>类加载时JVM的区域</h5><p><img src="/./../imgs/JVM/image-20231006115620436.png" alt="image-20231006115620436"></p><p>类对象 xxx.class放在堆中， 存放instanceKlass的镜像指针，instanceKlass的中包含类的所有信息</p><h5 id="类加载器-1"><a href="#类加载器-1" class="headerlink" title="类加载器"></a>类加载器</h5><p>1.启动类加载器（Bootstrap ClassLoader）加载核心类</p><p>2.扩展类加载器（Extension ClassLoader）加载扩展类</p><p>3.应用程序类加载器（Application ClassLoader）加载应用classpath中的类</p><p>4.自定义类加载器，重写findClass方法。</p><p><img src="/./../imgs/JVM/image-20231010185648889.png" alt="image-20231010185648889"></p><h4 id="（类的加载机制）双亲委派机制是什么？怎么打破？"><a href="#（类的加载机制）双亲委派机制是什么？怎么打破？" class="headerlink" title="（类的加载机制）双亲委派机制是什么？怎么打破？"></a>（类的加载机制）双亲委派机制是什么？怎么打破？</h4><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><p>当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol><li><p>保证类加载的安全性</p><p>通过双亲委派机制，让顶层的类加载器去加载核心类，避免恶意代码替换JDK中的核心类库（比如Java.lang.String），确保核心类库的完整性和安全性。</p></li><li><p>避免重复加载</p><p>可以避免同一个类被多次记载，上层的类加载器如果记载过类，就会直接返回该类，避免重复加载造成资源浪费，</p></li></ol><h5 id="怎么打破"><a href="#怎么打破" class="headerlink" title="怎么打破"></a>怎么打破</h5><p><img src="/./../imgs/JVM/image-20231010192356056.png" alt="image-20231010192356056"></p><ul><li><p>ClassLoader中包含了4个核心方法，对Java程序员来说，打破双亲委派机制的唯一方法就是实现自定义类加载器重写loadClass方法，将其中的双亲委派机制代码去掉。</p><p><img src="/./../imgs/JVM/1711175083796-113.png" alt="img"></p></li></ul><h5 id="为什么要打破"><a href="#为什么要打破" class="headerlink" title="为什么要打破"></a>为什么要打破</h5><p><strong>用双亲委派也存在一定的局限性</strong>，</p><p>在加载核心类库时，如果需要使用用户代码，双亲委派流程就无法满足；</p><p>比如在使用JDBC时， 利用DriverManager.getConnection获取连接时，就会存在这样的问题。</p><p>DriverManager是由根类加载器Bootstrap加载的，在加载DriverManager时，会执行其静态方法，加载初始驱动程序，也就是Driver接口的实现类；但是这些实现类基本都是第三方厂商提供的，根据双亲委派原则，第三方的类应该是由ApplicationClassLoader来加载</p><h4 id="什么情况下会报ClassNotFound的异常？"><a href="#什么情况下会报ClassNotFound的异常？" class="headerlink" title="什么情况下会报ClassNotFound的异常？"></a>什么情况下会报ClassNotFound的异常？</h4><p>当应用程序运行的过程中尝试使用类加载器去加载Class文件的时候，如果没有在classpath中查找到指定的类，就会抛出ClassNotFoundException。一般情况下，当我们使用Class.forName()或者ClassLoader.loadClass以及使用ClassLoader.findSystemClass()在运行时加载类的时候，如果类没有被找到，那么就会导致JVM抛出ClassNotFoundException。</p><h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><ul><li>默认无参构造</li><li>自动拆装箱</li><li>for-each</li><li>泛型擦除（比如在list集合中put和get都把泛型当作Object）</li><li>可变参数</li><li>枚举类</li><li>重写桥接（子类重写父类方法的返回值可以是父类方法返回值的子类， 通过一个桥接方法来调用子类的重写方法）</li></ul><h4 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h4><p> 内存泄漏（memory leak）：在Java中如果不再使用一个对象，但是该对象依然在GC ROOT的引用链上，这个对象就不会被垃圾回收器回收，这种情况就称之为内存泄漏</p><p> 少量的内存泄漏可以容忍，但是如果发生持续的内存泄漏，就像滚雪球雪球越滚越大，不管有多大的内存迟早会被消耗完，最终导致的结果就是内存溢出。                </p><p><img src="/./../imgs/JVM/1711161957517-1.png" alt="img"></p><p>解决内存泄漏问题总共分为四个步骤，其中前两个步骤是最核心的：</p><p><img src="/./../imgs/JVM/image-20240323104729041.png" alt="image-20240323104729041"></p><h5 id="发现问题-–-堆内存状况的对比"><a href="#发现问题-–-堆内存状况的对比" class="headerlink" title="发现问题 – 堆内存状况的对比"></a>发现问题 – 堆内存状况的对比</h5><p><strong>正常情况</strong></p><p><img src="/./../imgs/JVM/1711162227058-8.png" alt="img"></p><ul><li>处理业务时会出现上下起伏，业务对象频繁创建内存会升高，触发MinorGC之后内存会降下来。</li><li>手动执行FULL GC之后，内存大小会骤降，而且每次降完之后的大小是接近的。</li><li>长时间观察内存曲线应该是在一个范围内。</li></ul><p><strong>出现内存泄漏</strong></p><p><img src="/./../imgs/JVM/1711162227058-9.png" alt="img"></p><ul><li>处于持续增长的情况，即使Minor GC也不能把大部分对象回收</li><li>手动FULL GC之后的内存量每一次都在增长</li><li>长时间观察内存曲线持续增长</li></ul><p>生成方式有两种</p><p>1、内存溢出时自动生成，添加生成内存快照的Java虚拟机参数：</p><p>​    -XX:+HeapDumpOnOutOfMemoryError：发生OutOfMemoryError错误时，自动生成hprof内存快照文件。</p><p>​    -XX:HeapDumpPath&#x3D;<path>：指定hprof文件的输出路径。</p><p><img src="/./../imgs/JVM/1711162274734-14.png" alt="img"></p><p>发生oom之后，就会生成内存快照文件：</p><p><img src="/./../imgs/JVM/1711162274735-15.png" alt="img"></p><p>2、导出运行中系统的内存快照，比较简单的方式有两种，注意只需要导出标记为存活的对象：</p><p>通过JDK自带的jmap命令导出，格式为：</p><p>​      jmap -dump:live,format&#x3D;b,file&#x3D;文件路径和文件名 进程ID</p><p>通过arthas的heapdump命令导出，格式为：</p><p>​      heapdump –live  文件路径和文件名 </p><p><img src="/./../imgs/JVM/1711162274735-16.png" alt="img"></p><p>诊断 – <strong>MAT</strong>定位问题</p><p>使用MAT打开hprof文件，并选择内存泄漏检测功能，MAT会自行根据内存快照中保存的数据分析内存泄漏的根源。</p><p><img src="/./../imgs/JVM/1711162274735-17.png" alt="img"></p><p><strong>修复问题</strong></p><p>修复内存溢出问题的要具体问题具体分析，问题总共可以分成三类：</p><ul><li>代码中的内存泄漏，由于代码的不合理写法存在隐患，导致内存泄漏</li><li>并发引起内存溢出 - 参数不当,由于参数设置不当，比如堆内存设置过小，导致并发量增加之后超过堆内存的上限。解决方案：设置合理参数</li><li>并发引起内存溢出 – 设计不当，系统的方案设计不当，比如：<ul><li>从数据库获取超大数据量的数据</li><li>线程池设计不当</li><li>生产者-消费者模型，消费者消费性能问题</li></ul></li></ul><p>​      解决方案：优化设计方案</p><h4 id="常见JVM参数"><a href="#常见JVM参数" class="headerlink" title="常见JVM参数"></a>常见JVM参数</h4><h5 id="一、堆内存相关配置"><a href="#一、堆内存相关配置" class="headerlink" title="一、堆内存相关配置"></a>一、<strong>堆内存相关配置</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">设置堆初始值</span><br><span class="line">指令<span class="number">1</span>：-Xms2g</span><br><span class="line">指令<span class="number">2</span>：-XX:InitialHeapSize=2048m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">设置堆区最大值</span><br><span class="line">指令<span class="number">1</span>：`-Xmx2g` </span><br><span class="line">指令<span class="number">2</span>： -XX:MaxHeapSize=2048m</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">新生代内存配置</span><br><span class="line">指令<span class="number">1</span>：-Xmn512m</span><br><span class="line">指令<span class="number">2</span>：-XX:MaxNewSize=512m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">缩小堆内存的时机</span><br><span class="line">-XX:MaxHeapFreeRatio=<span class="number">70</span><span class="comment">//堆内存使用率大于70时扩张堆内存，xms=xmx时该参数无效，默认值70</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">扩张堆内存的时机</span><br><span class="line">-XX:MinHeapFreeRatio=<span class="number">40</span><span class="comment">//堆内存使用率小于40时缩减堆内存，xms=xmx时该参数无效，默认值40</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>个survivor区和Eden区大小比率</span><br><span class="line">指令：-XX:SurvivorRatio=<span class="number">6</span>  <span class="comment">//S区和Eden区占新生代比率为1:6,两个S区2:6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">新生代和老年代的占比</span><br><span class="line">-XX:NewRatio=<span class="number">4</span>  <span class="comment">//表示新生代:老年代 = 1:4 即老年代占整个堆的4/5；默认值=2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h5 id="二、方法区内存配置常用参数"><a href="#二、方法区内存配置常用参数" class="headerlink" title="二、方法区内存配置常用参数"></a><strong>二、方法区内存配置常用参数</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">初始化的Metaspace大小，</span><br><span class="line">-XX:MetaspaceSize ：</span><br><span class="line"></span><br><span class="line">Metaspace最大值</span><br><span class="line">-XX:MaxMetaspaceSize</span><br><span class="line">  </span><br></pre></td></tr></table></figure><hr><h5 id="三、线程栈内存配置常用参数"><a href="#三、线程栈内存配置常用参数" class="headerlink" title="三、线程栈内存配置常用参数"></a><strong>三、线程栈内存配置</strong>常用参数</h5><p>每个线程栈最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令<span class="number">1</span>：-Xss256k</span><br><span class="line"></span><br><span class="line">指令<span class="number">2</span>：-XX:ThreadStackSize=256k</span><br></pre></td></tr></table></figure><p>注意：</p><p>栈设置太大，会导致线程创建减少。</p><p>栈设置小，会导致深入不够，深度的递归会导致栈溢出。</p><p>建议栈深度设置在3000-5000</p><h5 id="四、配置垃圾收集器"><a href="#四、配置垃圾收集器" class="headerlink" title="四、配置垃圾收集器"></a><strong>四、配置垃圾收集器</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Serial垃圾收集器（新生代）</span><br><span class="line">开启：-XX:+UseSerialGC</span><br><span class="line">关闭：-XX:-UseSerialGC</span><br><span class="line"><span class="comment">//新生代使用Serial  老年代则使用SerialOld</span></span><br><span class="line"></span><br><span class="line">ParNew垃圾收集器（新生代）</span><br><span class="line">开启 -XX:+UseParNewGC</span><br><span class="line">关闭 -XX:-UseParNewGC</span><br><span class="line"><span class="comment">//新生代使用功能ParNew 老年代则使用功能CMS</span></span><br><span class="line"></span><br><span class="line">Parallel Scavenge收集器（新生代）</span><br><span class="line">开启 -XX:+UseParallelOldGC</span><br><span class="line">关闭 -XX:-UseParallelOldGC</span><br><span class="line"><span class="comment">//新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器</span></span><br><span class="line"></span><br><span class="line">ParallelOl垃圾收集器（老年代）</span><br><span class="line">开启 -XX:+UseParallelGC</span><br><span class="line">关闭 -XX:-UseParallelGC</span><br><span class="line"><span class="comment">//新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器</span></span><br><span class="line"></span><br><span class="line">CMS垃圾收集器（老年代）</span><br><span class="line">开启 -XX:+UseConcMarkSweepGC</span><br><span class="line">关闭 -XX:-UseConcMarkSweepGC</span><br><span class="line"></span><br><span class="line">G1垃圾收集器</span><br><span class="line">开启 -XX:+UseG1GC</span><br><span class="line">关闭 -XX:-UseG1GC</span><br></pre></td></tr></table></figure><hr><h5 id="五、GC策略配置"><a href="#五、GC策略配置" class="headerlink" title="五、GC策略配置"></a><strong>五、GC策略配置</strong></h5><p><strong>GC并行执行线程数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=<span class="number">16</span></span><br></pre></td></tr></table></figure><p><strong>新生代可容纳的最大对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PretenureSizeThreshold=<span class="number">1000000</span> <span class="comment">//大于此值的对象直接会分配到老年代，设置为0则没有限制。</span></span><br><span class="line">    <span class="comment">//避免在Eden区和Survivor区发生大量的内存复制，该参数只对Serial和ParNew收集器有效，Parallel Scavenge并不认识该参数</span></span><br></pre></td></tr></table></figure><p><strong>进入老年代的GC年龄</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">进入老年代最小的GC年龄</span><br><span class="line">-XX:InitialTenuringThreshol=<span class="number">7</span> <span class="comment">//年轻代对象转换为老年代对象最小年龄值，默认值7，对象在坚持过一次Minor GC之后，年龄就加1，每个对象在坚持过一次Minor GC之后，年龄就增加1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进入老年代最大的GC年龄</span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">15</span> <span class="comment">//年轻代对象转换为老年代对象最大年龄值，默认值15</span></span><br></pre></td></tr></table></figure><hr><h5 id="六、GC日志信息配置"><a href="#六、GC日志信息配置" class="headerlink" title="六、GC日志信息配置"></a><strong>六、GC日志信息配置</strong></h5><p><strong>配置GC文件路径</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xloggc:/data/gclog/gc.log<span class="comment">//固定路径名称生成</span></span><br><span class="line">-Xloggc:/home/GCEASY/gc-%t.log <span class="comment">//根据时间生成</span></span><br></pre></td></tr></table></figure><p><strong>滚动生成日志</strong></p><p>日志文件达到一定大小后，生成另一个文件。须配置Xloggc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+UseGCLogFileRotation</span><br><span class="line">关闭 -XX:-UseGCLogFileRotation</span><br><span class="line"></span><br><span class="line">-XX:NumberOfGCLogFiles=<span class="number">4</span>   <span class="comment">//滚动GC日志文件数，默认0，不滚动</span></span><br><span class="line">-XX:GCLogFileSize=100k  <span class="comment">//GC文件滚动大小，需配置UseGCLogFileRotation，设置为0表示仅通过jcmd命令触发</span></span><br></pre></td></tr></table></figure><p><strong>打印详细的GC日志</strong></p><p>打印GC的详细日志，并且在程序运行结束是会打印出JVM的内存占用情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+PrintGCDetails</span><br><span class="line">关闭 -XX:-PrintGCDetails</span><br></pre></td></tr></table></figure><p><strong>打印应用暂停时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+PrintGCApplicationStoppedTime</span><br><span class="line">关闭 -XX:-PrintGCApplicationStoppedTime</span><br></pre></td></tr></table></figure><p><strong>每次GC完成后，打印出JVM堆内存每个区域的使用情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+PrintHeapAtGC</span><br><span class="line">关闭 -XX:-PrintHeapAtGC</span><br></pre></td></tr></table></figure><p><strong>打印存活实例年龄信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+PrintTenuringDistribution</span><br><span class="line">关闭 -XX:-PrintTenuringDistribution</span><br></pre></td></tr></table></figure><hr><h5 id="七、条件触发配置"><a href="#七、条件触发配置" class="headerlink" title="七、条件触发配置"></a><strong>七、条件触发配置</strong></h5><p><strong>OutOfMemory异常时输出文件</strong></p><p>抛出内存溢出错误时导出堆信息到指定文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开启 -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">关闭 -XX:-HeapDumpOnOutOfMemoryError</span><br><span class="line"><span class="comment">//可以通过jinfo -flag [+|-]HeapDumpOnOutOfMemoryError &lt;pid&gt; 或 jinfo -flag HeapDumpOnOutOfMemoryError=&lt;value&gt; &lt;pid&gt; 来动态开启或设置值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-XX:HeapDumpPath=/data/dump/jvm.dump<span class="comment">//设置文件路径</span></span><br><span class="line"><span class="comment">//当HeapDumpOnOutOfMemoryError开启的时候，dump文件的保存路径，默认为工作目录下的</span></span><br></pre></td></tr></table></figure><p><strong>在Full GC时生成dump文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpBeforeFullGC       <span class="comment">//实现在Full GC前dump</span></span><br><span class="line">-XX:+HeapDumpAfterFullGC        <span class="comment">//实现在Full GC后dump。</span></span><br><span class="line">-XX:HeapDumpPath=e:\dump        <span class="comment">//设置Dump保存的路径</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">&quot;-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=/data/dump/jvm.dump&quot;</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><p><strong>查看JVM所有参数</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsInitial</span><br></pre></td></tr></table></figure><hr><h5 id="九、常用启动参数"><a href="#九、常用启动参数" class="headerlink" title="九、常用启动参数"></a><strong>九、常用启动参数</strong></h5><p><strong>1、设置堆内大小</strong></p><p>设置堆内存大小，Xms 最小内存，Xmx最大内存，不设置默认为物理机内存的四分之一。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms2g   -Xmx2g`     </span><br></pre></td></tr></table></figure><p><strong>2、GC日志参数</strong></p><p>生成GC滚动日志记录 ，当需要对GC排查问题时候需要对此日志分析。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+UseGCLogFileRotation  -XX:+PrintHeapAtGC -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M    -Xloggc:/opt/ard-user-gc-%t.log </span><br><span class="line">-Xloggc:/opt/app/ard-user/ard-user-gc-%t.log   设置日志目录和日志名称</span><br><span class="line">-XX:+UseGCLogFileRotation           开启滚动生成日志</span><br><span class="line">-XX:NumberOfGCLogFiles=5            滚动GC日志文件数，默认0，不滚动</span><br><span class="line">-XX:GCLogFileSize=20M               GC文件滚动大小，需开启UseGCLogFileRotation</span><br><span class="line">-XX:+PrintGCDetails                 开启记录GC日志详细信息（包括GC类型、各个操作使用的时间）,并且在程序运行结束打印出JVM的内存占用情况</span><br><span class="line">-XX:+ PrintGCDateStamps             记录系统的GC时间           </span><br><span class="line">-XX:+PrintGCCause                   产生GC的原因(默认开启)</span><br></pre></td></tr></table></figure><p><strong>3、异常时记录内存日志</strong></p><p>抛出内存溢出错误时导出堆信息到指定文件，内存溢出时需要对此日志进行分析</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=/data/dump/jvm.dump</span><br><span class="line">HeapDumpOnOutOfMemoryError  异常后打印堆内存信息</span><br><span class="line">HeapDumpPath                生成的堆内存日志的路径</span><br></pre></td></tr></table></figure><hr><h5 id="十、各种场景的参数设置方式"><a href="#十、各种场景的参数设置方式" class="headerlink" title="十、各种场景的参数设置方式"></a><strong>十、各种场景的参数设置方式</strong></h5><p><strong>Idea</strong></p><p><img src="/./../imgs/JVM/v2-d78c1b323328416df15ae0d49f782edd_1440w.webp" alt="img"></p><p><img src="/./../imgs/JVM/v2-542d3d81b989240197ba520b9fa9ff29_1440w.webp" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2024/04/19/MySQL/"/>
      <url>/2024/04/19/MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL："><a href="#MySQL：" class="headerlink" title="MySQL："></a>MySQL：</h2><h3 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h3><h4 id="执行一条-SQL-查询语句，期间发生了什么？"><a href="#执行一条-SQL-查询语句，期间发生了什么？" class="headerlink" title="执行一条 SQL 查询语句，期间发生了什么？"></a>执行一条 SQL 查询语句，期间发生了什么？</h4><ul><li><p>连接器：建立连接，管理连接、校验用户身份；</p></li><li><p>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</p></li><li><p>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</p></li><li><p>执行 SQL：执行 SQL 共有三个阶段：</p><ul><li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul><p><img src="/./../../imgs/MySQL/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p></li></ul><h4 id="为什么禁止使用select"><a href="#为什么禁止使用select" class="headerlink" title="为什么禁止使用select *"></a>为什么禁止使用select *</h4><ul><li>增加查询分析器解析成本。</li><li>增减字段容易与 resultMap 配置不一致。</li><li>无用字段增加网络 消耗，尤其是 text 类型的字段。</li></ul><h4 id="SQL语句执行顺序"><a href="#SQL语句执行顺序" class="headerlink" title="SQL语句执行顺序"></a>SQL语句执行顺序</h4><ol><li><p>from 子句组装来自不同数据源的数据；</p></li><li><p>where 子句基于指定的条件对记录行进行筛选；  </p></li><li><p>group by 子句将数据划分为多个分组；  </p></li><li><p>使用聚集函数进行计算； </p></li><li><p>使用 having 子句筛选分组；</p></li><li><p>计算所有的表达式后，select；  </p></li><li><p>使用 order by 对结果集进行排序。</p></li><li><p>limit限制查询数量、查询偏移量</p><p><img src="/./../../imgs/MySQL/image-20231003111856990.png" alt="image-20231003111856990"></p></li></ol><h4 id="Mysql表字段限制"><a href="#Mysql表字段限制" class="headerlink" title="Mysql表字段限制"></a>Mysql表字段限制</h4><p>（1）innodb引擎对于列的硬性要求是不能超过1017列，MyISAM引擎能达到4096的限制</p><p>（2）一个表最多可以包含64个 二级索引,两种引擎都有这个限制。</p><p>（3）索引键前缀长度限制为767个字节 ，<strong>当某一列中的数据非常多的话，在数据页中只会存储该列的前767个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做行溢出，存储超出767字节的那些页面也被称为溢出页。</strong>主键是聚集索引，也是其他二级索引的基础，所以每个主键要在一个数据页存储，不能分布在其他的溢出页，不能像其他大字段一样溢出数据页</p><p>（4）MySQL本身对所有列的组合大小强加了65535的行大小限制，这个更多对应单个列的字段长度不能大于65535字节</p><p><img src="/./../../imgs/MySQL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xKRlBIUA==,size_16,color_FFFFFF,t_70.png" alt="img"></p><h4 id="行溢出后怎么处理"><a href="#行溢出后怎么处理" class="headerlink" title="行溢出后怎么处理"></a>行溢出后怎么处理</h4><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</p><p>Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p><p><img src="/./../../imgs/MySQL/%E8%A1%8C%E6%BA%A2%E5%87%BA.png" alt="img"></p><p>Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。</p><h4 id="varchar-n-中-n-最大取值为多少？"><a href="#varchar-n-中-n-最大取值为多少？" class="headerlink" title="varchar(n) 中 n 最大取值为多少？"></a>varchar(n) 中 n 最大取值为多少？</h4><p>行数据保存格式</p><p>变长字段列表存储各个变长字段的长度 null值列表用一个bit表示该行某一列位null</p><p><img src="/./../../imgs/MySQL/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A81.png" alt="img"></p><p><img src="/./../../imgs/MySQL/COMPACT.drawio.png" alt="img"></p><p><strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节</strong>。</p><p>varchar(n) 字段类型的 n 代表的是最多存储的字符数量，不是字节大小。</p><p>要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。</p><p>我们存储字段类型为 varchar(n) 的数据时，其实分成了三个部分来存储：</p><ul><li>真实数据</li><li>真实数据占用的字节数</li><li>NULL 标识，如果不允许为NULL，这部分不需要</li></ul><p><strong>因为我们这个案例是只有 1 个变长字段，所以「变长字段长度列表」&#x3D; 1 个「变长字段长度」占用的字节数，也就是 2 字节</strong>。</p><p>因为我们在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。所以，<strong>在数据库表只有一个 varchar(n) 字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 &#x3D; 65535 - 2 - 1 &#x3D; 65532</strong>。</p><p><strong>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;&#x3D; 65535</strong>。</p><h4 id="Insert-into和replace-into有什么区别"><a href="#Insert-into和replace-into有什么区别" class="headerlink" title="Insert into和replace into有什么区别"></a>Insert into和replace into有什么区别</h4><p>inset into是不允许添加主键重复列的,而replace可以,且影响行数是2,</p><p>replace into用于不知道操作为更新还是新增的时候,使用时,先尝试直接向库中插入数据,遇到主键或唯一索引而引发的重复键错误时,删除掉冲突行并再次尝试插入,这个过程是MySQL自行处理的,并不会存在用户感知之类的</p><h4 id="union和union-all的区别"><a href="#union和union-all的区别" class="headerlink" title="union和union all的区别"></a>union和union all的区别</h4><p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</p><p>union：对两个结果集进行并集操作，不包括重复行，相当于distinct，同时进行默认规则的排序；</p><p>union all：对两个结果集进行并集操作，包括重复行，不进行排序；</p><p>union因为要进行重复值扫描，所以在结果集庞大的情况下，效率极低，因此建议使用union all。</p><p>若结果集去重是强需求，则在应用程序代码上进行去重，因为数据库资源要比应用服务器资源更加珍贵。</p><h4 id="MySQL根据某一个或者多个字段查找重复数据的sql语句（MySQL如何避免查询重复字段）"><a href="#MySQL根据某一个或者多个字段查找重复数据的sql语句（MySQL如何避免查询重复字段）" class="headerlink" title="MySQL根据某一个或者多个字段查找重复数据的sql语句（MySQL如何避免查询重复字段）"></a>MySQL根据某一个或者多个字段查找重复数据的sql语句（MySQL如何避免查询重复字段）</h4><p><strong>1.表中有id和name 两个字段，查询出name重复的所有数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> xi a <span class="keyword">where</span> (a.username) <span class="keyword">in</span> (<span class="keyword">select</span> username  <span class="keyword">from</span> xi <span class="keyword">group</span> <span class="keyword">by</span> username <span class="keyword">having</span> <span class="built_in">count</span> (<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>2、查询出所有数据进行分组之后，查询重复的name字段和重复次数，先列下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span> (username) <span class="keyword">as</span> <span class="string">&#x27;重复次数&#x27;</span>,username <span class="keyword">from</span> xi <span class="keyword">group</span> <span class="keyword">by</span> username <span class="keyword">having</span> <span class="built_in">count</span> (<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> username <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>3、以下为查看别人的 结果，现列下：查询及删除重复记录的方法大全</p><p>1、查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> people <span class="keyword">where</span> peopleId <span class="keyword">in</span> (<span class="keyword">select</span> peopleId <span class="keyword">from</span> people <span class="keyword">group</span> <span class="keyword">by</span> peopleId <span class="keyword">having</span> <span class="built_in">count</span> (peopleId) <span class="operator">&gt;</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>2、删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断，只留有rowid最小的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> people <span class="keyword">where</span> rowid  <span class="keyword">not</span> <span class="keyword">in</span> ( <span class="keyword">select</span> <span class="built_in">min</span>(rowid)  <span class="keyword">from</span> people  <span class="keyword">group</span> <span class="keyword">by</span> peopleId )</span><br></pre></td></tr></table></figure><p>3、删除两个字段重复的数据，只保留一条</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> group_member</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> b.id</span><br><span class="line">  <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(id) <span class="keyword">AS</span> id</span><br><span class="line">    <span class="keyword">FROM</span> group_member</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> group_id, member_id</span><br><span class="line">  ) <span class="keyword">AS</span> b</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>4、查找表中多余的重复记录（多个字段）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> vitae a <span class="keyword">where</span> rowid  <span class="keyword">in</span> ( <span class="keyword">select</span> rowid  <span class="keyword">from</span> vitae  <span class="keyword">group</span> <span class="keyword">by</span> peopleId,seq  <span class="keyword">having</span> <span class="built_in">count</span> (<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>5、查找表中多余的重复记录（多个字段），不包含id最小的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  group_member</span><br><span class="line"><span class="keyword">where</span> id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(g.id) </span><br><span class="line">    <span class="keyword">from</span> group_member g</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> group_id, member_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>6、查询排名前十的数据，包含并列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">s1.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student s1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student s2 <span class="keyword">ON</span> s1.t_id <span class="operator">=</span> s2.t_id </span><br><span class="line"><span class="keyword">AND</span> s1.score <span class="operator">&lt;</span> s2.score </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">s1.id</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="built_in">COUNT</span>( s2.id ) <span class="operator">&lt;</span> <span class="number">10</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">s1.t_id,</span><br><span class="line">s1.score <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h4 id="使用自增id还是UUID来当主键"><a href="#使用自增id还是UUID来当主键" class="headerlink" title="使用自增id还是UUID来当主键"></a>使用自增id还是UUID来当主键</h4><p>应该使用UUID。</p><p>B+树使用双向链表来保存数据，所以使用自增id能够直接加到尾部，不需要页分裂，效率很高，且占用的空间小。但是如果一些敏感信息设置成自增就很容易被推理，暴露机密。</p><p>同时当单表的数据量上来之后我们就需要进行水平分表操作（将一张数据表的数据分成多张表），如果这时我们还是按照之前的自增形式来做主键 id，就有可能会出现 id 重复的问题。</p><p>如果使用UUID，生成的ID不仅是表独立的，而且是库独立的。对以后的数据操作很有好处，可以说一劳永逸。我们可以使用 UUID 来作为不重复的主键 id，但是 UUID 是无序的字符串，所以主键索引就会失效，而且占用空间大。</p><ul><li>全局唯一性：不能出现重复的 id</li><li>递增性：MySQL 的 InnoDB 使用的是聚簇索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，因此在主键的选择上我们还是应该尽可能地使用有序的主键来保证写入性能，我们保证下一个 id 一定大于上一个 id，以此来满足事务版本号、IM 增量消息或者排序的特殊需求</li><li>安全性：如果 id 是连续的，那么我们在知道一些基本规则的情况下就能很轻松地推测出下一份数据，这在一些机密性较高的业务场景是很危险的。所以我们有时会希望 id 是无规则的，最好还能包含有时间戳，这样就能够在开发中快速了解这个分布式 id 的生成时间</li><li>高性能高可用性：确保在任何时候都能正确地生成 id，并且在高并发的环境下也能表现良好</li></ul><p>UUID：我们可以使用 UUID 来作为不重复的主键 id，但是 UUID 是无序的字符串，所以主键索引就会失效</p><p>优点：简单、方便、性能好、出现数据拆分、合并存储的时候，能达到全局的唯一性<br>缺点：占用空间大，无序性、存储的是字符串、查询效率低、传输数据量大</p><p>雪花算法：雪花算法是 Twitter 推出的针对分布式环境下的 id 生成算法，其结果是一个 Long 型的 64bit id。具体实现上使用 41bit 作为毫秒数，10bit 作为机器的 id（5bit 是数据中心，5bit 是机器 id），12bit 作为毫秒内的流水号（这意味着每个节点在每毫秒内可以产生 4096 个 id），最后还有一个符号位永远是 0</p><p>优点：不依赖数据库、完全在内存中生成 id、高性能高可用、容量大、每秒可生成数百万个 id、id 递增、后续插入数据库的索引时性能较高<br>缺点：严重依赖系统时钟，如果某台机器的系统时钟发生回拨，就有可能会造成 id 冲突甚至 id 乱序</p><h4 id="MySQL三大范式"><a href="#MySQL三大范式" class="headerlink" title="MySQL三大范式"></a>MySQL三大范式</h4><ul><li><h5 id="第一范式（1-NF）：字段不可再拆分。"><a href="#第一范式（1-NF）：字段不可再拆分。" class="headerlink" title="第一范式（1 NF）：字段不可再拆分。"></a>第一范式（1 NF）：字段不可再拆分。</h5><p><img src="/./../../imgs/MySQL/image-20231003112028615.png" alt="image-20231003112028615"></p></li><li><h5 id="第二范式（2-NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。"><a href="#第二范式（2-NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。" class="headerlink" title="第二范式（2 NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。"></a>第二范式（2 NF）：表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。</h5></li></ul><p>​即一张表只能描述一件事情，学生表中就不要存储成绩，可以专门设计一张成绩表存储学生ID和每一科的成绩。否则造成整张表的数据冗余且更新插入等不方便</p><ol><li>造成整表的数据冗余。</li></ol><p>如，学生表，可能我就只有2个学生，每个学生都有许多的信息，比如，年龄、性别、身高、住址……如果与课程信息放到同一张表中，可能每个学生有3门课程，那数据总条数就会变成6条了。但是通过拆分，学生表我们只需要存储 2 条学生信息，课程表只需要存储 3 条课程信息，成绩表就只需保留学号、课程名称和成绩字段。</p><ol start="2"><li>更新数据不方便。</li></ol><p>假设，课程的学分发生了变更，那我们就需要把整表关于该课程的学分都要更新一次，但如果我们拆分出课程表，那我们就只需要把课程表中的课程信息更新就行。</p><ol start="3"><li>插入数据不方便或产生异常。</li></ol><p>① 假设主键是学号或课程名称，我们新增了某个课程，需要把数据插入到表中，这时，可能只有部分人有选修这门课程，那我们插入数据的时候还要规定给哪些人插入对应的课程信息，同时可能由于成绩还没有，我们需要对成绩置空，后续有成绩后还得重新更新一遍。</p><p>② 假设主键是学号和课程名称的联合主键。同样也是新增了某课程，但是暂时没有人选修这门课，缺少了学号主键字段数据，会导致课程信息无法插入。</p><ul><li><h5 id="第三范式（3-NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段-A-可以获取-某非主键字段-B。"><a href="#第三范式（3-NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段-A-可以获取-某非主键字段-B。" class="headerlink" title="第三范式（3 NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。"></a>第三范式（3 NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。</h5></li></ul><p>如果产生这样情况其实就可以把两者重新建表。如员工表既出现了员工所在的部门id，又出现了部门名称和工作地点，就可以把后面三个单独拆成一张表</p><h4 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h4><table><thead><tr><th>存储引擎</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>InnoDB</td><td>①支持事务②行级锁，提高并发性能③支持外键</td><td>各方面都比较优秀，适合绝大部分的场景</td></tr><tr><td>MyISAM</td><td>①不支持事务②不支持外键③只支持表锁不支持行锁④访问速度快</td><td>适合读操作和插入操作比较频繁的数据，而且对事务和并发要求不高，比如系统配置表等静态表</td></tr><tr><td>Memory</td><td>①存储在内存②hash索引</td><td>通常用于临时表以及缓存</td></tr></tbody></table><h4 id="怎么保证redis和DB的数据一致性"><a href="#怎么保证redis和DB的数据一致性" class="headerlink" title="怎么保证redis和DB的数据一致性"></a>怎么保证redis和DB的数据一致性</h4><h5 id="采用延时双删"><a href="#采用延时双删" class="headerlink" title="采用延时双删"></a>采用延时双删</h5><p><strong>其核心思想是在更新数据库后，先删除缓存中的数据，然后在一段时间后再次删除缓存。这样，即使在这段时间内有新的读请求导致缓存被重建，由于缓存中的数据已经被删除，所以新的读请求会重新从数据库中读取最新数据，从而保证缓存与数据库的一致性。</strong></p><p>这种方案，在并发写的时候，不会出问题。因为都是先更新数据库再删除缓存，不会出现不一致的情况。</p><p>但是在并发读写的时候，还是有可能出现数据不一致。</p><ol><li>读请求查询缓存没数据，然后查询数据库</li><li>写请求更新数据库，删除缓存</li><li>读请求回写缓存</li></ol><p>执行结果是，缓存中是旧数据，而数据库里是新数据，导致数据不一致。</p><p>其实这种情况出现的概率很低，写缓存比写数据库快出几个量级，读写缓存都是内存操作，速度非常快。</p><p>遇到了这种极端场景，我们也需要做一下兜底方案，缓存都要设置过期时间，或者当更新数据后休眠一段时间通过定时任务（可通过整合定时任务框架、创建线程池，从中拿出一个线程休眠一段时间再启动）再删除一次缓存。这种方案属于数据的弱一致性和最终一致性，而不是强一致性。</p><h5 id="异步更新缓存-基于订阅binlog的同步机制"><a href="#异步更新缓存-基于订阅binlog的同步机制" class="headerlink" title="异步更新缓存(基于订阅binlog的同步机制)"></a>异步更新缓存(基于订阅binlog的同步机制)</h5><p>采用缓存淘汰策略，先更新数据库，再删除对应redis缓存后更新缓存。</p><p><img src="/./../../imgs/MySQL/image-20231012113429919.png" alt="image-20231012113429919"></p><p>通过 Canal（消息推送工具也可以用kafka、rabbitMQ等来实现可靠性消息通信更新Redis。） 组件，（伪装成从节点）监控 Mysql 中 binlog（记录MySQL中新的写入、更新、删除等操作） 的日志，把更新后的数据同步到 Redis 里面，canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。</p><p><img src="/./../../imgs/MySQL/image-20231012113453556.png" alt="image-20231012113453556"></p><p>因为这里是基于最终一致性来实现的，如果业务场景不能接受数据的短期不一致性，那就不能使用这个方案来做。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务的四大特性（ACID）："><a href="#事务的四大特性（ACID）：" class="headerlink" title="事务的四大特性（ACID）："></a>事务的四大特性（ACID）：</h4><ul><li>原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性：事务完成时，必须使得所有的数据保持一致状态</li><li>隔离性：数据库系统提供的隔离机制，保证事务不受外部并发操作的影响，在独立的环境下运行。</li><li>持久性：事务一单提交或回滚，会对数据库产生永久的改变</li></ul><table><thead><tr><th>特性</th><th>由什么机制来保证</th></tr></thead><tbody><tr><td>原子性、一致性、持久性</td><td>redo log、 undo log</td></tr><tr><td>隔离性</td><td>MVCC多版本控制、数据库的锁</td></tr></tbody></table><h4 id="并发事务问题："><a href="#并发事务问题：" class="headerlink" title="并发事务问题："></a>并发事务问题：</h4><ol><li><p>脏读：一个事务读到了另一个事务还没有提交的数据。<img src="/./../../imgs/MySQL/image-20231003111916626.png" alt="image-20231003111916626"></p></li><li><p>不可重复读：一个事务先后读取同一条记录，但是两次读取的<strong>数据不同</strong>，强调数据不同</p></li></ol><p><img src="/./../../imgs/MySQL/image-20231003111926058.png" alt="image-20231003111926058"></p><ol start="3"><li>幻读：前后读取的记录数量不一致，强调说的是存不存在的问题：原来不存在的,现在存在了,则是幻读。<img src="/./../../imgs/MySQL/image-20231003111932452.png" alt="image-20231003111932452"></li></ol><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p><img src="/./../../imgs/MySQL/image-20231003111936844.png" alt="image-20231003111936844"></p><h4 id="undo-log（原子性-一致性）"><a href="#undo-log（原子性-一致性）" class="headerlink" title="undo log（原子性 一致性）"></a>undo log（原子性 一致性）</h4><ul><li>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性、一致性) 和MVCC(多版本并发控制) 。</li><li>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undolog中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</li><li>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</li></ul><h4 id="redo-log（持久性、-一致性）"><a href="#redo-log（持久性、-一致性）" class="headerlink" title="redo log（持久性、 一致性）"></a>redo log（持久性、 一致性）</h4><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo logfile）,前者是在内存中，后者在磁盘中。<strong>当事务提交之后</strong>会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p><img src="/./../../imgs/MySQL/image-20231003112038852.png" alt="image-20231003112038852"></p><p>有了redolog之后，<strong>当对缓冲区的数据进行增删改之后</strong>，会首先将操作的数据页的变化，记录在redolog buffer中。<strong>在事务提交时</strong>，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样<strong>就保证了事务的持久性</strong>。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="哪些情况适合创建索引"><a href="#哪些情况适合创建索引" class="headerlink" title="哪些情况适合创建索引"></a>哪些情况适合创建索引</h4><ul><li><strong>字段的数值有唯一性的限制</strong></li></ul><p>具有唯一索引的字段，即使是组合字段，也必须建成唯一索引。唯一索引对 insert 的速度损耗可以忽略，但是提高的查找速度是明显的。</p><ul><li><strong>频繁作为 *<em>where*</em> 查询条件的字段</strong></li><li><strong>经常GROUP BY 或 ORDER BY的列</strong></li><li><strong>UPDATE、DELETE 的 WHERE 条件列</strong></li><li><strong>DISTINCT 字段需要创建索引</strong>,排序后去重自然也更快了！</li></ul><h4 id="哪些情况不适合创建索引"><a href="#哪些情况不适合创建索引" class="headerlink" title="哪些情况不适合创建索引"></a>哪些情况不适合创建索引</h4><ul><li><strong>在 WHERE 中使用不到的字段，不要设置索引</strong></li></ul><p>同理，如GROUP BY 或 ORDER BY 条件里用不到的字段，也不要设置索引。原因也很简单，不需要快速定位，设置索引也没有用！</p><ul><li><strong>数据量小的表最好不要使用索引</strong></li></ul><p>在数据量很小的时候，原本查询时间已经很短了，不必要再添加索引。索引的回表等操作可能会使耗费时间更多！</p><ul><li><p><strong>有大量重复数据的列上不要建立索引</strong>, 比如sex、status，否则查找效率也很低</p></li><li><p><strong>避免对经常需要更新的表创建过多的索引</strong>，在对数据进行修改时，索引也会需要调整更新，造成很大负担</p></li></ul><h4 id="B-Tree-与-B-Tree相比"><a href="#B-Tree-与-B-Tree相比" class="headerlink" title="B+Tree 与 B-Tree相比"></a>B+Tree 与 B-Tree相比</h4><ul><li>所有的数据都会出现在叶子节点。</li><li>叶子节点形成一个双向循环链表。</li><li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。<img src="/./../../imgs/MySQL/image-20231003111941842.png" alt="image-20231003111941842"></li></ul><h4 id="为什么InnoDB存储引擎选择使用B-tree索引结构"><a href="#为什么InnoDB存储引擎选择使用B-tree索引结构" class="headerlink" title="为什么InnoDB存储引擎选择使用B+tree索引结构?"></a>为什么InnoDB存储引擎选择使用B+tree索引结构?</h4><ol><li>相对于二叉树，层级更少，搜索效率高；</li><li>对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；B+树叶子节点有链表，支持排序和范围查询。</li><li>相对Hash索引，Hash索引会发生Hash冲突，B+tree支持范围匹配及排序操作；</li><li>数据都在叶子节点，搜索效率稳定，且叶子节点形成双向循环链表，便于范围查找和排序</li></ol><p><strong>与shipList相比：****B+树</strong>是多叉树结构，每个结点都是一个16k的数据页，能存放较多索引信息，所以非叶子节点度数很大，三层<strong>左右就可以存储<code>2kw</code>左右的数据。也就是说查询一次数据，如果这些数据页都在磁盘里，那么最多需要查询</strong>三次磁盘IO**。</p><p><strong>跳表</strong>是链表结构，查询都要能达到<strong>二分查找</strong>的效果，相当于一颗二叉搜索树，保存相同量的数据，层数远比B+树高，需要更多的磁盘IO，查询效率更慢。</p><p>而针对<strong>写操作</strong>，B+树会出现页分裂，跳表则独立插入，没有旋转和维持平衡的开销，因此<strong>跳表的写入性能会比B+树要好。</strong></p><p>缺点:B+树用页来保存数据，会产生内存碎片。</p><h4 id="聚集索引-二级索引"><a href="#聚集索引-二级索引" class="headerlink" title="聚集索引&amp;二级索引"></a>聚集索引&amp;二级索引</h4><p><img src="/./../../imgs/MySQL/image-20231003111945629.png" alt="image-20231003111945629"></p><p>聚集索引选取规则:</p><ul><li><p>​如果存在主键，主键索引就是聚集索引。</p></li><li><p>​如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p></li><li><p>​如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p><p><img src="/./../../imgs/MySQL/image-20231003111949312.png" alt="image-20231003111949312"></p></li><li><p>聚集索引的叶子节点下挂的是这一行的数据 。</p></li><li><p>二级索引的叶子节点下挂的是该字段值对应的主键值。</p></li></ul><h4 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h4><p><font color = gold>聚簇索引和非聚簇索引不是聚集索引与二级索引，而是两种数据存储方式。</font></p><p>聚簇索引存储（InnoDB）：<font color = gold>行数据和主键B+树存储在一起</font>，辅助键B+树只存储辅助键和主键，主键和非主键B+树几乎是两种类型的树。</p><p>非聚簇索引存储（MySAM）：<font color = gold>表数据存储在独立的地方</font>&gt;,主键B+树在叶子节点存储指向真正数据行的<strong>地址指针</strong>，而非主键。</p><p>InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id &#x3D; 14″这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。</p><p>MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个<strong>地址指向真正的表数据</strong>，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索<strong>无需访问主键的索引树</strong>。</p><p>假想一个表如下图存储了4行数据。其中Id作为主索引，Name作为辅助索引。图示清晰的显示了聚簇索引和非聚簇索引的差异。</p><p><a href="https://kyle.ai/blog/wp-content/uploads/2018/03/9.png"><img src="/./../../imgs/MySQL/9.png" alt="9"></a> <a href="https://kyle.ai/blog/wp-content/uploads/2018/03/10.png"><img src="/./../../../../../../%2525E4%2525B8%2525AA%2525E4%2525BA%2525BA%2525E5%25258D%25259A%2525E5%2525AE%2525A2/hexo/blog/source/imgs/Java%2525E7%25259F%2525A5%2525E8%2525AF%252586%2525E7%252582%2525B9%2525E6%252580%2525BB%2525E7%2525BB%252593/10.png" alt="10"></a></p><h5 id="聚簇索引的优势"><a href="#聚簇索引的优势" class="headerlink" title="聚簇索引的优势"></a>聚簇索引的优势</h5><p>看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，聚簇索引的优势在哪？</p><ol><li><p>行数据和叶子节点存储在一起，这样主键和行数据是一起载入内存，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。</p></li><li><p>辅助索引使用主键作为”指针” 而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB<strong>在移动行时无须更新辅助索引中的这个”指针”</strong>。也就是说行的位置（会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。</p></li></ol><h4 id="为什么非主键索引存放的是主键ID而不是数据行的地址？"><a href="#为什么非主键索引存放的是主键ID而不是数据行的地址？" class="headerlink" title="为什么非主键索引存放的是主键ID而不是数据行的地址？"></a>为什么非主键索引存放的是主键ID而不是数据行的地址？</h4><p><strong>保持一致性：</strong><br>当数据库表进行DML操作时，可能会出现“页分裂”、’’非叶子节点分裂’’情况，同一行记录的页地址会发生改变，因非主键索引保存的是主键的值，无需同步更改，降低二级索引的维护开销。</p><h4 id="为什么存放主键id而不是行数据？"><a href="#为什么存放主键id而不是行数据？" class="headerlink" title="为什么存放主键id而不是行数据？"></a>为什么存放主键id而不是行数据？</h4><p><strong>节省存储空间：</strong><br>Innodb数据本身就已经汇聚到主键索引所在的B+树上了， 如果普通索引还继续再保存一份数据，就会导致有多少索引就要存多少份数据，造成数据冗余。</p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>存储一些比较长的字符串时，如果建立索引会使得索引变得很大，查询时大量的磁盘IO降低查询效率，此时可以提取字符串的一部分前缀来建立索引，这样可以大大节约索引空间，提高索引效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 截取某个字段的前 n 个字符建立索引</span></span><br><span class="line"><span class="keyword">create</span> index index_name <span class="keyword">on</span> table_name(column_name(n));</span><br></pre></td></tr></table></figure><p>具体截取的字符串的长度是 选择性最高的最小的n，选择性即是不重复的索引值和数据表的记录总数的比值</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p> 覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。索引的b+树的叶子节点中保存了我们需要查询的数据，此时无需进行回表查询。</p><h4 id="联合索引在b-树中怎么存储"><a href="#联合索引在b-树中怎么存储" class="headerlink" title="联合索引在b+树中怎么存储"></a>联合索引在b+树中怎么存储</h4><p>联合索引是对多个列（字段）建立的索引(需要满足最左前缀法则)</p><p><font color = gold><strong>前一个条件</strong>相等的情况下 <strong>当前条件</strong>才会是<strong>有序的</strong>，当<strong>前一个条件</strong>不同 那么无法保证<strong>当前条件</strong>为有序的 所以索引失效</font>,也就是说,只有<strong>记录左边的字段都是相等的时,记录的当前字段才会是有序的,才能使用当前字段索引</strong></p><p>联合索引和其他索引的区别就是在非叶子节点存储的是联合索引上全部字段，按照最左前缀法则排序，叶子节点会存储联合索引全部字段和主键id</p><p><img src="/./../../imgs/MySQL/v2-e6c3ce6effabafb1a96e08cffbeb104b_r.jpg" alt="img"></p><h4 id="索引下推？"><a href="#索引下推？" class="headerlink" title="索引下推？"></a><strong>索引下推？</strong></h4><p><a href="https://juejin.cn/post/7005794550862053412">五分钟搞懂MySQL索引下推 - 掘金 (juejin.cn)</a></p><p><a href="https://blog.csdn.net/wang_luwei/article/details/120274064">Mysql性能优化之什么是索引下推？_索引吓退-CSDN博客</a></p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li><p>索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，是针对非聚集索引得优化（聚集索引没有回表查询这一说法）用于减少存储引擎回表查询的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</p></li><li><p>在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</p></li><li><p>在使用ICP的情况下，如果<font color = gold><strong>存在某些被索引的列</strong>是<strong>判断条件</strong>时，MySQL服务器将<strong>这一部分判断条件</strong>传递给<strong>存储引擎</strong>，然后由存储引擎通过<strong>判断索引是否符合</strong>MySQL服务器传递的<strong>条件</strong>，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器</font>。</p></li></ul><h5 id="优化的原理"><a href="#优化的原理" class="headerlink" title="优化的原理"></a>优化的原理</h5><p>我们先简单了解一下MySQL大概的架构：</p><p><img src="/./../../imgs/MySQL/52288fa925f84cef937bb0b46d27c60atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="MySQL大概架构"></p><p>MySQL服务层负责SQL语法解析、生成执行计划等，并调用存储引擎层去执行数据的存储和检索。</p><p><font color = gold><code>索引下推</code>的<strong>下推</strong>其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理，推的是在查数据走联合索引时，将5.6版本之前 （联合）索引中容忽略的字段给添加上，让（联合）索引中的全部字段都用上。</font></p><p>我们来具体看一下，在没有使用ICP的情况下，MySQL的查询：</p><ul><li>存储引擎读取索引记录；</li><li>根据索引中的主键值，定位并读取完整的行记录；</li><li>存储引擎把记录交给<code>Server</code>层去检测该记录是否满足<code>WHERE</code>条件。</li></ul><p>使用ICP的情况下，查询过程：</p><ul><li>存储引擎读取索引记录（不是完整的行记录）；</li><li>判断<code>WHERE</code>条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；</li><li>条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；</li><li>存储引擎把记录交给<code>Server</code>层，<code>Server</code>层检测该记录是否满足<code>WHERE</code>条件的其余部分。</li></ul><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>使用一张用户表<code>tuser</code>，表里创建联合索引（name, age）。</p><p><img src="/./../../imgs/MySQL/1b49ff7a5bff433688d7640d1ca64fb4tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="用户表"></p><p>如果现在有一个需求：检索出表中<code>名字第一个字是张，而且年龄是10岁的所有用户</code>。那么，SQL语句是这么写的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>假如你了解索引最左匹配原则，那么就知道这个语句在搜索索引树的时候，只能用 <code>%张</code>，<font color = gold>会忽略age这个字段</font>，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为1，4，然后拿着取到的id值一次次的回表查询，因此这个过程需要回表两次。</p><p><strong>（忽略的原因是：<font color = gold>组合索引满足最左匹配，但是遇到非等值判断时匹配停止</font>。name like ‘陈%’ 不是等值匹配，所以 age &#x3D; 20 这里就用不上 (name,age) 组合索引了。如果没有索引下推，组合索引只能用到 name，age 的判定就需要回表才能做了。5.6版本之后有了索引下推，age &#x3D; 20 可以直接在组合索引里判定。）</strong></p><p><img src="/./../../imgs/MySQL/a2db6afbc11546fbb4205b2faa64400ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="B+树联合索引"></p><p><strong>没有使用ICP</strong></p><p>存储引擎根据通过联合索引找到<code>name like &#39;张%&#39;</code> 的主键id（1、4），逐一进行回表扫描，去聚簇索引找到完整的行记录，server层再对数据根据<code>age=10进行筛选</code>。</p><p>我们看一下示意图：</p><p><img src="/./../../imgs/MySQL/c97ed6c5e395416181cb57591151fb09tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="未使用ICP"></p><p>可以看到需要回表两次，把我们联合索引的另一个字段<code>age</code>浪费了。</p><p><strong>使用ICP</strong></p><p>存储引擎根据（name，age）联合索引，找到<code>name like &#39;张%&#39;</code>，由于<strong>联合索引中包含<code>age</code>列</strong>，InnoDB并没有忽略索引中age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要回表一次。，所以存储引擎直接再联合索引里按照<code>age=10</code>过滤。按照过滤后的数据再一一进行回表扫描。</p><p>我们看一下示意图：</p><p><img src="/./../../imgs/MySQL/8edc3c9af2e5403da79f77e50adaecd3tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="使用ICP的示意图"></p><p>可以看到只回表了一次。</p><p>除此之外我们还可以看一下执行计划，看到<code>Extra</code>一列里<code> Using index condition</code>，这就是用到了索引下推。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>复制代码<span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tuser <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> na_index      <span class="operator">|</span> na_index <span class="operator">|</span> <span class="number">102</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">25.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure><h5 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h5><ul><li>只能用于<code>range</code>（范围查询）、 <code>ref</code>、 <code>eq_ref</code>、<code>ref_or_null</code>访问方法；</li><li>只能用于<code>InnoDB</code>和 <code>MyISAM</code>存储引擎及其分区表；</li><li>对<code>InnoDB</code>存储引擎来说，索引下推只适用于二级索引（也叫辅助索引）;</li></ul><blockquote><p>索引下推的目的是为了减少回表次数，也就是要减少IO操作。对于<code>InnoDB</code>的<strong>聚簇索引</strong>来说，数据和索引是在一起的，不存在回表这一说。</p></blockquote><ul><li>引用了子查询的条件不能下推；</li><li>引用了存储函数的条件不能下推，因为存储引擎无法调用存储函数。</li></ul><h4 id="为什么范围查找Mysql没有用索引下推优化？"><a href="#为什么范围查找Mysql没有用索引下推优化？" class="headerlink" title="为什么范围查找Mysql没有用索引下推优化？"></a><strong>为什么范围查找Mysql没有用索引下推优化？</strong></h4><p>估计应该是Mysql认为范围查找过滤的结果集过大，like KK% 在绝大多数情况来看，过滤后的结果集比较小，所以这里Mysql选择给 like KK% 用了索引下推优化</p><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><p><a href="https://cloud.tencent.com/developer/article/1992920">15个必知的Mysql索引失效场景，别再踩坑了-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><ol><li><p><strong>在索引列上进行使用内置函数、运算操作（如，+、-、*、&#x2F;）， 索引将失效</strong> ，MySQL 查询优化器无法直接利用索引来定位满足条件的记录，执行全表扫描或使用其他索引进行查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="built_in">SUBSTRING</span>(name, <span class="number">1</span>, <span class="number">5</span>) <span class="operator">=</span> <span class="string">&#x27;Smith&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">-</span> <span class="number">1</span> <span class="operator">&gt;</span> <span class="number">20</span>; </span><br></pre></td></tr></table></figure></li><li><p><strong>发生隐式的类型转换</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> 软件工程 <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>比如字符串不加引号，比如将char转换为int，尽管我们为条件列创建了索引，但由于查询条件中的隐式类型转换，MySQL 将<code>&#39;1&#39;</code>视为一个字符串，而不是整数。这会导致索引无法生效，数据库将会执行全表扫描来搜索匹配的行。</p></li><li><p><strong>头部模糊查询</strong>（尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效） </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%软件%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>因为 % 通配符表示匹配任意数量的字符，导致数据库无法使用索引进行快速查找，而需要执行全表扫描来搜索匹配的行</p></li><li><p><strong>OR连接条件</strong>  OR连接多个条件时，如果一个条件不能使用索引，就需要全表扫描，导致索引失效。这是因为 OR 运算符要求数据库同时检索满足两个条件的数据，而无法利用单一列的索引进行快速查找。我们将查询拆分为两个独立的查询，并分别使用适当的索引，以提高查询性能，可以考虑用union 或者 union all将结果连接起来来替代or</p></li><li><p><strong>联合索引（多列索引）不满足最左前缀法则</strong>。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p></li><li><p>**联合索引中，出现范围查询(&gt;,&lt;)**，范围查询右侧的列索引失效,因为**前一个条件**相等的情况下 **当前条件**才会是**有序的**。<br>当**前一个条件**不同 那么无法保证**当前条件**为有序的 所以索引失效。当范围查询使用&gt;&#x3D; 或 &lt;&#x3D; 时，分为两种， “&#x3D;”走联合索引，不会使右侧的列索引失效， “&lt;” 或者“&gt;”会使索引失效</p></li><li><p><strong>当查询条件使用了is null 或者 is not null</strong>，由于null值不能使用索引，索引也会失效。</p></li><li><p><strong>索引字段上使用 !&#x3D; 或者 &lt;&gt;</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">!=</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure><p>MySQL 的 B-Tree 索引存储的是有序的键值，它只能高效地利用索引来定位特定键值或键值范围的数据。</p><p>但是，使用 !&#x3D; 操作符相当于一个不等条件，无法构建有效的键值范围，因此 MySQL 通常会选择不使用索引，而执行全表扫描来获取结果。</p><p>可以使用等于操作符 &#x3D; 和 NOT 运算符来取代 !&#x3D;，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure><p>或者使用等价的条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="keyword">NOT</span> (age <span class="operator">=</span> <span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>这样可以有效利用索引，提高查询性能。</p></li><li><p><strong>使用not in 或not exists</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_items <span class="keyword">WHERE</span> order_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_id <span class="keyword">FROM</span> orders);</span><br></pre></td></tr></table></figure><p>在这个查询中，子查询 (SELECT order_id FROM orders) 会返回所有的订单ID。如果 orders 表中的订单ID较多，子查询的结果集会很大，导致 MySQL 在执行主查询时需要扫描大量数据，无法高效地利用索引。这可能导致索引失效，性能下降。</p><p>使用 NOT EXISTS：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_items oi <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> orders o <span class="keyword">WHERE</span> o.order_id <span class="operator">=</span> oi.order_id);</span><br></pre></td></tr></table></figure><p>这个查询会查询 order_items 表中的订单项，并使用子查询 (SELECT 1 FROM orders o WHERE o.order_id &#x3D; oi.order_id) 来判断是否存在对应的订单。尽管 NOT EXISTS 子查询只需要找到第一个匹配的结果，就可以确定不存在匹配的结果，但是如果子查询中的条件复杂或执行计划不佳，也可能导致索引失效或影响查询性能。</p><p>为了避免这种情况，可以考虑使用其他方式，比如使用 LEFT JOIN 结合 IS NULL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> oi.<span class="operator">*</span> <span class="keyword">FROM</span> order_items oi <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders o <span class="keyword">ON</span> o.order_id <span class="operator">=</span> oi.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p>这种方式可以利用 LEFT JOIN 并检查 orders 表中的订单ID是否为 NULL，来确定哪些订单项没有对应的订单。这样就能更有效地利用索引，提高查询性能。</p></li><li><p><strong>order by 排序顺序与索引的顺序不匹配</strong>：</p><p>索引是按照升序（ASC）排列的，而我们尝试以降序（DESC）进行排序。虽然数据库可以通过排序结果的逆向扫描来实现降序排序，但这可能会导致索引失效，因为索引无法直接按照所需的顺序匹配。</p></li><li><p>MySQL优化器<strong>评估不走索引比走索引还快</strong>，索引也失效。</p></li></ol><h4 id="如何去合理地创建表的索引"><a href="#如何去合理地创建表的索引" class="headerlink" title="如何去合理地创建表的索引"></a>如何去合理地创建表的索引</h4><ul><li><strong>针对于查询比较频繁建立索引：</strong>常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li><li><strong>尽量选择区分度高的列作为索引</strong>，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li><strong>建立前缀索引</strong>：字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li><strong>建立联合索引</strong>：对进程需要同时查询多个列的语句，建立联合索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li><strong>要控制索引的数量</strong>：索引越多，每次插入删除数据都需要找到多棵B+树进行操作，维护索引结构的代价也就越大，会影响增删改的效率</li><li><strong>定期维护索引</strong>：定期维护索引可以清理无用的索引，以保证数据库的正常运行</li></ul><h4 id="B-树的查询时间复杂度："><a href="#B-树的查询时间复杂度：" class="headerlink" title="B+树的查询时间复杂度："></a>B+树的查询时间复杂度：</h4><p>B+树的搜索过程中的IO次数 &#x3D; 搜索过程中访问节点的数量 &#x3D; B+树的深度 &#x3D; logmN，其中m为B+树一个节点的度数</p><h4 id="通过索引查询数据，会经历几次磁盘IO"><a href="#通过索引查询数据，会经历几次磁盘IO" class="headerlink" title="通过索引查询数据，会经历几次磁盘IO"></a>通过索引查询数据，会经历几次磁盘IO</h4><p>B+树一般高度为3层（3层可以存放约2000W行数据）</p><ul><li><p>如果查询建立了聚集索引，或者能够使用覆盖索引，就不需要回表，也就是需要B+树的层高次，</p></li><li><p>否则要查两次索引，也就是两倍层高次</p></li></ul><p><strong>B+树数据的存储能有多少呢?</strong></p><ol><li>对于非叶子节点，如果key使用的是bigint，则为8字节，指针在mysql中为6字节，一共是14字节，则16k能存放 16 * 1024 &#x2F; 14 &#x3D; 1170 个索引指针。</li><li>对于叶子节点，如果一行数据大小为1k，那么一页就能存16条数据；</li></ol><p><strong>于是可以算出</strong></p><p>高度为2的B+树(18720 条数据)</p><ul><li>根节点存储索引指针节点，那么它有1170个叶子节点存储数据，每个叶子节点可以存储16条数据，一共 1170 x 16 &#x3D; 18720 条数据。</li></ul><p>而对于高度为3的B+树(21902400 条数据)</p><ul><li>就可以存放 1170 x 1170 x 16 &#x3D; 21902400 条数据（两千多万条数据），也就是对于两千多万条的数据，</li></ul><h4 id="为什么Mysql页设置为16KB"><a href="#为什么Mysql页设置为16KB" class="headerlink" title="为什么Mysql页设置为16KB"></a>为什么Mysql页设置为16KB</h4><p>mysql的数据是放在页里面的,一次数据I&#x2F;O至少加载一页数据.这样是为了减少I&#x2F;O资源浪费</p><p> mysql设置16K的大小，数据就可以存<strong>2千多万</strong>就已经足够了吧，既能保证一次磁盘IO不要Load太多的数据 又能保证一次load的性能，即便表的数据在几千万的数量也能保证树的高度在一个可控的范围。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="MySQL锁概述"><a href="#MySQL锁概述" class="headerlink" title="MySQL锁概述"></a>MySQL锁概述</h4><p>锁是计算机协调多个进程或线程并发访问某一资源的机制，在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源，所以数据库也需要使用不同的锁来保证数据并发访问的一致性、有效性，锁冲突也是影响数据库并发访问性能的一个重要因素，所以锁对于数据库是很重要的。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ul><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据</li></ul><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p><strong>锁定数据库中的所有表</strong></p><p>特点：</p><ul><li>加锁后整个数据库实例处于只读状态，</li><li>后续的DML语句，DDL语句，事务提交语句均被阻塞。</li><li>如果在主库上备份，整个数据库处于只读状态，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li></ul><p>应用场景：</p><ul><li>全库的逻辑备份，从而获取一致性视图。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加全局锁</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"><span class="comment">-- 备份文件</span></span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p <span class="number">1234</span> itcast <span class="operator">&gt;</span> itcast.sql</span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p><strong>每次操作锁住整张表</strong>。表级锁主要有三类：<strong>表锁、元数据锁、意向锁</strong>。</p><h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5><p>表锁分为两类，表共享读锁(read lock)和表共享写锁(write lock)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加锁</span></span><br><span class="line">lock <span class="keyword">table</span> table_name read<span class="operator">/</span>write</span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">unlock tables <span class="operator">/</span> 客户端断开连接</span><br></pre></td></tr></table></figure><p><strong>读锁</strong></p><p>客户端A对表a加上读锁，则A和其他客户端均不能执行DDL和DML语句，均可以执行DQL语句，直到客户端A释放读锁。</p><p><img src="/./../../imgs/MySQL/%E8%AF%BB%E9%94%81.png" alt="读锁"></p><p><strong>写锁</strong></p><p>客户端A对表a加上写锁，则A可以执行DDL&#x2F;DML&#x2F;DQL语句，其他客户端均不可以执行DDL&#x2F;DML&#x2F;DQL语句，直到客户端A释放锁。</p><p><img src="/./../../imgs/MySQL/%E5%86%99%E9%94%81.png" alt="写锁"></p><h5 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a>元数据锁（MDL）</h5><p>MDL加锁过程由系统自动控制，不需要显式使用</p><p>在表中有活动事务时，不可以对元数据进行写入操作，元数据简单来说就是一张表的表结构，简单来说就是防止DML语句和DDL语句的冲突，有事务时不能修改表结构，保证读写的正确性。</p><table><thead><tr><th>对表的操作</th><th>加的MDL锁</th></tr></thead><tbody><tr><td>DML和DQL语句(增删改查)</td><td>MDL读锁（共享）</td></tr><tr><td>DDL语句(修改表结构)</td><td>MDL写锁(排他)</td></tr></tbody></table><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p><strong>意向锁是为了防止行锁与表锁发生冲突</strong>，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p><ul><li>当一个事务修改某一行数据时有可能会对表加上行锁，此时如果有另一个事务试图对表加上表锁，就有可能发生锁冲突，表锁需要检查每行数据是否加锁。</li><li>为了防止这种情况，第一个事务在加行锁之前会对整张表加上意向锁，记录行锁信息，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。</li></ul><p>意向锁分为意向共享锁和意向排他锁。意向锁之间不会互斥。</p><p>意向共享锁（IS）：由语句select…lock in share mode添加。与表锁读锁兼容，与表锁写锁互斥。</p><p>意向排他锁（IX）：由insert，update，delect，select…for update添加。与表锁的写锁和读锁都互斥。</p><p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><p><strong>每次操作锁住对应的行数据</strong>。只存在于InnoDB存储引擎之中。行级锁是针对主键索引加锁。行级锁主要分为三类，行锁（Record Lock），间隙锁（Gap Lock），Next-Key Lock。</p><h5 id="行锁-Record-Lock"><a href="#行锁-Record-Lock" class="headerlink" title="行锁 - Record Lock"></a>行锁 - Record Lock</h5><p>锁定单个记录，防止其他事务对此进行update和delete，在读提交和可重复读的隔离级别下均支持。行锁分为两类，<strong>共享锁</strong>和<strong>排他锁</strong>，共享锁之间兼容，排他锁与共享锁和排他锁均不兼容。基本语句的行锁加锁情况如下：</p><p><img src="/./../../imgs/MySQL/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8A%A0%E9%94%81%E6%83%85%E5%86%B5.png" alt="基本语句的行锁加锁情况"></p><p>特点</p><ul><li>使用update或delete针对唯一索引已存在的记录进行等值匹配时，表锁会优化为行锁，只锁目标记录。</li><li>如果不用索引检索数据，语句不走索引，那么InnoDB会对所有的记录加锁，此时行锁升级为表锁。</li></ul><h5 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁 - Gap Lock"></a>间隙锁 - Gap Lock</h5><p>间隙锁 是 <strong>Innodb 在 RR(可重复读) 隔离级别</strong> 下为了解决<code>幻读问题</code>时引入的锁机制。<strong>间隙锁是innodb中行锁的一种</strong>。</p><p>锁定索引之间的间隙，确保索引之间的间隙不变，防止其他事务对这个间隙的insert的操作。</p><p>请务必牢记：<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据</strong>。</p><p>举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,…,100,101，下面的SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empid <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure><p>当我们用条件检索数据，并请求共享或排他锁时，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p><p>这个时候如果你插入empid等于102的数据的，如果那边事物还没有提交，那你就会处于等待状态，无法插入数据。</p><p>间隙锁在innoDB中的唯一作用就是在一定的“间隙”内防止其他事务的插入操作，以此防止幻读的发生：</p><ul><li>使用update或delete针对<strong>唯一索引</strong>上不存在的记录进行等值匹配时，InnoDB会对数据加上间隙锁，左开右闭。此时会阻塞这个间隙中的insert语句。</li><li>间隙锁之间兼容，同一个间隙可以重复加锁</li><li>普通索引（非唯一索引）上的等值查询向右遍历到第一个不满足要求的记录时，next-key退化为间隙锁，锁住 查询的值所在的区间</li></ul><h5 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h5><ul><li>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</li></ul><p><strong>临键锁</strong>只与<strong>非唯一索引列</strong>有关，在<strong>唯一索引列（包括主键列）上不存在临键锁。</strong>当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。</p><p>当查询的索引含有唯一属性（唯一索引，主键索引）时，Innodb存储引擎会对next-key lock进行优化，将其降为record lock,即仅锁住索引本身，而不是范围，因为是唯一索引，不会插入重复的数据，不会造成幻读。</p><h5 id="何时使用行锁，何时产生间隙锁"><a href="#何时使用行锁，何时产生间隙锁" class="headerlink" title="何时使用行锁，何时产生间隙锁"></a>何时使用行锁，何时产生间隙锁</h5><ol><li>只使用<strong>唯一索引查询</strong>，并且<strong>只锁定一条记录</strong>时，innoDB会<strong>使用行锁</strong>，因为是唯一索引，不能插入已经重复的数据，造成幻读。</li><li>只使用<strong>唯一索引查询</strong>，但是检索条件是<strong>范围检索</strong>，或者是<strong>唯一检索然而检索结果不存在</strong>（试图锁住不存在的数据）时，会产生 <strong>Next-Key Lock</strong>。</li><li>使用<strong>普通索引检索</strong>时，不管是何种查询，<strong>只要加锁</strong>，都会<strong>产生间隙锁</strong>。</li><li>同时使用<strong>唯一索引</strong>和<strong>普通索引</strong>时，由于数据行是<strong>优先根据普通索引排序</strong>，再根据唯一索引排序，所以<strong>也会产生间隙锁</strong>。</li></ol><h4 id="mysql：死锁是什么？-实习中你有遇到死锁的情况吗"><a href="#mysql：死锁是什么？-实习中你有遇到死锁的情况吗" class="headerlink" title="mysql：死锁是什么？ 实习中你有遇到死锁的情况吗"></a>mysql：死锁是什么？ 实习中你有遇到死锁的情况吗</h4><p><strong>1、产生原因：</strong></p><p>所谓死锁：是指两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用，它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。</p><ul><li>死锁的关键在于：两个(或以上)的线程加锁的顺序不一致。</li><li>那么对应的解决死锁问题的关键就是：让不同的线程加锁有次序</li></ul><p><strong>2、产生示例：</strong></p><p>案例一</p><p>需求：将投资的钱拆成几份随机分配给借款人。</p><p>起初业务程序思路是这样的：</p><p>投资人投资后，将金额随机分为几份，然后随机从借款人表里面选几个，然后通过一条条select for update 去更新借款人表里面的余额等。</p><p>例如两个用户同时投资，A用户金额随机分为2份，分给借款人1，2</p><p>B用户金额随机分为2份，分给借款人2，1</p><p>由于加锁的顺序不一样，死锁当然很快就出现了。</p><p>对于这个问题的改进很简单，直接把所有分配到的借款人直接一次锁住就行了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> xxx <span class="keyword">where</span> id <span class="keyword">in</span> (xx,xx,xx) <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><h4 id="乐观锁与悲观锁，在MySQL中怎么实现"><a href="#乐观锁与悲观锁，在MySQL中怎么实现" class="headerlink" title="乐观锁与悲观锁，在MySQL中怎么实现"></a>乐观锁与悲观锁，在MySQL中怎么实现</h4><p>悲观锁，比较消极的一种锁处理方式。直接在操作数据时，抢占锁。其他的事务在进行时就会等待，直到占有锁的事务释放锁为止。</p><p>​    这种处理方式能保证数据的最大一致性，但是容易导致锁超时、并发程度低等问题。 首先我们开启事务一，并且对id&#x3D;1的数据进行update操作，此时我们不提交事务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql root@127.0.0.1:demo&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.002s</span><br><span class="line">mysql root@127.0.0.1:demo&gt; update `user` <span class="built_in">set</span> name = <span class="string">&#x27;张三111111&#x27;</span><span class="built_in">where</span> <span class="built_in">id</span> = 1;</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line">Time: 0.004s</span><br></pre></td></tr></table></figure><p>​    接着我们开启事务二，对id&#x3D;1的数据进行update操作，查看此时会发生什么情况？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql root@127.0.0.1:demo&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.002s</span><br><span class="line">mysql root@127.0.0.1:demo&gt; update `user` <span class="built_in">set</span> sex = 1 <span class="built_in">where</span> <span class="built_in">id</span> = 1;</span><br></pre></td></tr></table></figure><p>​    我们执行完update语句之后，就处于等待状态，SQL语句也不会马上被执行，这是因为事务一没有commit，也就没有释放id&#x3D;1的数据对应的写锁。</p><p>乐观锁认为数据一般情况下不会造成冲突，只有当数据去执行修改情况时，才会针对数据冲突做处理。这里是如何发现冲突了呢？常规的方式，都是在数据行上加一个版本号或者时间戳等字段。(本文使用version作为版本号方式，使用时间戳方式同理)</p><p>​    <strong>乐观锁的实现原理：</strong></p><ul><li>一个事务在读取数据时，将对应的版本号字段读取出来，假设此时的版本号是1。    </li><li>另外一个事务也是执行同样的读取操作。当事务一提交时，对版本号执行+1，此时该数据行的版本号就是2。    </li><li>第二个事务执行修改操作时，针对业务数据做条件，并默认增加一个版本号作为where条件。此时修改语句中的版本号字段是不满足where条件，该事务执行失败。通过这种方式来达到锁的功能。</li></ul><h4 id="MySQL如何解决幻读"><a href="#MySQL如何解决幻读" class="headerlink" title="MySQL如何解决幻读"></a>MySQL如何解决幻读</h4><p><strong>快照读</strong></p><p>快照读，读取的是<strong>快照数据</strong>，不加锁的普通 SELECT 都属于快照读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure><p>通过mvcc机制来解决幻读</p><p><strong>当前读</strong></p><p>当前读就是读的是<strong>最新数据</strong>，而不是历史的数据，加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> <span class="keyword">values</span> ...</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ...</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> ...</span><br></pre></td></tr></table></figure><p>在当前读的条件下，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li><li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止，使用间隙锁锁住区间。</li></ul><p><em>间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会</em><br><em>阻止另一个事务在同一间隙上采用间隙锁。</em></p><p><a href="https://juejin.cn/post/7056583607929798692">MySQL 如何解决幻读（MVCC 原理分析） - 掘金 (juejin.cn)</a></p><h4 id="MVCC机制"><a href="#MVCC机制" class="headerlink" title="MVCC机制"></a>MVCC机制</h4><p>详见<a href="https://juejin.cn/post/7016165148020703246#heading-24">看一遍就理解：MVCC原理详解 - 掘金 (juejin.cn)</a></p><p>InnoDB还会自动的给我们每一条数据添加三个隐藏字段及其含义分别是</p><p><img src="/./../../imgs/MySQL/image-20231003112043284.png" alt="image-20231003112043284"></p><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><p>当某个事务执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，<br>并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/./../../imgs/MySQL/image-20231003112046405.png" alt="image-20231003112046405"></p><p>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致<strong>该记录的undolog生成一条记录版本链表</strong>，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><p>ReadView（读视图）是<strong>快照读 SQL执行时MVCC提取数据的依据</strong>，记录并维护系统当前活跃的事务（未提交的）id。</p><p><strong>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</strong></p><p><strong>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView</strong></p><p>ReadView中包含了四个核心字段：</p><p><img src="/./../../imgs/MySQL/image-20231003112049869.png" alt="image-20231003112049869"></p><p>readview中规定版本链数据的访问规则：<br>trx_id 代表当前undolog版本链对应事务ID。</p><p><img src="/./../../imgs/MySQL/image-20231003112052634.png" alt="image-20231003112052634"></p><h4 id="MySQL-事务的可重复读和读已提交，Read-View-时机"><a href="#MySQL-事务的可重复读和读已提交，Read-View-时机" class="headerlink" title="MySQL 事务的可重复读和读已提交，Read View 时机"></a>MySQL 事务的可重复读和读已提交，Read View 时机</h4><ul><li>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li><li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li></ul><h4 id="MVCC完全解决了幻读吗？"><a href="#MVCC完全解决了幻读吗？" class="headerlink" title="MVCC完全解决了幻读吗？"></a>MVCC完全解决了幻读吗？</h4><p>整个发生幻读的时序图如下：</p><p><img src="/./../../imgs/MySQL/%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png" alt="img"></p><p>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id &#x3D; 5 的记录并提交。接着，事务 A 对 id &#x3D; 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</p><p>因为这种特殊现象的存在，所以我们认为 <strong>MySQL Innodb 中的 MVCC 并不能完全避免幻读现象</strong></p><h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><h4 id="SQL优化（常规）"><a href="#SQL优化（常规）" class="headerlink" title="SQL优化（常规）"></a>SQL优化（常规）</h4><h5 id="插入数据优化"><a href="#插入数据优化" class="headerlink" title="插入数据优化"></a>插入数据优化</h5><ol><li><p>批量插入数据 <code>Insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;); </code></p></li><li><p>手动控制事务 ，避免频繁开启、提交事务</p><p><code>start transaction; insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;); insert into tb_test values(4,&#39;Tom&#39;),(5,&#39;Cat&#39;),(6,&#39;Jerry&#39;); insert into tb_test values(7,&#39;Tom&#39;),(8,&#39;Cat&#39;),(9,&#39;Jerry&#39;); commit;</code></p></li><li><p>主键顺序插入，性能要高于乱序插入，乱序插入会出现页分裂会降低效率。</p></li><li><p>一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，可以使用MySQL数据库提供的load指令进行插入</p><p><code>-- 客户端连接服务端时，加上参数 -–local-infile</code><br><code>mysql –-local-infile -u root -p</code><br><code>-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</code><br><code>set global local_infile = 1;</code><br><code>-- 执行load指令将准备好的数据，加载到表结构中</code><br><code>load data local infile &#39;/root/sql1.log&#39; into table tb_user fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39; ;</code></p></li></ol><h5 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h5><ul><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改</li></ul><h5 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h5><ul><li>在分组操作时，可以通过索引来提高效率。</li><li>分组操作时，索引的使用也是满足最左前缀法则的。</li></ul><h5 id="表连接优化"><a href="#表连接优化" class="headerlink" title="表连接优化"></a>表连接优化</h5><ul><li>经常在连接的列上,也是外键上创建索引,可以加快连接的速度；</li><li>合理选择驱动表，小表驱动大表。减少创建连接的次数，因为小表连接一次可以在大表中查询多次。</li><li>合理添加过滤条件可以显著减少扫描次数。</li></ul><p>left join的情况下，对右表加索引，左表是驱动表，左连接就是左边都要查出来，所以左边还是all，但是右边是ref了。</p><h5 id="子查询怎么优化"><a href="#子查询怎么优化" class="headerlink" title="子查询怎么优化"></a>子查询怎么优化</h5><p>把子查询转化为表连接，并在右表的连接字段（外键）建立索引实现优化</p><h5 id="limit优化-深度分页怎么优化？"><a href="#limit优化-深度分页怎么优化？" class="headerlink" title="(limit优化)深度分页怎么优化？"></a>(limit优化)深度分页怎么优化？</h5><p><strong>为什么深度分页比较慢？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,balance <span class="keyword">from</span> account <span class="keyword">where</span> update_time<span class="operator">&gt;</span> <span class="string">&#x27;2020-09-19&#x27;</span> limit <span class="number">100000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这条sql的执行流程:</p><ul><li>先从update_time的索引树中找到100010条满足条件的记录，返回主键id给server，server再从主键树中回表查询100010行记录，然后扔掉前面100000行</li></ul><p>由于扫描了100000行无用的记录，还要回表100010次，所以效率很低。</p><ol><li><strong>子查询优化</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,balance <span class="keyword">FROM</span> account <span class="keyword">where</span> id <span class="operator">&gt;=</span> (<span class="keyword">select</span> a.id <span class="keyword">from</span> account a <span class="keyword">where</span> a.update_time <span class="operator">&gt;=</span> <span class="string">&#x27;2020-09-19&#x27;</span> limit <span class="number">100000</span>, <span class="number">1</span>) LIMIT <span class="number">10</span></span><br></pre></td></tr></table></figure><p>一种优化思路是减少回表次数，即子查询优化。即从二级索引树中取出来记录的第一条的主键ID，这个过程是不用回表的，因为2级树的叶子节点中有ID，取到第一个记录的ID，再回到主键树从这个ID开始取十个数，大大减少了回表次数，从而提高了查询效率。</p><ol start="2"><li><strong>延迟关联</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  acct1.id,acct1.name,acct1.balance <span class="keyword">FROM</span> account acct1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> a.id <span class="keyword">FROM</span> account a <span class="keyword">WHERE</span> a.update_time <span class="operator">&gt;=</span> <span class="string">&#x27;2020-09-19&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a.update_time LIMIT <span class="number">100000</span>, <span class="number">10</span>) <span class="keyword">AS</span>  acct2 <span class="keyword">on</span> acct1.id<span class="operator">=</span> acct2.id;</span><br></pre></td></tr></table></figure><p>这个思路也是和子查询优化差不多，同样是先找好ID再回表，区别是从二级索引树中先找出对应的n条数据再两表联查。</p><ol start="3"><li><strong>游标标记法</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span>  birth_date <span class="operator">&gt;</span><span class="string">&#x27;1955-01-01&#x27;</span> <span class="keyword">and</span> emp_no <span class="operator">&gt;</span> <span class="number">229225</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> emp_no limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>记录上一次查询到的主键ID，下一次直接从主键树中该ID往后查询。缺点是在查询过程中数据库数据变化可能导致查询的数据不准，并且要求字段自增，并且每次查询要知道上一次查询结果中的最大Id，所以不能跳页查看，只能前后翻页。</p><h5 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h5><table><thead><tr><th>count(数字)</th><th>InoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，<strong>放一个数字“1”进去，直接按行进行累加</strong>。</th></tr></thead><tbody><tr><td>count(*)</td><td>InnoDB引擎<strong>并不会把全部字段取出来</strong>，而是专门做了优化，不取值，服务层直接按行进行累加。</td></tr><tr><td>count(字段)</td><td>没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，<strong>服务层判断是否为null.不为null，计数累加</strong>。有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</td></tr></tbody></table><p>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(※)，所以尽量使用 count(*※)。</p><h5 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h5><p>尽量给要Update的字段加索引，将表锁降为行锁，缓解锁冲突阻塞。</p><h5 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h5><p><a href="https://mp.weixin.qq.com/s/BLsd1b57-hlILzFvf9Gf0A">https://mp.weixin.qq.com/s/BLsd1b57-hlILzFvf9Gf0A</a></p><p>order by原理：</p><p>查找1000个杭州人，按照名字排序</p><p><img src="/./../../imgs/MySQL/20190505204141450.png" alt="img"></p><h6 id="全字段索引"><a href="#全字段索引" class="headerlink" title="全字段索引"></a>全字段索引</h6><p>我们需要在city上添加一个索引。 我们在执行explain命令来看看这个语句的执行情况。</p><p><img src="/./../../imgs/MySQL/2019050520441242.png" alt="在这里插入图片描述"></p><p>Extra这个字段中的”Using filesort“ 表示的就是需要排序，MySql会给每个线程分配分配一块内存用于排序，称为sort_buffer。</p><p><img src="/./../../imgs/MySQL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyOTYxNjU=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>从图中可以看到，满足city&#x3D;‘杭州’条件的行，是从ID_X到ID_(X+N)的这些记录。<br>通常情况下，这个语句执行流程如下所示：</p><ol><li>初始化sort_buffer, 确定放入name、city、age这三个字段;</li><li>从索引city找到第一个满足city&#x3D;“杭州” 条件的主键id，也就是图中的ID_X;</li><li>到主建索引取出整行数据（回表查询），取name、city、age 三个 字段的值，存入sort_buffer中;</li><li>从索引city取下一个记录的主键id ;</li><li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y;</li><li>对sort_buffer 中的数据<strong>按照字段name做快速排序</strong>;</li><li>按照排序结果取前1000行返回给客户端;</li></ol><p><img src="/./../../imgs/MySQL/640-1713193636636-6.webp" alt="图片"></p><p><img src="/./../../imgs/MySQL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyOTYxNjU=,size_16,color_FFFFFF,t_70-1711682366199-8.png" alt="在这里插入图片描述"></p><p>按照字段 username 做快速排序这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和 sort_buffer 的大小，由参数 <code>sort_buffer_size</code> 决定。</p><p>如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则就需要利用<strong>磁盘临时文件</strong>来辅助排序。</p><p>解释下这里使用磁盘临时文件来进行辅助排序的含义，外部排序常用的排序算法是<strong>多路归并排序算法</strong>，具体步骤如下：</p><ul><li>到主键 id 索引树上查找到对应的整行数据后，取 city、username、age 三个字段的值，存入 sort_buffer 中，能存多少是多少，当 sort_buffer 快要满时，就对 sort_buffer 中的<strong>数据进行排序</strong>，排完后，把数据<strong>临时放到磁盘的一个小文件</strong>中，然后<strong>清空 sort_buffer</strong>（这样的话，一个很大的数据，就会被分成若干个临时磁盘文件）</li><li>继续回到主键 id 索引树取数据，重复上一步，直到取出所有满足条件的数据</li><li>最后，<strong>归并已经有序的若干个临时磁盘文件</strong>，形成一个完整的有序大文件</li></ul><p>可以看出，整个排序过程，我们要查询的 city、username、age 全都参与了，所以，暂且把这个排序过程，称为<strong>全字段排序</strong></p><p><strong>routId 排序</strong><br>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。但这个算法有一个问题，如果查询返回的数据字段多，那么内存中放的数据就要分成多个临时文件，排序的性能就会很差。</p><p>修改参数 max_length_for_sort_data,是MySql中专门控制用于排序的行数据的长度的一个参数，它的意思是，如果单行的长度超过这个值 ，MySQL就认为单行太大，要换一个算法。</p><p><img src="/./../../imgs/MySQL/2019050521265030.png" alt="在这里插入图片描述"></p><p>city,name,age这三个字段的定义总长度是36，我把max_length_for_sort_data设置为16，那么放入sort_buffer的字段只有要排序的列(即 name 字段 是order by 后面的关键字)和主键id。<br>但这时，排序的结果就因为少了city和age字段的值 ，不能直接返回了，整个执行的流程就变成 如下所示的样子:</p><ol><li><p>初始化sort_buffer，确定放入两个字段，即name和id;</p></li><li><p>从索引city找到第一个满足city&#x3D;’上海’条件的主键,也就是图中的ID_X;</p></li><li><p>到主键id索引取出整行，取name、id这两个字段，存入sort_buffer中;</p></li><li><p>从索引city取下一个记录的主键id;</p></li><li><p>重复3、4步骤，直到找到不city!&#x3D;‘杭州’;</p></li><li><p>对sort_buffer中的数据按照name进行排序;</p></li><li><p>遍历排序结果，取前1000行，并按照id的值回到原表中的city、name和age三个字段返回给客户端。</p></li></ol><p><img src="/./../../imgs/MySQL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyOTYxNjU=,size_16,color_FFFFFF,t_70-1711682407937-13.png" alt="在这里插入图片描述"></p><h6 id="对排序进行优化"><a href="#对排序进行优化" class="headerlink" title="对排序进行优化"></a>对排序进行优化</h6><p>很显然，如果不排序就能得到正确的结果，那对系统的消耗会小很多，语句的执行时间也会变得更短。</p><p>从上面分析的执行过程我们可以看到，MySQL 之所以需要 sort_buffer，并且在 sort_buffer 上做排序操作，其原因是原来的数据都是无序的。</p><p>回顾下我们的需求：查询出 city 是 “杭州” 的所有 username，并且按照 username 进行排序，返回前 1000 个人的姓名、年龄。</p><p>那，<strong>如果能够保证从 city 这个索引上取出来的数据行，已经天然就是按照 username 进行递增排序的话，不就不用再排序了吗</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> index_city(city,name);</span><br></pre></td></tr></table></figure><p>这样数据的索引就有按照name进行排序。 这样整个排序过程就变成了下面这样。</p><ul><li><p>从索引(city,name)找到第一个满足city&#x3D;”杭州”条件的主键id;</p></li><li><p><font color = "gold">到主键id索引查找整行数据(回表查询),取name、city、age三个字段的值，作为结果集的一部分直接返回,因为索引中name就已经是有序的了，不需要在内存中继续排序。</font></p></li><li><p>从联合索引取出一个记录主键 id；</p></li><li><p>重复2、3步。</p><p><img src="/./../../imgs/MySQL/640.webp" alt="图片"></p></li></ul><p><img src="/./../../imgs/MySQL/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyOTYxNjU=,size_16,color_FFFFFF,t_70-1711682434446-16.png" alt="在这里插入图片描述"></p><p>在使用explain 来分析这个sql</p><p><img src="/./../../imgs/MySQL/20190506211600249.png" alt="在这里插入图片描述"></p><p>可以看到extra字段中没有Using filesort了，也就是不需要排序了。<br>由于覆盖索引的原则，我们可以再进行优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> index_city(city,name,age);</span><br></pre></td></tr></table></figure><p>1）从联合索引 (city, username, age) 树上找到第一个满足 city&#x3D;’杭州’ 条件的记录，把这条记录作为结果集的一部分直接返回；</p><p>2）从联合索引 (city, username, age) 树上取下一个记录，同样将这条记录作为结果集的一部分直接返回</p><p>3）重复执行步骤 2，直到查到第 1000 条记录，或者是不满足 city&#x3D;’南京’ 条件时循环结束</p><p>如下图所示：</p><p><img src="/./../../imgs/MySQL/640-1713193542850-3.webp" alt="图片"></p><p>在使用explain 对sql进行分析</p><p><img src="/./../../imgs/MySQL/20190506211915927.png" alt="在这里插入图片描述"></p><p>发现使用Using index，表示的就是使用了覆盖索引，性能上会快很多。</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li><li>尽量使用覆盖索引，避免fileSort。</li><li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）。</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。</li></ul><ol><li>order by 的基本原理其实就是 MySQL 会给每个线程分配一块内存也就是 sort_buffer 用于排序，sort_buffer 中存储的是 select 涉及到的所有的字段，可以称为全字段排序吧。排序这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和 sort_buffer 的大小，由参数 <code>sort_buffer_size</code> 决定。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，就需要利用磁盘临时文件来辅助排序,临时文件存放的是每一次sort后的有序的部分结果,需要将各个磁盘临时文件归并排序来构成完整的结果集。</li><li>这里其实可以优化下，<strong>只存放排序相关的字段</strong>(包括查询字段和主键id,其中主键id用于回表查询)，而不是 select 涉及的所有字段，这样 sort_buffer 中存放的东西就多一点，就尽可能避免使用磁盘进行外部排序，或者说使得划分的磁盘文件相对变少，减少磁盘访问。这种排序称为 rowid 排序。如果表中单行的长度超过 <code>max_length_for_sort_data</code> 定义的值，那 MySQL 就认为单行太大（那么数据量肯定就越大，sort_buffer 可能不够用），由全字段排序改为 rowid 排序, 再排序结束后再根据id会表查询。</li></ol><p>以上是我们说的关于 order by 的两个参数优化，还可以根据索引进行一些优化</p><ol><li>以 <code>select a, b, c from table where a = xxxx order by b</code> 为例，我们为查询条件 a 和排序条件 b 建立联合索引，联合索引就是 a 是从小到大绝对有序的，如果 a 相同，再按 b 从小到大排序，这样就不需要排序了，直接避免了排序这个操作。</li><li>还可以进一步优化，由于联合索引 (a, b) 中没有 c 的值，所以从联合索引树上获取符合条件的对应主键 id 后，还需要回表查询取出 a b c 的值，这个回表查询的过程可以通过建立 (a,b,c) 覆盖索引来避免。</li></ol><h4 id="SQL优化（技巧）"><a href="#SQL优化（技巧）" class="headerlink" title="SQL优化（技巧）"></a>SQL优化（技巧）</h4><h5 id="使用update更新一个大表，怎么优化"><a href="#使用update更新一个大表，怎么优化" class="headerlink" title="使用update更新一个大表，怎么优化"></a>使用update更新一个大表，怎么优化</h5><ol><li>批量更新，而不是一条一条更新</li><li>在分组、排序之前就过滤，过滤优先于一切</li><li>同时过滤、排序条件的列尽量走索引，过滤走索引才能使用行锁，否则会升级为表锁</li><li>尽量走主键索引，联合索引避免回表查询</li><li>分区表：如果可能的话，考虑将大表分成更小的分区表。这样可以将更新操作限制在特定分区内，减少锁定冲突的机会。</li></ol><h5 id="SQL优化，使用索引的时候怎么优化"><a href="#SQL优化，使用索引的时候怎么优化" class="headerlink" title="SQL优化，使用索引的时候怎么优化"></a>SQL优化，使用索引的时候怎么优化</h5><ol><li><p>避免索引失效：</p><ul><li><p>模糊查询 %放在右边<br>原理：模糊查询的时候尽量在字段后面使用模糊查询最左原则</p></li><li><p>避免使用or</p></li><li><p>在where条件中，等式左侧不要进行表带式、函数操作。</p></li><li><p>查询条件不要用 &lt;&gt; 或者 !&#x3D;</p></li><li><p>使用联合索引要符合最左匹配原则</p></li><li><p>避免出现select *</p></li></ul></li><li><p>优先过滤，尽量避免分组后再过滤</p></li><li><p>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p></li><li><p>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p></li></ol><h4 id="慢sql怎么看-怎么解决"><a href="#慢sql怎么看-怎么解决" class="headerlink" title="慢sql怎么看 怎么解决"></a>慢sql怎么看 怎么解决</h4><h5 id="慢查询日志："><a href="#慢查询日志：" class="headerlink" title="慢查询日志："></a>慢查询日志：</h5><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。如果要开启慢查询日志，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 开启MySQL慢日志查询开关`</span><br><span class="line">slow_query_log<span class="operator">=</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line">#设置慢日志的时间为<span class="number">2</span>秒，<span class="keyword">SQL</span>语句执行时间超过<span class="number">2</span>秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#重启mysql服务</span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>检查慢查询日志 ：在慢查询日志中，只会记录执行时间超多我们预设时间（2s）的SQL，执行较快的SQL是不会记录的。</p><p>那这样，通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化</p><h5 id="profile详情"><a href="#profile详情" class="headerlink" title="profile详情"></a>profile详情</h5><p>可以查看执行时间较长的sql，并且了解时间耗费在哪个步骤</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询数据库是否支持profile</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@have_profiling</span>;</span><br><span class="line"><span class="comment">-- 开启profile的开关</span></span><br><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 查看每一条sql的执行情况</span></span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"><span class="comment">-- 查询指定query_id在sql的各个阶段的耗时</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure><p><strong>用explain分析sql</strong></p><p>[explain有哪些字段，分别有什么含义_explain字段含义-CSDN博客](<a href="https://blog.csdn.net/weixin_50998273/article/details/111938295#:~:text=explain%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89">https://blog.csdn.net/weixin_50998273/article/details/111938295#:~:text=explain有哪些字段，分别有什么含义</a> 1 1. id SQL查询中的序列号。 id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行。 2 2.,查询真正使用到的索引。 … 8 8. key_len 查询用到的索引长度（字节数）。 … 更多项目)</p><p>explain命令可以查看select语句的执行计划，包括表连接顺序以及索引使用情况等等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select_sql;</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/MySQL/explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png" alt="sql的执行计划"></p><ul><li><p>id：指代sql语句中的执行顺序。多表查询中，id相同，执行顺序从上到下，id不同，id值越大越先执行</p></li><li><p>select_type:表示查询类型，常见取值有SIMPLE(简单表，即单表查询)，PRIMARY(子查询中的外层查询)等</p></li><li><p>type：表示查询的连接类型，由好到差依次是<strong>null &gt; system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</strong>。</p><ul><li>system,访问系统表</li><li>const，使用<strong>唯一索引</strong>或者<strong>主键索引</strong>，单表中<strong>最多有一条匹配行</strong>。select * from student where id &#x3D; 1;</li><li>eq_ref ,主键或者唯一索引被连接使用，最多只会返回一个值，常出现在多表查询中。从一个表中查出另一个表的主键然后在另一个表中进行查询。</li><li>ref，使用<strong>普通索引</strong>或者<strong>唯一性索引的部分前缀</strong>，有可能会<strong>返回多条值</strong></li><li>range，使用索引选择行，仅检索给定范围内的行，范围查询。</li><li>index，扫描<strong>全表索引</strong>，比all要快一些</li><li>all，<strong>全表扫描</strong>，效果最差</li></ul></li><li><p>possible_key：查询语句可能用到的索引</p></li><li><p>key：实际使用的索引，如果为NULL则说明没有使用索引</p></li><li><p>key_len：索引使用的字节数，这个值越短越好</p></li><li><p>row：MySQL认为可能扫描的行数，是一个估计值，这个值越小越好</p></li><li><p>filtered：表示返回结果的行数占读取行数的百分比，filtered值越大越好</p></li></ul><p>解决：</p><ol><li>SQL语句优化，尽量精简，去除非必要语句</li><li>索引优化，让所有SQL都能够走索引</li><li>如果是表的瓶颈问题，则分表，单表数据量维持在2000W（理论上）以内</li><li>如果是单库瓶颈问题，则分库，读写分离</li><li>如果是物理机器性能问题，则分多个数据库节点</li></ol><p>第 1 个原因：没有索引或者 导致索引失效。<br>第 2 个原因：单表数据量数据过多，导致查询瓶颈<br>第 3 个原因：网络原因或者机器负载过高。<br>第 4 个原因：热点数据导致单点负载不均衡。</p><p>第 1 种情况：索引失效或者没有没有索引的情况<br>首先，可以打开 MySQL 的慢查询日志，收集一段时间的慢查询日志内容，然后找出耗时最长的 SQL 语句，对这些 SQL 语句进行分析。<br>比如可以利用执行计划 explain 去查看 SQL 是否有命中索引。如果发现慢查询的 SQL 没有命中索引，可以尝试去优化这些 SQL 语句，保证 SQL 走索引执行。如果 SQL 结构没有办法优化的话，可以考虑在表上再添加对应的索引。我们在优化 SQL 或者是添加索引的时候，都需要符合最左匹配原则。</p><p>第 2 种情况：单表数据量数据过多，导致查询瓶颈的情况。即使 SQL 语句走了索引，表现性能也不会特别好。这个时候我们需要考虑对表进行切分。表切分规则一般分为两种，一种是水平切分，一种是垂直切分。水平切分的意思是把一张数据行数达到千万级别的大表，按照业务主键切分为多张小表，这些小表可能达到 100 张甚至 1000 张。</p><p><img src="/./../../imgs/MySQL/image-20240318112030315.png" alt="image-20240318112030315"></p><p>那垂直切分的意思是，将一张单表中的多个列，按照业务逻辑把关联性比较大的列放到同一张表中去。</p><p><img src="/./../../imgs/MySQL/image-20240318112110577.png" alt="image-20240318112110577"></p><p>除了这种分表之外，我们还可以分库，</p><p><img src="/./../../imgs/MySQL/image-20240318112121184.png" alt="image-20240318112121184"></p><p>比如我们已经拆分完 1000 表，然后，把后缀为 0-100 的表放到同一个数据库实例中，然后，100-200 的表放到另一个数据库实例中，依此类推把 1000 表存放到 10 个数据库实例中。这样的话，我们就可以根据业务主键把请求路由到不同数据库实例，从而让每一个数据库实例承担的流量比较小，达到提高数据库性能的目的。</p><p>第 3 种情况：网络原因或者机器负载过高的情况，我们可以进行读写分离.</p><p><img src="/./../../imgs/MySQL/image-20240318112139782.png" alt="image-20240318112139782"></p><p>比如 MySQL 支持一主多从的分布式部署，我们可以将主库只用来处理写数据的操作，而多个从库只用来处理读操作。在流量比较大的场景中，可以增加从库来提高数据库的负载能力，从而提升数据的总体性能。</p><p>第 4 种情况：热点数据导致单点负载不均衡的情况。</p><p><img src="/./../../imgs/MySQL/image-20240318112149545.png" alt="image-20240318112149545"></p><p>这种情况下，除了对数据库本身的调整以外，还可以增加缓存。将查询比较频繁的热点数据预存到缓存当<br>中，比如 Redis、MongoDB、ES 等，以此来缓解数据的压力，从而提高数据库的响应速度。</p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><h4 id="binlog刷盘策略"><a href="#binlog刷盘策略" class="headerlink" title="binlog刷盘策略"></a>binlog刷盘策略</h4><p>mysql只有在事务提交的时候才会记录binlog日志，此时日志还在内存中，那binlog是什么时候被刷到磁盘中的呢？<br>mysql通过sync_binlog控制刷盘，取值范围0~N</p><ul><li>0：不强制要求刷盘，由系统自行判断什么时候将binlog写入磁盘；</li><li>1：每次提交事务就将binlog写入磁盘；</li><li>n：每提交n个事务将binlog写入磁盘；</li></ul><p>显然，sync_binlog为1是最安全的，每次提交事务就将binlog写入磁盘，数据一致性最好。但实际情况中，往往为了提高数据库的性能，会将sync_binlog适当设大，来减少磁盘IO次数，用数据一致性换性能。<br>在对数据库一致性要求不高或数据没那么重要的业务场景，完全可以把sync_binlog设置在100~1000范围内的某个值，以此来提高数据库的性能。而在对数据一致性要求高的业务场景或特别重要的数据，比如订单则建议将sync_binlog的值设置为1，这样可以保证哪怕数据库挂了也不会丢失数据。<br>sync_binlog的默认值是0，这时由系统会自行判断将binlog写入磁盘的时机。数据库可能会在空闲的时候综合考虑缓存的binlog日志大小来决定是否要将binlog写入磁盘。</p><h5 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h5><blockquote><p>由于每一个binlog与事务相关，随事务的提交而提交，所以每一个事务都有一个binlog cache，如果存储内容超过了这个参数，就要暂存到磁盘，待事务提交后一次性写入文件系统的 page cache，而sync_binlog&#x3D;n这个参数表示文件系统积累多少个事务的binlog后一次性刷盘到磁盘，安全性和一致性要求比较高的场景这个值设置为1，磁盘IO压力比较大的情况下可以增大。</p></blockquote><h4 id="binlog组提交"><a href="#binlog组提交" class="headerlink" title="binlog组提交"></a>binlog组提交</h4><p>MySQL引入binlog来实现主从实例之间的数据同步，提高数据库系统的可用性，但同时也增加了事务整体的资源消耗，需要额外的磁盘空间和IO处理能力。尤其是为了保证本地事务的持久性，必须将binlog刷盘控制参数sync_binlog设置为1，设想如果每一次事务提交，都强制进行一次刷盘操作，数据库整体的性能会受到极大的影响。<br>MySQL引入组提交的目的是为了在高并发下合并多个线程的刷盘操作，降低日志刷盘次数，提高数据库的整体性能</p><h4 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog 归档日志"></a>binlog 归档日志</h4><p>binlog是Server层的日志，binlog的主要作用是归档，即可以把数据库恢复到之前一段时间内的任意一天的状态。</p><p>binlog会记录MySQL执行的SQL原始语句，具体流程就是，当MySQL执行一条update语句时，流程如下：</p><ol><li>更新缓存中的对应行，如果缓存中不存在则从数据库中读入内存然后更新。</li><li>将数据页变化写入redo log，此时处于prepare的状态。</li><li>事务提交前，将执行的sql语句写入binlog</li><li>提交事务，redo log处于commit状态</li></ol><p>sync_binlog&#x3D;1时，每次事务的binlog都会持久化到磁盘，建议设置为1.</p><h5 id="binlog-实现-数据库恢复的原理"><a href="#binlog-实现-数据库恢复的原理" class="headerlink" title="binlog 实现 数据库恢复的原理"></a>binlog 实现 数据库恢复的原理</h5><p>数据库一般隔一段时间比如三天或者五天或者七天会做整库备份，而binlog则会保留一段时间的所有sql语句的逻辑操作。所以进行整库备份的流程：</p><ol><li>找到上一次的全量备份的文件，将这个备份恢复到数据库，同时记录备份时间a</li><li>如果想要恢复到时间点b的状态，则将binlog中a和b之间的逻辑操作全部取出来依次执行</li></ol><h5 id="binlog和redo-log的区别"><a href="#binlog和redo-log的区别" class="headerlink" title="binlog和redo log的区别"></a>binlog和redo log的区别</h5><p>binlog用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。binlog是mysql的逻辑日志，并且由Server层进行记录，使用任何存储引擎的mysql数据库都会记录binlog日志。</p><table><thead><tr><th>binlog</th><th>① Server层 ② 逻辑日志，记录原始逻辑 （命令）③ 循环写，空间固定④主从复制，数据恢复</th></tr></thead><tbody><tr><td>redo log</td><td>①引擎层，InnoDB独有 ②物理日志，记录数据页变化 ③追加写，不会覆盖④故障恢复</td></tr></tbody></table><h4 id="讲一讲mysql主从部署"><a href="#讲一讲mysql主从部署" class="headerlink" title="讲一讲mysql主从部署"></a>讲一讲mysql主从部署</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p><p>MySQL 复制的优点主要包含以下三个方面：</p><ul><li>主库出现问题，可以快速切换到从库提供服务。</li><li>实现读写分离，降低主库的访问压力。</li><li>可以在从库中执行备份，以避免备份期间影响主库服务。</li></ul><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>MySQL主从复制的核心就是 二进制日志，具体的过程如下：</p><p><img src="/./../../imgs/MySQL/image-20231003112012277.png" alt="image-20231003112012277"></p><p>从上图来看，复制分成三步：</p><ol><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li><li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ol><h5 id="主从复制的问题？"><a href="#主从复制的问题？" class="headerlink" title="主从复制的问题？"></a>主从复制的问题？</h5><ol><li>同步延迟：由于主从复制是异步执行的，从服务器需要等待主服务器将数据操作记录到二进制日志（BinLog）并传输到从服务器后才能执行。这可能导致从服务器的数据与主服务器存在一定的时间差，从而引起同步延迟。而且从服务器上只有一个 SQL Thread，当主服务器有大量写操作时，复制延时也可能会增大。</li><li>数据一致性：在主从复制过程中，如果主服务器发生故障或网络中断，从服务器可能会丢失部分尚未复制的数据。</li></ol><ul><li><strong>半同步复制</strong>—解决数据丢失的问题</li><li><strong>并行复制</strong>—-解决从库复制延迟的问题</li></ul><p>半同步复制（5.5集成到mysql，以插件的形式存在，需要单独安装）</p><ul><li>该模式下 MySQL 主节点在发送完 BinLog 后不会立刻提交数据，而是至少等待一个从服务器写完 RelayLog 并返回 ACK 消息后，才提交事务</li><li>确保事务提交后binlog至少传输到一个从库</li><li>不保证从库应用完成这个事务的binlog</li><li>性能有一定的降低</li></ul><p><img src="/./../../imgs/MySQL/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd2jmn5LlhavkuZ0=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><p><strong>并行复制</strong></p><p>单线程的 SQL Thread Relay 操作在 Master 的 TPS 比较高的情况下，会出现严重的性能瓶颈，进而导致主从同步延迟。</p><p>MySQL 为了解决这个问题，将 SQL Thread 演化成了多个 Worker 的形式，在 Slave 端并行应用 Relay Log 中的事务，从而提升 Relay Log 的应用速度，降低复制延迟</p><p><img src="/./../../imgs/MySQL/curr-relay.webp" alt="relay worker"></p><ul><li>并行是指从库多线程并行应用binlog，同一个库数据更改还是串行的</li></ul><h5 id="搭建主从环境："><a href="#搭建主从环境：" class="headerlink" title="搭建主从环境："></a>搭建主从环境：</h5><p>配置主库，修改配置文件 &#x2F;etc&#x2F;my.cnf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 232-1，默认为1</span><br><span class="line">server-id=1</span><br><span class="line">#是否只读,1 代表只读, 0 代表读写</span><br><span class="line">read-only=0</span><br></pre></td></tr></table></figure><p>重启MySQL服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld </span><br></pre></td></tr></table></figure><p>登录mysql，创建远程连接的账号，并授予主从复制权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#创建itcast用户，并设置密码，该用户可在任意主机连接该MySQL服务</span><br><span class="line">CREATE USER &#x27;itcast&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;Root@123456&#x27;</span><br><span class="line">;</span><br><span class="line">#为 &#x27;itcast&#x27;@&#x27;%&#x27; 用户分配主从复制权限</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;itcast&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>通过指令，查看二进制日志坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status ;</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/MySQL/image-20231003112018880.png" alt="image-20231003112018880"></p><p>字段含义说明：<br>file : 从哪个日志文件开始推送日志文件<br>position ： 从哪个位置开始推送日志<br>binlog_ignore_db : 指定不需要同步的数据库</p><h5 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h5><p>修改配置文件 &#x2F;etc&#x2F;my.cnf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，和主库不一样即可</span><br><span class="line">server-id=2</span><br><span class="line">#是否只读,1 代表只读, 0 代表读写</span><br><span class="line">read-only=1</span><br></pre></td></tr></table></figure><p>重新启动MySQL服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>登录mysql，设置主库配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CHANGE REPLICATION SOURCE TO SOURCE_HOST=&#x27;192.168.200.200&#x27;, SOURCE_USER=&#x27;itcast&#x27;,</span><br><span class="line">SOURCE_PASSWORD=&#x27;Root@123456&#x27;, SOURCE_LOG_FILE=&#x27;binlog.000004&#x27;,</span><br><span class="line">SOURCE_LOG_POS=663;</span><br><span class="line">或者</span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.200.200&#x27;, MASTER_USER=&#x27;itcast&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;Root@123456&#x27;, MASTER_LOG_FILE=&#x27;binlog.000004&#x27;,</span><br><span class="line">MASTER_LOG_POS=663;</span><br></pre></td></tr></table></figure><p>开启同步操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start replica ; #8.0.22之后</span><br><span class="line">start slave ; #8.0.22之前</span><br></pre></td></tr></table></figure><p>查看主从同步状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show replica status ; #8.0.22之后</span><br><span class="line">show slave status ; #8.0.22之前</span><br></pre></td></tr></table></figure><p><img src="/./../../imgs/MySQL/image-20231003112023725.png" alt="image-20231003112023725"></p><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><p>分库分表的原因：</p><ul><li>当某一个数据库被访问得特别频繁时，有可能会占用绝大部分的服务器磁盘IO和网络IO，影响同一台服务器上的其他数据，此时可以将数据库进行拆分，将一台服务器上的数据库拆分到多台服务器上。</li><li>当表的数据量特别大或者表中的字段很多时，可以将字段进行拆分或者分散到多张表中，提高查询效率以及更新效率。</li></ul><h5 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h5><p>垂直拆分</p><p>垂直分库：以表为依据，将不同业务的表拆分到不同的数据库中。</p><p><img src="/./../../imgs/MySQL/image-20240318140611487.png" alt="image-20240318140611487"></p><ul><li>每个库的表结构都不一样。</li><li>每个库的数据也不一样。</li><li>所有库的并集是全量数据。</li></ul><p>垂直分表：以字段为依据，将一张表中的字段进行分类拆分到不同的表中。不同表可以通过外键进行关联</p><p><img src="/./../../imgs/MySQL/image-20240318140637932.png" alt="image-20240318140637932"></p><ul><li>每个表的结构都不一样。</li><li>每个表的数据也不一样，一般通过一列（主键&#x2F;外键）关联。</li><li>所有表的并集是全量数据。</li></ul><p>水平拆分</p><ul><li>水平分库，将数据库中的表复制到多个服务器数据库中，每个数据库中的表结构都是一样的，各自存储一部分的数据。</li></ul><p><img src="/./../../imgs/MySQL/image-20240318141105540.png" alt="image-20240318141105540"></p><ul><li>每个库的表结构都一样。</li><li>每个库的数据都不一样。</li><li>所有库的并集是全量数据。</li></ul><ul><li>水平分表：将一张表拆分成多个结构相同的表，每个表中保存一部分数据。</li></ul><p><img src="/./../../imgs/MySQL/image-20240318141154799.png" alt="image-20240318141154799"></p><ul><li>每个表的表结构都一样。</li><li>每个表的数据都不一样。</li><li>所有表的并集是全量数据</li></ul><h5 id="分片规则"><a href="#分片规则" class="headerlink" title="分片规则"></a>分片规则</h5><p>范围分片：根据指定的字段及其配置的范围与数据节点的对应情况， 来决定该数据属于哪一个分片。</p><p><img src="/./../../imgs/MySQL/image-20240318144804381.png" alt="image-20240318144804381"></p><p>取模分片：指定的字段值与节点数量进行求模运算，根据运算结果， 来决定该数据属于哪一个分片</p><p><img src="/./../../imgs/MySQL/image-20240318144846254.png" alt="image-20240318144846254"></p><p>哈希切片：对数据库的某个字段进行来求哈希，再除以分片总数后取模，取模后相同的数据为一个分片，这样将数据分成多个分片的方法叫做哈希分片，我们大多数在数据没有时效性的情况下使用哈希分片，就是数据不管是什么时候产生的，系统都需要处理或者查询；复制table_index &#x3D; hash(order_id) % tables_num</p><ul><li>优点：负载均衡，每个表的数据分布相对均匀。</li><li>缺点：不利于二次扩容。</li></ul><p><img src="/./../../imgs/MySQL/image-20240318145159998.png" alt="image-20240318145159998"></p><p>时间切片：按照时间的范围将数据分布到不同的分片上，比如我们可以将交易数据按照与进行切片，或者按照季度进行切片，由交易数据的多少来决定按照什么样的时间周期来进行切片</p><p>这种切片方式适合明显时间特点的数据，常见的就是订单历史查询</p><p><img src="/./../../imgs/MySQL/image-20240318145310059.png" alt="image-20240318145310059"></p><ul><li><p>一致性hash：计算指定字段的hash值，然后根据hash值不同将数据存储在对应节点。而一致性的意思是即使以后增加节点，原来的数据依然会划分到原来的节点，不会因为节点的增加而发生改变，有效的解决了分布式数据的拓容问题。</p><p><img src="/./../../imgs/MySQL/image-20240318145000616.png" alt="image-20240318145000616"></p></li><li><p>枚举分片：枚举指定字段的值来决定数据会被分配到哪个节点。适用于按照省份，状态，性别等进行分片的场景</p><p><img src="/./../../imgs/MySQL/image-20240318145038787.png" alt="image-20240318145038787"></p></li><li><p>应用指定：根据数据的某个字段的一部分（必须是数字）来直接决定数据存储在哪个节点。如01_xx,02_xx,03_xx</p><p><img src="/./../../imgs/MySQL/image-20240318145106020.png" alt="image-20240318145106020"></p></li></ul><h4 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h4><h5 id="普通-hash-算法的缺陷："><a href="#普通-hash-算法的缺陷：" class="headerlink" title="普通 hash 算法的缺陷："></a>普通 hash 算法的缺陷：</h5><p><strong>hash（key）% N</strong></p><p>​        如果增加或者删除服务器节点，那么n的数量就会改变，所有缓存的位置都要发生改变，也就是说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据。</p><ul><li><p>一致性哈希算法将整个哈希值空间按照顺时针方向组织成一个虚拟的圆环，称为 Hash 环；</p></li><li><p>接着将各个服务器使用 Hash 函数进行哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，从而确定每台机器在哈希环上的位置</p></li><li><p>最后使用算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针寻找，第一台遇到的服务器就是其应该定位到的服务器</p></li></ul><p>哈希环的组织：</p><p>​    我们将 2^32 想象成一个圆，像钟表一样，钟表的圆可以理解成由60个点组成的圆，而此处我们把这个圆想象成由2^32个点组成的圆，示意图如下：</p><p><img src="/./../../imgs/MySQL/1dabc6d21275466885e876058dd81d7a.png" alt="img"></p><p>​    圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第一个点代表2^32-1，我们把这个由 2^32 个点组成的圆环称为hash环。</p><p>（2）步骤二：确定服务器在哈希环的位置：</p><p>哈希算法：hash（服务器的IP） % 2^32</p><p>​    上述公式的计算结果一定是 0 到 2^32-1 之间的整数，那么上图中的 hash 环上必定有一个点与这个整数对应，所以我们可以使用这个整数代表服务器，也就是服务器就可以映射到这个环上，假设我们有 ABC 三台服务器，那么它们在哈希环上的示意图如下：</p><p><img src="/./../../imgs/MySQL/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_14,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p> （3）步骤三：将数据映射到哈希环上：</p><p>​    我们还是使用图片的名称作为 key，所以我们使用下面算法将图片映射在哈希环上：hash（图片名称） % 2^32，假设我们有4张图片，映射后的示意图如下，其中橘黄色的点表示图片：</p><p><img src="/./../../imgs/MySQL/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>​    那么，怎么算出上图中的图片应该被缓存到哪一台服务上面呢？我们只要从图片的位置开始，沿顺时针方向遇到的第一个服务器就是图片存放的服务器了。最终，1号、2号图片将会被缓存到服务器A上，3号图片将会被缓存到服务器B上，4号图片将会被缓存到服务器C上。</p><p>一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，只有部分缓存会失效，不至于将所有压力都在同一时间集中到后端服务器上，具有较好的容错性和可扩展性。</p><p>​    假设服务器B出现了故障，需要将服务器B移除，那么移除前后的示意图如下图所示：</p><p><img src="/./../../imgs/MySQL/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>hash 环的倾斜与虚拟节点：<br>        一致性哈希算法在服务节点太少的情况下，容易因为节点分部不均匀而造成数据倾斜问题，也就是被缓存的对象大部分集中缓存在某一台服务器上，从而出现数据分布不均匀的情况，这种情况就称为 hash 环的倾斜。如下图所示：</p><p><img src="/./../../imgs/MySQL/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_20,color_FFFFFF,t_70,g_se,x_16-1712633028188-13.png" alt="img"></p><p>​     hash 环的倾斜在极端情况下，仍然有可能引起系统的崩溃，为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对<strong>每一个服务节点计算多个哈希</strong>，每个<strong>计算结果位置都放置一个此服务节点，称为虚拟节点</strong>，一个实际物理节点可以对应多个虚拟节点，虚拟节点越多，hash环上的<strong>节点就越多</strong>，缓存被均匀分布的概率就越大，hash环倾斜所带来的影响就越小，同时数据定位算法不变，只是多了一步<strong>虚拟节点到实际节点的映射</strong>。<strong>具体做法可以在服务器ip或主机名的后面增加编号来实现</strong>，加入虚拟节点以后的hash环如下：</p><p><img src="/./../../imgs/MySQL/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg57u06bmP,size_15,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><ul><li><strong>节点数量多了后，节点在哈希环上的分布就相对均匀了</strong>。这时候，如果有访问请求寻址到「A-01」这个虚拟节点，接着再通过「A-01」虚拟节点找到真实节点 A，这样请求就能访问到真实节点 A 了。</li><li>虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。<strong>当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高</strong>。</li><li>有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如对权重更高的节点增加更多的虚拟机节点即可。</li></ul><h4 id="假设有一个用户表，你用ID做的分片键，那么有一个类似于name这样的字段如何查询？"><a href="#假设有一个用户表，你用ID做的分片键，那么有一个类似于name这样的字段如何查询？" class="headerlink" title="假设有一个用户表，你用ID做的分片键，那么有一个类似于name这样的字段如何查询？"></a>假设有一个用户表，你用ID做的分片键，那么有一个类似于name这样的字段如何查询？</h4><p>这里提供几种常见的思路：</p><h5 id="全局索引"><a href="#全局索引" class="headerlink" title="全局索引"></a>全局索引</h5><p>全局索引是一个跨所有分片的索引，它包含了非分片键字段和对应的分片键信息。查询时，先通过全局索引找到相关的分片键，然后在相应的分片中查询详细数据。</p><p>适用场景：适用于查询频率高、数据量大的非分片键字段。</p><p>优点：查询效率高，可以快速定位到数据所在的分片。</p><p>缺点：全局索引维护成本较高，需要定期更新以保持与分片数据的一致性。</p><h5 id="2-数据冗余"><a href="#2-数据冗余" class="headerlink" title="2. 数据冗余"></a>2. 数据冗余</h5><p>在每个分片中存储部分非分片键字段的数据。这样，即使不直接查询分片键，也可以在分片内快速找到相关数据。</p><p>适用场景：适用于查询性能要求极高，且可以接受一定数据冗余的场景。</p><p>优点：查询性能高，无需跨分片查询。</p><p>缺点：数据冗余增加了存储成本和维护复杂性。</p><h5 id="3-应用层处理"><a href="#3-应用层处理" class="headerlink" title="3. 应用层处理"></a>3. 应用层处理</h5><p>在应用层实现复杂的查询逻辑，将多个分片中的查询结果汇总后进行处理。</p><p>适用场景：适用于查询频率不高，或者可以接受一定延迟的场景。</p><p>优点：灵活性高，可以根据业务需求定制查询逻辑。</p><p>缺点：查询性能可能受到网络延迟和分片数量的影响。</p><h5 id="4-使用Elasticsearch（ES）"><a href="#4-使用Elasticsearch（ES）" class="headerlink" title="4. 使用Elasticsearch（ES）"></a>4. 使用Elasticsearch（ES）</h5><p>将非分片键字段的数据同步到Elasticsearch中，利用Elasticsearch强大的搜索和查询能力进行查询。</p><p>适用场景：适用于非结构化数据、全文搜索、复杂查询等场景。</p><p>优点：支持复杂的查询操作，如全文搜索、模糊匹配等；查询性能高，支持分布式部署。</p><p>缺点：需要维护Elasticsearch集群，增加了系统的复杂性；数据同步可能引入一定的延迟。</p><h5 id="5-数据库中间件"><a href="#5-数据库中间件" class="headerlink" title="5. 数据库中间件"></a>5. 数据库中间件</h5><p>使用数据库中间件（如ShardingSphere、MyCAT等）来管理分库分表，中间件可以自动处理非分片键字段的查询，将请求路由到正确的分片。</p><p>适用场景：适用于希望减少应用层复杂性的场景。</p><p>优点：简化了应用层的查询逻辑，减少了开发和维护的工作量。</p><p>缺点：需要配置和维护数据库中间件。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2024/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>进程作为资源分配的基本单位,线程作为调度的基本单位。</p><ul><li>进程可看做是正在执行的程序,每个进程都有独立的代码和数据空间，所以进程间的切换会有较大的开销。一个进程在其执行的过程中可以产生多个线程。</li><li><strong>线程是进程当中的一条执行流程。</strong>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器（</strong>线程切换后能恢复到正确的执行位置<strong>）</strong>、<strong>虚拟机栈（</strong>保证线程中的局部变量不被别的线程访问到<strong>）</strong>和<strong>本地方法栈</strong>（包含局部变量，本地方法），在所以系统在产生一个线程要分配的资源更少，或是在各个线程之间作切换工作时，只需要保存栈和寄存器等不共享的数据，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul><p>线程相比进程能减少开销，体现在：</p><ul><li>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li><li>线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</li><li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li><li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</li></ul><p>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响,因为它们共享了堆和方法区资源。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231016143302701.png" alt="image-20231016143302701"></p><ul><li>堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存</li><li>方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li></ul><h4 id="有了进程为什么还需要线程"><a href="#有了进程为什么还需要线程" class="headerlink" title="有了进程为什么还需要线程?"></a>有了进程为什么还需要线程?</h4><ul><li>进程切换是一个开销很大的操作，线程切换的成本较低。</li><li>线程更轻量，一个进程可以创建多个线程。</li><li>多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。</li><li>同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。</li></ul><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p><strong>协程，又称用户态线程，因为创建一个线程需要调用操作系统的功能（系统调用）, 而创建一个线程则只需要在用户态下完成，一个线程可以有多个协程。</strong></p><p>协程抽象于线程之上，线程是被分割的CPU资源, 协程是组织好的代码流程，可以看作是一种特殊的函数，这个函数可以在某个地方挂起，又可以重新在挂起出继续运行，<strong>协程的调度完全由用户程序控制（也就是在用户态执行）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销。</strong></p><p>协程与线程不同：同一个线程下协程只有并发没有并行，多个协程可以并发地执行任务，在发生IO阻塞地时候就挂起并切换到其他的协程，不需要发生线程的切换，而线程的创建、切换又很消耗系统资源，所以协程能提高效率</p><p>不需要多线程的锁机制。由于只有一个线程，也不存在同时写变量的冲突，在协程中控制共享资源不需要加锁，只需要判断数据的状态，所以执行效率远高于线程</p><h5 id="协程的优点"><a href="#协程的优点" class="headerlink" title="协程的优点"></a>协程的优点</h5><ul><li>由用户程序来控制协程的切换，而不是操作系统的任务调度器来调度，不需要发起系统调用切换到内核态，</li><li>使用寄存器和栈来保存协程的上下文，占用资源少，保存、恢复上下文比线程更高效</li><li>不需要多线程的锁机制。由于只有一个线程，也不存在同时写变量的冲突，在协程中控制共享资源不需要加锁，只需要判断数据的状态，所以执行效率远高于线程。</li></ul><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODQ3NTYxMQ==,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>协程与线程的区别：</p><ol><li>由于协程的特性, 适合执行大量的<strong>I&#x2F;O 密集型任务</strong>, 而线程在这方面弱于协程</li><li>协程涉及到函数的切换, 多线程涉及到线程的切换, 所以都有<strong>执行上下文</strong>切换, 但是协程不是被操作系统内核所管理, 而完全是由用户程序所控制（也就是在<strong>用户态</strong>执行）, 不会像线程那样需要<strong>在内核态进行上下文切换</strong>来消耗资源，因此<strong>协程的开销远远小于线程的开销</strong></li><li>同一时间, 在多核处理器的环境下, <strong>多个线程是可以并行的</strong>，但是<strong>运行的协程的函数却只能有一个</strong>，<strong>其他的协程的函数都被挂起</strong>, 即<strong>协程是并发的</strong></li><li>由于协程在同一个线程中,也不存在同时写变量的冲突，在协程中控制共享资源不需要加锁。</li></ol><p>使用场景：</p><p><strong>协程适用于IO密集型任务</strong>，有了协程，我们在函数的执行过程中，如果遇到了<strong>I&#x2F;O密集型任务</strong>，函数可以临时让出控制权，<strong>让 CPU 执行其他函数</strong>，等 I&#x2F;O 操作执行完毕以后再收回其他函数的控制权.</p><h4 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h4><h5 id="内核态：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。其他的属于用户态。用户程序运行在用户态-操作系统运行在内核态-（操作系统内核运行在内核态，而服务器运行在用户态）。用户态不能干扰内核态"><a href="#内核态：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。其他的属于用户态。用户程序运行在用户态-操作系统运行在内核态-（操作系统内核运行在内核态，而服务器运行在用户态）。用户态不能干扰内核态" class="headerlink" title="内核态：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。其他的属于用户态。用户程序运行在用户态,操作系统运行在内核态.（操作系统内核运行在内核态，而服务器运行在用户态）。用户态不能干扰内核态."></a>内核态：当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。其他的属于用户态。用户程序运行在用户态,操作系统运行在内核态.（操作系统内核运行在内核态，而服务器运行在用户态）。用户态不能干扰内核态.</h5><h5 id="用户态："><a href="#用户态：" class="headerlink" title="用户态："></a>用户态：</h5><p>不能直接使用系统资源，也不能改变 CPU 的工作状态，并且只能访问这个用户程序自己的存储空间！</p><h5 id="内核态："><a href="#内核态：" class="headerlink" title="内核态："></a>内核态：</h5><p>内核态可以使用计算机所有的硬件资源，操作系统运行在内核态。为了安全性和稳定性，操作系统的程序不能随便访问，这就是内核态。即需要执行操作系统的程序就必须转换到内核态才能执行</p><h5 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h5><p>在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。如果所有的程序都能使用这些指令，那么你的系统一天死机N回就不足为奇了。<br>所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。<br>如此设计的本质意义是进行权限保护。 限定用户的程序不能乱搞操作系统，如果人人都可以任意读写任意地址空间软件管理便会乱套.</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5byg5a2f5rWpX2pheQ==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><h4 id="使用哪个命令去查看一个进程的信息"><a href="#使用哪个命令去查看一个进程的信息" class="headerlink" title="使用哪个命令去查看一个进程的信息"></a>使用哪个命令去查看一个进程的信息</h4><h5 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h5><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li>tasklist 查看进程</li><li>taskkill 杀死进程</li></ul><h5 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h5><ul><li>ps -fe 查看所有进程</li><li>ps -fT -p <PID> 查看某个进程（PID）的所有线程</li><li>kill 杀死进程</li><li>top 按大写 H 切换是否显示线程</li><li>top -H -p <PID> 查看某个进程（PID）的所有线程</li></ul><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><ul><li>jps 命令查看所有 Java 进程</li><li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</li><li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li></ul><h4 id="多线程通信方式"><a href="#多线程通信方式" class="headerlink" title="多线程通信方式"></a>多线程通信方式</h4><p>在Java中，多线程通信是通过一些机制和方法来实现的，以确保不同线程之间能够协同工作。以下是一些常见的多线程通信方式：</p><ol><li><strong>共享变量：</strong> 多个线程可以共享一个变量，通过读写该变量来进行通信。为了确保线程安全，通常需要使用<code>volatile</code>关键字或者<code>synchronized</code>关键字来控制访问。例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeclass SharedResource &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> sharedValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        sharedValue = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sharedValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>wait()和notify()：</strong> 这是基于对象监视器（Object Monitor）的机制，用于线程之间的等待和通知。<code>wait()</code>方法让一个线程等待，而<code>notify()</code>方法通知等待的线程继续执行。通常与<code>synchronized</code>关键字一起使用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeclass SharedResource &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sharedValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        sharedValue = value;</span><br><span class="line">        notify(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (sharedValue == <span class="number">0</span>) &#123;</span><br><span class="line">            wait(); <span class="comment">// 等待通知</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sharedValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>BlockingQueue：</strong> 使用<code>java.util.concurrent.BlockingQueue</code>可以方便地实现线程之间的通信。它提供了阻塞操作，当队列为空或已满时，线程会自动阻塞或等待。例如，<code>LinkedBlockingQueue</code>可以用于生产者-消费者问题。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code<span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    queue.put(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> queue.take();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>CountDownLatch和CyclicBarrier：</strong> 这两个类用于协调多个线程的执行。<code>CountDownLatch</code>用于等待一个或多个线程的完成，而<code>CyclicBarrier</code>用于等待多个线程到达某个同步点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个线程执行任务</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        latch.countDown(); <span class="comment">// 任务完成，计数减一</span></span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程等待所有任务完成</span></span><br><span class="line">latch.await();</span><br></pre></td></tr></table></figure><ol><li><strong>Semaphore：</strong> <code>java.util.concurrent.Semaphore</code>用于控制同时访问的线程数量。它允许多个线程同时访问一个共享资源。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javaCopy <span class="type">codeSemaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>); <span class="comment">// 最多允许3个线程同时访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程尝试获取许可</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    semaphore.acquire(); <span class="comment">// 获取许可</span></span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些是Java中常见的多线程通信方式。选择合适的通信方式取决于问题的性质和需求。需要注意，不正确的多线程通信可能导致竞态条件和死锁等问题，因此在设计多线程应用程序时应格外小心。</p><h4 id="虚拟内存的作用"><a href="#虚拟内存的作用" class="headerlink" title="虚拟内存的作用"></a>虚拟内存的作用</h4><p>如果直接使用物理内存，可能多个进程会同时使用同一个物理内存导致冲突。</p><p>我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「<strong>虚拟地址</strong>」，大家自己玩自己的地址就行，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，<strong>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</strong></p><p>如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/298fb68e3da94d767b02f2ed81ebf2c4.png" alt="进程的中间层"></p><h4 id="进程间通信方式，进程通信的时候信号量是如何实现的"><a href="#进程间通信方式，进程通信的时候信号量是如何实现的" class="headerlink" title="进程间通信方式，进程通信的时候信号量是如何实现的"></a>进程间通信方式，进程通信的时候信号量是如何实现的</h4><p><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E6%80%BB%E7%BB%93">5.2 进程间有哪些通信方式？ | 小林coding (xiaolincoding.com)</a></p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-%E6%8F%90%E7%BA%B2.jpg" alt="img"></p><p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4-%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4.jpg" alt="img"></p><h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>其实，<strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-%E7%AE%A1%E9%81%93-pipe.jpg" alt="img"></p><p>在 shell 里面执行 <code>A | B</code>命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8-%E7%AE%A1%E9%81%93-pipe-shell.jpg" alt="img"></p><p>所以说，在 shell 里通过「<code>|</code>」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。</p><p>我们可以得知，<strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p><p>另外，<strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p><p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><hr><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="#消息队列"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">#</a>消息队列</h5><p>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。</p><p>对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p><p>再来，<strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p><p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</p><p>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p><p>但邮件的通信方式存在不足的地方有两点，<strong>一是通信不及时，二是附件也有大小限制</strong>，这同样也是消息队列通信不足的点。</p><p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 <code>MSGMAX</code> 和 <code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p><p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p><hr><h5 id="共享内存"><a href="#共享内存" class="headerlink" title="#共享内存"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98">#</a>共享内存</h5><p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</p><p>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p><p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.jpg" alt="img"></p><hr><h5 id="信号量"><a href="#信号量" class="headerlink" title="#信号量"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E4%BF%A1%E5%8F%B7%E9%87%8F">#</a>信号量</h5><p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p><p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p><p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p><p>接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 <code>1</code>。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10-%E4%BF%A1%E5%8F%B7%E9%87%8F-%E4%BA%92%E6%96%A5.jpg" alt="img"></p><p>具体的过程如下：</p><ul><li>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。</li><li>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。</li><li>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的进程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。</li></ul><p>可以发现，信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p><p>另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。</p><p>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。</p><p>那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 <code>0</code>。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11-%E4%BF%A1%E5%8F%B7%E9%87%8F-%E5%90%8C%E6%AD%A5.jpg" alt="img"></p><p>具体过程：</p><ul><li>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；</li><li>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；</li><li>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。</li></ul><p>可以发现，信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p><hr><h5 id="信号"><a href="#信号" class="headerlink" title="#信号"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E4%BF%A1%E5%8F%B7">#</a>信号</h5><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p><p>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。</p><p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 命令，查看所有的信号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -l</span></span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p><ul><li>Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程；</li><li>Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li></ul><p>如果进程在后台运行，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p><ul><li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li></ul><p>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</p><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p><p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。</p><p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p><p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p><hr><h5 id="Socket"><a href="#Socket" class="headerlink" title="#Socket"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#socket">#</a>Socket</h5><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p><p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p><p>我们来看看创建 socket 的系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocal)</span></span><br></pre></td></tr></table></figure><p>三个参数分别代表：</p><ul><li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL&#x2F;AF_UNIX 用于本机；</li><li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；</li><li>protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；</li></ul><p>根据创建 socket 类型的不同，通信的方式也就不同：</p><ul><li>实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；</li><li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；</li><li>实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</li></ul><p>接下来，简单说一下这三种通信的编程模式。</p><blockquote><p>针对 TCP 协议通信的 socket 编程模型</p></blockquote><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12-TCP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" alt="img"></p><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li></ul><p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p><p>所以，监听的 socket 和真正用来传送数据的 socket，是「<strong>两个</strong>」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><blockquote><p>针对 UDP 协议通信的 socket 编程模型</p></blockquote><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/13-UDP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" alt="img"></p><p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p><p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p><p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。</p><blockquote><p>针对本地进程间通信的 socket 编程模型</p></blockquote><p>本地 socket 被用于在<strong>同一台主机上进程间通信</strong>的场景：</p><ul><li>本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；</li><li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</li></ul><p>对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。</p><p>对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。</p><p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</p><hr><h5 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E6%80%BB%E7%BB%93">#</a>总结</h5><p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。</p><p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。</p><p><strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「<code>|</code>」竖线就是匿名管道，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来<strong>匿名管道是只能用于存在父子关系的进程间通信</strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</p><p><strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是<strong>缓存在内核</strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><p><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></p><p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p><p>那么，就需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p><p>与信号量名字很相似的叫<strong>信号</strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是<strong>异步通信机制</strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，<strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SIGSTOP</code>，这是为了方便我们能在任何时候结束或停止某个进程。</p><p>前面说到的通信机制，都是工作于同一台主机，如果<strong>要与不同主机的进程间通信，那么就需要 Socket 通信了</strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p><h4 id="线程崩溃了进程也会崩溃吗"><a href="#线程崩溃了进程也会崩溃吗" class="headerlink" title="线程崩溃了进程也会崩溃吗"></a>线程崩溃了进程也会崩溃吗</h4><p>线程崩溃了，在正常情况下，操作系统为了保证系统安全，所以针对非法内存访问会发送一个 SIGSEGV 信号，而操作系统一般会调用默认的信号处理函数（一般会让相关的进程崩溃）。</p><p>但如果进程觉得”罪不致死”，那么它也可以选择自定义一个信号处理函数，这样的话它就可以做一些自定义的逻辑，比如记录 crash 信息等有意义的事。</p><p>回过头来看为什么JVM虚拟机会针对 StackoverflowError 和 NullPointerException 做额外处理让线程恢复呢，针对 stackoverflow 其实它采用了一种栈回溯的方法保证线程可以一直执行下去，而捕获空指针错误主要是这个错误实在太普遍了。</p><p>为了这一个很常见的错误而让 JVM 崩溃那线上的 JVM 要宕机多少次，所以出于工程健壮性的考虑，与其直接让 JVM 崩溃倒不如让线程起死回生，并且将这两个错误&#x2F;异常抛给用户来处理。</p><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><h5 id="传统的文件传输有多糟糕？"><a href="#传统的文件传输有多糟糕？" class="headerlink" title="传统的文件传输有多糟糕？"></a>传统的文件传输有多糟糕？</h5><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p><p>传统 I&#x2F;O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I&#x2F;O 接口从磁盘读取或写入。</p><p>代码通常如下，一般会需要两个系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure><p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png" alt="img"></p><p>首先，期间共<strong>发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 <code>read()</code> ，一次是 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p><p>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p><p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p><ul><li><em>第一次拷贝</em>，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li><li><em>第二次拷贝</em>，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li><li><em>第三次拷贝</em>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li><li><em>第四次拷贝</em>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li></ul><p>我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。</p><p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p><p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p><ul><li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li><li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li></ul><p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p><p><img src="/./../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="img"></p><p>这就是所谓的<strong>零拷贝（*Zero-copy*）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</strong>。</p><p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p><p>所以，总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法记录</title>
      <link href="/2024/04/19/%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/04/19/%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>UPDATING…</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2024/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络："><a href="#计算机网络：" class="headerlink" title="计算机网络："></a>计算机网络：</h2><h4 id="网络的构成"><a href="#网络的构成" class="headerlink" title="网络的构成"></a>网络的构成</h4><p><strong>节点</strong></p><ul><li><p>主机及其上运行的应用程序</p></li><li><p>路由器、交换机等网络交换设备</p></li></ul><p><strong>边：通信链路</strong></p><ul><li><p>接入网链路：主机连接到互联网的链路</p></li><li><p>主干链路：路由器间的链路</p></li></ul><p><strong>协议</strong></p><ul><li>传输层TCP、UDP协议</li><li>网络层IP协议</li><li>应用层FTP、SMTP、HTTP、DNS协议等</li></ul><p><strong>协议的定义</strong>：对等层实体，在通信过程中，需要遵守的规则的集合、包括语法、语义、报文格式以及次序。</p><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20231003112121217.png" alt="image-20231003112121217"></p><p>1、物理层：发送时将数据bit流转化为物理信号（电磁波，光波），接收时将物理信号转换为bit流数据。实现计算机节点之间比特流的传输，规定传输媒体接口的标准，屏蔽掉具体传输介质和物理设备的差异，使数据链路层不必关心网络的具体传输介质，按照物理层规定的标准传输数据就行</p><p>2、数据链路层：向上:将物理层的一个个bit，组合转换为帧包括帧头和帧尾，向下:把网络层数据报加头和尾，封装成帧，帧头中包括源MAC地址和目的MAC地址。 提供相邻两个节点之间的数据传输</p><p>通过差错控制、流量控制等方法，使有差错的物理线路变为无差错的数据链路。</p><p>数据链路层的几个基本方法：数据封装成桢、透明传输、差错控制、流量控制。</p><p>封装成桢：把网络层数据报加头和尾，封装成帧，帧头中包括源MAC地址和目的MAC地址。<br>透明传输：零比特填充、转义字符。<br>差错控制：接收者检测错误,如果发现差错，丢弃该帧，差错控制方法有 CRC 循环冗余码<br>流量控制：控制发送的传输速度，使得接收方来得及接收。传输层TCP也有流量控制功能，但TCP是端到端的流量控制，链路层是点到点（比如一个路由器到下一个路由器）<br>3、网络层：<strong>实现网络地址与物理地址的转换</strong>，并通过<strong>路由选择算法为分组通过通信子网选择最适当的路径</strong></p><p>网络层最重要的一个功能就是：路由选择。路由一般包括路由表和路由算法两个方面。每个路由器都必须建立和维护自身的路由表，一种是静态维护，也就是人工设置，适用于小型网络；另一种就是动态维护，是在运行过程中根据网络情况自动地动态维护路由表。</p><p>4、传输层：提供源端与目的端之间提供可靠的透明数据传输，传输层协议为不同主机上运行的进程提供逻辑通信。</p><p>网络层协议负责的是提供主机间的逻辑通信，而传输层协议负责的是提供进程间的逻辑通信。</p><p>5、会话层：管理（建立、维护、重连）应用之间的会话，是用户<strong>应用程序和网络之间的接口</strong>，负责在网络中的<strong>两节点之间建立、维持、终止通信</strong>。</p><p>6、表示层：<strong>处理用户数据的表示问题</strong>，如数据的编码、<strong>格式转换、加密和解密、压缩和解压缩</strong>。</p><p>7、应用层(FTP、SMTP、HTTP、DNS)：传输层基础上实现网络应用，为<strong>用户的应用进程提供网络通信服务</strong>，完成和实现用户请求的各种服务。</p><h4 id="各个设备工作在哪一层"><a href="#各个设备工作在哪一层" class="headerlink" title="各个设备工作在哪一层"></a>各个设备工作在哪一层</h4><ul><li><p>网桥：工作在<strong>数据链路层</strong>，在不同或相同类型的LAN之间存储并转发数据帧，必要时进行链路层上的协议转换。可连接两个或多个网络，在其中传送信息包。</p></li><li><p>交换机：工作在<strong>数据链路层</strong>，原理等同于多端口网桥。作用是连接数个相同网段的不同主机，减少网内冲突，隔离冲突域。利用存储转发和过滤技术来从物理上分割网段。</p></li><li><p>路由器：工作在<strong>网络层</strong>，在不同的网络间存储并转发分组。可在异种网络之间（即不同类型的局域网互连，局域网与广域网，广域网与广域网）传输数据并进行路径选择，使用专门的软件协议从逻辑上对整个网络进行划分。</p></li><li><p>网关：对高层协议（包括传输层及更高层次）进行转换的网间连接器。允许使用不兼容的协议，比如SPX&#x2F;IPX和TCP&#x2F;IP的系统和网络互连。因为协议转换是网关最重要的功能，所以答案是工作<strong>在传输层及以上层次</strong>。</p></li><li><p>网卡：在物理层上网卡主要是完成物理接口的连接,电信号的传送以及将数据分解为适当大小的数据包之后向网络上发送的功能. 数据链路层功能包括链路建立和拆除，帧定界同步顺序差错控制这些。大多认为主要工作在物理层。通常包含<strong>物理层以及链路层</strong></p></li></ul><h4 id="TCP粘包拆包问题"><a href="#TCP粘包拆包问题" class="headerlink" title="TCP粘包拆包问题"></a>TCP粘包拆包问题</h4><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><p>TCP在接受数据的时候，有一个滑动窗口来控制接受数据的大小，这个滑动窗口你就可以理解为一个缓冲区的大小。缓冲区满了就会把数据发送。数据包的大小是不固定的，有时候比缓冲区大有时候小。</p><ul><li>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题；</li><li>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包</li></ul><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/864571e427ea43eeb8db63e4bcd53455.png" alt="img"></p><h5 id="为什么会发生"><a href="#为什么会发生" class="headerlink" title="为什么会发生"></a>为什么会发生</h5><p>1.TCP会发生粘包问题：TCP 是面向连接的传输协议,TCP 传输的数据是以流的形式,而流数据是没有明确的开始结尾边界,所以 TCP 也没办法判断哪一段流属于一个消息;内容与内容之间没有明确的分界标志,需要认为手动地去给这些协议划分边界。<br>粘包时：发送方每次写入数据 &lt; 接收方套接字(Socket)缓冲区大小。<br>拆包时：发送方每次写入数据 &gt; 接收方套接字(Socket)缓冲区大小。</p><p>2.UDP不会发生粘包问题：UDP具有保护消息边界,在每个UDP包中就有了消息头(UDP长度、源端口、目的端口、校验和)。</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>1、客户端在发送数据包的时候，每个包都固定长度，比如1024个字节大小，如果客户端发送的数据长度不足1024个字节，则通过补充空格的方式补全到指定长度；</p><p>2、客户端在每个包的末尾使用固定的分隔符，例如\r\n，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的\r\n，然后对其拆分后的头部部分与前一个包的剩余部分进行合并，这样就得到了一个完整的包；</p><p>3、将消息分为头部和消息体，在头部中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；</p><h4 id="HTTP如何解决粘包问题的？"><a href="#HTTP如何解决粘包问题的？" class="headerlink" title="HTTP如何解决粘包问题的？"></a>HTTP如何解决粘包问题的？</h4><p>http请求报文格式<br>1）请求行：以\r\n结束；<br>2）请求头：以\r\n结束；<br>3）\r\n；<br>3）数据；</p><p>http响应报文格式<br>1）响应行：以\r\n结束；<br>2）响应头：以\r\n结束；<br>3）\r\n；<br>4）数据；</p><p>4.1、读取请求行&#x2F;请求头、响应行&#x2F;响应头<br>1、遇到第一个\r\n表示读取请求行或响应行结束；<br>2、遇到\r\n\r\n表示读取请求头或响应头结束；</p><p>4.2、 怎么读取body数据呢？<br>HTTP协议通常使用Content-Length来标识body的长度。在服务器端，需要先申请对应长度的buffer，然后再赋值。</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1279a01571164f2ba3c2a8141a0e996a.png" alt="img"></p><p>如果需要一边生产数据一边发送数据，就需要使用”Transfer-Encoding: chunked” 来代替Content-Length，也就是对数据进行分块传输。</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/de563592ba4c4d42b9d1acfbda2af5f5.png" alt="img"></p><p>4.2.1、 Content-Length 描述<br>http server接收数据时，发现header中有Content-Length属性，则读取Content-Length的值，确定需要读取body的长度。<br>http server发送数据时，根据需要发送byte的长度，在header中增加Content-Length项，其中value为byte的长度，然后将byte数据当做body发送到客户端。<br>4.2.2、 chunked描述<br>http server接收数据时，发现header中有Transfer-Encoding: chunked，则会按照chunked协议分批读取数据。<br>http server发送数据时，如果需要分批发送到客户端，则需要在header中加上Transfer-Encoding:chunked，然后按照chunked协议分批发送数据。<br>chunked协议具体如下图：</p><p> <img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/8ba16c3c85684457a1bfa01ce4014491.png" alt="img"></p><p>1、主要包含三部分: chunk，last-chunk和trailer。如果分多次发送，则chunk有多份。</p><p>2、 chunk主要包含大小和数据，大小表示这个这个chunk包的大小，使用16进制标示。其中chunk之间的分隔符为CRLF。</p><p>3、通过last-chunk来标识chunk发送完成。一般读取到last-chunk(内容为0)的时候，代表chunk发送完成。</p><p>4、trailer表示增加header等额外信息，一般情况下header是空。通过CRLF来标识整个chunked数据发送完成。</p><p>4.2.3 优&#x2F;缺点<br>优点</p><p>1、假如body的长度是10K，对于Content-Length则需要申请10K连续的buffer，而对于Transfer-Encoding:chunked可以申请1k的空间，然后循环使用10次。节省了内存空间的开销。</p><p>2、如果内容的长度不可知，则可使用chunked方式能有效的解决Content-Length的问题</p><p>3、http服务器压缩可以采用分块压缩，而不是整个块压缩。分块压缩可以一边进行压缩，一般发送数据，来加快数据的传输时间。</p><p>缺点</p><p>1、chunked协议解析比较复杂。</p><p>2、在http转发的场景下(比如nginx)难以处理，比如如何对分块数据进行转发。</p><h4 id="TCP队头阻塞问题"><a href="#TCP队头阻塞问题" class="headerlink" title="TCP队头阻塞问题"></a>TCP队头阻塞问题</h4><p>客户端接收端可能会先收到窗口末端的数据，这个时候 TCP 是不会向上层应用交付数据的，它得等到前面的数据都接收到了才向上交付，所以这就出现了队头阻塞，即队头的包如果发生延迟或者丢失，队尾必须等待发送端重新发送并接收到数据后才会一起向上交付。</p><h4 id="TCP和UDP的区别和应用场景"><a href="#TCP和UDP的区别和应用场景" class="headerlink" title="TCP和UDP的区别和应用场景"></a>TCP和UDP的区别和应用场景</h4><ul><li><p><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</p></li><li><p><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，确保通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p></li><li><p><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了</p></li><li><p><strong>传输效率</strong>：由于使用 TCP 建立连接有握手的机制，进行传输的时候多了连接、确认、重传等机制，TCP 的使用效率会比 UDP 要低</p></li><li><p><strong>传输形式</strong>：TCP 是面向字节流（把应用程序交下来的数据看成无结构的字节流）的，UDP 是面向报文（对应用层的报文既不合并也不拆分，对长度大小都不做任何改变）的。</p></li><li><p><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</p></li><li><p><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</p></li></ul><h5 id="TCP使用场景"><a href="#TCP使用场景" class="headerlink" title="TCP使用场景"></a>TCP使用场景</h5><p>效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</p><h5 id="UDP使用场景"><a href="#UDP使用场景" class="headerlink" title="UDP使用场景"></a>UDP使用场景</h5><p>效率要求相对高，对准确性要求相对低的场景。举几个例子：游戏、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播），即使出现传输错误也可以容忍。</p><h4 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h4><p>QUIC 全称：Quick UDP Internet Connections，是一种基于 UDP 的传输层协议。</p><p><strong>可靠传输</strong></p><p>QUIC 是基于 UDP 协议的，而 UDP 是不可靠传输协议，那 QUIC 是如何实现可靠传输的呢？</p><p>可靠传输有 2 个重要特点：</p><p>（1）完整性：发送端发出的数据包，接收端都能收到</p><p>（2）有序性：接收端能按序组装数据包，解码得到有效的数据</p><p>问题 1：发送端怎么知道发出的包是否被接收端收到了？</p><p>解决方案：通过包号（PKN）和确认应答（SACK）</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-aace93419dd55c73ab4b5fd2976e1375_1440w.webp" alt="img"></p><p>（1）客户端：发送 3 个数据包给服务器（PKN &#x3D; 1，2，3）</p><p>（2）服务器：通过 SACK 告知客户端已经收到了 1 和 3，没有收到 2</p><p>（3）客户端：重传第 2 个数据包（PKN&#x3D;4）</p><p>由此可以看出，QUIC 的数据包号是单调递增的。也就是说，之前发送的数据包（PKN&#x3D;2）和重传的数据包（PKN&#x3D;4），虽然数据一样，但包号不同。</p><p>问题 2：既然包号是单调递增的，那接收端怎么保证数据的有序性呢？</p><p>解决方案：通过数据偏移量 offset</p><p>每个数据包都有一个 offset 字段，表示在整个数据中的偏移量。</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-e6abef5bc9316fd87905a5e97b547050_1440w.webp" alt="img"></p><p>接收端根据 offset 字段就可以对异步到达的数据包进行排序了。为什么 QUIC 要将 PKN 设计为单调递增？解决 TCP 的重传歧义问题：</p><p>由于原始包和重传包的序列号是一样的，客户端不知道服务器返回的 ACK 包到底是原始包的，还是重传包的。但 QUIC 的原始包和重传包的序列号是不同的，也就可以判断 ACK 包的归属。</p><h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><strong>流量控制</strong></h5><p>和 TCP 一样，QUIC 也是利用滑动窗口机制实现流量控制：</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-2b659a36da1993c1a65bed4830606997_1440w.webp" alt="img"></p><p>发送端的窗口大小由接收端告知，包括发送窗口和可用窗口，如果发送端收到了接收端的 ACK 确认应答（比如 ACK 36），那整个窗口就会向右滑动，发送新的数据包。</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-62c627de56caf4617f97628215c4fa03_1440w.webp" alt="img"></p><p>和 TCP 不同的是，QUIC 的滑动窗口分为 Connection 和 Stream 两种级别。Connection 流量控制：规定了所有数据流的总窗口大小；Stream 流量控制：规定了每个流的窗口大小。</p><p>假设现在有 3 个 Stream，滑动窗口分别如下：</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-a5f95afac0935ae11f4672d3fdf9bf3e_1440w.webp" alt="img"></p><p>则整个 Connection 的可用窗口大小为：20+30+10 &#x3D; 60</p><h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><strong>拥塞控制</strong></h5><p>拥塞控制是通过拥塞窗口限制发送方的数据量，避免整个网络发生拥塞。那拥塞窗口（cwnd）和滑动窗口（发送窗口：swnd，接收窗口：rwnd）有什么关系呢？</p><p>swnd &#x3D; min（cwnd，rwnd）</p><p>也就是说，发送窗口的大小是由接收窗口和拥塞窗口共同决定的。那拥塞窗口的大小是如何计算的？通过 4 个拥塞控制算法：慢启动、拥塞避免、拥塞发生、快速恢复</p><h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a><strong>慢启动</strong></h5><p>初始拥塞窗口大小 cwnd&#x3D;1，也就是可以传输 1 个 MDS（Max Datagram Size）大小的数据包，一般网卡允许传输的最大数据单元 MTU 的大小是 1500 字节。对于 UDP 数据报而言：MDS &#x3D; 1500（MTU）- 20（IP 首部）- 8（UDP 首部） &#x3D; 1472 字节</p><p><strong>慢启动算法</strong>： 当发送方每收到一个 ACK，拥塞窗口就加 1（cwnd++）</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-54d7f3cc6ec67a9ae47fa5dfa3fccfc0_1440w.webp" alt="img"></p><p>由此可以看出，慢启动阶段，拥塞窗口呈指数增长，那增长到多少是个头？</p><p>有一个上限值：ssthresh（slow start threshold），从源码看，这个值是 2000 * MDS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const QuicPacketCount kDefaultMaxCongestionWindowPackets = 2000;</span><br></pre></td></tr></table></figure><ul><li>当 <strong>cwnd &lt; ssthresh</strong> 时，使用慢启动算法</li><li>当 <strong>cwnd &gt;&#x3D; ssthresh</strong> 时，使用拥塞避免算法</li></ul><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a><strong>拥塞避免</strong></h5><p>当拥塞窗口大小超过慢启动上限后，就会进入拥塞避免阶段。</p><p><strong>拥塞避免算法：</strong> 当发送方每收到一个 ACK，拥塞窗口就加 1&#x2F;cwnd</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-1072c63fd6e97e671affe2d9346c3836_1440w.webp" alt="img"></p><p>假设现在的 cwnd&#x3D;8，可以发送 8 个数据包，当收到这 8 个包的 ACK 时，拥塞窗口才会加 1，由此可知，在拥塞避免阶段，拥塞窗口是线性增长的。</p><p>那啥时候是个头呢？不管，让它继续增长，直到网络发生拥塞，出现丢包，这时就会触发重传机制，进入拥塞发生阶段</p><h5 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a><strong>拥塞发生</strong></h5><p>重传有 2 种：超时重传和快速重传</p><p>如果发生超时重传，使用的拥塞发生算法为：</p><ul><li>ssthresh &#x3D; cwnd &#x2F; 2</li><li>cwnd &#x3D; 1</li></ul><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-dcefc32fcbaca9acf5a347580b56ff3c_1440w.webp" alt="img"></p><p>重新使用慢启动和拥塞避免算法增加拥塞窗口的大小。</p><p>如果发生快速重传（发送方收到 3 个相同的 ACK），使用的拥塞发生算法为：</p><ul><li>cwnd &#x3D; cwnd &#x2F; 2</li><li>ssthresh &#x3D; cwnd</li></ul><p>接下来就会进入快速恢复阶段。</p><h5 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a><strong>快速恢复</strong></h5><p>快速恢复算法：cwnd &#x3D; ssthresh + 3（因为收到 3 个 ACK），然后进入拥塞避免阶段。</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-9158217fe2e02f6b17a29aadf649cdd2_1440w.webp" alt="img"></p><h4 id="QUIC相比于TCP的优势"><a href="#QUIC相比于TCP的优势" class="headerlink" title="QUIC相比于TCP的优势"></a>QUIC相比于TCP的优势</h4><p>安全性:QUIC它完全以加密形式通信，未加密的通信是完全被禁止的</p><p><strong>0-RTT 握手</strong>:其实原理很简单：客户端缓存了 ServerConfig（B&#x3D;b*G%P），下次建连直接使用缓存数据计算通信密钥。</p><p>多路复用方面，QUIC可以复用多个stream，同时其中一个stream的丢包并不会影响其他stream，这也说明了在QUIC中，每个stream是相对独立的,解决了TCP协议中队头阻塞问题。</p><h4 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h4><p>建立一个 TCP 连接需要“三次握手”，缺一不可：</p><ul><li><strong>一次握手</strong>:客户端发送带有 SYN（SEQ&#x3D;x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</li><li><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态</li><li><strong>三次握手</strong>:客户端发送带有 ACK(ACK&#x3D;y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成 TCP 三次握手。</li></ul><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p><ol><li><strong>第一次握手</strong>：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li><li><strong>第二次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li><li><strong>第三次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li><li>防止失效的请求报文又请求建立连接，浪费服务器资源</li></ol><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20240104135112905.png" alt="image-20240104135112905"></p><p>三次握手就能确认双方收发功能都正常，缺一不可。</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20231003112124898.png" alt="image-20231003112124898"></p><h5 id="第-2-次握手传回了-ACK，为什么还要传回-SYN？"><a href="#第-2-次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="第 2 次握手传回了 ACK，为什么还要传回 SYN？"></a>第 2 次握手传回了 ACK，为什么还要传回 SYN？</h5><p>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信也是正常的。</p><blockquote><p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP&#x2F;IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p></blockquote><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20231003112128868.png" alt="image-20231003112128868"></p><p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p><ol><li><strong>第一次挥手</strong>：客户端发送一个 FIN（SEQ&#x3D;x） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li><li><strong>第二次挥手</strong>：服务器收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （ACK&#x3D;x+1）标志的数据包-&gt;客户端 。然后服务端进入 <strong>CLOSE-WAIT</strong> 状态，客户端进入 <strong>FIN-WAIT-2</strong> 状态。</li><li><strong>第三次挥手</strong>：服务端发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 <strong>LAST-ACK</strong> 状态。</li><li><strong>第四次挥手</strong>：客户端发送 ACK (ACK&#x3D;y+1)标志的数据包-&gt;服务端，然后客户端进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (ACK&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li></ol><p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p><h5 id="为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？"><a href="#为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？" class="headerlink" title="为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？"></a>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</h5><p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p><h5 id="如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？"><a href="#如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？" class="headerlink" title="# 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？"></a><a href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84-ack-%E6%B2%A1%E6%9C%89%E9%80%81%E8%BE%BE%E5%AE%A2%E6%88%B7%E7%AB%AF-%E4%BC%9A%E6%80%8E%E6%A0%B7">#</a> 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h5><p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p><h5 id="为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？"><a href="#为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？" class="headerlink" title="# 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85-2-msl-%E6%8A%A5%E6%96%87%E6%AE%B5%E6%9C%80%E9%95%BF%E5%AF%BF%E5%91%BD-%E6%97%B6%E9%97%B4%E5%90%8E%E6%89%8D%E8%BF%9B%E5%85%A5-closed-%E7%8A%B6%E6%80%81">#</a> 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h5><p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p><blockquote><p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接，可根据具体实现动态调整MSL。</p></blockquote><h4 id="讲一讲SYN洪泛攻击，以及解决策略"><a href="#讲一讲SYN洪泛攻击，以及解决策略" class="headerlink" title="讲一讲SYN洪泛攻击，以及解决策略"></a>讲一讲SYN洪泛攻击，以及解决策略</h4><p>洪泛攻击： 在 TCP 的三次握手机制的第一步中，客户端会向服务器发送 SYN 报文段。服务器接收到 SYN 报文段后会为该 TCP分 配缓存和变量，如果攻击分子大量地往服务器发送 SYN 报文段，服务器的连接资源终将被耗尽，导致内存溢出无法继续服务。</p><p>解决策略：当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源 IP，目的 IP，端口号以及只有服务器自己知道的一个秘密函数生成一个 cookie，并把 cookie 作为序列号响应给客户端。</p><p>如果客户端是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段。接下来服务器会根据确认报文的源 Id，目的 Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1 等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源。</p><p>这样一来就不会为恶意攻击的 SYN 报文段分配资源空间，避免了攻击。</p><h4 id="详细介绍一下-TCP-的四次挥手机制，为什么要有-TIME-WAIT-状态，为什么需要四次握手？服务器出现了大量-CLOSE-WAIT-状态如何解决"><a href="#详细介绍一下-TCP-的四次挥手机制，为什么要有-TIME-WAIT-状态，为什么需要四次握手？服务器出现了大量-CLOSE-WAIT-状态如何解决" class="headerlink" title="详细介绍一下 TCP 的四次挥手机制，为什么要有 TIME_WAIT 状态，为什么需要四次握手？服务器出现了大量 CLOSE_WAIT 状态如何解决"></a>详细介绍一下 TCP 的四次挥手机制，为什么要有 TIME_WAIT 状态，为什么需要四次握手？服务器出现了大量 CLOSE_WAIT 状态如何解决</h4><p>当客户端要服务器断开连接时，客户端 TCP 会向服务器发送一个特殊的报文段，该报文段的 FIN 标志位会被置 1，接着服务器会向客户端发送一个确认报文段。然后服务器也会客户端发送一个 FIN 标志位为 1 的终止报文段，随后客户端回送一个确认报文段，服务器立即断开连接。客户端等待一段时间后也断开连接。</p><p>为什么要有 TIME_WAIT 状态？因为客户端最后向服务器发送的确认 ACK 是有可能丢失的，当出现超时，服务端会再次发送 FIN 报文段，如果客户端已经关闭了就收不到了。</p><p>大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。</p><p>详情可参考以下博客：<a href="https://www.cnblogs.com/sunxucool/p/3449068.html">https://www.cnblogs.com/sunxucool/p/3449068.html</a></p><h4 id="TCP的可靠传输是如何保障的"><a href="#TCP的可靠传输是如何保障的" class="headerlink" title="TCP的可靠传输是如何保障的"></a>TCP的可靠传输是如何保障的</h4><ul><li><strong>基于数据块传输</strong>：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li><li><strong>连接稳定可靠</strong>：通过三次握手四次挥手，保证了连接的可靠性，数据传输的完整性。</li><li><strong>序号机制，对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号（序列号是数据第一个字节的序号），有了序列号能够将接收到的数据<strong>根据序列号排序</strong>，并且<strong>去掉重复序列号的数据</strong>就可以实现数据包去重。</li><li><strong>校验和</strong> : TCP添加伪首部，TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个<strong>相应的确认信息</strong>（ACK）。<strong>超过该定时器时间依旧未收到对方确认，那么对应的数据包就被假设为已丢失并进行重传，便会重新发送该数据</strong></li><li><strong>流量控制</strong> : <strong>接收方根据自己接收缓冲的大小，可在设置确认报文字段的窗口字段，动态调整发送方发送窗口大小。</strong>TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制，窗口大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值）。</li><li><strong>拥塞控制</strong> : 通过慢启动，当网络拥塞时（发送方的数据迟迟无法到达接收方），发送方估算网络拥堵程度减少数据的发送。</li></ul><p>总结：TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20231003112139329.png" alt="image-20231003112139329"></p><p>udp第四个字段为17</p><h4 id="详细讲一下TCP的滑动窗口"><a href="#详细讲一下TCP的滑动窗口" class="headerlink" title="详细讲一下TCP的滑动窗口"></a>详细讲一下TCP的滑动窗口<img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp-send-window.png" alt="TCP发送窗口结构"></h4><p>从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。</p><h5 id="先讲流量控制："><a href="#先讲流量控制：" class="headerlink" title="先讲流量控制："></a>先讲流量控制：</h5><p><strong>接收方根据自己接收缓冲的大小，可在设置确认报文字段的窗口字段，动态调整发送方发送窗口大小。</strong>TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失</p><h5 id="接着讲解拥塞控制："><a href="#接着讲解拥塞控制：" class="headerlink" title="接着讲解拥塞控制："></a>接着讲解拥塞控制：</h5><p>拥塞控制是指发送方先设置一个小的窗口值作为发送速率，当成功发包并接收到 ACK 时，便以<strong>指数速率增大发送窗口的大小</strong>，直到遇到丢包（超时&#x2F;三个冗余 ACK ），才停止并调整窗口的大小。这么做能最大限度地利用带宽，又不至于让网络环境变得太过拥挤。</p><p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p><p><a href="https://blog.csdn.net/qq_41431406/article/details/97926927">TCP的拥塞控制（详解）-CSDN博客</a></p><p><strong>UDP接收缓冲区</strong></p><p>每个UDP socket都有一个接收缓冲区，没有发送缓冲区，从概念上来说就是只要有数据就发，不管对方是否可以正确接收，所以不缓冲，不需要发送缓冲区。</p><p>UDP：当套接口接收缓冲区满时，新来的数据报无法进入接收缓冲区，此数据报就被丢弃。UDP是没有流量控制的；快的发送者可以很容易地就淹没慢的接收者，导致接收方的UDP丢弃数据报。</p><h4 id="讲述浏览器中输入一个网址之后背后的过程："><a href="#讲述浏览器中输入一个网址之后背后的过程：" class="headerlink" title="讲述浏览器中输入一个网址之后背后的过程："></a><strong>讲述浏览器中输入一个网址之后背后的过程：</strong></h4><ol><li><p>URL 解析：</p><p><strong>地址解析</strong>：首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，（如果是关键词就直接按照关键词搜索）并且根据你输入的内容进行自动完成、字符编码等操作。浏览器还会进行一些额外的操作，比如安全检查、访问限制</p></li><li><p>DNS 查询</p><p><strong>1</strong>.<strong>浏览器缓存</strong>：浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p><p><strong>2. 操作系统缓存</strong>：操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p><p><strong>3. 路由器缓存</strong>：路由器也有自己的缓存。</p><p><strong>4. 本地 DNS 缓存</strong>：ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，也就是本地DNS服务器，它们在大多数情况下都会有缓存。</p><p><strong>5.根域名服务器查询</strong>：本地 DNS 服务器会将请求转发到互联网上的根域,再查询顶级域名服务器，权威域名服务器，找到对应服务器的ip地址</p></li><li><p>通过ip地址找到服务器，并与服务器建立TCP 连接</p></li><li><p>浏览器向web服务器发送一个HTTP请求</p></li><li><p>服务器对发送的请求进行处理，并发回一个HTML响应</p></li><li><p>浏览器接收到来自服务器的响应资源后，会对资源进行分析接受响应，浏览器渲染页面，得到我们看到的网页</p></li></ol><h4 id="一个请求达到后端整个过程"><a href="#一个请求达到后端整个过程" class="headerlink" title="一个请求达到后端整个过程"></a>一个请求达到后端整个过程</h4><ol><li><strong>建立连接</strong>：客户端通过TCP&#x2F;IP协议与服务器建立连接，这是HTTP的基础。</li><li><strong>发送请求</strong>：客户端向服务器发送一个HTTP请求，其中包含请求方法（例如GET或POST）和要访问的资源的URL。</li><li><strong>处理请求</strong>：服务器接收到请求后，会解析请求，查找所请求的资源，并准备好将其发送回客户端的响应。</li><li><strong>发送响应</strong>：服务器将响应发送回客户端，响应通常包括状态码、响应头和响应体。</li><li><strong>关闭连接</strong>：连接在请求和响应之后通常会被关闭，但HTTP&#x2F;1.1引入了持久连接以改善性能。</li></ol><h4 id="讲讲TCP的表头有哪些字段，这些字段你是背的还是了解过有什么作用，有过对每个字段的功能的测试吗"><a href="#讲讲TCP的表头有哪些字段，这些字段你是背的还是了解过有什么作用，有过对每个字段的功能的测试吗" class="headerlink" title="讲讲TCP的表头有哪些字段，这些字段你是背的还是了解过有什么作用，有过对每个字段的功能的测试吗"></a>讲讲TCP的表头有哪些字段，这些字段你是背的还是了解过有什么作用，有过对每个字段的功能的测试吗</h4><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20231003112148772.png" alt="image-20231003112148772"></p><ol><li><p>源端口和目的端口       各占2个字节，分别写入源端口和目的端口。</p></li><li><p>序号 在一个TCP连接中传送的字节流中的每一个字节都按照顺序编号，本字段表示本报文段所发送数据的第一个字节的序号。</p></li><li><p>确认号 起到收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则证明到序号N-1为止的所有数据都已正确收到。</p></li><li><p>数据偏移（TCP首部长度） TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B为单位，即一个数值是4B</p></li><li><p>保留          占6位，保留为今后使用，但目前应置为0 。</p></li><li><p>当URG置为1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。</p></li><li><p>确认ACK（ACKnowledgment）      仅当ACK &#x3D; 1时确认号字段才有效，当ACK &#x3D; 0时确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。</p></li><li><p>推送 PSH（PuSH）    当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。接收方TCP收到PSH&#x3D;1的报文段，就尽快地（即“推送”向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付。</p></li><li><p>复位RST（ReSeT）       当RST&#x3D;1时，表明 TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。</p></li><li><p>同步SYN（SYNchronization）       在连接建立时用来同步序号。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN&#x3D;1和ACK&#x3D;1，因此SYN置为1就表示这是一个连接请求或连接接受报文。</p></li><li><p>终止FIN（FINis，意思是“完”“终”）          用来释放一个连接。当FIN&#x3D;1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p></li><li><p>窗口             占2字节。窗口值是【0，2^16-1】之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。</p></li><li><p>检验和       占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式和UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）；把第5字段中的UDP中的长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用IPv6,则相应的伪首部也要改变。</p></li><li><p>紧急指针            占2字节。紧急指针仅在URG&#x3D;1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0时也可以发送紧急数据。</p></li><li><p>选项       长度可变，最长可达4字节。当没有使用“选项”时，TCP的首部长度是20字节。</p></li></ol><h4 id="IP头部"><a href="#IP头部" class="headerlink" title="IP头部"></a>IP头部</h4><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzM5NDMw,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>一行32bit</p><p>版本号（4bit）：告知IP地址是ipv4地址还是ipv6地址</p><p>首部长度（4bit）：告知这个数据包头的长度，由此推断出有无可选项</p><p>服务类型（8bit）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">按位被定义为 PPP DTRM0</span><br><span class="line">PPP：定义包的优先级，取值越大数据越重要</span><br><span class="line"> 000 普通 (Routine)</span><br><span class="line">   001 优先的 (Priority)</span><br><span class="line"> 010 立即的发送 (Immediate)</span><br><span class="line"> 011 闪电式的 (Flash)</span><br><span class="line">  100 比闪电还闪电式的 (Flash Override)</span><br><span class="line"> 101 CRI/TIC/ECP(找不到这个词的翻译)</span><br><span class="line"> 110 网间控制 (Internetwork Control)</span><br><span class="line"> 111 网络控制 (Network Control)</span><br><span class="line">D 时延: 0:普通 1:延迟尽量小</span><br><span class="line">T 吞吐量: 0:普通 1:流量尽量大</span><br><span class="line">R 可靠性: 0:普通 1:可靠性尽量大</span><br><span class="line">M 传输成本: 0:普通 1:成本尽量小</span><br><span class="line">0 最后一位被保留，恒定为0</span><br></pre></td></tr></table></figure><p>总长度（16bit）：告知IP数据报文的总长度（包括被分片数据在内），最大承载量为1500字节，超过将进行数据分片</p><p>片偏移量（13bit）：决定IP分片数据的先后顺序，只能是0或1480的倍数，第一个分片数据发送时偏移量为0，第二个为1480，第三个为2960，以此类推。目的端重组数据包时靠偏移量来按顺序组合分片数据</p><p>标志位（3bit）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一位bit未启用为0               </span><br><span class="line">第二位bit如果需要分片第二位为0，不需要分片第二位为1               </span><br><span class="line">第三位比特为1代表还有后续分片，为0代表为最后一个分片 </span><br><span class="line">共有三种情况：</span><br><span class="line">001（需要分片且还有后续分片）</span><br><span class="line">000（需要分片且当前为最后一个分片）</span><br><span class="line">010（不需要分片）</span><br></pre></td></tr></table></figure><p>标识符（16bit）：区分不同的IP数据包的分片数据，在目的端重组分片数据时能快速找到同一数据包的分片数据</p><p>生存时间TTL（8bit）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">范围为1-255；</span><br><span class="line">单位为跳数，数据包每经过一台路由器即为一跳，TTL值减一；当TTL为0时，丢弃数据包。</span><br><span class="line">作用是防止数据包在网络中永久的循环</span><br><span class="line">Windows系统TTL一般为128，Linux系统TTL为1-128之间，通常为56,64。</span><br><span class="line">注：跳点跟踪命令：tracert IP地址</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>协议（8bit）：区分上层协议；6代表TCP协议，17代表UDP协议</p><p>首部校验和（16bit）：校验三层IP包头是否有误</p><p>源IP地址（32bit）：指发送数据包的主机地址</p><p>目标IP地址（32bit）：指接收数据包的目标主机地址</p><p>选项字段（长度可变，0-40Byte）：通常不会使用到，因为IP包头部分的长度单位为32bit，因此可选项字段的长度必须为32bit的整数倍，当使用时且剩余部分不足32bit会自动填充无用数据来补足32bit。</p><h4 id="http和tcp的区别，分别在哪一层"><a href="#http和tcp的区别，分别在哪一层" class="headerlink" title="http和tcp的区别，分别在哪一层"></a>http和tcp的区别，分别在哪一层</h4><p><strong>TCP协议是传输层协议</strong>，主要解决数据如何在网络中传输，<em><strong>而HTTP是应用层协议</strong></em>**，主要解决如何包装数据，两者本质上没有可比性。</p><p>我们在传输数据时，可以只使用（传输层）TCP&#x2F;IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET 等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP&#x2F;IP做传输层协议将它发到网络上。</p><p><strong>Http协议是建立在TCP协议基础之上的</strong>，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的，所以Http连接是一种短连接，是一种无状态的连接。</p><p>说明：从HTTP&#x2F;1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p><p><strong>Http是无状态的短连接</strong>，直观地说，就是每个请求都是独立的，与前面的请求和后面的请求都是没有直接联系的，因此加入了cookie、session等机制实现有状态的的web。<strong>而TCP是有状态的长连接</strong></p><h4 id="tcp慢启动是怎么实现的"><a href="#tcp慢启动是怎么实现的" class="headerlink" title="tcp慢启动是怎么实现的"></a>tcp慢启动是怎么实现的</h4><p>最初的TCP的实现方式是，在连接建立成功后便会向网络中发送大尺寸的数据包，假如网络出现问题，很多这样的大包会积攒在路由器上，很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此现在的TCP协议规定了，新建立的连接不能够一开始就发送大尺寸的数据包，而只能从一个小尺寸的包开始发送，在发送和数据被对方确认的过程中去计算对方的接收速度，来逐步增加每次发送的数据量（最后到达一个稳定的值，进入高速传输阶段。相应的，慢启动过程中，TCP通道处在低速传输阶段），以避免上述现象的发生。这个策略就是慢启动。</p><p>TCP刚刚开始传输数据时，会<strong>从一个较小的cwnd &#x3D; 1开始，然后按照2的幂逐步增长到sshthresh的过程称为慢启动</strong>，直到<strong>cwnd（拥塞窗口）&gt;（慢启动门限）ssthresh</strong>，则<strong>结束慢启动过程</strong>，<strong>进入到拥塞避免阶段</strong></p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1036177bbd5c4ad6bdbe70a70bde14c4.png" alt="img"></p><h4 id="拥塞避免-1"><a href="#拥塞避免-1" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>当TCP经过慢启动阶段，wnd&gt;ssthresh时，就开始使用拥塞避免算法来进行拥塞控制，这个阶段cwnd是以线性方式增长的，每次收到前面发出去的所有包时，cwnd &#x3D; cwnd + 1（实际是每收到一个ACK, cwnd &#x3D; cwnd + 1&#x2F;cwnd），cwnd线性增长直到检测到拥塞发生。</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7a2514f97e0648cf8e44c127a298ca71.png" alt="img"></p><h4 id="快速重传与超时重传算法"><a href="#快速重传与超时重传算法" class="headerlink" title="快速重传与超时重传算法"></a>快速重传与超时重传算法</h4><p>首先， 我们要区别快速重传与超时重传。</p><p>当接收方发现重复的收到三次或者更多个前一个包的 ACK时，就说明中间丢了一个报文，这时候，发送端就不必等待超时再重传，而是可以直接快速地启动重传———这就是快速重传。</p><p>当接收方直到超时，也没有收到ACK和重复时，发送方TCP发送定时器超时后，也会主动发起重传————这就是超时重传。</p><p>发生超时重传和发生快速重传时，拥塞控制的算法是不一样的，当发生快速重传时，就引入了快速重传的算法。</p><h4 id="http和https有什么区别？"><a href="#http和https有什么区别？" class="headerlink" title="http和https有什么区别？"></a>http和https有什么区别？</h4><p>http与https都是常用的网络通信协议</p><p><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</p><p><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</p><p><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p><p><strong>SEO（搜索引擎优化）</strong>：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。</p><h4 id="说一说https实现加密通信的实现原理？CA证书是怎么获得的？一定安全吗？能有中间人吗？"><a href="#说一说https实现加密通信的实现原理？CA证书是怎么获得的？一定安全吗？能有中间人吗？" class="headerlink" title="说一说https实现加密通信的实现原理？CA证书是怎么获得的？一定安全吗？能有中间人吗？"></a>说一说https实现加密通信的实现原理？CA证书是怎么获得的？一定安全吗？能有中间人吗？</h4><ul><li>https是基于tcp协议的，首先客户端会和服务端发起链接建立</li><li>服务端返回它的证书给客户端，证书中包含了服务端公钥S.pub、颁发机构和有效期等信息，证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</li><li>客户端通过操作系统、浏览器内置的根证书（内部包含CA机构的公钥C.pub）验证证书的合法性</li><li>客户端生成随机的对称加密密钥Z，然后通过服务端的公钥S.pub加密发送给服务端</li><li>服务器通过私钥进行解密，获得客户端浏览器的对称加密密钥</li><li>客户端和服务端之后就通过对称加密密钥Z加密数据来进行http通信</li></ul><p>CA证书由网站向CA机构申请，由CA机构颁发，其中包含证书持有者的公钥、域名。同时通过数字签名来做到防止证书被篡改。</p><p>网站在使用HTTPS前，需要向<strong>CA机构</strong>申领一份<strong>数字证书</strong>，数字证书里含有证书持有者信息、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明“该公钥对应该网站”。而这里又有一个显而易见的问题，“<strong>证书本身的传输过程中，如何防止被篡改”</strong>？即如何证明证书本身的真实性？身份证运用了一些防伪技术，而数字证书怎么防伪呢？解决这个问题我们就接近胜利了！</p><h5 id="如何放防止数字证书被篡改？"><a href="#如何放防止数字证书被篡改？" class="headerlink" title="如何放防止数字证书被篡改？"></a><strong>如何放防止数字证书被篡改？</strong></h5><p>我们把证书原本的内容生成一份“签名”，比对证书内容和签名是否一致就能判别是否被篡改。这就是数字证书的“防伪技术”，这里的“签名”就叫<code>数字签名</code>：</p><h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a><strong>数字签名</strong></h5><p>这部分内容建议看下图并结合后面的文字理解，图中左侧是数字签名的制作过程，右侧是验证过程：</p><p><img src="/./../../imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/v2-7c78935389af46e197e96d9cd91c06dd_1440w-1696303314365-11.webp" alt="img"></p><p>数字签名的生成与验证（<a href="https://cheapsslsecurity.com/blog/digital-signature-vs-digital-certificate-the-difference-explained/%EF%BC%89">https://cheapsslsecurity.com/blog/digital-signature-vs-digital-certificate-the-difference-explained/）</a></p><p>数字签名的制作过程：</p><ol><li>CA机构拥有非对称加密的私钥和公钥。</li><li>CA机构对证书明文数据T进行hash。</li><li>对hash后的值用私钥加密，得到数字签名S。</li></ol><p>明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。<br>那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）</p><p>浏览器验证过程：</p><ol><li>拿到证书，得到明文T，签名S。</li><li>用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。</li><li>用证书里指明的hash算法对明文T进行hash得到T’。</li><li>显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。</li></ol><p>为何么这样可以保证证书可信呢？我们来仔细想一下。</p><h5 id="中间人有可能篡改该证书吗？"><a href="#中间人有可能篡改该证书吗？" class="headerlink" title="中间人有可能篡改该证书吗？"></a><strong>中间人有可能篡改该证书吗？</strong></h5><p>假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。</p><p>既然不可能篡改，那整个证书被掉包呢？</p><h5 id="中间人有可能把证书掉包吗？"><a href="#中间人有可能把证书掉包吗？" class="headerlink" title="中间人有可能把证书掉包吗？"></a><strong>中间人有可能把证书掉包吗？</strong></h5><p>假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，这确实会导致上文“中间人攻击”那里提到的漏洞？</p><p>其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</p><h5 id="为什么制作数字签名时需要hash一次？。"><a href="#为什么制作数字签名时需要hash一次？。" class="headerlink" title="为什么制作数字签名时需要hash一次？。"></a><strong>为什么制作数字签名时需要hash一次？</strong>。</h5><p>最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加解密就快很多。</p><h4 id="HTTP是基于TCP还是UDP？"><a href="#HTTP是基于TCP还是UDP？" class="headerlink" title="HTTP是基于TCP还是UDP？"></a>HTTP是基于TCP还是UDP？</h4><p>HTTP&#x2F;3.0 之前是基于 TCP 协议的，由于TCP的队头阻塞问题， HTTP&#x2F;3.0 将弃用 TCP，改用 <strong>基于 UDP 的 QUIC 协议</strong> 。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/10/03/hello-world/"/>
      <url>/2023/10/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
